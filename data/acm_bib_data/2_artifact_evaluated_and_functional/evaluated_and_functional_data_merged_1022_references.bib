@software{10.5281/zenodo.13827683,
author = {Pontes Miranda, James William and Bruneliere, Hugo and Tisi, Massimo and Suny\'{e}, Gerson},
title = {Towards an In-context LLM-based Approach for Automating the Definition of Model Views},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13827683},
abstract = {
    <p>This artifact accompanies the paper “Towards an In-context LLM-based
Approach for Automating the Definition of Model Views.” The provided
files contain all the necessary tools to replicate the experiments
described in the paper, including scripts for generating the
datasets.</p>
<p>Additionally, the artifact contains all prompt data used in the
experiments and baseline model views in VPDL (EMF Views DSL) and ATL.
This artifact enables the reproduction of the results discussed in the
paper.</p>

},
keywords = {Large Language Models, Model views, Model-Driven Engineering, Prompt engineering}
}

@software{10.5281/zenodo.13830707,
author = {Hummelgren, Lars and Palmkvist, Viktor and Stjerna, Linnea and Xu, Xuechun and Jalden, Joakim and Broman, David},
title = {Artifact for `Trellis: A Domain-Specific Language for Hidden Markov Models with Sparse Transitions`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13830707},
abstract = {
    <p>This is an artifact accompanying the paper
<code>Trellis: A Domain-Specific Language for Hidden Markov Models with Sparse Transitions</code>.
The artifact contains a Docker image which contains everything needed to
try out Trellis and run the complete benchmark suite. Further, it
contains the Dockerfile used to construct the image and the evaluation
results presented in the corresponding paper.</p>

},
keywords = {DSL, GPU acceleration, Hidden Markov models, parallelization}
}

@software{10.5281/zenodo.12453932,
author = {Cassano, Federico and Gouwar, John and Lucchetti, Francesca and Schlesinger, Claire and Freeman, Anders and Anderson, Carolyn Jane and Feldman, Molly Q and Greenberg, Michael and Jangda, Abhinav and Guha, Arjun},
title = {Artifact: Knowledge Transfer from High-Resource to Low-Resource Programming Languages for Code LLMs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12453932},
abstract = {
    <p>The artifact contains the code to fully reproduce the results in the
paper.</p>

},
keywords = {large language models trained on code}
}

@software{10.5281/zenodo.12663344,
author = {Yan, Zhenyu and Zhang, Xin and Di, Peng},
title = {Scaling Abstraction Refinement for Program Analyses in Datalog Using Graph Neural Networks (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12663344},
abstract = {
    <p>This is the artifact of the paper Scaling Abstraction Refinement for
Program Analyses in Datalog Using Graph Neural Networks to appear in
OOPSLA 2024.</p>

},
keywords = {abstraction refinement, graph neural networks, program analysis}
}

@software{10.5281/zenodo.12670155,
author = {Sistla, Meghana and Chaudhuri, Swarat and Reps, Thomas},
title = {Weighted CFLOBDDs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670155},
abstract = {
    <p>The artifact contains source code and experiments to run Weighted
CFLOBDDs (WCFLOBDDs)</p>

},
keywords = {quantum simulation, Weighted decision diagrams}
}

@software{10.5281/zenodo.12671461,
author = {Li, Yichuan and Song, Wei and Huang, Jeff},
title = {VarLifter: Recovering Variables and Types from Bytecode of Solidity Smart Contracts},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12671461},
abstract = {
    <p>The artifact presented here is VarLifter, a tool designed to lift
variables and their types from compiled Solidity smart contract runtime
bytecode. VarLifter provides precise variable and type information,
freeing researchers from the burden of dealing with intricate low-level
details, and is proven to assist downstream tasks related to smart
contracts. VarLifter supports both command-line interface (CLI) and
graphical user interface (GUI) for ease of use.</p>

},
keywords = {Blockchain, EVM, smart contract, Solidity bytecode, variable recovery}
}

@software{10.5281/zenodo.12783666,
author = {Yang, Chen and Chen, Junjie and Jiang, Jiajun and Huang, Yuliang},
title = {Dependency-aware code naturalness},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12783666},
abstract = {
    <p>Docker image and data for the artifact of DAN (dependency-aware code
naturalness)</p>

},
keywords = {Code Entropy, Naturalness, Program Dependency}
}

@software{10.5281/zenodo.13166254,
author = {Borgarelli, Andrea and Enea, Constantin and Majumdar, Rupak and Nagendra, Srinidhi},
title = {Artifact for Reward Augmentation in Reinforcement Learning for Testing Distributed Systems &nbsp;Creators},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13166254},
abstract = {
    <p>The artifact provides a framework - WaypointRL - for testing
distributed protocol implementations using Reinforcement learning
methods and strategies. The framework expects an instrumented
implementation as input. The instrumentation will allow the framework to
simulate the network and pick the order of messages delivered.
Additionally, the framework will control the nodes of the distributed
system to introduce failures (stops and restarts). Apart from RL based
strategies when testing, the framework provides a generic interface to
implement any strategy as an Agent that interacts with the distributed
system Environment.</p>

},
keywords = {distributed systems, reactive systems testing, reinforcement learning}
}

@software{10.5281/zenodo.13323059,
author = {Jungmair, Michael and Engelke, Alexis and Giceva, Jana},
title = {Artifact for "HiPy: Extracting High-Level Semantics From Python Code For Data Processing"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13323059},
abstract = {
    <p>This is the artifact to the paper “HiPy: Extracting High-Level
Semantics From Python Code For Data Processing” which provides the
source code of HiPy as well as tooling, benchmarks, and Docker images to
reproduce the experiments shown in the paper.</p>

},
keywords = {Data Processing, High-Level Optimizations, Program Generation, Python}
}

@software{10.5281/zenodo.13368062,
author = {Liu, Jiangyi and Murphy, Charlie and Grover, Anvay and Johnson, Keith J.C. and Reps, Thomas and D’Antoni, Loris},
title = {Artifact of paper "Synthesizing Formal Semantics from Executable Interpreters"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13368062},
abstract = {
    <p>This is the artifact of paper “Synthesizing Formal Semantics from
Executable Interpreters”. It contains code for the tool Synantic as well
as benchmarks used to support our claims in the paper.</p>

},
keywords = {program synthesis, semantics, SemGuS, SMT solvers, SyGuS}
}

@software{10.5281/zenodo.13373228,
author = {Ye, Wenjia and Sun, Yaozhu and Oliveira, Bruno C. d. S.},
title = {Imperative Compositional Programming (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13373228},
abstract = {
    <p>This is the artifact of the OOPSLA2024 research paper : Imperative
Compositional Programming.</p>

},
keywords = {Bidirectional Typing, Compositional Programming, Distributive Subtyping, Intersection Types, Mutable References, Type Soundness}
}

@software{10.5281/zenodo.13378311,
author = {Ye, Wenjia and Oliveira, Bruno C. d. S. and Toro, Mat\'{\i}as},
title = {Merging Gradual Typing (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13378311},
abstract = {
    <p>This is the artifact of OOPSLA2024 research paper: Merging Gradual
Typing.</p>

},
keywords = {Bidirectional Typing, Gradual Typing, Merge Operator, Type-Directed Semantics}
}

@software{10.5281/zenodo.13381352,
author = {Palmer, Zachary and Filardo, Nathaniel Wesley and Wu, Ke},
title = {Intensional Functions Virtual Machine Image},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13381352},
abstract = {
    <p>This archive contains a virtual machine image with a precompiled
version of the artifact from the paper Intensional Functions, which
appears in OOPSLA 2024 / PACMPL.</p>

},
keywords = {function, image, intensional, machine, virtual}
}

@software{10.5281/zenodo.13388204,
author = {Kim, Caleb and Li, Pai and Mohan, Anshuman and Butt, Andrew and Sampson, Adrian and Nigam, Rachit},
title = {Reproduction Package for "Unifying Static and Dynamic Intermediate Languages for Accelerator Generators"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13388204},
abstract = {
    <p>The artifact is a VirtualBox Image to reproduce the results for
“Unifying Static and Dynamic Intermediate Languages for Accelerator
Generators”. In particular, the artifact can be used to reproduce the
graphs and quantitative claims made in section 6 and 7 of the paper.
More detailed instructions can be found in the REAMDE.md of the
following repository: https://github.com/cucapra/calyx-resource-eval,
and more general documentation of Piezo can be found here:
https://docs.calyxir.org/.</p>
<p>The VirtualBox image consists of: - The Calyx/Piezo compiler - fud,
the compiler driver - The Dahlia compiler - The evaluation code. In
particular, it contains the scripts necessary to generate the data and
graphs used in the paper. It also contains the source code for the
benchmarks used in the paper: in particular Polybench benchmarks written
in Dahlia and PIFO tree benchmarks written in Piezo. For the systolic
arrays, fud uses a Python script to generate systolic arrays written in
Piezo. More details about fud’s systolic array generation can be found
here: https://docs.calyxir.org/frontends/systolic-array.html.</p>

},
keywords = {Accelerator Design Language, Intermediate Language}
}

@software{10.5281/zenodo.13393058,
author = {Qian, Kelvin and Smith, Scott and Stride, Brandon and Weng, Shiwei and Wu, Ke},
title = {Software Artifact for Semantic-Type-Guided Bug Finding},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13393058},
abstract = {
    <p>This is the codebase for the languages BlueJay, Jay, and JayIL, as
well as the languages’ semantic-type-guided type checker. This code is
developed by the JHU Programming Languages Lab. It is a pipeline of
functional languages that fits for research at each layer.</p>
<p>This snapshot is the artifact for Semantic-Type-Guided Bug
Finding.</p>
<p>With this artifact, the user can recreate all benchmarks seen in the
paper.</p>

},
keywords = {Incorrectness, OCaml, Semantic Typing, Symbolic Execution, Test Generation}
}

@software{10.5281/zenodo.13446443,
author = {Wong, Augustine and Bucci, Paul and Beschastnikh, Ivan and Fedorova, Alexandra},
title = {NonSequitur Source Code and User Study Result Data for the paper "Making Sense of Multi-Threaded Application Performance at Scale with NonSequitur."},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13446443},
abstract = {
    <p>The artifact accompanying the paper “Making Sense of Multi-Threaded
Application Performance at Scale with NonSequitur,” which contains: The
source code for the NonSequitur visualization tool. Some additional
Python scripts and data collected/used during the user study described
in the paper.</p>
<p>This paper was accepted in the OOPSLA 2024 conference held in
Pasadena, California. The artifact is contained in the zip file
“oopsla24-ns-artifact.zip.” A detailed description of the artifact is in
the file “OOPSLA 2024 NonSequitur Artifact Doc.pdf.”</p>

},
keywords = {Multi-threaded Applications, Outlier events, Performance debugging, Runtime trace visualization}
}

@software{10.5281/zenodo.13618683,
author = {Yi, Xin and Yu, Hengbiao and Chen, Liqian and Mao, Xiaoguang and Wang, Ji},
title = {FPCC: Detecting Floating-Point Errors via Chain Conditions (Paper Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13618683},
abstract = {
    <p>This is the artifact for “FPCC: Detecting Floating-Point Errors via
Chain Conditions”, published in SPLASH/OOPSLA 2024. All instructions can
be found in the zip file.</p>

},
keywords = {accuracy, chain condition, error-triggering input, floating-point error}
}

@software{10.5281/zenodo.13625822,
author = {Geeson, Luke and Brotherston, James and Dijkstra, Wilco and Donaldson, Alastair F. and Smith, Lee and Sorensen, Tyler and Wickerson, John},
title = {Artifact for "Mix Testing: Specifying and Testing ABI Compatibility Of C/C++ Atomics Implementations"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13625822},
abstract = {
    <p>This is the artifact accompanying our paper “Mix Testing: Specifying
and Testing ABI Compatibility Of C/C++ Atomics Implementations”,
conditionally accepted for publication at OOPSLA2024</p>
<p>The artifact consists of scripts to reproduce the figures in the
paper paper. We aim for all badges. For comments please contact
luke.geeson@cs.ucl.ac.uk.</p>

},
keywords = {Compiler Testing, Concurrency, Interoperability}
}

@software{10.5281/zenodo.13863694,
author = {Mariano, Benjamin and Wang, Ziteng and Pailoor, Shankara and Collberg, Christian and Dillig, I\c{s}il},
title = {Software Artifact for "Control-Flow Deobfuscation using Trace-Informed Compositional Program Synthesis"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13863694},
abstract = {
    <p>Software artifact for the paper “Control-Flow Deobfuscation using
Trace-Informed Compositional Program Synthesis”.</p>

},
keywords = {Deobfuscation, Program Synthesis}
}

@software{10.6084/m9.figshare.26105056.v1,
author = {Li, Haofeng and Shi, Chenghang and Lu, Jie and Li, Lian and Xue, Jingling},
title = {Boosting the Performance of Alias-Aware IFDS Analysis with CFL-Based Environment Transformers (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.26105056.v1},
abstract = {
    <p>The IFDS algorithm is pivotal in solving field-sensitive data-flow
problems. However, its conventional use of access paths for field
sensitivity leads to the generation of a large number of data-flow
facts. This causes scalability challenges in larger programs, limiting
its practical application in extensive codebases. In response, we
propose a new field-sensitive technique that reinterprets the generation
of access paths as a CFL for field-sensitivity and formulates it as an
IDE problem. This approach significantly reduces the number of data-flow
facts generated and handled during the analysis, which is a major factor
in performance degradation.</p>
<p>To demonstrate the effectiveness of this approach, we developed a
taint analysis tool, IDEDroid, in the IFDS/IDE framework. IDEDroid
outperforms FlowDroid, an established IFDS-based taint analysis tool, in
the analysis of 24 major Android apps while improving its precision
(guaranteed theoretically). The speed improvement ranges from 2.1\texttimes{} to
2,368.4\texttimes{}, averaging at 222.0\texttimes{}, with precision gains reaching up to 20.0\%
(in terms of false positives reduced). This performance indicates that
IDEDroid is substantially more effective in detecting information-flow
leaks, making it a potentially superior tool for mobile app vetting in
the market.</p>

},
keywords = {Alias Analysis, CFL-Reachability, IDE, IFDS, Taint Analysis}
}

@software{10.5281/zenodo.12661302,
author = {Luo, Chuan and Lyu, Shuangyu and Zhao, Qiyuan and Wu, Wei and Zhang, Hongyu and Hu, Chunming},
title = {Artifact for ISSTA 2024 Article `Beyond Pairwise Testing: Advancing 3-wise Combinatorial Interaction Testing for Highly Configurable Systems'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12661302},
abstract = {
    <p>ScalableCA is a novel and scalable algorithm that demonstrates
effectiveness and efficiency in solving large-scale 3-wise CCAG
instances. This artifact includes the implementation of ScalableCA, the
testing instances adopted in the experiments and the experimental
results.</p>

},
keywords = {Combinatorial Interaction Testing, Sampling, Satisfiability}
}

@software{10.5281/zenodo.12662090,
author = {Cheng, Runxiang and Wang, Shuai and Jabbarvand, Reyhaneh and Marinov, Darko},
title = {Artifact for "Revisiting Test-Case Prioritization on Long-Running Test Suites" (ISSTA 2024)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12662090},
abstract = {
    <p>This is the artifact of the research paper “Revisiting Test-Case
Prioritization on Long-Running Test Suites” in ISSTA 2024.</p>
<p>This artifact provides a quick walkthrough of its general
functionality (e.g., downloading and extracting data from more builds,
running TCP techniques) using one of the evaluated projects as an
example, and steps to produce tables and figures analyzed in the paper’s
evaluation section.</p>
<p>This artifact provides: (1) steps to download and use the full
dataset of Long-Running Test Suites (LRTS) we previously collected; (2)
scripts to collect more builds from the evaluated projects; (3)
implementations of different categories of test-case prioritization
(TCP) algorithms (time-based, history-based,
information-retrieval-based, ML-based, RL-based); (4) experiment scripts
to evaluate the implemented TCP algorithms on the collected, extensible
dataset.</p>

},
keywords = {regression testing, reliability, Software testing, test prioritization}
}

@software{10.5281/zenodo.12662219,
author = {Cui, Di and Wang, Qiangqiang and Zhao, Yutong and Wang, Jiaqi and Wei, Minjie and Hu, Jingzhao and Wang, Luqiao and Li, Qingshan},
title = {HECS: A Hypergraph Learning-based System for Detecting Extract Class Refactoring Opportunities},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12662219},
abstract = {
    <p>HECS is an advanced tool designed for Extract Class refactoring by
leveraging hypergraph learning to model complex dependencies within
large classes. Unlike traditional tools that rely on direct oneto-one
dependency graphs, HECS uses intra-class dependency hypergraphs to
capture one-to-many relationships. This allows HECS to provide more
accurate and relevant refactoring suggestions. The tool constructs
hypergraphs for each target class, attributes nodes using a pre-trained
code model, and trains an enhanced hypergraph neural network. Coupled
with a large language model, HECS delivers practical refactoring
suggestions. In evaluations on largescale and real-world datasets, HECS
achieved a 38.5\% increase in precision, 9.7\% in recall, and 44.4\% in
f1-measure compared to JDeodorant, SSECS, and LLMRefactor. These
improvements make HECS a valuable tool for developers, offering
practical insights and enhancing existing refactoring techniques.</p>

},
keywords = {Extract Class Refactoring, Hypergraph Neural Network}
}

@software{10.5281/zenodo.12663279,
author = {Nguyen, Thanh-Dat and Do-Viet, Tung and Nguyen-Duy, Hung and Luu, Tuan-Hai and Le, Hung and Le, Bach and Thongtanunam, Patanamon},
title = {VRDSynth Replication Package},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12663279},
abstract = {
    <p>Full replication package of VRDSynth</p>

},
keywords = {Automatic Programming, Information Extraction, Program Synthesis}
}

@software{10.5281/zenodo.12667479,
author = {Jajal, Purvish and Jiang, Wenxin and Tewari, Arav and Kocinare, Erik and Woo, Joseph and Sarraf, Anusha and Lu, Yung-Hsiang and Thiruvathukal, George K. and Davis, James C.},
title = {Interoperability in Deep Learning: A User Survey and Failure Analysis of ONNX Model Converters},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12667479},
abstract = {
    <p>This is the artifact for Interoperability in Deep Learning: A User
Survey and Failure Analysis of ONNX Model Converters, that will be
presented at the 2024 International Symposium on Software Testing and
Analysis (ISSTA).</p>
<p>Instructions are in the README.</p>

},
keywords = {Empirical software engineering, ONNX, Software Engineering}
}

@software{10.5281/zenodo.12669148,
author = {Blumschein, Christoph and Niephaus, Fabio and Stancu, Codru\c{t} and Wimmer, Christian and Lincke, Jens and Hirschfeld, Robert},
title = {Finding Cuts in Static Analysis Graphs to Debloat Software - Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669148},
abstract = {
    <p>This artifact consists of two parts: the CutTool as described in
section 5.2 of our paper, and evaluation scripts for reproducing the
results of section 6.3 and 6.4.</p>

},
keywords = {CutTool}
}

@software{10.5281/zenodo.12670050,
author = {Chen, Yang and Jabbarvand, Reyhaneh},
title = {Artifact for "Neurosymbolic Repair of Test Flakiness"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670050},
abstract = {
    <p>This is the artifact for “Neurosymbolic Repair of Test
Flakiness”.</p>

},
keywords = {Large Language Models, Program Repair, Test Flakiness}
}

@software{10.5281/zenodo.12673450,
author = {Liu, Zengyu and Chen, Liqian and Liu, Wanwei and Wang, Ji},
title = {Synthesizing Boxes Preconditions for Deep Neural Networks},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12673450},
abstract = {
    <p>This repository contains the artifact of the following ISSTA 2024
paper. Zengyu Liu, Liqian Chen, Wanwei Liu and Ji Wang. Synthesizing
Boxes Preconditions for Deep Neural Networks</p>

},
keywords = {Boxes, Neural Network, Precondition Synthesis, Robustness, Safety}
}

@software{10.5281/zenodo.13625004,
author = {Hu, Tianmin and Ye, Guixin and Tang, Zhanyong and Tan, Shin Hwei and Wang, Huanting and Li, Meng and Wang, Zheng},
title = {Artifact for the paper "Upbeat: Test Input Checks of Q# Quantum Libraries"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13625004},
abstract = {
    <p>Upbeat is a fuzzing tool designed to generate random test cases for
identifying input-checking bugs in Q# libraries. This artifact includes
the source code and necessary data for Upbeat, along with documentation
to guide users through installation and usage, ensuring a smooth and
convenient experience.</p>

},
keywords = {Fuzzing, Quantum computing, Software testing}
}

@software{10.5281/zenodo.13690435,
author = {Xie, Linna and Li, Chongmin and Pei, Yu and Zhang, Tian and Pan, Minxue},
title = {BRAFAR: Bidirectional Refactoring, Alignment, Fault Localization, and Repair for Programming Assignments Linna Xie, Chongmin Li, Yu Pei, Tian Zhang, and Minxue Pan},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13690435},
abstract = {
    <p>The published version of this work.</p>

},
keywords = {Program Repair, Programming Education, Software Refactoring}
}

@software{10.6084/m9.figshare.26156944.v4,
author = {Shi, Chenghang and Li, Haofeng and Lu, Jie and Li, Lian},
title = {Artifact for Article ``Better Not Together: Staged Solving for Context-Free Language Reachability''},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.26156944.v4},
abstract = {
    <p>This is the official artifact of our ISSTA’24 paper ``Better Not
Together: Staged Solving for Context-Free Language Reachability’’.
Please follow the instructions of README.pdf to reproduce our
results.</p>

},
keywords = {CFL-reachability, Performance, Staged Analysis}
}

@software{10.5281/zenodo.11363460,
author = {Song, Yahui and Foo, Darius and Chin, Wei-Ngan},
title = {Specification and Verification for Unrestricted Algebraic Effects and Handling},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11363460},
abstract = {
    <p>This repository serves for the artifact evaluation for the ICFP24 (#95) submission: Specification and Verification for Unrestricted Algebraic Effects and Handling.</p>

},
keywords = {Automated Verification, Effectful Specification Logic, Multi-shot Continuations, Separation Logic}
}

@software{10.5281/zenodo.11493754,
author = {Xia, Li-yao and Israel, Laura and Kramarz, Maite and Coltharp, Nicholas and Claessen, Koen and Weirich, Stephanie and Li, Yao},
title = {Story of Your Lazy Function's Life: A Bidirectional Demand Semantics for Mechanized Cost Analysis of Lazy Programs (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11493754},
abstract = {
    <p>The Coq formalization of paper “Story of Your Lazy Function’s Life: A Bidirectional Demand Semantics for Mechanized Cost Analysis of Lazy Programs”.</p>
<p>Original abstract of the paper:</p>
<p>Lazy evaluation is a powerful tool that enables better compositionality and potentially better performance in functional programming, but it is challenging to analyze its computation cost. Existing works either require manually annotating sharing, or rely on separation logic to reason about heaps of mutable cells. In this paper, we propose a bidirectional demand semantics that allows for reasoning about the computation cost of lazy programs without relying on special program logics. To show the effectiveness of our approach, we apply the demand semantics to a variety of case studies including insertion sort, selection sort, Okasaki’s banker’s queue, and the implicit queue. We formally prove that the banker’s queue and the implicit queue are both amortized and persistent using the Rocq Prover (formerly known as Coq). We also propose the reverse physicist’s method, a novel variant of the classical physicist’s method, which enables mechanized, modular and compositional reasoning about amortization and persistence with the demand semantics.</p>

},
keywords = {amortized analysis, computation cost, Coq, formal verification, lazy evaluation}
}

@software{10.5281/zenodo.11498450,
author = {Torrens, Paulo and Orchard, Dominic and Vasconcellos, Cristiano},
title = {Artifact for "On the Operational Theory of the CPS-calculus"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11498450},
abstract = {
    <p>Archived copy of the artifact for the paper “On the Operational Theory of the CPS-calculus: Towards a Theoretical Foundation for IRs”, submitted to ICFP24.</p>

},
keywords = {Continuations, intermediate representations, strong normalization.}
}

@software{10.5281/zenodo.11500626,
author = {Chen, Yijia and Parreaux, Lionel},
title = {The Long Way to Deforestation: A Type Inference and Elaboration Technique for Removing Intermediate Data Structures (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11500626},
abstract = {
    <p>This artifact consists of an <code>sbt</code> project with a Scala implementation of Lumberhack as introduced in the corresponding paper. Lumberhack aims to improve the efficiency of programs by eliminating intermediate data structures. We provide a test suite containing all the examples in the paper and all the <code>nofib</code> benchmarks we have ported and presented in the paper. Related scripts in bash, R and Python to generate the figures and tables in the paper are also contained in this artifact.</p>

},
keywords = {Compiler, Deforestation, OCaml, Optimization, Scala, Type Inference}
}

@software{10.5281/zenodo.11906121,
author = {Quiring, Benjamin and Van Horn, David},
title = {Experiments for "Deriving with Derivatives: Optimizing Incremental Fixpoints for Higher-Order Flow Analysis"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11906121},
abstract = {
    <p>This artifact contains the current implementation of the compiler for the 3CPS compiler and fixpoint methods for its static analysis. It also contains the benchmark programs from the paper, and a script to the run the experiments.</p>

},
keywords = {compiler, fixpoint, higher-order, incremental-computation, Standard ML, static analysis}
}

@software{10.5281/zenodo.12518800,
author = {Beck, Calvin and Yoon, Irene and Chen, Hanxi and Zakowski, Yannick and Zdancewic, Steve},
title = {Development for "A Two-Phase Infinite/Finite Low-Level Memory Model"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12518800},
abstract = {
    <p>This paper provides a novel approach to reconciling complex low-level memory model features, such as pointer–integer casts, with desired refinements that are needed to justify the correctness of program transformations. The idea is to use a “two-phase” memory model, one with an unbounded memory and corresponding unbounded integer type, and one with a finite memory; the connection between the two levels is made explicit by a notion of refinement that handles out-of-memory behaviors. This approach allows for more optimizations to be performed and establishes a clear boundary between the idealized semantics of a program and the implementation of that program on finite hardware.</p>
<p>The two-phase memory model has been incorporated into an LLVM IR semantics, demonstrating its utility in practice in the context of a low-level language with features like undef and bitcast. This yields infinite and finite memory versions of the language semantics that are proven to be in refinement with respect to out-of-memory behaviors. Each semantics is accompanied by a verified executable reference interpreter. The semantics justify optimizations, such as dead-alloca-elimination, that were previously impossible or difficult to prove correct.</p>
<p>The artifact contains the development including the Coq proofs of the important theorems. The source code can be used to build the executable interpreter as well, which can execute LLVM programs. A VM is included with all of the dependencies pre-installed.</p>

},
keywords = {Coq, integer--pointer casts, llvm, memory models, ocaml, semantics, vellvm}
}

@software{10.5281/zenodo.10626343,
author = {Y\i{}ld\i{}ran, Necip Faz\i{}l and Oh, Jeho and Lawall, Julia and Gazzillo, Paul},
title = {Artifact from "Maximizing Patch Coverage for Testing of Highly-Configurable Software without Exploding Build Times"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10626343},
abstract = {
    <p>Artifact from “Maximizing Patch Coverage for Testing of Highly-Configurable Software without Exploding Build Times”</p>

},
keywords = {krepair}
}

@software{10.5281/zenodo.11079042,
author = {Qin, Yi and Tong, Yanxiang and Xu, Yifei and Cao, Chun and Ma, Xiaoxing},
title = {Active Monitoring Mechanism},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11079042},
abstract = {
    <p>AMM is a runtime monitoring solution for detecting potentially abnormal behavior of control-based self-adaptive systems. The basic intuition of AMM is to stimulate the control-SAS with an active control signal when vague observations might mask model deviations. To determine the appropriate time for triggering the active signals, AMM proposes a stochastic framework to quantify the relationship between the implicit variation of a control-SAS and its explicit observation. Based on this framework, AMM’s monitor and remediator enhance model deviation detection by generating active control signals of well-designed timing and intensity.</p>

},
keywords = {control-based sefl-adpative systems, model deviation, runtime monitoring}
}

@software{10.5281/zenodo.11094381,
author = {de Souza, Cleidson R. B. and Ma, Emilie and Wong, Jesse and Yoon, Dongwook and Beschastnikh, Ivan},
title = {Reproduction Package for Article "Revealing Software Development Work Patterns with PR-Issue Graph Topologies"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11094381},
abstract = {
    <p>Scripts and data for quantitative analysis in the above paper. The goal of this work is to enable topological analysis of PR-Issue networks on GitHub via graph database queries, an image generation module, and many statistics scripts. This repository includes:</p>
<ul>
<li>Data scraped from over 50 large open source projects on GitHub and converted into a Neo4j data dump.</li>
<li>Reusable Cypher (Neo4j query language) queries to surface instances of workflow types.</li>
<li>Image generation modules written in Python to visualize workflow types and clusters of Issues and PRs, used during the paper’s qualitative coding process.</li>
<li>Interactive web-based project explorer to aggregate workflow types found in a project, used during developer interviews.</li>
</ul>
<p>These were primarily used to support the qualitative aspects of this paper.</p>

},
keywords = {collaboration, open source, repository mining, software engineering}
}

@software{10.5281/zenodo.11097846,
author = {Xin, Qi and Wu, Haojun and Tang, Jinran and Liu, Xinyu and Reiss, Steven P. and Xuan, Jifeng},
title = {Reproduction Package for Article Detecting, Creating, Repairing, and Understanding Indivisible Multi-Hunk Bugs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11097846},
abstract = {
    <p>The artifact includes the source code of our IBugFinder tool for indivisible bug detection and creation, the new bug dataset CatenaD4J, the result of the study of multi-hunk fixes, and the repair tools and test scripts used in the repair experiment. The artifact is intended to facilitate the evaluation and development of new multi-hunk repair techniques.</p>

},
keywords = {Automated program repair, indivisible multi-hunk bugs, partial patch relationship}
}

@software{10.5281/zenodo.10804712,
author = {Anand, Aditya and Adithya, Solai and Rustagi, Swapnil and Seth, Priyam and Sundaresan, Vijay and Maier, Daryl and Nandivada, V. Krishna and Thakur, Manas},
title = {Optimistic Stack Allocation and Dynamic Heapification for Managed Runtimes},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10804712},
abstract = {
    <p>Artifact for PLDI 2024 paper title “Optimistic Stack Allocation and Dynamic Heapification for Managed Runtimes”.</p>

},
keywords = {Escape analysis, Managed runtimes, Stack allocation}
}

@software{10.5281/zenodo.10807169,
author = {Youn, Dongjun and Shin, Wonho and Lee, Jaehyun and Ryu, Sukyoung and Breitner, Joachim and Gardner, Philippa and Lindley, Sam and Pretnar, Matija and Rao, Xiaojia and Watt, Conrad and Rossberg, Andreas},
title = {Artifact for "Bringing the WebAssembly Standard up to Speed with SpecTec"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10807169},
abstract = {
    <p>Artifact for “Bringing the WebAssembly Standard up to Speed with SpecTec”, containing the source code and evaluation results.</p>

},
keywords = {DSL, executable prose, language specification, WebAssembly}
}

@software{10.5281/zenodo.10901544,
author = {Garg, Poorva and Holtzen, Steven and Van den Broeck, Guy and Millstein, Todd},
title = {Reproduction Package for Article "Bit Blasting Probabilistic Programs"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10901544},
abstract = {
    <p>The artifact consists of implementation of HyBit, a probabilistic programming system based on bit blasting. It scales inference for hybrid probabilistic programs with respect to the discrete structure. The artifact also consists of all the necessary scripts to reproduce the experiment in the article “Bit Blasting Probabilistic Programs”.</p>

},
keywords = {bit blasting, discretization, probabilistic inference, probabilistic programming system}
}

@software{10.5281/zenodo.10937816,
author = {Matute, Gabriel and Ni, Wode and Barik, Titus and Cheung, Alvin and Chasins, Sarah E.},
title = {Syntactic Code Search with Sequence-to-Tree Matching},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10937816},
abstract = {
    <p>A docker image <code>stbench</code> to evaluate our tool <code>stsearch</code>, under <code>/artifact</code> we include: * <code>stsearch</code>, the Rust source code (together with a release build) of our tool; * <code>queries</code>, the Semgrep rules used to curate our real-world query benchmark; * <code>corpus</code>, the Javascript corpus (scrapped from <code>npm</code>) to search over; and * <code>stbench</code>, a Python package to collect and analyze matches.</p>

},
keywords = {Code Search, Syntactic Analysis, Tree Wildcards}
}

@software{10.5281/zenodo.10948026,
author = {Ketkar, Ameya and Ramos, Daniel and Clapp, Lazaro and Barik, Raj and Ramanathan, Murali Krishna},
title = {Replication of A Lightweight Polyglot Code Transformation Language},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10948026},
abstract = {
    <p>The artifact contains the necessary instructions to replicate part of the experiments in the paper. It also provides with users with an environment to run our tool.</p>
<p>Detailed instructions can be found within the zip file.</p>

},
keywords = {code cleanup, code transformation, refactoring}
}

@software{10.1145/3672536,
author = {Kelly, Terence},
title = {Source code for "Zero Tolerance for Bias"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3672536},
abstract = {
    <p>The tarball containing this README file contains example code related to the problem of shuffling, i.e., randomly permuting a given set of items.  Compile and run the C programs in the obvious way after reading the source, noting any warnings in the comments.</p>
}
}

@software{10.5281/zenodo.10464500,
author = {Liu, Jie and Zhao, Zhongyuan and Ding, Zijian and Brock, Benjamin and Rong, Hongbo and Zhang, Zhiru},
title = {Reproduction Package for Article `UniSparse: An Intermediate LanguageforGeneralSparseFormatCustomization'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10464500},
abstract = {
    <p>UniSparse is an intermediate language for general sparse format customization. UniSparse automates code generation for custom sparse format conversion and compute operations targeting heterogeneous architectures.</p>

},
keywords = {compilers, heterogeneous systems, programming languages, sparse data formats}
}

@software{10.5281/zenodo.10609061,
author = {Zhang, Chi and Wang, Linzhang and Rigger, Manuel},
title = {Artifact for "Finding Cross-rule Optimization Bugs in Datalog Engines"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10609061},
abstract = {
    <p>The artifact consists of two main components:</p>
<p>1、The source code of the tool Datalog Engine Optimization Tester (Deopt), which we used to find all of the bugs presented in our paper. 2、The data and reproduce documents for the results of the evaluation in the paper.</p>

},
keywords = {cross-rule optimization bugs, Datalog engine testing, test oracle}
}

@software{10.5281/zenodo.10727570,
author = {Honor\'{e}, Wolf and Qiu, Longfei and Kim, Yoonseung and Shin, Ji-Yong and Kim, Jieung and Shao, Zhong},
title = {Artifact For "AdoB: Bridging Benign and Byzantine Consensus with Atomic Distributed Objects"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10727570},
abstract = {
    <p>This artifact includes the Coq definitions and proofs to support the claims in the paper. It also includes the OCaml shim layer needed to evaluate the GenJolteon implementation.</p>

},
keywords = {byzantine, consensus protocols, distributed systems, formal verification, liveness, proof assistants, refinement}
}

@software{10.5281/zenodo.10774458,
author = {Sundram, Shiv and Tariq, Muhammad Usman and Kjolstad, Fredrik},
title = {Artifact for OOPSLA 2024 Paper: Compiling Recurrences over Dense and Sparse Arrays (version 1)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10774458},
abstract = {
    <p>This is a docker container containing the artifact for the OOPSLA 2024 accepted paper “Compiling Recurrences over Dense and Sparse Arrays” by Shiv Sundram, Muhammad Usman Tariq, Fredrik Kjolstad</p>
<p>Directions for running artifact and reproducing the paper’s figures can be found in the Getting Started Guide:</p>
<p>https://docs.google.com/document/d/1YCC8AskQYFQfUQ1_jtW2OOqWrT9-qpizTR4BUmbYBXQ/edit?usp=sharing</p>

},
keywords = {Domain specific languages, Recurrences, Software and its engineering, Source code generation}
}

@software{10.5281/zenodo.10780591,
author = {Li, Haonan and Hao, Yu and Zhai, Yizhuo and Qian, Zhiyun},
title = {Enhancing Static Analysis for Practical Bug Detection: An LLM-Integrated Approach (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10780591},
abstract = {
    <p>This repo contains all the code and test cases for the paper “Enhancing Static Analysis for Practical Bug Detection: An LLM-Integrated Approach”. LLift is an automated framework enhancing static analysis in bug detection with LLMs.</p>

},
keywords = {bug detection, large language model, Static analysis}
}

@software{10.5281/zenodo.10795614,
author = {He, Yang and Zhao, Pinhan and Wang, Xinyu and Wang, Yuepeng},
title = {Artifact Evaluation VeriEQL: Bounded Equivalence Verification for Complex SQL Queries with Integrity Constraints},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10795614},
abstract = {
    <p>The artifact aims to show that our claims and conclusions in the paper (VeriEQL: Bounded Equivalence Verification for Complex SQL Queries with Integrity Constraints) are well-founded and that others can reproduce the experimental results. It employs a SQL encoder and an SMT solver to encode and check equivalence of two SQL queries on relational schemas.</p>

},
keywords = {Equivalence Checking, Program Verification, Relational Databases}
}

@software{10.5281/zenodo.10796555,
author = {Stjerna, Amanda and R\"{u}mmer, Philipp},
title = {Reproduction Package for `A Constraint Solving Approach to Parikh Images of Regular Languages'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10796555},
abstract = {
    <p>This is a reproduction and software package for A Constraint Solving Approach to Parikh Images of Regular Languages, published in OOPSLA 2024. For more information, see Artifact Overview.md.</p>
<p>It contains all software developed for the paper, as well as Jupyter notebooks for analysing experiments and relevant scripts for building them.</p>

},
keywords = {automata, automated theorem proving, parikh automata, parikh images, regular languages, SMT, string solving}
}

@software{10.5281/zenodo.10797459,
author = {Rose, Abhishek and Bansal, Sorav},
title = {Artifact for paper "Modeling Dynamic (De)Allocations of Local Memory for Translation Validation"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10797459},
abstract = {
    <p>This artifact contains a prototype implementation of the Dynamo algorithm described in the paper “Modeling Dynamic (De)Allocations of Local Memory for Translation Validation”. The artifact is packaged as a Docker application and is tested to run on Ubuntu 20.04 operating system. Please see README.pdf (packaged inside the archive) for more details.</p>

},
keywords = {Certified compilation, Equivalence checking, Translation validation}
}

@software{10.5281/zenodo.10798978,
author = {Lamba, Ada and Taylor, Max and Beardsley, Vincent and Bambeck, Jacob and Bond, Michael D. and Lin, Zhiqiang},
title = {Implementation for "Cocoon: Static Information Flow Control in Rust"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10798978},
abstract = {
    <p>Cocoon is a Rust library that provides types and mechanisms for statically enforcing information flow control in Rust programs. Cocoon is currently intended to prevent programmer errors such as accidentally leaking a “private” value to an untrusted function or other value. Cocoon does not currently address dynamic labels, integrity labels, OS integration, or leaks caused by other means such as side-channel attacks.</p>
<p>This artifact contains the Cocoon library itself, all examples presented in the paper, and evaluation scripts.</p>

},
keywords = {information flow control, Rust, type and effect systems}
}

@software{10.5281/zenodo.10814650,
author = {Enea, Constantin and Koskinen, Eric},
title = {CION: Concurrent Trace Reductions},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10814650},
abstract = {
    <p>A proof-of-concept implementation to automatically generate candidate layer quotient automata directly form the source code of concurrent object implementations. See f OOPSLA 2024 paper, “Scenario-Based Proofs for Concurrent Objects”.</p>

},
keywords = {concurrent objects, layer quotients, linearizability, proofs of concurrent objects, Quotients}
}

@software{10.6084/m9.figshare.25365340.v1,
author = {Ryan, Gabriel and Cetin, Burcu and Lim, Yongwhan and Jana, Suman},
title = {HBFourier Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.25365340.v1},
abstract = {
    <p>Replication artifact for paper “Accurate Data Race Prediction in the Linux Kernel through Sparse Fourier Learning” to appear in OOPSLA 2024. The artifact contains HBFourier’s core implementation as a well as scripts for reproducing all results presented in the paper.</p>

},
keywords = {Data Race Prediction, Linux Kernel, Machine Learning, Spectral Method}
}

@software{10.5281/zenodo.10574579,
author = {VenkataKeerthy, S. and Jain, Siddharth and Kalvakuntla, Umesh and Gorantla, Pranav Sai and Chitale, Rajiv Shailesh and Brevdo, Eugene and Cohen, Albert and Trofin, Mircea and Upadrasta, Ramakrishna},
title = {ML-Compiler-Bridge: The Next 700 ML-Enabled Compiler Optimizations},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10574579},
abstract = {
    <p>This artifact corresponds to the tool described in the paper, “The Next 700 ML-Enabled Compiler Optimizations”, published in CC 2024.</p>
<p>Please visit our project page - https://compilers.cse.iith.ac.in/publications/mlcompilerbridge for the latest version of ML-Compiler-Bridge.</p>

},
keywords = {Compilers, ML-based Compiler Optimizations}
}

@software{10.5281/zenodo.10577943,
author = {Mu, Pei and Mavrogeorgis, Nikolaos and Vasiladiotis, Christos and Tsoutsouras, Vasileios and Kaparounakis, Orestis and Stanley-Marbell, Phillip and Barbalace, Antonio},
title = {CoSense Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10577943},
abstract = {
    <p>The artifact of CoSense, which is a CC’2024 paper.</p>

},
keywords = {compiler optimizations, embedded systems, interval arithmetic, sensors, value interval propagation}
}

@software{10.1145/3643873,
author = {Kelly, Terence},
title = {Source code for "Programmer Job Interviews"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3643873},
abstract = {
    <p>The tarball containing this README file provides several programs that illustrate different ways of solving the FIFO State Penitentiary problem discussed in my Drill Bits column on programmer job interview questions.  Read that column first.  This README file explains how the example programs work, how to compile and run them, and the insights we gain from implementing solutions --- insights that we might overlook if we merely design a solution without writing code.</p>
}
}

@software{10.1145/3580426,
author = {Geller, Adam T. and Frank, Justin and Bowman, William J.},
title = {Artifacts and Reproduction Package for Article `Indexed Types for a Statically Safe WebAssembly'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580426},
abstract = {
    <p>Contains the software artifacts we created as part of our work, and the benchmarks along with scripts to reproduce the data presented in the evaluation.</p>
<p>The software artifacts available through following the installation instructions are as follows: - The folder <code>wasmtime</code> contains our implementation of wasm-prechk on top of wasmtime. It is also modified not to use any memory guard pages. - The folder <code>no_checks</code> contains the configuration of wasmtime modified to produce no dynamic checks. - The folder <code>vm_guards</code> contains the unmodified version of wasmtime. - The folder <code>wasm-tools</code> contains our implementation of the wasm-prechk parser and typechecker. - The folder <code>wasm-prechk</code> contains our redex model of wasm-prechk. - The folder <code>polybenchC-4.2.1</code> contains the benchmark suite, including scripts to generate the evaluation data, the version of wasm modules with annotations and manual checks added for each benchmark, and the unmodified wasm modules for each benchmark.</p>

},
keywords = {Indexed Types, Optimization and Compiler Design, Program Logics, Type Systems, WebAssembly}
}

@software{10.5281/zenodo.10019663,
author = {Attouche, Lyes and Baazizi, Mohamed-Amine and Colazzo, Dario and Ghelli, Giorgio and Sartiani, Carlo and Scherzinger, Stefanie},
title = {Reproduction Package for: Validation of Modern JSON Schema: Formalization and Complexity.},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10019663},
abstract = {
    <p>Reproduction package for the POPL’24 contribution “Validation of Modern JSON Schema: Formalization and Complexity”.</p>
<p>All artifacts (source code, data, scripts) are packaged in a virtual machine running Ubuntu Linux, which can be run using VirtualBox.</p>

},
keywords = {complexity of validation, JSON Schema}
}

@software{10.5281/zenodo.10125861,
author = {Hague, Matthew and Je\.{z}, Artur and Lin, Anthony W.},
title = {Parikh's Theorem Made Symbolic: Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10125861},
abstract = {
    <p>The artifact contains the source code of the tool developed in the article. This may be compiled on your own machine, or inside a Docker image (Dockerfile provided). It also contains a disk image with the tool installed, the benchmarks, and the tools that we compared with.</p>

},
keywords = {Abstraction, Decision Procedures, Infinite Alphabets, Satisfiability Modulo Theories, Sequence Theory, String Constraints, Symbolic Automata}
}

@software{10.5281/zenodo.8425923,
author = {Atkey, Robert},
title = {Agda formalisation of Polynomial Time and Dependent Types},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8425923},
abstract = {
    <p>The Agda code formalising the construction of the realisability model described in Sections 5 and 6 of the paper. Please refer to the module names in the paper to find the relevant formalisations.</p>

},
keywords = {agda, formal proof}
}

@software{10.5281/zenodo.10160153,
author = {Park, Sungwoo and Oh, Seyeon and Kim, Min-Soo},
title = {INFINEL: An efficient GPU-based processing method for unpredictable large output graph queries},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10160153},
abstract = {

                <p>Artifact appendix item for PPoPP24</p>

}
}

@software{10.5281/zenodo.10223597,
author = {Manohar, Magdalen Dobson and Shen, Zheqi and Blelloch, Guy and Dhulipala, Laxman and Gu, Yan and Simhadri, Harsha Vardhan and Sun, Yihan},
title = {ParlayANN: Scalable and Deterministic Parallel Graph-Based Approximate Nearest Neighbor Search Algorithms},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10223597},
abstract = {

                <p>Artifact appendix item for PPoPP24</p>

}
}

@software{10.5281/zenodo.10225634,
author = {Park, Seongyeon and Hong, Junguk and Song, Jaeyong and Kim, Hajin and Kim, Youngsok and Lee, Jinho},
title = {AGAThA: Fast and Efficient GPU Acceleration of Guided Sequence Alignment for Long Read Mapping},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10225634},
abstract = {

                <p>Artifact appendix item for PPoPP24</p>

}
}

@software{10.5281/zenodo.10433852,
author = {Ma, Lixian and Chen, Haoruo and Shao, En and Wang, Leping and Chen, Quan and Tan, Guangming},
title = {POSTER: FineCo: Fine-grained Heterogeneous Resource Management for Concurrent DNN Inferences},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10433852},
abstract = {

                <p>Artifact appendix item for PPoPP24</p>

}
}

@software{10.5281/zenodo.10531146,
author = {Ahmad, Zafar and Browne, Reilly and Chowdhury, Rezaul and Das, Rathish and Huang, Yushen and Zhu, Yimin},
title = {Fast American Option Pricing using Nonlinear Stencils},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10531146},
abstract = {

                <p>Artifact appendix item for PPoPP24</p>

}
}

@software{10.6084/m9.figshare.24803229,
author = {Jangda, Abhinav and Yadav, Mohit},
title = {Fast Kronecker Matrix-Matrix Multiplication on GPUs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24803229},
abstract = {

                <p>Artifact appendix item for PPoPP24</p>

}
}

@software{10.6084/m9.figshare.24902067,
author = {Du, Jiangsu and Wei, Jinhui and Jiang, Jiazhi and Cheng, Shenggan and Chen, Zhiguang and Huang, Dan and Lu, Yutong},
title = {Liger: Interleaving Intra- and Inter-Operator Parallelism for Distributed Large Model Inference},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24902067},
abstract = {

                <p>Artifact appendix item for PPoPP24</p>

}
}

@software{10.21227/vp9n-wv96,
author = {Tihanyi, Norbert and Bisztray, Tamas and Jain, Ridhi and Ferrag, Mohamed Amine and Cordeiro, Lucas C. and Mavroeidis, Vasileios},
title = {FormAI dataset},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.21227/vp9n-wv96},
abstract = {
    <p>FormAI is a novel AI-generated dataset comprising 112,000 compilable and independent C programs. All the programs in the dataset were generated by GPT-3.5-turbo using dynamic zero-shot prompting technique and comprises programs with varying levels of complexity. Some programs handle complicated tasks such as network management, table games, or encryption, while others deal with simpler tasks like string manipulation. Each program is labelled based on vulnerabilities present in the code using a formal verification method based on the Efficient SMT-based Bounded Model Checker (ESBMC). This strategy conclusively identifies vulnerabilities without reporting false positives (due to the presence of counter examples), or false negatives (up to a certain bound). The labeled samples can be utilized to train Large Language Models (LLMs) since they contain the exact program location of the software vulnerability.</p>

},
keywords = {Artificial Intelligence, Dataset, Formal Verification, Large Language Models, Software Security, Vulnerability Classification}
}

@software{10.5281/zenodo.10215955,
author = {Xu, Junjielong and Fu, Qiuai and Zhu, Zhouruixing and Cheng, Yutong and Li, Zhijing and Ma, Yuchi and He, Pinjia},
title = {Hue: A User-Adaptive Parser for Hybrid Logs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10215955},
abstract = {
    <p>This is the artifact of " Hue: A User-Adaptive Parser for Hybrid Logs" (ESEC/FSE’23). Please refer to README.md for more details.</p>

},
keywords = {Hybrid Logs, Log Analysis, Log Parsing}
}

@software{10.5281/zenodo.7040003,
author = {Wang, Jiyuan and Zhang, Qian and Rong, Hongbo and Xu, Guoqing Harry and Kim, Miryung},
title = {Reproduction Package for "Leveraging Hardware Probes and Optimizations for Accelerating Fuzz Testing of Heterogeneous Applications"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7040003},
abstract = {
    <p>This is the repo for the HFuzz. We build a cross-devices fuzz testing tool that works on devcloud with DPC++.</p>

},
keywords = {Fuzzing, Heterogeneous, Software testing}
}

@software{10.5281/zenodo.8198972,
author = {Ma, Chenyang and Song, Wei and Huang, Jeff},
title = {Reproduction Package for Article 'TransRacer: Function Dependence-Guided Transaction Race Detection for Smart Contracts'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8198972},
abstract = {
    <p>A symbolic analysis tool that detects transaction races for Ethereum smart contracts. Install dependencies: pip install -r requirements.txt. When using the “pip install” command to install web3 on Windows, you may encounter an error if you haven’t installed gcc. To resolve this, you can install Microsoft Visual C++.</p>
<p>Dependencies source: Z3 solver: Install Z3 package from <a href="https://pypi.org/project/z3-solver/#files">here</a> web3 suit: Install web3 package from [here](https://pypi.org/project/web3/#files Infura account: Acquire Infura from <a href="https://infura.io/">here</a> Etherscan api key: Acquire api key from <a href="https://etherscan.io/">here</a> Contract initial storage: Acquire contract initial storage from <a href="https://etherscan.io/">here</a> If this item is missed, TransRacer will attempt to access the contract’s initial storage by deploying the contract on a private network.</p>
<p>Steps to Run TransRacer 1) Make sure you can connect to the internet before running TransRacer. 2) After the TransRacer.zip is downloaded and the python environment is configured, one can run TransRacer with follow command: cd /SE &amp;\&amp; python main.py –addr [Contract address] –owner [Owner address] – agency_account [Infura account] –init_storage_path [initial storage file path] –api_key [api key]</p>
<p>Quick test Contract DistractedBoyfriend: cd /SE &amp;\&amp; python main.py –addr 0x351016D3eC753Db8E98a783CF51c8D6a4a8af151 –owner 0x4a3D25D58930f7b04E85E7946852fC2d8Fd59489 –agency_account https://mainnet.infura.io/v3/e67c4e1f139d4940a53bc61120bc3bf5 –api_key WTZ5E69T1SKACPGYF29W6ZG6CE3123APIU</p>
<p>The output of TransRacer is stored in a report file, which includes the following sub-files: 1) The “races” file provides information on function pairs that can lead to races and their corresponding witness transactions. 2) The “race bugs” file lists function pairs that can lead to storage and balance differences. 3) The “deps” file presents the found function dependencies. 4) The “time_cost” file reports the time duration spent by TransRacer on testing each contract. For the 50 contracts, the average time cost of the static analyzing, dependence analyzing, and race checking steps is approximately 1.0 minute, 1.5 minutes, and 2.6 minutes, respectively.</p>

},
keywords = {data race, Ethereum, smart contract, symbolic execution}
}

@software{10.5281/zenodo.8264819,
author = {Utture, Akshay and Palsberg, Jens},
title = {Artifact for FSE'23 paper "From Leaks to Fixes: Automated Repairs for Resource Leak Warnings"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8264819},
abstract = {
    <p>The artifact includes the source code, experimental results, and detailed documentation. It also includes a VM image that comes with pre-installed dependencies, and can be used to quickly reproduce the results of the paper by running a few simple scripts.</p>

},
keywords = {Automated Repair, Resource Leaks, Static Analysis}
}

@software{10.5281/zenodo.8266660,
author = {Yin, Yining and Feng, Yang and Weng, Shihao and Liu, Zixi and Yao, Yuan and Zhang, Yichi and Zhao, Zhihong and Chen, Zhenyu},
title = {wengshihao/DFauLo: Dfaulo V1.3},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8266660},
abstract = {
    <p>This repository is the official implementation of the tool DfauLo.</p>
<p>DfauLo is a dynamic data fault localization tool for deep neural networks (DNNs), which can locate mislabeled and noisy data in the deep learning datasets. Inspired by conventional mutation-based code fault localization, DfauLo generates multiple DNN model mutants of the original trained DNN model and maps the extracted features into a suspiciousness score indicating the probability of the given data being a data fault. DfauLo is the first dynamic data fault localization technique, prioritizing the suspected data based on user feedback and providing the generalizability to unseen data faults during training.</p>

},
keywords = {fault localization
deep learning testing
data quality}
}

@software{10.5281/zenodo.8267775,
author = {Liu, Bo and Liu, Hui and Li, Guangjie and Niu, Nan and Xu, Zimao and Wang, Yifan and Xia, Yunni and Zhang, Yuxia and Jiang, Yanjie},
title = {Reproduction Package for Ariticle `Deep Learning Based Feature Envy Detection Boosted by Real-World Examples'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8267775},
abstract = {
    <p>feTruth is a tool written in Python that can detect feature envy smells in Java projects.</p>

},
keywords = {Code Smells, Feature Envy, Software Refactoring}
}

@software{10.5281/zenodo.8267827,
author = {Yang, Jun and Wang, Yuehan and Lou, Yiling and Wen, Ming and Zhang, Lingming},
title = {Reproduction artifact of the paper "A Large-scale Empirical Review of Patch Correctness Checking Approaches"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8267827},
abstract = {
    <p>The artifact of the paper “A Large-scale Empirical Review of Patch Correctness Checking Approaches”. The artifact contains a new manually labeled dataset for Patch Correctness Checking and evaluation experiments for nine Patch Correctness Checking techniques.</p>

},
keywords = {Empirical assessment., Patch correctness, Program repair}
}

@software{10.5281/zenodo.8271236,
author = {Karimipour, Nima and Pham, Justin and Clapp, Lazaro and Sridharan, Manu},
title = {Practical Inference of Nullability Types},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8271236},
abstract = {
    <h2 id="this-upload-is-a-docker-image-containing-the-artifact-and-scripts-to-rerun-experiments.">This upload is a docker image containing the artifact and scripts to rerun experiments.</h2>
<h3 id="container-structure">Container Structure</h3>
<p>This docker image contains:</p>
<ul>
<li><p>source code (NullAwayAnnotator) of our tool (will be found in /var/NullAwayAnnotator)</p></li>
<li><p>all benchmarks (will be cloned in /var/benchmarks)</p></li>
<li><p>scripts to reproduce our experiments (will be found in /var/AE)</p></li>
</ul>
<h3 id="setup">Setup</h3>
<ol type="1">
<li><p>Install Docker based on your system configuration: <a href="https://docs.docker.com/get-docker/">Get Docker</a>.</p></li>
<li><p>Import the artifact into Docker: <code>docker load annotator-ae-fse-2023</code></p></li>
<li><p>Run the Docker image (give container at least 16gigs of ram): <code>docker run --name annotator-ae annotator-ae-fse-2023 &amp;</code></p></li>
<li><p>Access docker container shell: <code>docker exec -it annotator-ae bash</code></p></li>
</ol>
<p>All required packages have been already installed in the docker image, the docker can be safely executed with no internet connection.</p>
<p>Instructions for how to run the paper’s experiments are inside the container in the <code>README.md</code> file at <code>/var/README.md</code>.</p>

},
keywords = {inference, java, nullability, static-code-analysis}
}

@software{10.5281/zenodo.8280911,
author = {Nguyen, Giang and Biswas, Sumon and Rajan, Hridesh},
title = {Replication Package of the ESEC/FSE 2023 Paper Entitled "Fix Fairness, Don't Ruin Accuracy: Performance Aware Fairness Repair using AutoML"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8280911},
abstract = {
    <p>To increase transparency and encourage reproducibility, we have made our artifact publicly available. All the source code and evaluation data with detailed descriptions will be updated here: https://github.com/giangnm58/Fair-AutoML.</p>

},
keywords = {automated machine learning, bias mitigation, fairness-accuracy trade-off, machine learning software, Software fairness}
}

@software{10.6084/m9.figshare.23913096.v1,
author = {Kim, Shinhae and Hwang, Sungjae},
title = {Replication Package for Article `EtherDiffer: Differential Testing on RPC Services of Ethereum Nodes'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.23913096.v1},
abstract = {
    <p>Binary files of target nodes: clients/ Configuration template files for network construction: configs/ Smart contracts used for testing: contracts/ License file: LICENSE.txt Dependency packages of EtherDiffer: node_modules/ Dependency information files: package.json, package-lock.json Readme file: README.txt Main implementation of EtherDiffer: src/ Source files for multi-concurrent transactions: transactions/</p>

},
keywords = {blockchain, differential testing, ethereum nodes, rpc services}
}

@software{10.6084/m9.figshare.24004242.v1,
author = {Song, Suhwan and Lee, Byoungyoung},
title = {Reproduction Package for Article "Metamong: Detecting Render-update Bugs in Web Browsers through Fuzzing"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24004242.v1},
abstract = {
    <p>Source code and all dataset used in the paper.</p>
<p>“Metamong.zip” contains the source code of Metamong.</p>
<p>“6.1.zip” contains the result of 6.1 Effectiveness of Render-update Oracle.</p>
<p>The data used in the paper. The directory ‘chrome’ contains Chrome render-update bugs. The directory ‘firefox’ contains Firefox render-update bugs.</p>
<p>In each directory, the file ‘issue_url’ contains the URL of a bug tracker result. The file ‘bug_list.txt’ categorizes which bugs are reproducible or not. The name of each directory in ‘chrome’ and ‘firefox’ represents the issue number. It contains a PoC HTML file (poc.html), a mutation primitive file (poc.js), and the correct and incorrect rendering outputs. “6.2.zip” contains the result of 6.2 Effectiveness of Page Mutator.</p>
<p>“100k_inputs” contains the HTML testcases. “output” contains the result of each mutation primitive test.</p>

},
keywords = {Software testing, verification and validation}
}

@software{10.1145/3580414,
author = {Lee, Edward and Lhot\'{a}k, Ond\v{r}ej},
title = {Artifact for the OOPSLA 2023 paper 'Simple Reference Immutability for System F-Sub'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580414},
abstract = {
    <p>This artifact The artifact consists of the Coq proofs for the paper ‘Simple Reference Immutability for System F-sub’. There are two calculi formalized in this artifact.</p>
<ul>
<li><p>System Lm, our untyped reference immutability calculus with the dynamic immutability safety results discussed in Section 3 of the paper.</p></li>
<li><p>System Fm, our typed calculi building on Lm and System F-sub with both the static soundness results discussed in Section 4 of our paper as well as the dynamic immutability safety results discussed in Section 4 of the paper.</p></li>
</ul>

},
keywords = {Coq, reference immutability, System F-sub, System Fm, System Lm}
}

@software{10.1145/3580418,
author = {Jung, Jaehwang and Lee, Janggun and Choi, Jaemin and Kim, Jaewoo and Park, Sunho and Kang, Jeehoon},
title = {Coq Formalization for the Article "Modular Verification of Safe Memory Reclamation in Concurrent Separation Logic"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580418},
abstract = {
    <p>Coq Formalization for the Article “Modular Verification of Safe Memory Reclamation in Concurrent Separation Logic”.</p>

},
keywords = {concurrent algorithm, Coq, Iris, memory reclamation, separation logic}
}

@software{10.5281/zenodo.8124395,
author = {Thy, Sewen and Costea, Andreea and Gopinathan, Kiran and Sergey, Ilya},
title = {Reproduction Artefact for Article 'Adventure of a Lifetime: Extract Method Refactoring for Rust'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8124395},
abstract = {
    <p>This release snapshots the functionality of the submitted artefact for the tool Rusty Extraction Maestro (REM) described in the OOPSLA 23 paper “Adventure of a Lifetime: Extract Method Refactoring for Rust”:</p>
<ul>
<li><p>Docker file with reproducible build environment</p></li>
<li><p>Readme with getting started and step-by-step instructions</p></li>
<li><p>Source code and build files for REM</p></li>
<li><p>40 experiment programs</p></li>
</ul>

},
keywords = {Extract Method, IDE, Language Tooling, Program Repair, Refactoring, Rust}
}

@software{10.5281/zenodo.8144182,
author = {Chen, Qiaochu and Banerjee, Arko and Demiralp, \c{C}a\u{g}atay and Durrett, Greg and Dillig, I\c{s}\i{}l},
title = {Reproduction Package for Article 'Data Extraction via Semantic Regular Expression Synthesis'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8144182},
abstract = {
    <p>This repository contains the code artifact for evaluation section of the paper “Data Extraction via Semantic Regular Expression Synthesis”. The included README file contains further instructions on how to reproduce the evaluations.</p>

},
keywords = {Programming by examples, regular expressions}
}

@software{10.5281/zenodo.8200210,
author = {Feser, Jack and Dillig, I\c{s}\i{}l and Solar-Lezama, Armando},
title = {Inductive Program Synthesis Guided by Observational Program Similarity (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8200210},
abstract = {
    <p>Artifact for “Inductive Program Synthesis Guided by Observational Program Similarity”.</p>

},
keywords = {program synthesis}
}

@software{10.5281/zenodo.8202373,
author = {Cai, Zhuo and Farokhnia, Soroush and Goharshady, Amir Kafshdar and Hitarth, S.},
title = {Artifact-Asparagus: Automated Synthesis of Parametric Gas Upper-bounds for Smart Contracts},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8202373},
abstract = {
    <p>The artifact offers code, data and a virtual machine that can reproduce the result of our paper. It can be used to estimate upper bound of gas cost for ethereum smart contract public functions.</p>
<p>Structure of the Repository The root directory of the repository is Aspragus/ present in Github https: //github.com/zhuocai/Asparagus/. The artifact repository consists of the following: Algorithm/Code. The code of the algorithm is present in the src directory. It is written in Python3. Shell Scripts Various shell scripts that we use to run the benchmarks are in the root folder of our repository. GASTAP Dataset. We have evaluated our tool on the GASTAP dataset that can be found in our GitHub Repository in the directory dataset/gastap dataset. Each subfolder contains a solidity source code .sol file, Rule-Based-Representation .rbr file compiled using the EthIR tool, and .meta file that stores auxiliary information about RBR and the variables.</p>

},
keywords = {Ethereum, gas}
}

@software{10.5281/zenodo.8219447,
author = {Sahebolamri, Arash and Barrett, Langston and Moore, Scott and Micinski, Kristopher},
title = {Code and experiments for paper 'Bring Your Own Data Structures to Datalog'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8219447},
abstract = {
    <p>The artifact, packaged as a Docker image, contains the code for BYODS, a Datalog engine that allows custom relation-backing data structures in Datalog programs. In addition, the experiments presented in the paper ‘Bring Your Own Data Structures to Datalog’ are included in the artifact, allowing easy reproduction of experiments results. The file <code>README.MD</code> in the Docker image contains instructions for running the experiments.</p>

},
keywords = {data structures, Datalog, program analysis, union find}
}

@software{10.5281/zenodo.8313104,
author = {Haas, Thomas and Maseli, Ren\'{e} and Meyer, Roland and Ponce de Le\'{o}n, Hern\'{a}n},
title = {Static Analysis of Memory Models for SMT Encodings (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8313104},
abstract = {
    <p>This artifact allows for reproducing the results of Section 6 of the paper Static Analysis of Memory Models for SMT Encodings published OOPSLA2023.</p>

},
keywords = {Abstract interpretation, axiomatic semantics, verification, weak memory models}
}

@software{10.5281/zenodo.8314888,
author = {Vindum, Simon Friis and Birkedal, Lars},
title = {Artifact for the paper "Spirea: A Mechanized Concurrent Separation Logic for Weak Persistent Memory" in OOPSLA23},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8314888},
abstract = {
    <p>Artifact for the paper ‘Spirea: A Mechanized Concurrent Separation Logic for Weak Persistent Memory’. The artifact contains a full mechanization of the paper. The project is also available at: https://github.com/logsem/spirea</p>

},
keywords = {coq, iris, perennial, persistent memory}
}

@software{10.5281/zenodo.8317948,
author = {Crichton, Will and Gray, Gavin and Krishnamurthi, Shriram},
title = {Artifact for "A Grounded Conceptual Model for Ownership Types in Rust"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8317948},
abstract = {
    <p>These are Docker images that contain the codebase and evaluation scripts for our OOPSLA 2023 paper “A Grounded Conceptual Model for Ownership Types in Rust”.</p>

},
keywords = {concept inventory, ownership types, program state visualization, Rust}
}

@software{10.5281/zenodo.8320671,
author = {Conrado, Giovanna Kobus and Goharshady, Amir Kafshdar and Kochekov, Kerim and Tsai, Yun Chen and Zaher, Ahmed Khaled},
title = {Artifact for Exploiting the Sparseness of Control-flow and Call Graphs for Efficient and On-demand Algebraic Program Analysis},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8320671},
abstract = {
    <p>This artifact compares the performance of our algorithm presented in the paper vs.&nbsp;the classical approach of using Tarjan’s algorithm. It uses programs from DaCapo benchmarks as well as programs generated by Windows device drivers for the purpose of running the algorithms on them. After putting these programs into an appropriate form and finding the associated tree and depth decompositions, it feeds them to both our algorithm and Tarjan’s, and compares the performance of the two algorithms. Detailed instructions can be found inside the artifact in artifact-documentation.pdf</p>

},
keywords = {Algebaric Program Analysis, Data-flow Analysis, Graph Sparsity, Parameterized Algorithms, Parameterized complexity and exact algorithms, Program analysis, Program reasoning, Program verification, Treedepth, Treewidth}
}

@software{10.5281/zenodo.8325410,
author = {Sun, Yican and Peng, Xuanyu and Xiong, Yingfei},
title = {Artifact for "Synthesizing Efficient Memoization Algorithms"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8325410},
abstract = {
    <p>This is the artifact for the OOPLSA2023 paper “Synthesizing Efficient Memoization Algorithms”, including: - the docker image of our tool, and the reproduction package. - the readme file.</p>

},
keywords = {docker file}
}

@software{10.5281/zenodo.8327489,
author = {Hance, Travis and Howell, Jon and Padon, Oded and Parno, Bryan},
title = {Leaf: Modularity for Temporary Sharing in Separation Logic (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8327489},
abstract = {
    <p>This contains the Coq development validating the core technical contributions of the paper <em>Leaf: Modularity for Temporary Sharing in Separation Logic</em>. It contains:</p>
<ul>
<li>Definitions of Leaf concepts and proofs of Leaf inference rules</li>
<li>Instantiation of Leaf for a simple heap-based language with atomic heap operations</li>
<li>Derivation of fractional permissions and counting permissions within Leaf</li>
<li>The reader-writer lock example</li>
<li>The hash table example</li>
</ul>

},
keywords = {Coq, Iris, separation logic}
}

@software{10.5281/zenodo.8329813,
author = {Yi, Pu (Luke) and Achour, Sara},
title = {Artifact for the OOPSLA 2023 Article "Hardware-Aware Static Optimization of Hyperdimensional Computations"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8329813},
abstract = {
    <p>This is the artifact accompanying our study of hardware-aware static optimization of hyperdimensional computation, accepted for presentation at the 38th ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA) 2023. The artifact contains the implementation of our system, scripts to reproduce the evaluation results shown in the paper, and detailed instructions for setting up the environment and step-by-step reproduction of the results.</p>

},
keywords = {emerging hardware technologies, program optimization, unconventional computing}
}

@software{10.5281/zenodo.8331516,
author = {Meier, Shawn and Mover, Sergio and Kaki, Gowtham and Chang, Bor-Yuh Evan},
title = {Historia: Refuting Callback Reachability with Message-History Logics (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8331516},
abstract = {
    <p>This is the artifact for the paper Historia: Refuting Callback Reachability with Message-History Logics and contains the implementation and open source Android applications used for evaluation. This artifact implements an application-only message-history based program analysis for Android. It handles safety properties relating to event and callback order including null pointer exceptions and other runtime exceptions in the Android framework.</p>

},
keywords = {event-driven applications, program analysis, separation logic, software safety, static analysis, temporal logics}
}

@software{10.5281/zenodo.8331740,
author = {Cho, Minki and Song, Youngju and Lee, Dongjae and G\"{a}her, Lennard and Dreyer, Derek},
title = {Stuttering For Free},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8331740},
abstract = {
    <p>This is the artifact for the paper “Stuttering For Free”.</p>

},
keywords = {Coq, stuttering simulation, verification}
}

@software{10.5281/zenodo.8332962,
author = {Phipps-Costin, Luna and Rossberg, Andreas and Guha, Arjun and Leijen, Daan and Hillerstr\"{o}m, Daniel and Sivaramakrishnan, KC and Pretnar, Matija and Lindley, Sam},
title = {Artifact for Continuing WebAssembly with Effect Handlers},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8332962},
abstract = {
    <p>The artifact contains the software and instructions on how to reproduce the results of the associated paper.</p>

},
keywords = {effect handlers, experiments, WebAssembly}
}

@software{10.5281/zenodo.8333055,
author = {Shadab, Narges and Gharat, Pritam and Tiwari, Shrey and Ernst, Michael D. and Kellogg, Martin and Lahiri, Shuvendu K. and Lal, Akash and Sridharan, Manu},
title = {Inference of Resource Management Specifications},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8333055},
abstract = {
    <p>This artifact contains the data and analysis supporting the evaluation section in the ‘Inference of Resource Management Specifications’ paper. It includes the implementation of the inference algorithm for resource management specifications in both Java and C#, along with instructions for running the tools on the benchmarks we used to evaluate our tools. The goal of these tools is to automatically infer specifications for the Resource Leak Checker and RLC#.</p>

},
keywords = {accumulation analysis, Pluggable type systems, resource leaks, specify-and-check, specify-and-verify, static analysis, typestate analysis}
}

@software{10.5281/zenodo.8416208,
author = {Gao, Pengfei and Zhang, Yedi and Song, Fu and Chen, Taolue and Standaert, Francois-Xavier},
title = {Peproduction Package for Article "Compositional Verification of Efficient Masking Countermeasures against Side-Channel Attacks"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8416208},
abstract = {
    <p>CONVINCE is the artifact of paper “Compositional Verification of Efficient Masking Countermeasures against Side-Channel Attacks”.</p>

},
keywords = {compositional reasoning, countermeasures, cryptographic implementations, Formal verification, power side-channel attacks}
}

@software{10.1145/3626492,
author = {Kelly, Terence},
title = {Source code for "Protecting Secrets from Computers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3626492},
abstract = {
    <p>The column argues that secrets should be protected from contact with computers and software. In that spirit, I recommend that you prevent the software associated herewith from seeing secrets of any kind. Use this example code only to check your practice work with paper-and-pencil methods, and for amusement.</p>
}
}

@software{10.5281/zenodo.7993545,
author = {Sieczkowski, Filip and Pyzik, Mateusz and Biernacki, Dariusz},
title = {A General Fine-Grained Reduction Theory for Effect Handlers: Formalisation},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7993545},
abstract = {
    <p>The artifact consists of a Coq formalisation and an OCaml implementation associated with the paper “A General Fine-Grained Reduction Theory for Effect Handlers”, conditionally accepted to ICFP 2023. The main part of the artifact is the Coq formalisation of the reduction theory developed in the paper, and of most of the metatheoretical results. In addition, an OCaml implementation of the (semi-)normalization procedure developed in the paper is provided.</p>

},
keywords = {algebraic effect, delimited continuation, formalisation, normalization-by-evaluation, reduction}
}

@software{10.5281/zenodo.7905120,
author = {Ma, Haoyang and Shen, Qingchao and Tian, Yongqiang and Chen, Junjie and Cheung, Shing-Chi},
title = {Artifact for the ISSTA2023 Paper Fuzzing Deep Learning Compilers with HirGen},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7905120},
abstract = {
    <p>This is the artifact of HirGen. It contains about 3K LOC C++ code and cmake files for building the softwares. The main purpose of it is to generate executable <code>hirgen</code> for generating computational graphs and use them to test DL compilers.</p>

},
keywords = {Fuzzer, Program Generator}
}

@software{10.5281/zenodo.7944722,
author = {Lipp, Stephan and Elsner, Daniel and Kacianka, Severin and Pretschner, Alexander and B\"{o}hme, Marcel and Banescu, Sebastian},
title = {Artifacts for the paper: "Green Fuzzing: A Saturation-Based Stopping Criterion using Vulnerability Prediction"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7944722},
abstract = {
    <p>This repository contains the training and evaluation data, including the analysis script and machine-learned vulnerability prediction models, of the paper “Green Fuzzing: A Saturation-Based Stopping Criterion using Vulnerability Prediction”.</p>

},
keywords = {fuzzing, stopping criteria, vulnerability prediction}
}

@software{10.5281/zenodo.7962308,
author = {Chow, Yiu Wai and Sch\"{a}fer, Max and Pradel, Michael},
title = {Artifact for "Beware of the Unexpected: Bimodal Taint Analysis"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7962308},
abstract = {
    <p>This artifact contains supplementary material for the paper “Beware of the Unexpected: Bimodal Taint Analysis” (ISSTA’23).</p>

},
keywords = {AI4SE, software security}
}

@software{10.5281/zenodo.7976809,
author = {Kamm, Matteo and Rigger, Manuel and Zhang, Chengyu and Su, Zhendong},
title = {Reproduction artifact for "Testing Graph Database Engines via Query Partitioning"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7976809},
abstract = {
    <p>The artifact consists of two main components: - GDBMeter, the tool which implements Predicate Partitioning and was used to find all bugs reported in the paper. - A SQLite database with a list of bugs that we reported and additional meta information.</p>

},
keywords = {automatic testing, database testing, graph databases, test oracle}
}

@software{10.5281/zenodo.7977256,
author = {Liu, Kaibo and Han, Yudong and Zhang, Jie M. and Chen, Zhenpeng and Sarro, Federica and Harman, Mark and Huang, Gang and Ma, Yun},
title = {TrickyBugs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7977256},
abstract = {
    <p>This is TrickyBugs, the dataset of the ISSTA’23 paper entitled “Who Judges the Judge: An Empirical Study on Online Judge Tests”. This dataset contains the detected false positive solutions (bugs) and the corresponding generated hack test inputs and hack test outputs in the paper. Read the paper for detailed information.</p>

},
keywords = {Online judge platform, Software testing, Test assessment}
}

@software{10.5281/zenodo.7977434,
author = {Jia, Fuqi and Han, Rui and Huang, Pei and Liu, Minghao and Ma, Feifei and Zhang, Jian},
title = {Improving Bit-Blasting for Nonlinear Integer Constraints},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7977434},
abstract = {
    <p>This Artifact Evaluation document provides an assessment of the artifact submitted with the paper titled “Improving Bit-Blasting for Nonlinear Integer Constraints”, which was accepted at ISSTA 2023. The purpose of this evaluation is to verify the artifact’s reproducibility and usefulness in advancing the field.</p>
<p>The tool names BLAN, i.e., Bit-bLAst to solve Nonlinear integer constraints. In the paper, we combine it with an SMT-LIB frontend so that it can solve QF_NIA (quantifier free nonlinear integer arithmetic) constraints. It is available at</p>
<pre><code>https://github.com/MRVAPOR/BLAN</code></pre>

},
keywords = {nonlinear integer constraints, satisfiability modulo theories}
}

@software{10.5281/zenodo.7977570,
author = {Xie, Zifan and Wen, Ming and Jia, Haoxiang and Guo, Xiaochen and Huang, Xiaotong and Zou, Deqing and Jin, Hai},
title = {Reproduction Package for Ariticle "Precise and Efficient Patch Presence Test for Android Applications against Code Obfuscation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7977570},
abstract = {
    <p>This is the repository for paper submission “Precise and Efficient Patch Presence Test for Android Applications against Code Obfuscation”. It introduces PHunter, which is a precise and efficient patch presence test tool for Android applications against code obfuscation, including identifier renaming, package flattening, control flow randomization, and dead code removal. PHunter does not rely on debug information and uses fine-grained anti-obfuscation</p>

},
keywords = {Android Security, Library Detection, Patch Presence Test}
}

@software{10.5281/zenodo.7978245,
author = {Chen, Simin and Wei, Shiyi and Liu, Cong and Yang, Wei},
title = {Reproducation package for “DyCL: Dynamic Neural Network Compilation Via Program Rewriting and Graph Optimization”},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978245},
abstract = {
    <p>This artifact contains three parts: (1) the dynamic neural networks used in our evaluation, (2) the core implementation of DyCL, and (3) the script to automatically launch the experiments and test the compilation results.</p>

},
keywords = {Deep Learning Compiler, Dynamic Neural Networks, Static analysis.}
}

@software{10.5281/zenodo.7978488,
author = {Pang, Chengbin and Zhang, Tiantai and Xu, Xuelan and Wang, Linzhang and Mao, Bing},
title = {OCFI: Make Function Entry Identification Hard Again},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978488},
abstract = {
    <p>We introduce OCFI, a modified LLVM/Clang compiler that offers the capability to obfuscate the .eh_frame section of compiled binaries. This obfuscation process aims to make it more challenging for disassemblers to identify function entries.</p>
<p>By leveraging OCFI, C/C++ projects can be compiled with the obfuscation feature enabled. This means that the resulting binaries will have their .eh_frame sections modified, enhancing their resistance to reverse engineering attempts and making the analysis of function boundaries more difficult for disassemblers. The application of OCFI as a compiler tool provides an additional layer of security for C/C++ projects, safeguarding sensitive code and intellectual property from potential attackers or unauthorized access.</p>

},
keywords = {binary disassembly, function entry detection, obfuscation}
}

@software{10.5281/zenodo.7978507,
author = {Jayasuriya, Dhanushka and Terragni, Valerio and Dietrich, Jens and Ou, Samuel and Blincoe, Kelly},
title = {Replication Package for Article "Understanding Breaking Changes in the Wild"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978507},
abstract = {
    <p>This Artifact comprises the data used for the research and the scripts utilized to extract the data from GitHub repositories. We have included the dataset we used for the manual analysis and the codes used for the manual analysis process. Additionally we included the transitive data we have extracted for these repositories. The README.md file includes the steps you need to create the python environment to execute the queries you need to execute on the dataset to extract the answers for each research question.</p>

},
keywords = {breaking changes, software dependency, software evolution, software libraries}
}

@software{10.5281/zenodo.7978718,
author = {Kedia, Piyus and Purandare, Rahul and Agarwal, Udit and Rishabh},
title = {CGuard: Scalable and Precise Object Bounds Protection for C},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978718},
abstract = {
    <p>A tool to detect spatial safety bugs in C programs.</p>

},
keywords = {Buffer overflow, Spatial safety}
}

@software{10.5281/zenodo.7980923,
author = {Deng, Yinlin and Xia, Chunqiu Steven and Peng, Haoran and Yang, Chenyuan and Zhang, Lingming},
title = {ISSTA2023 Artifact for "Large Language Models Are Zero-Shot Fuzzers: Fuzzing Deep-Learning Libraries via Large Language Models"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7980923},
abstract = {
    <p>The artifact provides the source code of the ISSTA’2023 paper “Large Language Models Are Zero-Shot Fuzzers: Fuzzing Deep-Learning Libraries via Large Language Models”. Specifically, it contains TitanFuzz’s implementation for fuzzing PyTorch and TensorFlow.</p>

},
keywords = {Fuzz Testing, Large Language Model, Test Generation}
}

@software{10.5281/zenodo.8004172,
author = {Zhang, Yiyu and Liu, Tianyi and Sun, Zewen and Chen, Zhe and Li, Xuandong and Zuo, Zhiqiang},
title = {Artifact Package for Article 'Catamaran: Low-Overhead Memory Safety Enforcement via Parallel Acceleration'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8004172},
abstract = {
    <p>This artifact contains the main implementation of Catamaran, as well as the scripts used for running it. This artifact claims the availability and the functionality of Catamaran.</p>

},
keywords = {memory safety enforcement, parallel acceleration, program analysis}
}

@software{10.5281/zenodo.8006662,
author = {Vikram, Vasudev and Laybourn, Isabella and Li, Ao and Nair, Nicole and OBrien, Kelton and Sanna, Rafaello and Padhye, Rohan},
title = {Mu2: Guiding Greybox Fuzzing with Mutation Testing (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8006662},
abstract = {
    <p>This artifact accompanies the paper “Guiding Greybox Fuzzing with Mutation Testing”, published at ISSTA 2023. It contains a replication package for experiments and evaluation data used to generate the figures in the paper. The evaluation data contains logs of the fuzzing experiments described in the paper.</p>

},
keywords = {fuzz testing, mutation testing, test generation}
}

@software{10.5281/zenodo.8128613,
author = {Pan, Yu and Xu, Zhichao and Li, Levi Taiji and Yang, Yunhe and Zhang, Mu},
title = {Reproduction package for article "Automated Generation of Security-Centric Descriptions for Smart Contract Bytecode"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8128613},
abstract = {
    <p>Reproduce experiments in paper “Automated Generation of Security-Centric Descriptions for Smart Contract Bytecode”</p>

},
keywords = {decentralized apps, natural language generation, program analysis, smart contracts, textual description}
}

@software{10.6084/m9.figshare.23173448,
author = {Xue, Zhiyi and Liu, Si and Zhang, Zhaodi and Wu, Yiting and Zhang, Min},
title = {DualApp},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.23173448},
abstract = {
    <p>DualApp is a prototype tool for the robustness verification of neural networks. It is the official implementation for paper “A Tale of Two Approximations: Tightening Over-Approximation for DNN Robustness Verification via Under-Approximation”. In this project, we propose a dual-approximation approach to tighten over-approximations, leveraging an activation function’s underestimated domain to define tight approximation bounds.We assess it on a comprehensive benchmark of DNNs with different architectures. Our experimental results show that DualApp significantly outperforms the state-of-the-art approaches on the verified robustness ratio and the certified lower bound.</p>

},
keywords = {Deep Neural Network, DualApp, Over approximation, Robustness Verification, Under approximation}
}

@software{10.5281/zenodo.7921796,
author = {Shen, Mingjie and Davis, James C. and Machiry, Aravind},
title = {Reproduction Package for Article `Towards Automated Identification of Layering Violations in Embedded Applications (WIP)'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7921796},
abstract = {
    <p>This is a tool to detect layering violations in embedded applications. The tool uses LLVM and requires a bitcode file of the target application.</p>
<p>Specifically, given a bitcode file, our tool will generate the list of all NCMAs (a type of layering violations).</p>

},
keywords = {Embedded Systems, Firmware, Hardware Abstraction Layer, Portability, Static Analysis}
}

@software{10.5281/zenodo.7929610,
author = {Gollenstede, Niklas and Kulau, Ulf and Dietrich, Christian},
title = {Implementations for "reUpNix: Reconfigurable and Updateable Embedded Systems"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7929610},
abstract = {
    <p>This repository contains the practical contributions for the paper “reUpNix: Reconfigurable and Updateable Embedded Systems”.</p>
<p>The differential update transfer mechanism <code>nix store sent</code> is implemented as part of Nix, and is included here as one big patch in <code>patches/nix-store-send.patch</code>.</p>
<p><code>modules/hermetic-bootloader.nix.md</code> implements the bootloader configuration, and <code>modules/minify.nix.md</code> realizes the reduction in installation size.</p>
<p>Container integration is implemented in <code>modules/target/containers.nix.md</code>, and the configuration model (Machine Config / System Profile) by the layout of the individual hosts in <code>hosts/</code>, by <code>lib/misc.nix#importMachineConfig</code>, and by <code>modules/target/specs.nix.md</code>.</p>

},
keywords = {embedded systems, NixOS, reproducible systems}
}

@software{10.5281/zenodo.7939291,
author = {Rommel, Florian and Dietrich, Christian and Ziegler, Andreas and Ostapyshyn, Illia and Lohmann, Daniel},
title = {Thread-Level Attack-Surface Reduction - Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7939291},
abstract = {
    <p>This artifact contains the raw data of the evaluation results and the necessary programs and scripts to repeat the experiments and analyses of the paper “Thread-Level Attack-Surface Reduction”, presented at the 24th ACM SIGPLAN/SIGBED International Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES 2023). See https://doi.org/10.1145/3589610.3596281</p>

},
keywords = {binary tailoring, debloating, return-oriented programming}
}

@software{10.5281/zenodo.7709681,
author = {Huang, Yulong and Yallop, Jeremy},
title = {Defunctionalization with Dependent Types: Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709681},
abstract = {
    <p>We provide a portable standalone implementation of the defunctionalization translation, written in OCaml and compiled to run in a web browser using js_of_ocaml. The implementation performs type checking of CC and DCC terms, abstract defunctionalization and backwards translation from DCC to CC, allowing the interested reader to experiment with the effects of the translation on real examples. We include several ready-made examples, including dependent composition, dependent pairs and finite sets.</p>

},
keywords = {compilation, dependent types, type preservation, type systems}
}

@software{10.5281/zenodo.7709704,
author = {Prinz, Jacob and Lampropoulos, Leonidas},
title = {Reproduction Package for "Merging Inductive Relations"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709704},
abstract = {
    <p>VM that allows for replicating all the experiments in the PLDI 2023 paper “Merging Inductive Relations”.</p>

},
keywords = {Merging Inductive Relations, Property-Based Testing, QuickChick}
}

@software{10.5281/zenodo.7787547,
author = {Park, Jihyeok and Youn, Dongjun and Lee, Kanguk and Ryu, Sukyoung},
title = {Artifact For "Feature-Sensitive Coverage for Conformance Testing of Programming Language Implementations"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7787547},
abstract = {
    <p>Artifact For “Feature-Sensitive Coverage for Conformance Testing of Programming Language Implementations”</p>

},
keywords = {conformance test synthesis, coverage-guided fuzzing, feature-sensitive coverage, mechanized specification}
}

@software{10.5281/zenodo.7798646,
author = {Goens, Andr\'{e}s and Chakraborty, Soham and Sarkar, Susmit and Agarwal, Sukarn and Oswald, Nicolai and Nagarajan, Vijay},
title = {Compound Memory Models: Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7798646},
abstract = {
    <p>This is the artifact to the paper “Compound Memory Models”. It includes the LOST-POP model implementation in Lean 4, the CMM implementation in Alloy, multiple litmus tests for both and accompanying gem5 simulations for some litmus tests.</p>

},
keywords = {alloy, axiomatic, compositional, gem5, lean4, memory models, operational, simulator}
}

@software{10.5281/zenodo.7809339,
author = {Kovach, Scott and Kolichala, Praneeth and Gu, Tiancheng and Kjolstad, Fredrik},
title = {Benchmark Reproduction for "Indexed Streams: A Formal Intermediate Representation for Fused Contraction Programs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7809339},
abstract = {
    <p>Contains formal proofs in Lean3 and benchmarking code for evaluation (section 8).</p>

},
keywords = {contractions, functional programming, operational semantics, streams}
}

@software{10.5281/zenodo.7810841,
author = {Barnaby, Celeste and Chen, Qiaochu and Samanta, Roopsha and Dillig, I\c{s}\i{}l},
title = {Reproduction Package for 'ImageEye: Batch Image Editing with Program Synthesis'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7810841},
abstract = {
    <p>This artifact contains the source code for ImageEye, along with a Docker image that runs the experiments described in the paper. In particular, the Docker image runs the benchmarks, ablations, and comparison with EUSolver.</p>

},
keywords = {computer vision, neuro-symbolic synthesis, program synthesis}
}

@software{10.5281/zenodo.7143413,
author = {Bilal, Muhammad and Canini, Marco and Fonseca, Rodrigo and Rodrigues, Rodrigo},
title = {Accompanying artifact for the paper "With Great Freedom Comes Great Opportunity: Rethinking Resource Allocation for Serverless Functions"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7143413},
abstract = {
    <p>This repository contains the code and data related to the research paper: With Great Freedom Comes Great Opportunity: Rethinking Resource Allocation for Serverless Functions. It includes&nbsp;the serverless applications, input data for the applications, the optimization algorithms, analysis notebooks and the performance data collected for the experimental scenarios described in the paper.&nbsp;</p>
}
}

@software{10.5281/zenodo.7703209,
author = {Alzayat, Mohamed and Mace, Jonathan and Druschel, Peter and Garg, Deepak},
title = {Accompanying artifact for the paper "Groundhog: Efficient Request Isolation in FaaS"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7703209},
abstract = {
    <p>Groundhog is a lightweight in-memory snapshot and restore tool that enforces sequential request isolation in Function-as-a-Service (FaaS).
In FaaS each function executes in its own container&nbsp;to isolate concurrent executions of different functions from one another. However, successive invocations of the same function commonly reuse the runtime state of a previous invocation in order to avoid container cold-start delays when invoking a function. Although efficient, this container reuse has security implications for functions that are invoked on behalf of differently privileged users or administrative domains: bugs in a function's implementation --- or a third-party library/runtime it depends on --- may leak private data from one invocation of the function to subsequent invocations of the same function.
Groundhog isolates sequential invocations of a function by efficiently reverting to a clean state, free from any private data, after each invocation. The system exploits two properties of typical FaaS platforms: each container executes at most one function at a time and legitimate functions do not retain state across invocations. This enables Groundhog to efficiently snapshot and restore function state between invocations in a manner that is independent of the programming language/runtime and does not require any changes to existing functions, libraries, language runtimes, or OS kernels.
Please visit&nbsp;https://groundhog.mpi-sws.org/ for the latest version and documentation of Groundhog.</p>
}
}

@software{10.5281/zenodo.7703530,
author = {Jeong, Jinwoo and Baek, Seungsu and Ahn, Jeongseob},
title = {Accompanying artifact for the paper "Fast and Efficient Model Serving Using Multi-GPUs with Direct-Host-Access"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7703530},
abstract = {
    <p>This is the artifact of the paper: "Fast and Efficient Model Serving Using Multi-GPUs with Direct-Host-Access" to appear in 'EuroSys 2023'. This artifact includes the DeepPlan tool generating the inference execution plans for given DNN models, the libTorch execution engine guided by the generated plans, and the DL inference server prototype powered by our libTorch engine. It also includes the DNN workloads used in our paper and script files to set up and test our artifact.</p>
}
}

@software{10.5281/zenodo.7703583,
author = {Koo, Jinhyung and Bae, Jinwook and Yuk, Minjeong and Oh, Seonggyun and Kim, Jungwoo and Park, Jung-Soo and Lee, Eunji and Kim, Bryan S. and Lee, Sungjin},
title = {Accompanying artifact for the paper "All-Flash Array Key-Value Cache for Large Objects"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7703583},
abstract = {
    <p>BigKV is a key-value cache specifically designed for caching large objects in an all-flash array (AFA).
The original paper that introduced BigKV is currently in the camera-ready stage of&nbsp;ACM/SIGOPS EuroSys 2023.
Please reference the README file in the zip file for the test.</p>
}
}

@software{10.5281/zenodo.7704577,
author = {Yoon, Wonsup and Ok, Jisu and Oh, Jinyoung and Moon, Sue and Kwon, Youngjin},
title = {Accompanying artifact for the paper "DiLOS: Do Not Trade Compatibility for Performance in Memory Disaggregation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7704577},
abstract = {
    <p>DiLOS: Do Not Trade Compatibility for Performance in Memory Disaggregation (Artifact)
&nbsp;
See README.md.</p>
}
}

@software{10.5281/zenodo.7707312,
author = {Gramoli, Vincent and Guerraoui, Rachid and Natoli, Chris and Lebedev, Andrei and Voron, Gauthier},
title = {Accompanying artifact for the paper "Diablo: A Benchmark Suite for Blockchains"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7707312},
abstract = {
    <p>This upload contains the artifact for Diablo: A Benchmark Suite for Blockchains, EuroSys 2023

diablo-benchmark-eurosys23.zip —&nbsp;Diablo source code
diablo-workloads.zip — workloads used in the paper
diablo.mp4&nbsp;— screencast which explains how to run a simple demo using the VirtualBox image
diablo.ova&nbsp;— VirtualBox image used to run a simple demo
diablobench.github.io-main.zip&nbsp;— Diablo website source code containing all the required information, such as the simple demo instruction and&nbsp;steps to reproduce the experiments from the paper
minion-eurosys23.zip&nbsp;— Minion source code
results.csv.gz&nbsp;— results from the paper, which can be used to generate the plots
scripts.tar.gz&nbsp;—&nbsp;scripts used to generate the plots from the paper
</p>
}
}

@software{10.5281/zenodo.7709922,
author = {Wei, Junyu and Zhang, Guangyan and Chen, Junchao and Wang, Yang and Zheng, Weimin and Sun, Tingtao and Wu, Jiesheng and Jiang, Jiangwei},
title = {Accompanying artifact for the paper "LogGrep: Fast and Cheap Cloud Log Storage by Exploiting both Static and Runtime Patterns"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709922},
abstract = {
    <p>Open-source repository for paper "LogGrep: Fast and Cheap Cloud Log Storage by Exploiting both Static and Runtime Patterns"(ACM Eurosys 2023)</p>
}
}

@software{10.5281/zenodo.7710637,
author = {Stoica, Bogdan Alexandru and Lu, Shan and Musuvathi, Madan and Nath, Suman},
title = {Accompanying artifact for the paper "WAFL: Exposing Memory Ordering Bugs Efficiently with Active Delay Injection"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7710637},
abstract = {
    <p>WAFFLE is an active delay injection tool for .NET platforms that aims to find memory ordering bugs - or MemOrder bugs, for short - such as use-after-free and use-before-init faults. This is a snapshot of the original code release from Sep 12, 2022. For the latest version of our tool, a link to our EuroSys'23 paper and slide decks describing WAFFLE's key features, please visit: https://github.com/bastoica/waffle.</p>
}
}

@software{10.5281/zenodo.7719328,
author = {Narayanan, Vikram and Detweiler, David and Huang, Tianjiao and Burtsev, Anton},
title = {Accompanying artifact for the paper "DRAMHiT: A Hash Table Architected for the Speed of DRAM"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7719328},
abstract = {
    <p>Artifact evaluation for the paper "DRAMHiT: A Hash Table Architected for the Speed of DRAM" (Eurosys 2023)</p>
}
}

@software{10.5281/zenodo.7721895,
author = {Yang, Jin and Yoon, Heejin and Yun, Gyeongchan and Noh, Sam H. and Choi, Young-ri},
title = {Accompanying artifact for the paper "DyTIS: A Dynamic Dataset Targeted Index Structure Simultaneously Efficient for Search, Insert, and Scan"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7721895},
abstract = {
    <p>The version for EuroSys'23 AE.
@sheepjin11 @heejin5178 @gyeongchan-yun</p>
}
}

@software{10.5281/zenodo.7726172,
author = {Tang, Lilia and Bhandari, Chaitanya and Zhang, Yongle and Karanika, Anna and Ji, Shuyang and Gupta, Indranil and Xu, Tianyin},
title = {Accompanying artifact for the paper "Fail through the Cracks: Cross-System Interaction Failures in Modern Cloud Systems"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7726172},
abstract = {
    <p>EuroSys '23 artifact for&nbsp;Fail through the Cracks: Cross-System Interaction Failures in Modern Cloud Systems</p>
}
}

@software{10.5281/zenodo.7728972,
author = {Berlakovich, Felix and Brunthaler, Stefan},
title = {Accompanying artifact for the paper "R2C: AOCR-Resilient Diversity with Reactive and Reflective Camouflage"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7728972},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.7734495,
author = {Gupta, Suyash and Rahnama, Sajjad and Pandey, Shubham and Crooks, Natacha and Sadoghi, Mohammad},
title = {Accompanying artifact for the paper "Dissecting BFT Consensus: In Trusted Components we Trust!"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7734495},
abstract = {
    <p>Creating a persistent release using Zenodo.</p>
}
}

@software{10.5281/zenodo.7734815,
author = {Park, Misun and Bhardwaj, Ketan and Gavrilovska, Ada},
title = {Accompanying artifact for the paper "Pocket: ML Serving from the Edge"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7734815},
abstract = {
    <p>Artifact-evaluation release.</p>
}
}

@software{10.5281/zenodo.7735158,
author = {Yildiz, Eren and Ahmed, Saad and Islam, Bashima and Hester, Josiah and Yildirim, Kasim Sinan},
title = {Accompanying artifact for the paper "Efficient and Safe I/O Operations for Intermittent Systems"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7735158},
abstract = {
    <p>This is the Digital Object Identifier (DOI) page for persistently indexing the source code and artifact of EaseIO. Their latest version can be found in the following GitHub repository:&nbsp;
https://github.com/tinysystems/easeIO</p>
}
}

@software{10.5281/zenodo.7737645,
author = {Raza, Ali and Unger, Thomas and Boyd, Matthew and Munson, Eric and Sohal, Parul and Drepper, Ulrich and Jones, Richard and de Oliveira, Daniel Bristot and Woodman, Larry and Mancuso, Renato and Appavoo, Jonathan and Krieger, Orran},
title = {Accompanying artifact for the paper "Unikernel Linux (UKL)"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7737645},
abstract = {
    <p>Unikernel Linux (UKL) is a small patch to Linux and glibc which allows you to build many programs, unmodified, as unikernels. That means they are linked with the Linux kernel into a final vmlinuz and run in kernel space. You can boot these kernels on baremetal or inside a virtual machine. Almost all features and drivers in Linux are available for use by the unikernel.</p>
}
}

@software{10.5281/zenodo.7737994,
author = {Lim, Hwijoon and Kim, Jaehong and Cho, Inho and Jang, Keon and Bai, Wei and Han, Dongsu},
title = {Accompanying artifact for the paper "FlexPass: A Case for Flexible Credit-based Transport for Datacenter Networks"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7737994},
abstract = {
    <p>Official Github repository for the EuroSys '23 paper "FlexPass: A Case for Flexible Credit-based Transport for Datacenter Networks"</p>
}
}

@software{10.5281/zenodo.7738934,
author = {Seneviratne, Yasas and Seemakhupt, Korakit and Liu, Sihang and Khan, Samira},
title = {Accompanying artifact for the paper "NearPM: A Near-memory Processing Prototype for Storage-class Workloads"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7738934},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.7141105,
author = {Abdelmoniem, Ahmed M. and Sahu, Atal and Canini, Marco and Fahmy, Suhaib A},
title = {Accompanying artifact for the paper "REFL: Resource-Efficient Federated Learning"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7141105},
abstract = {
    <p>First release after the artifact evaluation by ACM EuroSys artifacts evaluation committee.</p>
}
}

@software{10.6084/m9.figshare.22223914.v1,
author = {Zhang, Jian and Ji, Ye and Mu, Shuai and Tan, Cheng},
title = {Accompanying artifact for the paper "Viper: A Fast Snapshot Isolation Checker"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.22223914.v1},
abstract = {
    <p>Viper is an SI checker that is sound, complete, and fast. Viper checks black-box databases and hence is transparent to both users and databases.</p>
}
}

@software{10.1145/3594731,
author = {Kelly, Terence},
title = {Source code for Drill Bits 9 article "Catch-23: The New C Standard Sets the World on Fire"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3594731},
abstract = {
    <p>File stack.c contains the code shown in Figure 1 of my column, which illustrates idiomatic use of standard C realloc(). The stack assumes a sane "zero-null" memory allocator, i.e., a memory allocator that works the way C89 and C99 strongly recommended: Zero-length allocation requests return NULL, which means that realloc(p,0) unconditionally frees p and returns NULL and cannot fail.  Standards from C89 through C17 have *permitted* zero-null implementations of the standard library but have not *required* zero-null behavior.  Historically, many wise and good implementations have followed the zero-null rule.  Unfortunately, some implementations have done otherwise.</p>
}
}

@software{10.1145/3594732,
author = {Kelly, Terence},
title = {Source code for "Persistent Memory Programming on Conventional Hardware"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3594732},
abstract = {
    <p>"famus" is "failure-atomic msync() in user space", a library for C/C++ applications on Linux that provides an interface similar to conventional POSIX mmap()/msync() but with stronger semantics.  Like its conventional counterpart, famus enables applications to manipulate a backing file via LOADs and STOREs to the file's in-memory image.  However, unlike conventional mmap()/msync(), famus provides a strong fault tolerance guarantee: Following recovery, the state of the backing file will always reflect the most recent successful sync operation, even in the presence of failures such as power outages, OS kernel panics, and application process crashes.</p>
}
}

@software{10.1145/3594733,
author = {Kelly, Terence},
title = {Source code for "Is Persistent Memory Persistent?"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3594733},
abstract = {
    <p>This file contains instructions for running sudden whole-system power interruption tests on a Raspberry Pi 3 Model B+, as described in the accompanying article.</p>
}
}

@software{10.5281/zenodo.7709003,
author = {Wang, Bo and Kolluri, Aashish and Nikoli\'{c}, Ivica and Baluta, Teodora and Saxena, Prateek},
title = {DuoGlot: User-Customizable Transpilation of Scripting Languages (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709003},
abstract = {
    <p>This is the artifact named DuoGlot from the paper User-Customizable Transpilation of Scripting Languages accepted by the conference OOPSLA 2023. DuoGlot is a customizable code translator. Translation rules in DuoGlot are synthesized from user-provided code snippets. DuoGlot iteratively explores possible translations given the provided translation rules until finding a translation that passes tests. It currently supports customized translation from Python to JavaScript for single-file standalone programs. This artifact includes code and datasets to reproduce all the main results in the paper.</p>

},
keywords = {Program Synthesis, Program Translation}
}

@software{10.5281/zenodo.7711788,
author = {Dardinier, Thibault and Parthasarathy, Gaurav and M\"{u}ller, Peter},
title = {Verification-Preserving Inlining in Automatic Separation Logic Verifiers (artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7711788},
abstract = {
    <p>This artifact contains: 1. An Isabelle/HOL mechanization that fully supports the technical claims from the paper. 2. A reproducible analysis of the test suites of VeriFast, GRASShopper, RSL-Viper, and Nagini, corresponding to the results shown in table 1. 3. An inlining tool for Viper, which inlines calls and unrolls loops, while also checking the structural condition. 4. A test framework that runs the inlining tool on the examples in table 2 (main paper) and table 3 (appendix in the extended version).</p>

},
keywords = {Bounded Verification, GRASShopper, Isabelle, Isabelle/HOL, Loop Unrolling, Method Inlining, Modular Verification, Nagini, RSL-Viper, VeriFast, Viper}
}

@software{10.5281/zenodo.7714175,
author = {Emre, Mehmet and Boyland, Peter and Parekh, Aesha and Schroeder, Ryan and Dewey, Kyle and Hardekopf, Ben},
title = {Artifact for "Aliasing Limits on Translating C to Safe Rust"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7714175},
abstract = {
    <p>The artifact is a Docker image that contains (1) the prototype of our pseudo-safety transformations, (2) the affected pointer set analysis we implemented on top of SVF, (3) Laertes with our extensions for directionality, and (4) data analysis scripts to produce the tables and the figures in the paper. It also contains C2Rust, SVF, and Laertes themselves to run these prototypes, as well as a corpus of programs we use to evaluate our method.</p>

},
keywords = {C, Empirical Study, Memory Safety, Rust, Translation}
}

@software{10.5281/zenodo.7719431,
author = {Zhou, Jie and Criswell, John and Hicks, Michael},
title = {Artifact of the `Fat Pointers for Temporal Memory Safety of C Paper` of OOPSLA23},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7719431},
abstract = {
    <p>This artifact provides a VM and a docker image that contain all the source code to perform experiments of the Fat Pointers for Temporal Memory Safety of C Paper of OOPSLA’23.</p>

},
keywords = {Checked C, Fat Pointers, LLVM, Temporal Memory Safety}
}

@software{10.5281/zenodo.7720410,
author = {Chiang, David and McDonald, Colin and Shan, Chung-chieh},
title = {Reproduction Package for Article "Exact Recursive Probabilistic Programming"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7720410},
abstract = {
    <p>This Docker image contains everything needed to reproduce the experiments in the paper “Exact Recursive Probabilistic Programming.”</p>

},
keywords = {linear types, probabilistic programming, recursive types}
}

@software{10.5281/zenodo.7722241,
author = {Ji, Ruyi and Kong, Chaozhe and Xiong, Yingfei and Hu, Zhenjiang},
title = {Artifact for OOPSLA'23: Improving Oracle-Guided Inductive Synthesis by Efficient Question Selection},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7722241},
abstract = {
    <p>Artifact for OOPSLA’23: Improving Oracle-Guided Inductive Synthesis by Efficient Question Selection</p>
<p>This project will be maintained at https://github.com/jiry17/LearnSy, and details about this artifact can be found in README.md.</p>

},
keywords = {Oracle-Guided Inductive Synthesis, Question Selection Problem}
}

@software{10.5281/zenodo.7727577,
author = {Li, Shaohua and Su, Zhendong},
title = {Accelerating Fuzzing through Prefix-Guided Execution},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7727577},
abstract = {
    <p>This is the artifact for “Accelerating Fuzzing through Prefix-Guided Execution”, published in SPLASH/OOPSLA 2023. All instructions can be found in the zip file.</p>

},
keywords = {code coverage, fuzzing, software testing}
}

@software{10.5281/zenodo.7114594,
author = {Waleffe, Roger and Mohoney, Jason and Rekatsinas, Theodoros and Venkataraman, Shivaram},
title = {Accompanying artifact for the paper "MariusGNN: Resource-Efficient Out-of-Core Training of Graph Neural Networks"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7114594},
abstract = {
    <p>This release contains the initial artifact for the paper MariusGNN: Resource-Efficient Out-of-Core Training of Graph Neural Networks to be published at EuroSys 2023. The artifact contains the necessary code to reproduce experiments reported in the paper.</p>
}
}

@software{10.1145/3554353,
author = {Landgraf, Joshua and Giordano, Matthew and Yoon, Esther and Rossbach, Christopher J.},
title = {File System for Reconfigurable Fabrics Codebase},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554353},
abstract = {
    <p>This artifact contains the software and hardware code for FSRF, File System for Reconfigurable Fabrics, along with corresponding scripts and documentation for preparing test data, setting up the system, and running workloads and experiments.</p>

},
keywords = {FPGAs, Operating Systems, Virtual Memory, Virtualization}
}

@software{10.5281/zenodo.7564087,
author = {Feng, Yuan and Xu, Yingte},
title = {NQPV},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7564087},
abstract = {
    <p>NQPV is a verification assistant prototype of nondeterministic quantum programs. It implements the verification logic of partial correctness in the numerical form, with soundness guaranteed by the theory and experiments.</p>

},
keywords = {nondeterminism, program verification, quantum programming}
}

@software{10.5281/zenodo.7583154,
author = {Chen, Zizhan and Shao, Zili},
title = {Reproduction Package for Article ‘Transparent Runtime Change Handling for Android Apps’},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7583154},
abstract = {
    <p>The artifact provides the source code of RCHDroid, along with the instructions to generate the results. The artifact allows users to reproduce key results from the paper, including Figure 7, Figure 8, Figure 9, Figure 10, and Figure 14. The hardware must contain the ROC-RK3399-PC-PLUS development board connected to a screen. We provide compiled images to simplify the experiment workflow. Users can also build images from the source code.</p>

},
keywords = {embedded systems, mobile systems, operating systems}
}

@software{10.5281/zenodo.7583399,
author = {Bi, Jun and Guo, Qi and Li, Xiaqing and Zhao, Yongwei and Wen, Yuanbo and Guo, Yuxuan and Zhou, Enshuai and Hu, Xing and Du, Zidong and Li, Ling and Chen, Huaping and Chen, Tianshi},
title = {Reproduction pakage for Heron},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7583399},
abstract = {
    <p>This artifact describes how to set up the compilation infrastructure of HERON and how to run the workloads described in Section 6.2. Concretely, this guide provides instructions to: • Set up the experimental environment of HERON. • Run experiments to demonstrate the optimization ability of HERON as shown in Figure 6, Figure 7, Figure 8, and Figure 10. • Visualization of the search spaces as shown in Figure 11. • Run experiments to demonstrate the effectiveness of CGA as shown in Figure 12 and Figure 13.</p>

},
keywords = {code generation, compiler optimization, tensor computation}
}

@software{10.5281/zenodo.7588406,
author = {Lin, Mao and Zhou, Keren and Su, Pengfei},
title = {Reproduction Package for Article 'DrGPUM: Guiding Memory Optimization for GPU-Accelerated Applications'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7588406},
abstract = {
    <p>The artifact includes DrGPUM and benchmarks, along with instructions to reproduce the results shown in the paper.</p>

},
keywords = {CUDA, GPU profilers, GPUs, Memory management}
}

@software{10.5281/zenodo.7590151,
author = {Kolokasis, Iacovos G. and Evdorou, Giannos and Akram, Shoaib and Kozanitis, Christos and Papagiannis, Anastasios and Zakkak, Foivos S. and Pratikakis, Polyvios and Bilas, Angelos},
title = {TeraHeap: Reducing Memory Pressure in Managed Big Data Frameworks},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7590151},
abstract = {
    <p>How to Access. All scripts are available in the GitHub repository https://github.com/CARV-ICS-FORTH/asplos2023_ae. All sources, including JVM, frameworks, and benchmarks, are included as public git submodules. Also, the artifact is available at https://doi.org/10.5281/zenodo.7590151.</p>
<p>Hardware Dependencies. We recommend a dual-socket server that is equipped with two Intel(R) Xeon(R) CPU E5-2630 v3 CPUs running at 2.4 GHz, each with eight physical cores and 16 hyper-threads for a total of 32 hyper-threads. The server should have at least 128 GB DRAM. We recommend using two 1 TB Samsung PM983 PCI Express NVMe SSDs and an HDD (larger than 1.5 TB) to allocate the datasets. For the evaluation with NVM, we consider using a dual-socket server with two Intel Xeon Platinum 8260M CPUs at 2.4 GHz, with 24 cores and (96 hyper-threads), and 192 GB of DDR4 DRAM. We use Intel Optane DC Persistent Memory with a total capacity of 3 TB, of which 1 TB is in Memory mode and 2 TB are in AppDirect mode.</p>
<p>Software Dependencies. The compilation environment and the provided scripts assume Centos 7, which uses Linux Kernel v.3.10 and v.4.14.</p>
<p>Data Sets. The required datasets for Spark workloads (except BC) are automatically generated using the SparkBench suite dataset generator. The dataset will be generated when executing the specific scripts to run Spark workloads. The datasets for Spark-BC and Giraph workloads are downloaded automatically before each workload execution.</p>

},
keywords = {fast storage devices, garbage collection, Java Virtual Machine (JVM), large analytics datasets, large managed heaps, memory hierarchy, memory management, serialization}
}

@software{10.5281/zenodo.7591603,
author = {Malik, Raghav and Sheth, Kabir and Kulkarni, Milind},
title = {Coyote: A Compiler for Vectorizing Encrypted Arithmetic Circuits (artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7591603},
abstract = {
    <p>This artifact contains everything necessary to replicate the results of the paper, including: * An implementation of the compiler described in the paper * A backend test harness for profiling vectorized code * Implementations of all benchmarks used in the evaluation * Scripts necessary to automate the process of compiling, running, and collecting data from the benchmarks.</p>

},
keywords = {arithmetic circuits, Homomorphic encryption, vectorization}
}

@software{10.5281/zenodo.7591742,
author = {Hsu, Olivia and Strange, Maxwell and Sharma, Ritvik and Won, Jaeyeon and Olukotun, Kunle and Emer, Joel S. and Horowitz, Mark A. and Kj\o{}lstad, Fredrik},
title = {Reproduction Package for 'The Sparse Abstract Machine'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7591742},
abstract = {
    <p>This artifact describes how to set up and run our Sparse Abstract Machine (SAM) Python simulator and the C++ CUSTARD compiler, which compiles from concrete index notation (CIN) to SAM graphs (represented and stored in the DOT file format). The artifact also describes how to reproduce the quantitative experimental results in this paper. The artifact can be executed with any X86-64 or M-series Apple machine with Docker support and Python 3, at least 32 GB of RAM, and more than 20 GB of disk space.</p>
<p>Additionally, all instructions and dependencies for using the artifact are contained in the artifact appendix of the paper.</p>

},
keywords = {abstract machine, compilers, cycle-approximate modeling, sparse tensor algebra, streaming dataflow}
}

@software{10.5281/zenodo.7592823,
author = {Tan, Zujun and Chon, Yebin and Kruse, Michael and Doerfert, Johannes and Xu, Ziyang and Homerding, Brian and Campanoni, Simone and August, David I.},
title = {SPLENDID: Supporting Parallel LLVM-IR Enhanced Natural Decompilation for Interactive Development},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7592823},
abstract = {
    <p>The artifact for this paper contains tools and data to reproduce, with minimal effort, the entire testing flow and corroborate its claims. All results can be generated from scratch (source codes) and run across different platforms with the provided docker image. The pre-built docker image supports runs across different platforms with software dependencies taken care of, including a pre-compiled copy of the proposed decompiler, its variants, state-of-the-art decompilers used for comparison, and miscellaneous software such as vim and python. We provide an easy top level interface,  to simplify the testing process.</p>

},
keywords = {ASPLOS'23, Automatic Parallelization, Decompiler}
}

@software{10.5281/zenodo.7592848,
author = {Norman, Chase and Godbole, Adwait and Manerkar, Yatin A.},
title = {Code for Article 'PipeSynth: Automated Synthesis of Microarchitectural Axioms for Memory Consistency'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7592848},
abstract = {
    <p>This is the code for the ASPLOS 2023 paper ‘PipeSynth: Automated Synthesis of Microarchitectural Axioms for Memory Consistency’.</p>

},
keywords = {formal methods, memory consistency, microarchitecture, synthesis}
}

@software{10.5281/zenodo.7592970,
author = {Gao, Xiangyu and Raghunathan, Divya and Fang, Ruijie and Wang, Tao and Zhu, Xiaotong and Sivaraman, Anirudh and Narayana, Srinivas and Gupta, Aarti},
title = {Reproduction Package for Article CaT: A Solver-Aided Compiler for Packet-Processing Pipelines},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7592970},
abstract = {
    <p>This is the artifact evaluation part for the CaT compiler, proposed in our paper. The instruction helps reproduce the results from all tables and figures in IMPLEMENTATION AND EVALUATION section.</p>

},
keywords = {code generation, integer linear programming, packet processing pipelines, program synthesis, Programmable switches}
}

@software{10.5281/zenodo.7598726,
author = {Shu, Junyi and Zhu, Ruidong and Ma, Yun and Huang, Gang and Mei, Hong and Liu, Xuanzhe and Jin, Xin},
title = {Reproduction Package for Article 'Disaggregated RAID Storage in Modern Datacenters'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7598726},
abstract = {
    <p>We provide the artifact for the ASPLOS 2023 paper “Disaggregated RAID Storage in Modern Datacenters”, including:</p>
<ul>
<li>The main implementation of dRAID.</li>
<li>CloudLab testbed setup scripts.</li>
<li>FIO experiment scripts (Sec 9.2-9.5), which get the main results of the paper.</li>
<li>YCSB experiment scripts (Sec 9.6).</li>
</ul>

},
keywords = {Disaggregated Storage, NVMe-oF, RAID, RDMA}
}

@software{10.5281/zenodo.7612226,
author = {Li, Shaohua and Su, Zhendong},
title = {Artifact for "Finding Unstable Code via Compiler-Driven Differential Testing"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7612226},
abstract = {
    <p>The artifact contains the code and datasets we used for our experiments, as well as scripts to generate the numbers, tables, and figures of our evaluation. Specifically, it includes (a) the Juliet testsuite used for evaluation; (b) scripts for running CompDiff, sanitizers, Coverity, CppCheck, and Infer on the Juliet testsuite; (c) scripts for reporting detection results of these tools; (d) scripts for generating bug statistics on 23 real-world programs; and (e) scripts for fuzzing a target with CompDiff-AFL++. Everything is packaged and pre-built as a docker image. A standard X86 Linux machine running docker is necessary to evaluate this artifact.</p>

},
keywords = {compiler, fuzzing, undefined behavior, Unstable code}
}

@software{10.5281/zenodo.7621336,
author = {Wang, Haoyuan and Beamer, Scott},
title = {RepCut: Superlinear Parallel RTL Simulation with Replication-Aided Partitioning},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7621336},
abstract = {
    <p>This package contains the artifact for of RepCut: Superlinear Parallel RTL Simulation with Replication-Aided Partitioning, DOI 10.1145/3582016.3582034</p>
<p>This artifact contains the source code for RepCut, as well as other open source projects that are required to reproduce the results in the paper. We include Verilator 4.226 as a baseline. In addition, this artifact also contains scripts and a Makefile to compile and run the generated simulators, as well as to reproduce every figure and table from experiment data.</p>
<p>Please find more details in README.md</p>

},
keywords = {Parallel RTL Simulation, RepCut}
}

@software{10.5281/zenodo.7633678,
author = {Garimella, Karthik and Ghodsi, Zahra and Jha, Nandan Kumar and Garg, Siddharth and Reagen, Brandon},
title = {Source Code for "Characterizing and Optimizing End-to-End Systems for Private Inference"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7633678},
abstract = {
    <p>We open source our private inference simulator at the following GitHub repo: <a href="https://github.com/kvgarimella/characterizing-private-inference">https://github.com/kvgarimella/characterizing-private-inference</a>. We construct a model of a system for private inference and a simulator using Simpy to explore and evaluate tradeoffs under different system conditions. We model a single-client, single-server setting where inferences are queued in a FIFO manner and are generated by sampling from a Poisson distribution.</p>
<p>The repository itself contains four high-level directories. The directory <code>garbled_circuits</code> contains the raw data for benchmarking ReLU Garbling and Evaluation on an Intel Atom Z8350 embedded device (1.92GHz, 4 cores, 2GB RAM) and an AMD EPYC 7502 server (2.5GHz, 32 cores, 256GB RAM). These two devices represent our client and server, respectively. Next, the directory <code>layer_parallel_HE</code> contains our code and the raw data for applying layer-parallelism to linear layer homomorphic evaluations. The directory <code>simulator</code> contains our private inference simulator. Finally, <code>artifact</code> contains scripts to replicate key figures in our paper.</p>

},
keywords = {cryptography, machine learning, private inference protocols, systems for machine learning}
}

@software{10.5281/zenodo.7643745,
author = {Ye, Zihao and Lai, Ruihang and Shao, Junru and Chen, Tianqi and Ceze, Luis},
title = {SparseTIR Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7643745},
abstract = {
    <p>This repository contains scripts for setting up environments and reproducing results presented in the ASPLOS 2023 paper entitled SparseTIR: Composable Abstractions for Deep Learning.</p>
<p>Please read the README.md file or visit https://github.com/uwsampl/sparsetir-artifact for instructions on how to run and install this artifact.</p>

},
keywords = {Deep-Learning-Compilers, Sparse-Computation, Tensor-Compilers}
}

@software{10.5281/zenodo.7651655,
author = {Khazraee, Moein and Forencich, Alex and Papen, George C. and Snoeren, Alex C. and Schulman, Aaron},
title = {Code for Rosebud, Making FPGA-Accelerated Middlebox Development More Pleasant},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7651655},
abstract = {
    <p>This artifact contains the code to generate the Rosebud image, alongside code for simulation and runtime development. It also describes how new applications can be accelerated using this framework.</p>

},
keywords = {200G, FPGA, Hardware-Software Co-design, Middlebox}
}

@software{10.5281/zenodo.7668541,
author = {Raina, Ashwini and Lu, Jianan and Cidon, Asaf and Freedman, Michael J.},
title = {ASPLOS 2023 Artifact for "Efficient Compactions Between Storage Tiers with PrismDB"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7668541},
abstract = {
    <p>This artifact consists of the source code of PrismDB and the necessary scripts to reproduce the evaluation of the paper “Efficient Compactions Between Storage Tiers with PrismDB”, ASPLOS 23.</p>
<p>NOTE: Source code for the baselines rocksdb and mutant is not provided here. For rocksdb baseline, please refer to its official documentation on GitHub. For mutant baseline please follow the mutant SoCC paper.</p>

},
keywords = {compaction, key-value store, PrismDB, storage, tiered}
}

@software{10.5281/zenodo.7680535,
author = {Zuo, Gefei and Ma, Jiacheng and Quinn, Andrew and Kasikci, Baris},
title = {Reproduction Package for Article "Vidi: Record Replay for Reconfigurable Hardware"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7680535},
abstract = {
    <p>Source code is available at https://github.com/efeslab/aws-fpga</p>
<p>This artifact is prepared for ASPLOS 2023 artifact evaluation. Please refer to the <code>artifact-eval/README.md</code> for usage instructions.</p>

},
keywords = {Debugging, FPGA, Record Replay}
}

@software{10.5281/zenodo.7685681,
author = {Laeufer, Kevin and Iyer, Vighnesh and Biancolin, David and Bachrach, Jonathan and Nikoli\'{c}, Borivoje and Sen, Koushik},
title = {Simulator Independent Coverage for RTL Hardware Languages - Software Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7685681},
abstract = {
    <p>The code to reproduce results from our ASPLOS’23 paper on “Simulator Independent Coverage for RTL Hardware Languages”. Most results can be reproduced on a standard x86 Linux computer, however, for the FireSim performance and area/frequency results a more complicated setup on AWS cloud FPGAs is necessary. Please consult the Readme.md in <code>simulator-independent-coverage.tar.gz</code> for more instructions.</p>

},
keywords = {Chisel, ChiselTest, FireSim, FIRRTL, FPGA, FSM Coverage, Hardware Compiler, Line Coverage, RTL, Toggle Coverage}
}

@software{10.5281/zenodo.7699872,
author = {Ye, Haojie and Vedula, Sanketh and Chen, Yuhan and Yang, Yichen and Bronstein, Alex and Dreslinski, Ronald and Mudge, Trevor and Talati, Nishil},
title = {Reproduction Package for Article "GRACE: A Scalable Graph-Based Approach To Accelerating Recommendation Model Inference"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7699872},
abstract = {
    <p>Our paper “GRACE: A Scalable Graph-Based Approach To Accelerating Recommendation Model Inference” presents an algorithm-system co-design for improving the performance of the embedding layer in Deep Learning Recommendation Models (DLRMs). This artifact reproduces some of the main results of our paper. The performance results shown in the paper are machine-dependent. For example, Fig. 8, Fig. 13, and Fig. 14 show results on a CPU-GPU system, HBM-only system, and DIMM-HBM system with Processing-In-Memory (PIM) capability, respectively. To enable reproducing results in a timely fashion on different machines, we reproduce the main result of our paper that is machine-independent (Fig. 10). Specifically, our instructions include 1) how to download the input datasets, 2) how to pre-process these datasets, 3) how to reproduce the memory traffic reduction results for each baseline, and 4) how to generate a plot similar to Fig. 10. Expected result: compared to a no-reduction baseline, GRACE reduces the memory traffic by 1.7x.</p>

},
keywords = {Algorithm-System Co-Design, DLRM, Embedding Reduction}
}

@software{10.5281/zenodo.7702231,
author = {Liu, Jiesong and Zhang, Feng and Guan, Jiawei and Sung, Hsin-Hsuan and Guo, Xiaoguang and Du, Xiaoyong and Shen, Xipeng},
title = {Artifact for Article "Space Efficient TREC for Enabling Deep Learning on Microcontrollers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7702231},
abstract = {
    <p>This directory contains the artifact for Space Efficient TREC for Enabling Deep Learning on Microcontrollers published in ASPLOS 2023. For detailed information, please see the readme.md in TREC-Artifact.zip.</p>

},
keywords = {Compiler Optimization, Real-time Machine Learning}
}

@software{10.5281/zenodo.7709303,
author = {Gosakan, Krishnan and Han, Jaehyun and Kuszmaul, William and Mubarek, Ibrahim N. and Mukherjee, Nirjhar and Sriram, Karthik and Tagliavini, Guido and West, Evan and Bender, Michael A. and Bhattacharjee, Abhishek and Conway, Alex and Farach-Colton, Martin and Gandhi, Jayneel and Johnson, Rob and Kannan, Sudarsun and Porter, Donald E.},
title = {Mosaic Pages: Big TLB Reach with Small Pages},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709303},
abstract = {
    <p>There are three artifacts for this paper: a Gem5 model to reproduce Figure 4, a modified Linux kernel to reproduce Tables 3 and 4, and Verilog code to reproduce Table 5. The Linux artifact includes scripts to setup a KVM environment with Mosaic and vanilla Linux kernels. The artifact also includes scripts to run the Linux workloads in a VM and a script to generate tables.</p>

},
keywords = {address translation, gem5, hashing, linux, paging, TLB, verilog, virtual memory}
}

@software{10.6084/m9.figshare.22081901.v1,
author = {Swamy, Tushar and Zulfiqar, Annus and Nardi, Luigi and Shahbaz, Muhammad and Olukotun, Kunle},
title = {Artifact for "Homunculus: Auto-Generating Efficient Data-Plane ML Pipelines for Datacenter Networks" - ASPLOS 2023},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.22081901.v1},
abstract = {
    <p>The artifact contains the source code for the titular Homunculus compiler, a backend for the Taurus ASIC switch architecture, as well as three representative applications. We used these applications to demonstrate the core results of our paper, i.e., how Homunculus-generated models outperform or match the hand-tuned baseline versions. We include applications for anomaly detection, traffic classification, and botnet detection. Homunculus also generates the appropriate hardware code for each of these applications to run on a Taurus switch architecture.</p>

},
keywords = {ML Compilers, Per-packet ML, Self-driving Networks}
}

@software{10.1145/3554348,
author = {Li, Bolun and Su, Pengfei and Chabbi, Milind and Jiao, Shuyin and Liu, Xu},
title = {Reproduction Package for Article "DJXPerf: Identifying Memory Inefficiencies via Object-Centric Profiling for Java"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554348},
abstract = {
    <p>DJXPerf is a lightweight, object-centric memory profiler for Java, which associates memory-hierarchy performance metrics (e.g., cache/TLB misses) with Java objects. DJXPerf uses statistical sampling of hardware performance monitoring counters to attribute metrics to not only source code locations but also Java objects.</p>

},
keywords = {Java, performance optimization, PMU, profiling}
}

@software{10.5281/zenodo.7369395,
author = {Aanjaneya, Mridul and Nagarakatte, Santosh},
title = {Artifact for "Fast Polynomial Evaluation for Correctly Rounded Elementary Functions using the RLIBM Approach"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7369395},
abstract = {
    <p>Our library with the correctly rounded functions and the polynomial generator for them is available open source and publicly available at https://github.com/rutgers-apl/cgo23- artifact. It is available with the MIT license. The artifact includes: (1) 24 correctly rounded implementations for six elementary functions using the coefficient adaptation proce- dure by Knuth, Estrin’s method, and Estrin’s method with fused multiply-add operations for polynomial evaluation, (2) correctness testing framework for the 24 functions, (3) perfor- mance testing framework to demonstrate the performance improvements over RLibm and CRLIBM, and (4) polynomial generator for generating the polynomials using the Estrin’s method with fused multiply-add operations.</p>

},
keywords = {coefficient adaptation, correctly rounded, Estrin's procedure, fused-multiply-add, Horner's method, RLIBM}
}

@software{10.5281/zenodo.7374843,
author = {Deiana, Enrico Armenio and Suchy, Brian and Wilkins, Michael and Homerding, Brian and McMichen, Tommy and Dunajewski, Katarzyna and Dinda, Peter and Hardavellas, Nikos and Campanoni, Simone},
title = {Artifact for "Program State Element Characterization" CGO 2023.},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7374843},
abstract = {
    <p>This artifact is a podman image containing the CARMOT system and its dependencies, and it generates the main results of this paper in text format. All benchmark suites are included in the artifact, except for SPEC CPU 2017, which we cannot share directly (please refer to README.md in the artifact on how to include SPEC CPU 2017 results). This artifact requires podman (or docker) to load and run the image, and a network connection to download additional dependencies of the CARMOT system. The execution of this artifact requires an Intel multicore processor with shared memory.</p>

},
keywords = {code optimization, dynamic analysis, program characterization}
}

@software{10.5281/zenodo.7496594,
author = {Zhang, Peihua and Wu, Chenggang and Peng, Mingfan and Zeng, Kai and Yu, Ding and Lai, Yuanming and Kang, Yan and Wang, Wei and Wang, Zhe},
title = {Reproduction Package for Article 'Khaos: The Impact of Inter-procedural Code Obfuscation on Binary Diffing Techniques'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7496594},
abstract = {
    <p>Artifact for article ‘Khaos: The Impact of Inter-procedural Code Obfuscation on Binary Diffing Techniques’, including diffing files of 5 diffing works, scripts to parse the diffing result, and all the result of the paper.</p>

},
keywords = {binary diffing, code obfuscation}
}

@software{10.25442/hku.21342192.v1,
author = {Gao, Yizhao and Zhang, Baoheng and Qi, Xiaojuan and So, Hayden Kwok-Hay},
title = {DPACS: Hardware Accelerated Dynamic Neural Network Pruning through Algorithm-Architecture Co-design},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.25442/hku.21342192.v1},
abstract = {
    <p>DPCAS is an algorithm-architecture co-design framework for dynamic neural network pruning. It utilizes a hardware-aware dynamic spatial and channel pruning mechanism in conjunction with a dynamic dataflow engine in hardware to facilitate efficient processing of the pruned network.</p>

},
keywords = {Deep Learning Applications, hardware accelerators}
}

@software{10.5281/zenodo.7196061,
author = {Levine, Reese and Guo, Tianhao and Cho, Mingun and Baker, Alan and Levien, Raph and Neto, David and Quinn, Andrew and Sorensen, Tyler},
title = {MC Mutants Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7196061},
abstract = {
    <p>This artifact contains information for both collecting analyzing the results we present in the paper. On the collection side, we provide the means to run the exact experiments included in the paper. Using the exact devices from the paper will show very similar results to ours, but any GPU can be used to evaluate the way in which we collect and analyze data. On the analysis side, we include the results from running the experiments on the four devices in the paper, as well as the analysis tools we used to generate the main figures in the paper.</p>

},
keywords = {memory consistency, mutation testing, parallel programming models}
}

@software{10.5281/zenodo.7215748,
author = {Song, Yongju and Kim, Wook-Hee and Monga, Sumit Kumar and Min, Changwoo and Eom, Young Ik},
title = {Prism: Optimizing Key-Value Store for Modern Heterogeneous Storage Devices},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7215748},
abstract = {
    <p>We addressed the question: “How should we design a key-value store for the non-hierarchical storage landscape?”. We designed and implemented a novel key-value store named Prism that utilizes modern heterogeneous storage devices. This artifact contains three major components: 1) the source code of Prism, 2) a benchmark suite, and 3) a workload generator to evaluate the system. Additionally, the scripts enclosed allow readers to configure, build, and run Prism conveniently and precisely. For reference, since Prism is built on modern heterogeneous storage devices including non-volatile memory and NVMe SSDs, there are some hardware dependencies. For the software side, Prism needs PMDK and liburing libraries. Although it could be challenging to make up an identical testbed to ours, it is necessary to satisfy both the hardware and software requirements in order to get the expected key outcomes.</p>

},
keywords = {Key-value Stores, Non-volatile Memory}
}

@software{10.5281/zenodo.7217356,
author = {Qureshi, Zaid and Mailthody, Vikram Sharma and Gelado, Isaac and Min, Seungwon and Masood, Amna and Park, Jeongmin and Xiong, Jinjun and Newburn, C. J. and Vainbrand, Dmitri and Chung, I-Hsin and Garland, Michael and Dally, William and Hwu, Wen-mei},
title = {Reproduction Package for Article "GPU-Initiated On-Demand High-Throughput Storage Access in the BaM System Architecture"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7217356},
abstract = {
    <p>The artifact is the source code the BaM system that enables efficient, on-demand accesses to storage from GPU thread. The artifact includes the source code for the system’s kernel module, library, and micro-benchmarks and applications. The applications and micro-benchmarks support multiple state-of-the-art implementations as well as BaM implementations for easy comparison.</p>

},
keywords = {GPUDirect, GPUs, Memory capacity, Memory hierarchy, SSDs, Storage systems}
}

@software{10.5281/zenodo.7217959,
author = {Xiao, Haocheng and Ainsworth, Sam},
title = {Reproduction package for article 'Hacky Racers: Exploiting Instruction-Level Parallelism to Generate Stealthy Fine-Grained Timers'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7217959},
abstract = {
    <p>Our artifact provides source code and scripts for four timing side-channel experiments mentioned in this paper, corresponding to sections 7.3 to 7.5, and each demonstrates the efficiency and portability of either/both Racing and Magnifier Gadgets. Our results should be evaluated on an Intel or AMD x86 machine (we used an i7-8750h, but systems of a similar architecture will work out-of-the-box). Migration to systems with other ISAs or significantly different micro-architectures require minor source-code modifications.</p>

},
keywords = {Caches, Instruction-level Parallelism, JavaScript, Microarchitectural Security, Spectre}
}

@software{10.5281/zenodo.7218057,
author = {Wang, Theodore Luo and Tian, Yongqiang and Dong, Yiwen and Xu, Zhenyang and Sun, Chengnian},
title = {DFusor},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7218057},
abstract = {
    <p>ASPLOS 2023 Artifact for “Compilation Consistency Modulo Debug Information”</p>

},
keywords = {Compiler Testing, Debug Information}
}

@software{10.5281/zenodo.7218907,
author = {Chen, Yun and Pei, Lingfeng and Carlson, Trevor E.},
title = {AfterImage: Leaking Control Flow Data and Tracking Load Operations via the Hardware Prefetcher},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7218907},
abstract = {
    <p>AfterImage is a hardware side-channel inside specific Intel processors. In this artifact, we provide the needed information to reproduce the main results presented in the paper.</p>

},
keywords = {Hardware Security, Prefetcher, Side-channel Attacks}
}

@software{10.5281/zenodo.7221411,
author = {Won, Jaeyeon and Mendis, Charith and Emer, Joel S. and Amarasinghe, Saman},
title = {Artifact for paper "WACO: Learning Workload-Aware Co-optimization of the Format and Schedule of a Sparse Tensor Program"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7221411},
abstract = {
    <p>Our artifact includes programs for 1. training a cost model, 2. searching with a nearest neighbor search, and 3. a performance evaluator of the SuperSchedule. Our artifact is available at https://github.com/nullplay/Workload-Aware-Co-Optimization. Please follow the README.md instructions.</p>

},
keywords = {Approximate Nearest Neighbor Search, Auto-scheduling, Auto-tuning, Sparse Matrix, Sparse Tensor}
}

@software{10.5281/zenodo.7222132,
author = {Liu, Jiawei and Lin, Jinkun and Ruffy, Fabian and Tan, Cheng and Li, Jinyang and Panda, Aurojit and Zhang, Lingming},
title = {ASPLOS2023 Artifact for "NNSmith: Generating Diverse and Valid Test Cases for Deep Learning Compilers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222132},
abstract = {
    <p>The artifact contains evidence of bug finding, source code of NNSmith’s prototype, and user-friendly HTML documentation for re-generating the results. Specifically, it includes (1) links to bugs reported by the authors as real-world bug finding evidence, and (2) scripts and code to re-generate main results in § 5. To make artifact evaluation as simple as possible, our artifact is packaged into a pre-built docker image, along with a detailed and friendly HTML documentation. To fully evaluate the artifact, a X86-CPU platform with docker access is needed, with approximately 21 hours of machine time and 1 hour of manual inspection time.</p>

},
keywords = {Compiler, Fuzzing, Machine Learning Systems, Testing}
}

@software{10.5281/zenodo.7222728,
author = {Berlstein, Griffin and Nigam, Rachit and Gyurgyik, Christophe and Sampson, Adrian},
title = {Evaluation for "Stepwise Debugging for Hardware Accelerators"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222728},
abstract = {
    <p>This artifact consists of one piece of software, the Cider Interpreter and Debugger for Calyx, alongside data and helper scripts. Cider is a simulator and debugger for hardware accelerators written in the Calyx IR. Since Cider is also a simulator, it can be used to interpreter and debug hardware designs without lowering them from the IR to RTL.</p>
<p>This artifact seeks to reproduce the benchmark results discussed in our performance evaluation as well as the debugging process shown in section 3 of our paper. This supports our paper by showing the usability of Cider and how it compares to related tools, alongside demonstrating the debugging interface.</p>

},
keywords = {Accelerator Design, Accelerator Simulation, Debugging, Intermediate Language}
}

@software{10.5281/zenodo.7222794,
author = {Shen, Han and Pszeniczny, Krzysztof and Lavaee, Rahman and Kumar, Snehasish and Tallam, Sriraman and Li, Xinliang David},
title = {Artifacts for "Propeller: A Profile Guided, Relinking Optimizer for Warehouse Scale Applications"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222794},
abstract = {
    <p>The disassembly-driven, monolithic design of post link optimizers face scaling challenges with large binaries and is at odds with distributed build systems. To reconcile and enable post link optimizations within a distributed build environment, we propose Propeller, a relinking optimizer for warehouse scale workloads. Propeller uses basic block sections (a novel linker abstraction) to enable a new approach to post link optimization without disassembly. Propeller achieves scalability by relinking the binary using precise profiles instead of rewriting the binary. The overhead of relinking is lowered by caching and leveraging distributed compiler actions during code generation.</p>
<p>In this artifact, we present the means to replicate the results on a standalone machine. We provide a cloud-hosted bare metal machine which has been provisioned with the tooling and dependencies to run Propeller and Lightning BOLT. We use this environment to demonstrate Propeller’s approach to post link optimizations on a bootstraped build of clang. We show Propeller can achieve equitable performance to Lightning BOLT with lower peak memory consumption. A key aspect of Propeller enabled optimizations is the integration with a distributed build system which provides caching. To demonstrate the effect of caching we provide scripting which emulates the effect on a single machine. The scripts used to replicate the results are also publicly available at https://github.com/google/llvm-propeller.</p>

},
keywords = {Binary Optimization, Datacenters, Distributed Build System, Post-Link Optimization, Profile Guided Optimization, Warehouse-Scale Applications}
}

@software{10.5281/zenodo.7222849,
author = {Kim, Thomas and Jeon, Jekyeom and Arora, Nikhil and Li, Huaicheng and Kaminsky, Michael and Andersen, David G. and Ganger, Gregory R. and Amvrosiadis, George and Bj\o{}rling, Matias},
title = {RAIZN: Redundant Array of Independent Zoned Namespaces},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222849},
abstract = {
    <p>Source code for RAIZN: Redundant Array of Independent Zoned Namespaces (ASPLOS 23)</p>

},
keywords = {RAID, Reliability, Storage, ZNS, Zoned Namespaces}
}

@software{10.5281/zenodo.7225459,
author = {Gao, Mingyu and Chakraborty, Soham and Ozkan, Burcu Kulahcioglu},
title = {Probabilistic Concurrency Testing for Weak Memory Programs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7225459},
abstract = {
    <p>The upload is a VagrantBox package, containing the artifact for the paper Probabilistic Testing for Weak Memory Programs. This vagrant package offers the experimental environment, which contains all code, benchmarks, and scripts to reproduce the experimental results in the paper.</p>

},
keywords = {Concurrency, Randomized algorithms, Testing, Weak memory}
}

@software{10.5281/zenodo.7240401,
author = {Liu, Congyu and Gong, Sishuai and Fonseca, Pedro},
title = {ASPLOS' 23 Artifact of "KIT: Testing OS-Level Virtualization for Functional Interference Bugs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7240401},
abstract = {
    <p>Container isolation is implemented through OS-level virtualization, such as Linux namespaces. Unfortunately, these mechanisms are extremely challenging to implement correctly and, in practice, suffer from functional interference bugs, which compromise container security. In particular, functional interference bugs allow an attacker to extract information from another container running on the same machine or impact its integrity by modifying kernel resources that are incorrectly isolated. Despite their impact, functional interference bugs in OS-level virtualization have received limited attention in part due to the challenges in detecting them. Instead of causing memory errors or crashes, many functional interference bugs involve hard-to-catch logic errors that silently produce semantically incorrect results. This paper proposes KIT, a dynamic testing framework that discovers functional interference bugs in OS-level virtualization mechanisms, such as Linux namespaces. The key idea of KIT is to detect inter-container functional interference by comparing the system call traces of a container across two executions, where it runs with and without the preceding execution of another container. To achieve high efficiency and accuracy, KIT includes two critical components: an efficient algorithm to generate test cases that exercise inter-container data flows and a system call trace analysis framework that detects functional interference bugs and clusters bug reports. KIT discovered 9 functional interference bugs in Linux kernel 5.13, of which 6 have been confirmed. All bugs are caused by logic errors, showing that this approach is able to detect hard-to-catch semantic bugs.</p>

},
keywords = {Bugs, OS-level Virtualization, Testing}
}

@software{10.5281/zenodo.7275326,
author = {Hu, Qinghao and Zhang, Meng and Sun, Peng and Wen, Yonggang and Zhang, Tianwei},
title = {Lucid Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7275326},
abstract = {
    <p>This artifact appendix describes how to reproduce main results in our paper. In our public repository, we provide the source code, related dataset and the instructions to perform artifact evaluation. Please refer to the README file for more details.</p>

},
keywords = {Cluster Management, Machine Learning, Workload Scheduling}
}

@software{10.5281/zenodo.7277139,
author = {Fingler, Henrique and Tarte, Isha and Yu, Hangchen and Szekely, Ariel and Hu, Bodun and Akella, Aditya and Rossbach, Christopher J.},
title = {Artifacts of LAKE},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7277139},
abstract = {
    <p>Kernel API remoting system, kernel drivers of workloads and benchmarks scripts.</p>

},
keywords = {api remoting, kernel, ml for systems, systems for ml}
}

@software{10.5281/zenodo.7306303,
author = {Pandey, Shweta and Kamath, Aditya K and Basu, Arkaprava},
title = {Scoped Buffered Release Persistency Model for GPUs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7306303},
abstract = {
    <p>We provide the source code and setup for our GPU persistency model, Scoped Buffered Release Persistency (SBRP). SBRP is a scope-aware, buffered persistency model that provides high performance to GPU applications that wish to persist data on Non-Volatile Memory (NVM). SBRP modifies the GPU hardware and has been implemented using GPGPU-Sim, a GPU simulator. For more details on the simulator requirements, check the README in the simulator folder.</p>
<p>This repository consists of the source code of the simulator, benchmarks used for evaluation and all scripts needed to replicate the figures in the paper.</p>

},
keywords = {Grpahics Processing Unit, Persistent Memory}
}

@software{10.5281/zenodo.7311322,
author = {You, Xin and Yang, Hailong and Lei, Kelun and Luan, Zhongzhi and Qian, Depei},
title = {Reproduction Package for Article "VClinic: A Portable and Efficient Framework for Fine-Grained Value Profilers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7311322},
abstract = {
    <p>The provided docker images contain pre-built VClinic and compared value profilers. For X86 platforms, docker image “vclinic_artifact_x86.tar” should be used; otherwise, for ARM platforms, docker image “vclinic_artifact_arm.tar” should be used. As pin-based value profilers only support X86 platforms, we only include the built pin-based value profilers in the “vclinic_artifact_x86.tar” docker image. The detailed instructions for evaluating the artifacts as well as the estimated evaluation time for each step on both platforms are listed in “/home/vclinic_artifact/README.md”. The summary of how to set up the experimental environment is listed in README. Note that both “vclinic_artifact_x86.tar” and <code>vclinic_artifact_arm.tar</code> are pre-built docker images and one can directly follow the instructions in the README file to reproduce the evaluation results.</p>

},
keywords = {Dynamic Binary Instrumentation, Performance Analysis, Value Profiler}
}

@software{10.5281/zenodo.7319957,
author = {Porter, Chris and Khan, Sharjeel and Pande, Santosh},
title = {Decker},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7319957},
abstract = {
    <p>The Decker framework consists of a compiler pass and runtime library. Its main objective is to debloat software at runtime. The artifact includes a Docker image that encapsulates basic dependencies, the<br>
Decker code itself, benchmarks, and the scripts to drive artifact evaluation.</p>

},
keywords = {program security, software debloating}
}

@software{10.5281/zenodo.7330354,
author = {Aguilera, Marcos K. and Ben-David, Naama and Guerraoui, Rachid and Murat, Antoine and Xygkis, Athanasios and Zablotchi, Igor},
title = {Artifacts to reproduce all experiments in `uBFT: Microsecond-Scale BFT using Disaggregated Memory`},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7330354},
abstract = {
    <p>This artifact contains all the necessary source code to compile, execute and generate the data of all the figures in <code>uBFT: Microsecond-Scale BFT using Disaggregated Memory</code>.</p>

},
keywords = {Byzantine fault tolerance, disaggregated memory, fast path, finite memory, microsecond scale, RDMA, replication, signatureless}
}

@software{10.5281/zenodo.7333207,
author = {Hildenbrand, David and Schulz, Martin and Amit, Nadav},
title = {Software artifacts for the paper "Copy-on-Pin: The Missing Piece for Correct Copy-on-Write"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7333207},
abstract = {
    <p>Software artifacts for the paper “Copy-on-Pin: The Missing Piece for Correct Copy-on-Write”.</p>

},
keywords = {copy-on-write, COW, fork, memory deduplication, page pinning, page sharing, virtual memory}
}

@software{10.5281/zenodo.7339970,
author = {Sun, Jinghan and Li, Shaobo and Sun, Yunxin and Sun, Chao and Vucinic, Dejan and Huang, Jian},
title = {Artifact of "LeaFTL: A Learning-Based Flash Translation Layer for Solid-State Drives"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7339970},
abstract = {
    <p>This artifact is for reproducing the experiment results in the paper. The artifact includes the simulator source code with LeaFTL implementation, datasets for evaluation, and also scripts and instructions for reproducing the results. More details on the artifact can be found in the GitHub README File.</p>

},
keywords = {Flash Translation Layer, Learning-Based Storage, Solid-State Drive}
}

@software{10.5281/zenodo.7423535,
author = {Duan, Zhuohui and Yao, Jiabo and Liu, Haikun and Liao, Xiaofei and Jin, Hai and Zhang, Yu},
title = {Reproduction Package for Article `Revisiting Log-structured Merging for KV Stores in Hybrid Memory Systems’},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7423535},
abstract = {
    <p>All experimental results in Figures 6, 7, 8, 9, 10, 11, and 12 can be reproduced. These results can reflect the performance of MioDB.</p>

},
keywords = {Key-Value Store, Log-Structured Merge, LSM-tree Compaction, Non-Volatile Memory, Skip List}
}

@software{10.5281/zenodo.7425382,
author = {Huang, Haochen and Shen, Bingyu and Zhong, Li and Zhou, Yuanyuan},
title = {Reproduction Package for Paper `Protecting Data Integrity of Web Applications with Database Constraints Inferred from Application Code`},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7425382},
abstract = {
    <p>This repo is for the code release of our paper <code>Protecting Data Integrity of Web Applications with Database Constraints Inferred from Application Code.</code> in ASPLOS 2023.</p>
<p>In the paper, we developed a static analysis tool to infer the missing database constraints from the application source code.</p>

},
keywords = {Data integrity, Database constraints, Static analysis, Web applications}
}

@software{10.5281/zenodo.7429879,
author = {Ding, Yaoyao and Yu, Cody Hao and Zheng, Bojian and Liu, Yizhi and Wang, Yida and Pekhimenko, Gennady},
title = {Artifact for paper "Hidet: Task Mapping Programming Paradigm for Deep Learning Tensor Programs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7429879},
abstract = {
    <p>This artifact helps readers to reproduce all experiments in the evaluation section of our paper. In Section 6, there are 6 experiments (one end to end experiment and 5 case studies). These experiments compare Hidet with other DNN frameworks and compilers on representative DNN models from the perspective of execution latency, optimization time, schedule space, input sensitivity, and different batch sizes. In the public artifact, we provide scripts to launch the 6 experiments automatically. With the hardware and software described in Section A.3.2 and A.3.3, the artifact should reproduce all experimental results in the evaluation section.</p>

},
keywords = {artifact, deep learning compiler, deep nerual networks, inference}
}

@software{10.5281/zenodo.7430228,
author = {Hackett, Finn and Hosseini, Shayan and Costa, Renato and Do, Matthew and Beschastnikh, Ivan},
title = {Compiling Distributed System Models with PGo [evaluation]},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7430228},
abstract = {
    <p>This repository aggregates all the tools and data necessary to reproduce the results in the evaluation section of our ASPLOS 2023 paper.</p>
<p>Our artifact has two components. We provide the PGo compiler itself, which can compile MPCal specifications, and we also provide a method for reproducing our performance results from our ASPLOS 2023 paper. These files describe how to reproduce our performance results.</p>
<p>Our own set of results is included in the <code>results_paper/</code> folder. For how to use the included tools and how to interpret the included results, see the README.</p>

},
keywords = {Compilers, Distributed systems, Formal methods, PlusCal, TLA+}
}

@software{10.5281/zenodo.7439846,
author = {Yang, Shuangyan and Zhang, Minjia and Dong, Wenqian and Li, Dong},
title = {Betty: Enabling Large-Scale GNN Training with Batch-Level Graph Partitioning},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7439846},
abstract = {
    <p>The directory of the Betty includes dataset/, Figures/, pytorch/, README.md, requiremnets.sh. We can execute ‘bash install_requirements.sh’ to install requirments. After downloading benchmarks and generating full batch data into folder /Betty/dataset/. The directory pytorch contains all necessary files for the micro-batch training and mini-batch training. In folder micro_batch_train, graph_partitioner.py contains our implementation of redundancy embedded graph partitioning. block_dataloader.py is implemented to construct the micro-batch based on the partitioning results of REG. The folder Figures contains these important figures for analysis and performance evaluation.</p>

},
keywords = {Graph neural network, Graph partition, Redundancy reduction}
}

@software{10.5281/zenodo.7481637,
author = {Gu, Diandian and Zhao, Yihao and Zhong, Yinmin and Xiong, Yifan and Han, Zhenhua and Cheng, Peng and Yang, Fan and Huang, Gang and Jin, Xin and Liu, Xuanzhe},
title = {ElasticFlow Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7481637},
abstract = {
    <p>The artifact provides source code for the prototype of the proposed system ElasticFlow, including the main implementation of ElasticFlow, testbed experiment scripts (Section 6.2 \&amp; Section 6.6), and cluster simulation scripts (Section 6.3 \&amp; Section 6.4 \&amp; Section 6.5). We provide a docker image with pre-installed prerequisites to simplify the testbed experiment workflow. Users can also use a script to install all software dependencies from scratch. Please refer to the documents in our repository for more details.</p>

},
keywords = {Cluster Scheduling, Distributed Deep Learning, GPU Cluster, Serverless Computing}
}

@software{10.5281/zenodo.7493145,
author = {Jayarajan, Anand and Zhao, Wei and Sun, Yudi and Pekhimenko, Gennady},
title = {Reproduction package for the article 'TiLT: A Time-Centric Approach for Stream Query Optimization and Parallelization'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7493145},
abstract = {
    <p>This artifact appendix includes the source code and scripts to reproduce the scalability results and the real-world applications performance in the article ‘TiLT: A Time-Centric Approach for Stream Query Optimization and Parallelization’. We include docker containers to setup the runtime environment for all the experiments in order to support portability. Therefore, the artifact can be executed on any multi-core machine with docker engine installed. We also use Linux gnuplot utility to generate figures from the collected performance numbers. We  using Ubuntu 20.04 operating system for running the scripts provided in the artifact.</p>

},
keywords = {compiler, intermediate representation, stream data analytics, temporal query processing}
}

@software{10.6084/m9.figshare.21354552.v2,
author = {Yuan, Ziqi and Hong, Siyu and Chang, Rui and Zhou, Yajin and Shen, Wenbo and Ren, Kui},
title = {Artifact of Article "VDom: Fast and Unlimited Virtual Domains on Multiple Architectures"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21354552.v2},
abstract = {
    <p>The artifact of paper “VDom: Fast and Unlimited Virtual Domains on Multiple Architectures”, consists of the source code of VDom modified Linux kernel, user-space libraries, all evaluation benchmarks, and scripts necessary to reproduce the paper’s evaluation results.</p>

},
keywords = {computer system security, operating system, operating systems, software security, virtualization}
}

@software{10.1145/3554344,
author = {Michael, Alexandra E. and Gollamudi, Anitha and Bosamiya, Jay and Johnson, Evan and Denlinger, Aidan and Disselkoen, Craig and Watt, Conrad and Parno, Bryan and Patrignani, Marco and Vassena, Marco and Stefan, Deian},
title = {Reproduction Package for "MSWasm: Soundly Enforcing Memory-Safe Execution of Unsafe Code"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554344},
abstract = {
    <p>The artifact contains a Dockerfile that automates the setup of the MSWasm toolchain, as well as a README with instructions on installing and using the toolchain.</p>

},
keywords = {Memory-safety, Secure Compilation, WebAssembly}
}

@software{10.1145/3554346,
author = {Kallas, Konstantinos and Zhang, Haoran and Alur, Rajeev and Angel, Sebastian and Liu, Vincent},
title = {Reproduction package for article "Executing Microservice Applications on Serverless, Correctly"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554346},
abstract = {
    <p>Our artifact contains all claims made in the paper regarding the prototype and its evaluation. The proofs in the paper are not mechanized and therefore are not part of the artifact. The claims made in our paper are: 1. We have developed the mu2sls prototype that generates a serverless implementation from a set of service specifications. You can find information about this claim in the “Additional Artifact Information” section, where we describe the structure of the artifact code, and how it corresponds to the paper. 2. We have evaluated our prototype w.r.t. the three questions (Q1), (Q2), (Q3) described in Section 8. You can reproduce the experiments for this claim by following the “Evaluation Instructions Section”.</p>

},
keywords = {microservices, stateful serverless, transactions}
}

@software{10.5281/zenodo.7150706,
author = {Jacobs, Jules and Wi\ss{}mann, Thorsten},
title = {Fast Coalgebraic Bisimilarity Minimization (artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7150706},
abstract = {
    <p>This is the artifact for the paper “Fast Coalgebraic Bisimilarity Minimization”.</p>
<p>It contains a Rust program called “boa”, which implements the algorithm for the paper.</p>

},
keywords = {automata, bisimilarity, Coalgebra, minimization}
}

@software{10.5281/zenodo.7173860,
author = {Yin, Xizhe and Zhao, Zhijia and Gupta, Rajiv},
title = {Reproduction Package for Article `Glign: Taming Misaligned Graph Traversals in Concurrent Graph Processing’},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7173860},
abstract = {
    <p>This artifact contains the source code of Glign, including the five concurrent query evaluation designs discussd in the paper and some graph benchmarks along with their inputs used in the experiments. In addition, this artifact provides bash scripts to compile Glign and reproduce the key experimental results reported in the paper.</p>

},
keywords = {concurrent graph processing, data locality, graph system}
}

@software{10.5281/zenodo.7182800,
author = {Sutherland, Mark and Falsafi, Babak and Daglis, Alexandros},
title = {Discrete-Event Simulation Software and Results Accompanying "Cooperative Concurrency Control for Write Intensive Key-Value Workloads"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7182800},
abstract = {
    <p>This archive contains the code, datasets, and instructions to generate the discrete-event simulation results appearing in the paper: “Cooperative Concurrency Control for Write-Intensive Key-Value Workloads”.</p>
<p>All instructions and tutorials for using the artifact are contained in the paper’s artifact appendix.</p>

},
keywords = {concurrency control, discrete-event simulation, key-value store, load balancing}
}

@software{10.5281/zenodo.7198195,
author = {Gouicem, Redha and Sprokholt, Dennis and Ruehl, Jasper and Rocha, Rodrigo C. O. and Spink, Tom and Chakraborty, Soham and Bhatotia, Pramod},
title = {Risotto: A Dynamic Binary Translator for Weak Memory Model Architectures},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7198195},
abstract = {
    <p>Artifact for the Risotto: A Dynamic Binary Translator for Weak Memory Model Architectures paper published at ASPLOS’23.</p>

},
keywords = {binary translation, formal verification, memory models}
}

@software{10.5281/zenodo.7220659,
author = {Luo, Shutian and Xu, Huanle and Ye, Kejiang and Xu, Guoyao and Zhang, Liping and He, Jian and Yang, Guodong and Xu, Chengzhong},
title = {Reproduction Package for Article &nbsp;Erms: Efficient Resource Management for Shared Microservices with SLA Guarantees},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7220659},
abstract = {
    <p>Erms is a cluster-level resource management system for shared microservices with SLA guarantees. This artifact includes a proto- type implementation of Erms and the experimental workflows for running DeathStarBench on Erms.</p>

},
keywords = {Resource Management, Shared Microservices, SLA Guarantees}
}

@software{10.1145/3576916,
author = {Kelly, Terence},
title = {Source code for Drill Bits 8 article "Literate Executables"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3576916},
abstract = {
    <p>Literate executables redefine the relationship between compiled binaries and source code to be that of chicken and egg, so it’s easy to derive either from the other. This episode of Drill Bits provides a general-purpose literacy tool and showcases the advantages of literacy by retrofitting it onto everyone's favorite command-line utility.</p>
}
}

@software{10.5281/zenodo.6640549,
author = {Pfandzelter, Tobias and Bermbach, David},
title = {Implementation of the article "Celestial: Virtual Software System Testbeds for the LEO Edge"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6640549},
abstract = {
    <p></p><p>Artifact appendix item for Middleware 2022</p><p></p>
}
}

@software{10.5281/zenodo.7311277,
author = {S\'{a}nchez-Artigas, Marc and Eizaguirre, Germ\'{a}n T.},
title = {Implementation of the article "A seer knows best: optimized object storage shuffling for serverless analytics"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7311277},
abstract = {
    <p></p><p>Artifact appendix item for Middleware 2022</p><p></p>
}
}

@software{10.5281/zenodo.7345983,
author = {Wang, Yu-Ping and Dong, Yuejiang and Tan, Gang},
title = {Implementation of the article "ROS-SF: A Transparent and Efficient ROS Middleware using Serialization-Free Message"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7345983},
abstract = {
    <p></p><p>Artifact appendix item for Middleware 2022</p><p></p>
}
}

@software{10.5281/zenodo.7351673,
author = {Zandberg, Koen and Yuan, Shenghao and Baccelli, Emmanuel and Fr\'{e}d\'{e}ric, Besson and Talpin, Jean-Pierre},
title = {Femto-Containers: Lightweight Virtualization and Fault Isolation For Small Software Functions on Low-Power IoT Microcontrollers},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7351673},
abstract = {
    <p></p><p>Artifact appendix item for Middleware 2022</p><p></p>
}
}

@software{10.5281/zenodo.7183177,
author = {Verano Merino, Mauricio and van Wijk, Koen},
title = {Blocklybench},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7183177},
abstract = {
    <p>We present Blocklybench, a meta-block-based environment for describing block-based languages for both programming and semi-structured data languages; it allows developers to express the specific elements of both types of block-based languages using blocks. We present three case studies created with Blocklybench to evaluate the proposed solution. Our results show that the block meta-environment allows developers to describe block-based specific aspects of the language constructs such as layout and color.</p>

},
keywords = {block-based environments, Blockly, data languages, IDEs, Projectional editors, visual languages}
}

@software{10.5281/zenodo.7189905,
author = {Smits, Jeff and Hartman, Toine and Cockx, Jesper},
title = {Optimising First-Class Pattern Matching - Artefact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7189905},
abstract = {
    <p>This is the artefact for the paper Optimising First-Class Pattern Matching, accepted at the International Conference on Software Language Engineering. It contains a Docker image with the setup to rerun the benchmarks we used in the evaluation of the paper.</p>
<h3 id="table-of-contents">Table of Contents</h3>
<ul>
<li>Preliminary PDF version of the accepted paper.</li>
<li>Docker image archive, containing:
<ul>
<li>A Linux installation.</li>
<li>A development version of Spoofax pre-installed (based on release 2.5.17) (libraries only, no GUI).</li>
<li>The benchmark setup as used in the paper, with a check-out of the Tiny Imperative Language Spoofax project.</li>
<li>Benchmark results from one previous run.</li>
</ul></li>
</ul>

},
keywords = {First-Class Pattern Matching, Pattern Match Optimisation, Pattern Matching, Spoofax, Stratego}
}

@software{10.5281/zenodo.7260980,
author = {Khorram, Faezeh and Bousse, Erwan and Garmendia, Antonio and Mottu, Jean-Marie and Suny\'{e}, Gerson and Wimmer, Manuel},
title = {Coverage Computation and Fault Localization for Executable DSLs Artefacts},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7260980},
abstract = {
    <p>This repository contains the tool and the evaluation data of our paper titled “From Coverage Computation to Fault Localization: A Generic Framework for Domain-Specific Languages”, accepted at SLE 2022. The provided tool is built atop the Eclipse GEMOC Studio.</p>

},
keywords = {Coverage, Executable Domain-Specific Languages, Executable Models, Fault Localization, Testing}
}

@software{10.1145/3550218,
author = {Kelly, Terence},
title = {Source code for the article "Drill Bits 04: Schrodingers Code"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550218},
abstract = {
    <p>The example programs, Roman numerals I, II, III, and IV, each has a shell script that shows how I compiled and ran them; sample output is listed below.  The code has been compiled and tested with GCC 10.2.1 and Clang 11.0.0.  In my experience the .c source files compile as both C17 and C++17 and other relatively modern dialects.</p>
}
}

@software{10.1145/3550219,
author = {Kelly, Terence},
title = {Source code for Drill Bits 6 article "Steampunk Machine Learning"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550219},
abstract = {
    <p>Script "run.csh" generates the data sets discussed in my column and runs R to estimate regression parameters for a linear model using two techniques, least-squares and least absolute residuals.  Read this script to understand how the sample data were created and analyzed with R.  File "cmds.R" contains the actual R commands.</p>
}
}

@software{10.1145/3550220,
author = {Kelly, Terence},
title = {Source code for Drill Bits 7 article "Persistent Memory Allocation"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550220},
abstract = {
    <p>Most of the test programs bundled with pma are primarily intended to exercise pma functionality for my benefit; they're not optimized for tutorial value.  However they illustrate basic usage and you might learn a trick or two by studying them.  For example, test5 shows how to use the root pointer; test6 shows how to make pma fall back on the conventional ephemeral memory allocator (standard malloc); and test7 shows an easy way to create a persistent C++ STL container by sliding a pma persistent heap beneath an STL <map>.  The tests also show how to create an uninitialized backing file for a persistent heap using the "truncate" command-line utility.  Some tests run under Valgrind. Tests come in .c/.csh file pairs; the scripts run under the C Shell (csh).  My test scripts might not be perfectly compatible with every OS and compiler.  Edit as necessary.</map></p>
}
}

@software{10.1145/3550221,
author = {Kelly, Terence},
title = {Source code for pmgawk in Drill Bits 7 article "Persistent Memory Allocation"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550221},
abstract = {
    <p>To use persistent gawk, first create for the persistent heap a sparse file whose size is a multiple of the system page size. The media beneath the filesystem containing the backing file are unconstrained, i.e., pma supports persistent memory programming  on conventional hardware as well as NVM.</p>
}
}

@software{10.5281/zenodo.6369874,
author = {Le-Cong, Thanh and Kang, Hong Jin and Nguyen, Truong Giang and Haryono, Stefanus Agus and Lo, David and Le, Xuan-Bach D. and Huynh, Quyet Thang},
title = {Dataset for "AutoPruner: Transformer-based Call Graph Pruning"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6369874},
abstract = {
    <p>This repository contains data for research paper “AutoPruner: Transformer-based Call Graph Pruning”, which is published at ESEC/FSE 2022</p>
<p>The structure of our data’s repository is as follows:</p>
<ul>
<li>dl_dataset: contains our processed dataset for AutoPruner;</li>
<li>gnn_dataset: contains our processed dataset for GNN benchmark;</li>
<li>gnn_model: contains our trained models for GNN benchmarks;</li>
<li>info_data: contains the lists of training and testing programs;</li>
<li>model: contains our trained models for AutoPruner;</li>
<li>npe_result: contains the results of manual evaluation for Null-pointer analysis;</li>
<li>processed_data: contains extracted source code for methods in programs in <a href="https://zenodo.org/record/5806537">cgPruner’s dataset</a></li>
<li>raw_data: contains the static call graphs generated by static analysis tools from <a href="http://web.cs.ucla.edu/~akshayutture/papers/icse22_firstPaper_preprint.pdf">cgPruner</a></li>
</ul>

},
keywords = {Call Graph Pruning, Pretrained Language Model, Static Analysis, Transformer}
}

@software{10.5281/zenodo.6970062,
author = {Ibrahimzada, Ali Reza and Varli, Yigit and Tekinoglu, Dilara and Jabbarvand, Reyhaneh},
title = {Reproduction Package for Article "Perfect Is the Enemy of Test Oracle"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6970062},
abstract = {
    <p>Artifact repository for the paper Perfect Is the Enemy of Test Oracle, accepted at ESEC/FSE 2022. Authors are Ali Reza Ibrahimzada, Yi\u{g}it Varl\i{}, Dilara Tekino\u{g}lu, and Reyhaneh Jabbarvand.</p>
<p>The artifact mainly consists of Python scripts which were used for automating dataset generation, mutation testing, and deep learning model implementation. We have split each distinct component of SEER into a separate directory in this repository. Please refer to each directory for a detailed explanation of the component.</p>
<p>Plesae refer to README file on GitHub repository (https://github.com/Intelligent-CAT-Lab/SEER) for more details.</p>

},
keywords = {Deep Learning, Software Testing, Test Automation, Test Oracle}
}

@software{10.5281/zenodo.7033365,
author = {OBrien, David and Biswas, Sumon and Imtiaz, Sayem and Abdalkareem, Rabe and Shihab, Emad and Rajan, Hridesh},
title = {Artifact for the ESEC/FSE'22 Paper: "23 Shades of Self-Admitted Technical Debt: An Empirical Study on Machine Learning Software"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7033365},
abstract = {
    <p>This artifact contains the code, data, and additional information for reproducing the results found in the ESEC/FSE 2022 paper entitled “23 Shades of Self-Admitted Technical Debt: An Empirical Study on Machine Learning Software”. This study analyzes the occurrence of self-admitted technical debt (SATD) in a dataset consisting of 2,641 open-source machine learning repositories. The artifact contains the Boa scripts ran to acquire the comment data, as well as the Python scripts which were used to filter the dataset into 68,820 SATD comments. During the dataset creation, a sample was taken for two authors to independently label before settling disagreements in discussion of a moderator. The authors’ labels and the agreed upon labels are included within the artifact.</p>

},
keywords = {data science, machine learning, open-source, technical debt}
}

@software{10.5281/zenodo.7036218,
author = {Zhao, Yixue and Talebipour, Saghar and Baral, Kesina and Park, Hyojae and Yee, Leon and Khan, Safwat Ali and Brun, Yuriy and Medvidovi\'{c}, Nenad and Moran, Kevin},
title = {Artifacts for "AVGUST: Automating Usage-Based Test Generation from Videos of App Executions"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7036218},
abstract = {
    <p>This artifact contains code and data related to the paper “Avgust: Automating Usage-Based Test Generation from Videos of App Executions”. Avgust is a human-in-the-loop technique that assists developers in generating usage-based tests for mobile apps by learning from videos of app usage. This artifact is made public to foster future research in automated testing of mobile applications and app comprehension in general. This repository contains the main source code of Avgust, processed video frames, screenshots, cropped widgets, and all the intermediate results such as IR models and generated tests.</p>

},
keywords = {AI/ML, Mobile Application, Test Generation, UI Understanding}
}

@software{10.5281/zenodo.7037946,
author = {Eghbali, Aryaz and Pradel, Michael},
title = {DynaPyt},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7037946},
abstract = {
    <p>Dynamic analysis framework for Python.</p>

},
keywords = {dynamic analysis, python}
}

@software{10.5281/zenodo.7047061,
author = {Riley, Daniel and Fedyukovich, Grigory},
title = {Artifact for Multi-Phase Invariant Synthesis},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7047061},
abstract = {
    <p>This is an artifact for the FSE’22 paper “Multi-Phase Invariant Synthesis”.</p>
<p>The purpose of the artifact is to provide an environment to reproduce the results presented in the paper. This is not a full documentation of the <code>ImplCheck</code> method within <code>FreqHorn</code>. It is meant to allow for an individual to run the tools used in the paper’s experiments for themselves.</p>

},
keywords = {automated safety verification, inductive invariant synthesis, model based projection, satisfiability modulo theories}
}

@software{10.5281/zenodo.7048525,
author = {Nong, Yu and Ou, Yuzhe and Pradel, Michael and Chen, Feng and Cai, Haipeng},
title = {Reproduction Package for Article "Generating Realistic Vulnerabilities via Neural Code Editing: An Empirical Study"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7048525},
abstract = {
    <p>Using a commonly used synthetic dataset and one real-world dataset, we investigate the potential and gaps of three state-of-the-art neural code editors (Graph2Edit, Hoppity, SequenceR) for DL-based realistic vulnerability data generation, and two state-of-the-art vulnerability detectors (Devign, ReVeal) to evaluate the usefulness of the generated realistic vulnerability data in improving the effectiveness of such detectors.</p>

},
keywords = {benchmarking, data augmentation, data generation, datasets, deep learning, software vulnerability, vulnerability detection}
}

@software{10.5281/zenodo.7080252,
author = {Chen, Haoxian and Whitters, Gerald and Amiri, Mohammad Javad and Wang, Yuepeng and Loo, Boon Thau},
title = {Reproduction package for "Declarative Smart Contracts"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080252},
abstract = {
    <p>This artifact contains two docker images: (1) the main tool developed in this paper, a compiler that translates Declarative smart contracts into Solidity programs. (2) software and scripts for reproducing experiment results in the paper.</p>

},
keywords = {declarative programming, domain-specific language, Smart contracts}
}

@software{10.5281/zenodo.7080276,
author = {Jodavi, Mehran and Tsantalis, Nikolaos},
title = {CodeTracker},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080276},
abstract = {
    <p>CodeTracker is a refactoring-aware tool that can generate the commit change history for method and variable declarations in a Java project with a very high accuracy. https://github.com/jodavimehran/code-tracker https://search.maven.org/artifact/io.github.jodavimehran/code-tracker</p>

},
keywords = {commit change history, refactoring-aware source code tracking}
}

@software{10.5281/zenodo.7081378,
author = {Silva, Pedro and Oliveira, Jos\'{e} N. and Macedo, Nuno and Cunha, Alcino},
title = {QAlloy Artifact, ESEC/FSE 2022},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7081378},
abstract = {
    <p>This artifact complements the paper Quantitative relational modelling with QAlloy submitted to the ESEC/FSE 2022 conference. It provides the necessary tools and instructions to run QAlloy and apply it to the examples discussed throughout the paper. Moreover, the benchmarking models and data are also provided, so that its results can be reproduced.</p>

},
keywords = {Alloy, linear algebra, model finding, quantitative modelling, relational specifications, SMT}
}

@software{10.5281/zenodo.7083445,
author = {Alon, Yoav and David, Cristina},
title = {Reproduction Package for Article: "Using Graph Neural Networks for Program Termination"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7083445},
abstract = {
    <p>Classifier for program termination based on Graph Attention layers. Published in ESEC/FSE 2022 - The 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering. The repository contains a sample dataset that can be used to train a classifier for program termination based on the abstract syntax tree representation as described in our paper. The repository can be tested using a python virtual environment. All necessary instruction are contained in the readme and install files. The central file is train.py that performs training of a model according to a dataset with sample programs (where programs in folders with folder name 0 represent non-terminating programs and programs in folders with folder name 1 represent terminating programs). Utils.py contains code that transforms programs into their respective abstract syntax tree representation. The final models are saved in the models folder. Essentially, the runs folder create on runtime will contain all tensorboard event files that enable evaluation of all training and test metrics.</p>

},
keywords = {Graph Attention Networks, Graph Neural Networks, Program Nontermination, Program Termination}
}

@software{10.5281/zenodo.7088367,
author = {Pai, Rekha and Uppar, Abhishek and Shenoy, Akshatha and Kushwaha, Pranshul and D'Souza, Deepak},
title = {The tool AndRacer for Static Executes-Before Analysis for Event Driven Programs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7088367},
abstract = {
    <p>The tool AndRacer presents an implementation of sound, efficient, and effective static analysis technique to compute executes-before pairs of tasks for a general class of event driven programs. The executes-before information to identify disjoint-blocks in Android applications and hence use them for data race detection of the applications. Furthermore, we check for the shared resources protected by disjoint blocks due to locks and hence decide on the possible Redundant Synchronisation Blocks.</p>
<p>The artifact is submitted as an Installation Package. The Installation Package is a Virtual Machine for Virtual Box. Details on installation and usability of the artifact are given in repo hosted at https://zenodo.org/record/7088367#.Yy7WDi0RpQI</p>

},
keywords = {Android applications., asynchronous calls, event driven programming, executes-before, race detection, static analysis}
}

@software{10.1145/3550217,
author = {Kelly, Terence},
title = {Source code for the article "Offline Algorithms in Low-Frequency Trading"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550217},
abstract = {
    <p>The source code has been compiled with GCC and tested on Linux.  It is intended to be portable to other compilers and OSes without excessive fuss.  Re-format to taste with the "indent" utility. I recommend compiling with GCC's "-fsanitize=undefined" flag if your version of GCC supports it.  That should catch out-of-bounds array subscripts and signed integer overflow errors at run time. Program "rb" generates random bids.  Program "auclear" clears two-resource auctions.  Script "run.csh" compiles and runs both programs.</p>
}
}

@software{10.1145/3554329,
author = {Laurel, Jacob and Yang, Rem and Ugare, Shubham and Nagel, Robert and Singh, Gagandeep and Misailovic, Sasa},
title = {Reproduction Package for the article: A General Construction for Abstract Interpretation of Higher-Order Automatic Differentiation},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554329},
abstract = {
    <p>This artifact contains the implementation and experiments for the paper “A General Construction for Abstract Interpretation of Higher-Order Automatic Differentiation” (OOPSLA 2022) by Jacob Laurel, Rem Yang, Shubham Ugare, Robert Nagel, Gagandeep Singh, and Sasa Misailovic. For both the interval and zonotope domains, we implement abstract first- and second-order automatic differentiation. We use our technique to study (1) robustly explaining a neural network via their first and second derivatives and (2) computing the Lipschitz constant of neural networks.</p>

},
keywords = {Abstract Interpretation, Automatic Differentiation, Differentiable Programming}
}

@software{10.5281/zenodo.6885003,
author = {Zhao, Zihan and Beillahi, Sidi Mohamed and Song, Ryan and Cai, Yuxi and Veneris, Andreas and Long, Fan},
title = {Artifact for the OOPSLA 2022 paper: SigVM: Enabling Event-Driven Execution for Truly Decentralized Smart Contracts},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6885003},
abstract = {
    <p>The artifact consists of a VM image that is based on an Ubuntu-20.04-desktop-LTS image. It was tested using Oracle VM VirtualBox Manager Version 6.1 (and the default config: 4 processors and 8192 MB base memory). The admin password is <code>test</code>. The image includes all the tools (with their dependencies) and the benchmarks (and tool parameters) used to carry out the experiments in the paper.</p>

},
keywords = {Blockchain Client, Conflux, Ethereum Virual Machine (EVM), Event-Driven, Smart Contracts, Solidity Compiler (solc)}
}

@software{10.5281/zenodo.7061819,
author = {Susag, Zachary and Lahiri, Sumit and Hsu, Justin and Roy, Subhajit},
title = {Artifact for Symbolic Execution for Randomized Programs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7061819},
abstract = {
    <p>This is the primary artifact for ‘Symbolic Execution for Randomized Programs’. It contains the source code for Plinko and our modified version of KLEE. Plinko is our prototype tool to verify probabilistic properties of randomized programs which universally quantify over all inputs. Additionally, it contains C++ source code for each of the case studies presented in the paper. Scripts to reproduce all of the experiments in the paper are also included.</p>

},
keywords = {probabilistic programs, symbolic execution, Verification}
}

@software{10.5281/zenodo.7067362,
author = {Ellis, Stephen and Zhu, Shuofei and Yoshida, Nobuko and Song, Linhai},
title = {Artifact of "Generic Go to Go: Dictionary-Passing, Monomorphisation, and Hybrid"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7067362},
abstract = {
    <p>This artifact is a docker image that contains the implementation of the two translators and the benchmark set used in the paper. For more information, please refer to the README document.</p>

},
keywords = {Artifact, Benchmark, Dictionary-passing translation, Generic types}
}

@software{10.5281/zenodo.7071393,
author = {Zwaan, Aron and van Antwerpen, Hendrik and Visser, Eelco},
title = {Incremental Type-Checking for Free: Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7071393},
abstract = {
    <p>The artifact consists of the following: - An executable JAR of the benchmark. - Sources of the incremental type checker framework. - Sources of the Statix implementation based on the incremental type checker framework. - Sources of the Statix specifications, of a subset of Java and WebDSL, that is used in the benchmark. - Sources of the Java and WebDSL projects that are used in the benchmark.</p>
<p>The artifact is executable on the host machine as well as in a VirtualBox/QEMU virtual machine.</p>
<p>The artifact allows executing the benchmarks, in order to reproduce the performance results reported in the paper.</p>

},
keywords = {incremental type-checking, name binding, reference resolution, scope graphs, Statix, type systems, type-checker}
}

@software{10.5281/zenodo.7071693,
author = {Liu, Si and Meseguer, Jose and \"{O}lveczky, Peter Csaba and Zhang, Min and Basin, David},
title = {Reproduction package for article "Bridging the Semantic Gap between Qualitative and Quantitative Models of Distributed Systems"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7071693},
abstract = {
    <p>This package contains the artifacts used to (re)produce the experimental results in the article “Bridging the Semantic Gap between Qualitative and Quantitative Models of Distributed Systems”.</p>

},
keywords = {actors, distributed systems, formal model transformation, Maude, rewriting logic, statistical model checking}
}

@software{10.5281/zenodo.7079674,
author = {Haas, Thomas and Meyer, Roland and Ponce de Le\'{o}n, Hern\'{a}n},
title = {CAAT: Consistency as a Theory (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7079674},
abstract = {
    <p>This artifact allows to reproduce the results from Section 7 of the paper CAAT: Consistency as a Theory published at OOPSLA 2022.</p>

},
keywords = {BMC, concurrency, SMT, weak memory models}
}

@software{10.5281/zenodo.7080357,
author = {Sakkas, Georgios and Endres, Madeline and Guo, Philip J. and Weimer, Westley and Jhala, Ranjit},
title = {Reproduction package and code for "Seq2Parse: Neurosymbolic Parse Error Repair"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080357},
abstract = {
    <p>The artifact consists of the code to extract ML-appropriate datasets, train the sequence models and repair and parse ill-parsed programs with Seq2Parse. A pre-trained model for repairing and parsing Python programs is included.</p>

},
keywords = {machine learning, parsers, seq2parse, syntax errors}
}

@software{10.5281/zenodo.7080559,
author = {Chowdhary, Sangeeta and Nagarakatte, Santosh},
title = {Artifact for "Fast Shadow Execution for Debugging Numerical Errors using Error Free Transformations"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080559},
abstract = {
    <p id="artifact-for-the-paper-fast-shadow-execution-for-debugging-numerical-errors-using-error-free-transformations-at-oopsla-2022">Artifact for the paper “Fast Shadow Execution for Debugging Numerical Errors using Error Free Transformations” at OOPSLA 2022</p>
<p id="abstract-of-the-paper"><strong>Abstract of the paper</strong></p>
<p>This paper proposes, EFTSanitizer, a fast shadow execution framework for detecting and debugging numerical errors during late stages of testing especially for long-running applications. Any shadow execution framework needs an oracle to compare against the floating point (FP) execution. This paper makes a case for using error free transformations, which is a sequence of operations to compute the error of a primitive operation with existing hardware supported FP operations, as an oracle for shadow execution. Although the error of a single correctly rounded FP operation is bounded, the accumulation of errors across operations can result in exceptions, slow convergences, and even crashes. To ease the job of debugging such errors, EFTSanitizer provides a directed acyclic graph (DAG) that highlights the propagation of errors, which results in exceptions or crashes. Unlike prior work, DAGs produced by EFTSanitizer’s include operations that span various function calls while keeping the memory usage bounded. To enable the use of such shadow execution tools with long-running applications, EFTSanitizer also supports starting the shadow execution at an arbitrary point in the dynamic execution, which we call selective shadow execution. EFTSanitizer is an order of magnitude faster than prior state-of-art shadow execution tools such as FPSanitizer and Herbgrind. We have discovered new numerical errors and debugged them in many long-running applications using EFTSanitizer.</p>
<p id="claims-to-validatereproduce"><strong>Claims to validate/reproduce</strong></p>
<p>In this artifact, we provide instructions to reproduce and validate the following claims in the paper.</p>
<ol type="1">
<li><p>Ability to detect known errors in microbenchmarks.</p></li>
<li><p>Debugging with gdb to diagnose the bug in the case study.</p></li>
<li><p>Performance slowdown of EFTSanitizer</p></li>
<li><p>Speedups for EFTSanitizer when compared to FPSanitizer</p></li>
</ol>
<p>Note: To make it feasible to run the artifact quickly, we have created mini-versions especially for (4) above. Otherwise it takes more than a day on a native machine to get the performance numbers.</p>

},
keywords = {EFTSanitizer, floating point, rounding errrors}
}

@software{10.5281/zenodo.7080821,
author = {Laddad, Shadaj and Power, Conor and Milano, Mae and Cheung, Alvin and Hellerstein, Joseph M.},
title = {Reproduction Package for Paper "Katara: Synthesizing CRDTs with Verified Lifting"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080821},
abstract = {
    <p>The software artifact accompanying the OOPSLA’22 paper “Katara: Synthesizing CRDTs with Verified Lifting”. This includes the sources of our synthesis algorithm, VM images that can be used for testing the software, and an artifact overview that walks through the steps needed to evaluate the synthesis algorithm.</p>

},
keywords = {distributed systems, program synthesis}
}

@software{10.5281/zenodo.7083308,
author = {Kolesar, John C. and Piskac, Ruzica and Hallahan, William T.},
title = {Checking Equivalence in a Non-strict Language: &nbsp;Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7083308},
abstract = {
    <p>The artifact is a zip file that contains a VM image, a README, and the file expected-results.txt. The code for our tool Nebula is downloaded on the VM image, along with all of the dependencies for it. The purpose of the artifact is to allow readers to verify the claims from the Evaluation section of our paper. The README provides instructions on how to run the evaluation suite, and it includes instructions for running Nebula outside the VM as well. The file expected-results.txt lists the specific theorems in the evaluation suite that Nebula should be able to prove or disprove.</p>

},
keywords = {coinduction, equivalence, Haskell, non-strictness, symbolic execution}
}

@software{10.5281/zenodo.7087913,
author = {Mackay, Julian and Eisenbach, Susan and Noble, James and Drossopoulou, Sophia},
title = {Necessity Specifications for Robustness},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7087913},
abstract = {
    <p>Coq sources for the paper Necessity Specifications for Robustness, published at OOPSLA 2022. The artifact consists of a model of the Necessity and Assert specification languages, along with a proof system for Necessity, a soundness proof of the Necessity proof system, and proofs using Necessity that two examples detailed in the paper satisfy their specifications.</p>

},
keywords = {Formal Methods, Necessity, Robustness, Verification}
}

@software{10.5281/zenodo.7088869,
author = {Sivaraman, Aishwarya and Sanchez-Stern, Alex and Chen, Bretton and Lerner, Sorin and Millstein, Todd},
title = {Data-Driven Lemma Synthesis for Interactive Proofs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7088869},
abstract = {
    <p>Interactive proofs of theorems often require auxiliary helper lemmas to prove the desired theorem. Existing approaches for automatically synthesizing helper lemmas fall into two broad categories. Some approaches are goal-directed, producing lemmas specifically to help a user make progress from a given proof state, but they have limited expressiveness in terms of the lemmas that can be produced. Other approaches are highly expressive, able to generate arbitrary lemmas from a given grammar, but they are completely undirected and hence not amenable to interactive usage. In this paper, we develop an approach to lemma synthesis that is both goal-directed and expressive. The key novelty is a technique for reducing lemma synthesis to a data-driven program synthesis problem, whereby examples for synthesis are generated from the current proof state. We also describe a technique to systematically introduce new variables for lemma synthesis, as well as techniques for filtering and ranking candidate lemmas for presentation to the user. We implement these ideas in a tool called lfind, which can be run as a Coq tactic. In an evaluation on four benchmark suites, lfind produces useful lemmas in 68\% of the cases where a human prover used a lemma to make progress. In these cases lfind synthesizes a lemma that either enables a fully automated proof of the original goal or that matches the human-provided lemma.</p>

},
keywords = {lemma synthesis, program synthesis, theorem proving}
}

@software{10.5281/zenodo.7092952,
author = {Kalita, Pankaj Kumar and Muduli, Sujit Kumar and D’Antoni, Loris and Reps, Thomas and Roy, Subhajit},
title = {Synthesizing Abstract Transformers},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7092952},
abstract = {
    <p>This artifact consists of the source code of AMURTH and other dependencies installed to reproduce the results shown in the paper. This artifact contains README.pdf, where step-by-step instructions to reproduce the results are provided.</p>

},
keywords = {abstract transformer, DSL, program synthesis}
}

@software{10.5281/zenodo.7121838,
author = {Parreaux, Lionel and Chau, Chun Yin},
title = {MLstruct: Principal Type Inference in a Boolean Algebra of Structural Types (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7121838},
abstract = {
    <p>This is the artifact release for our OOPSLA 2022 paper MLstruct: Principal Type Inference in a Boolean Algebra of Structural Types, version 2.</p>

},
keywords = {principal type inference, structural typing, union and intersection types}
}

@software{10.1145/3550216,
author = {Kelly, Terence},
title = {Source code for the article "Decentralized Computing"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550216},
abstract = {
    <p>Two maximal independent set (MIS) solver implementations are provided: "mixer" and "mis".  Shell scripts run both implementations on the example graph.<br>The "mixer.py" Python program is a decentralized implementation.  For each vertex in the graph we create a process that decides for itself whether to be "in" or "out" of the MIS after communicating as necessary with other processes representing adjacent vertices in the graph.  Read "mixer.csh" to see how the set of processes run. Without options, "mixer.csh" runs a set of "mixer.py" processes on the example graph.  With the "renum" option, the script also runs the Python code again on a different graph created by re-numbering the vertices of the original example graph.<br>The "mis.c" C program is a centralized implementation.  It reads the graph in file "example_graph.txt" and uses the same basic algorithm as the decentralized implementation to compute the same MIS.  Shell script "mis.csh" compiles the C code, runs the executable under the control of Valgrind, and uses the "check.awk" script to verify that the output is indeed an MIS of the input graph.  Run "indent" to adjust the layout of the C program to taste.</p>
}
}

@software{10.1145/3550215,
author = {Kelly, Terence},
title = {Source code for the article "Efficient Graph Search"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550215},
abstract = {
    <p>The run.csh script compiles two random graph generators and two variants of the BFS implementation, then the script runs experiments. I recommend running the script twice: once to bring your computer up to normal operating temperature and a second time to gather performance results.  Some modern computers may throttle back CPU performance when intensive computations cause them to overheat, so we want to measure performance with the machine in a warm steady state rather than under cold-start conditions.</p>
}
}

@software{10.5281/zenodo.6480633,
author = {Lu, Yifei and Pan, Minxue and Pei, Yu and Li, Xuandong},
title = {The reproduction package for 'Detecting Resource Utilization Bugs Induced by Variant Lifecycles in Android'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6480633},
abstract = {
    <p>VALA is a static analyzer to detect resource utilization bugs in Android applications induced by variant lifecycles. The VALA artifact has three components: (1) the executable jar file with configuration files in the folder ‘bin’; (2) the benchmark including 35 apps and all the experiment results in the folder ‘BenchmarkAndResults’; (3) a ‘README.md’ and demonstration video to teacher users how to use VALA and reproduce the experiment. With the three components, users can easily reproduce the experiment and get the results claimed in our paper ‘Detecting Resource Utilization Bugs Induced by Variant Lifecycles in Android’ within around 10 minutes. If provided with APK files of other Android apps as input, VALA can also detect the resource utilization bugs induced by variant lifecycles in the apps.</p>

},
keywords = {Android applications, resource utilization bugs, static analysis, variant lifecycles}
}

@software{10.5281/zenodo.6515687,
author = {Lipp, Stephan and Banescu, Sebastian and Pretschner, Alexander},
title = {Artifacts for the ISSTA 2022 Paper: An Empirical Study on the Effectiveness of Static C Code Analyzers for Vulnerability Detection},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6515687},
abstract = {
    <p>This artifact contains the evaluation script and the corresponding data of the ISSTA’22 paper “An Empirical Study on the Effectiveness of Static C Code Analyzers for Vulnerability Detection”. It can be used to replicate the evaluation results as well as to perform further analyses on the effectiveness of static code analyzers.</p>

},
keywords = {empirical study, static code analysis, vulnerability detection}
}

@software{10.5281/zenodo.6516441,
author = {Liu, Pei and Zhao, Yanjie and Cai, Haipeng and Fazzini, Mattia and Grundy, John and Li, Li},
title = {Reproduction Packages for "Automatically Detecting API-induced Compatibility Issues in Android Apps: A Comparative Analysis (Replicability Study)"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6516441},
abstract = {
    <p>This artefact provides the experimental datasets and results presented in our paper.</p>

},
keywords = {Android, API, Compatibility Issues, Fragmentation}
}

@software{10.5281/zenodo.6529828,
author = {Andronidis, Anastasios and Cadar, Cristian},
title = {Artefact for SnapFuzz: High-Throughput Fuzzing of Network Applications},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6529828},
abstract = {
    <p>This is the artefact submitted for the SnapFuzz: High-Throughput Fuzzing of Network Applications paper. The artefact includes a README file with full details on how to run and reproduce our results.</p>
<p>A latest version can always be found in: https://github.com/srg-imperial/SnapFuzz-artefact</p>

},
keywords = {afl, aflnet, artefact, binary rewriting, fuzzing, snapfuzz}
}

@software{10.5281/zenodo.6530839,
author = {Kapugama, Charaka Geethal and Pham, Van-Thuan and Aleti, Aldeida and B\"{o}hme, Marcel},
title = {Grammar2Fix:Human-in-the-Loop Oracle Learning for Semantic Bugs in String Processing Programs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6530839},
abstract = {
    <p>GRAMMAR2FIX is an active oracle learning technique for programs processing string inputs. Given a single failing input of a bug, it learns a grammar describing the pattern of all the failing inputs of the bug, interacting with a bug oracle systematically. GRAMMAR2FIX returns this grammar as a collection of Deterministic Finite Automata(DFA), and the grammar can serve as an automated test oracle for the bug. GRAMMAR2FIX also produces a test suite in grammar learning, which can be used as a repair test suite in Automated Program Repair.</p>

},
keywords = {Automated Test Oracle, Grammar Inference, Software Debugging}
}

@software{10.5281/zenodo.6534173,
author = {Rak-amnouykit, Ingkarat and Milanova, Ana and Baudart, Guillaume and Hirzel, Martin and Dolby, Julian},
title = {The Raise of Machine Learning Hyperparameter Constraints in Python Code (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6534173},
abstract = {
    <p>The artifact for the paper “The Raise of Machine Learning Hyperparameter Constraints in Python Code”.</p>

},
keywords = {interprocedural analysis, machine learning libraries, Python}
}

@software{10.5281/zenodo.6534554,
author = {Kim, Myeongsoo and Xin, Qi and Sinha, Saurabh and Orso, Alessandro},
title = {Reproduction Package for Article `Automated Test Generation for REST APIs: No Time to Rest Yet`},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6534554},
abstract = {
    <p>This artifact is for reproducing the results of the article <code>Automated Test Generation for REST APIs: No Time to Rest Yet.</code> It has an automated script to run the ten state-of-the-art REST API testing tools for 20 RESTful services. Users can analyze the result using the provided script.</p>

},
keywords = {Automated software testing, RESTful APIs}
}

@software{10.5281/zenodo.6534803,
author = {Huang, Pei and Yang, Yuting and Liu, Minghao and Jia, Fuqi and Ma, Feifei and Zhang, Jian},
title = {Reproduction Package for Article "ε-Weakened Robustness of Deep Neural Networks"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6534803},
abstract = {
    <p>The artifact is used for reproducing the experimental results in the article “ε-Weakened Robustness of Deep Neural Networks”, including the attack algorithm PGD, robustness enhancement algorithm FPP, ε-Weakened robustness evaluation and decision algorithms (EWRE and EWRD) for several neural networks (resnet18, densenet121, dpn92, regnetx_200, etc.)</p>

},
keywords = {adversarial attack, neural networks, robustness, testing}
}

@software{10.5281/zenodo.6535525,
author = {Song, Xuezhi and Lin, Yun and Ng, Siang Hwee and Wu, Yijian and Peng, Xin and Dong, Jin Song and Mei, Hong},
title = {RegMiner: Towards Constructing Large Regression Dataset from Code Evolution History},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6535525},
abstract = {
    <p>Bug datasets lay significant empirical and experimental foundation for various SE/PL researches such as fault localization, software testing, and program repair. All well-known datasets are constructed manually, which inevitably limits their scalability, representativeness, and the support for the emerging data-driven research. In this work, we propose an approach to automate the process of harvesting replicable regression bugs from the code evolution history. We focus on regression bugs, as they (1) manifest how a bug is introduced and fixed (as non-regression bugs), (2) support regression bug analysis, and (3) incorporate a much stronger specification (i.e., the original passing version) than non-regression bug dataset for bug analysis. Technically, we address an information retrieval problem on code evolution history. Given a code repository, we search for regressions where a test can pass a regression-fixing commit, fail a regression-inducing commit, and pass a previous working commit. In this work, we address the challenges of (1) identifying potential regression-fixing commits from the code evolution history, (2) migrating the test and its code dependencies over the history, and (3) minimizing the compilation overhead during the regression search. We build our tool, RegMiner, which harvested 1035 regressions over 147 projects for 8 weeks, creating the largest replicable regression dataset within the shortest period, to the best of our knowledge. Our extensive experiments show that (1) RegMiner can construct the regression dataset with very high precision and acceptable recall, and (2) the constructed regression dataset is of high authenticity and diversity. We foresee that a continuously growing regression dataset opens many data-driven research opportunities in the SE/PL communities.</p>

},
keywords = {bug collection, mining code repository, regression bug}
}

@software{10.5281/zenodo.6539575,
author = {Busse, Frank and Gharat, Pritam and Cadar, Cristian and Donaldson, Alastair F.},
title = {Artefact for the ISSTA 2022 Paper: "Combining Static Analysis Error Traces with Dynamic Symbolic Execution (Experience Paper)"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6539575},
abstract = {
    <p>The artefact provides a Docker image that contains the source code and binaries of our instrumentation/bug injection tools and KLEE extension, all benchmarks with their bitcode files, scripts to reproduce our experiments, and the static analysis reports for investigated real-world applications.</p>

},
keywords = {Clang Static Analyzer, Infer, KLEE, software testing, static analysis, symbolic execution}
}

@software{10.5281/zenodo.6575363,
author = {An, Gabin and Yoo, Shin},
title = {Replication Package for Article: "FDG: A Precise Measurement of Fault Diagnosability Gain of Test Cases"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6575363},
abstract = {
    <p>This artifact contains a replication package for the paper “FDG: A Precise Measurement of Fault Diagnosability Gain of Test Cases”. It provides the scripts and documents to replicate the experiment described in the paper. The detailed guide to replication is provided in the artifact’s README.md file.</p>

},
keywords = {fault diagnosability, fault localisation, test augmentation, test generation}
}

@software{10.1145/3462320,
author = {Schlaak, Christof and Juang, Tzung-Han and Dubach, Christophe},
title = {Reproducton Package for Article "Optimizing Data Reshaping Operations in Functional IRs for High-Level Synthesis"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462320},
abstract = {
    <p>This artifact fully covers all the experiments in section 4 of the LCTES 2022 paper “Optimizing Data Reshaping Operations in Functional IRs for High-Level Synthesis”. Starting from high-level expressions as described in sections 4.1 and 4.2 for tiled matrix multiplication and 2D convolution, the compiler automatically generates an optimized hardware design based on VHDL files. On the FPGA server, a bitstream for an FPGA is synthesised from these generated design files. Then the design is run on a real FPGA to get all the performance numbers and resource usages of Table 2 and Table 3.</p>

},
keywords = {compilers, functional IR, High-level synthesis, rewrite rules}
}

@software{10.1145/3462321,
author = {Schneider, Klaus and Bhagyanath, Anoop and Roob, Julius},
title = {Reproduction Package for Paper "Code Generation Criteria for Buffered Exposed Datapath Architectures from Dataflow Graphs "},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462321},
abstract = {
    <p>The software can be used to reproduce the computations described in the corresponding paper and also to perform computations with modified or completely different examples. In general, one can derive via a SAT solver a move code program for a BED architecture either from a sequential program or a dataflow graph derived from it.</p>

},
keywords = {code generation, dataflow graphs, exposed data- path architectures, linear graph layouts, queue layouts}
}

@software{10.5281/zenodo.6605099,
author = {Wang, Tianyu and Shen, Zhaoyan and Shao, Zili},
title = {Reproduction package of "Co-mining: A Processing-in-Memory Assisted Framework for Memory-Intensive PoW Acceleration"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6605099},
abstract = {
    <p>A simple simulator that can simulate hashrate for different NVIDIA graphic cards with GDDR6 or HBM-PIM. Content: /configs: All the configurations of different graphic cards. /build: The trace file and result analysis scripts. /src: Main logic of the simulator.</p>

},
keywords = {GPU-PIM simulator}
}

@software{10.5281/zenodo.6607837,
author = {Chen, Zizhan and Shang, Siqi and Wu, Qihong and Xue, Jin and Shen, Zhaoyan and Shao, Zili},
title = {AE Package for "An Old Friend Is Better Than Two New Ones: Dual-Screen Android"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6607837},
abstract = {
    <p>The artifact is for “An Old Friend Is Better Than Two New Ones: Dual-Screen Android”. App_List.pdf contains the Corpus-L application list.</p>
<p>Modifications/ folder contains the modified files.</p>
<p>Scripts/ folder contains the scripts.</p>
<p>Expected_outputs/ folder contains the expected outputs.</p>
<p>Link to the demo Videos: https://mycuhk-my.sharepoint.com/:f:/g/personal/1155107934_link_cuhk_edu_hk/EmUhtXbQ5I5EqrmK66yOrDQBS7948nAc2ye-JFsBp5xd5w?e=bbP3gw</p>
<p>AE_Addition/ contains the python scripts to generate the experimental results.</p>

},
keywords = {display energy optimization, Embedded system, mobile system}
}

@software{10.5281/zenodo.6330461,
author = {Choi, Wonhyuk and Finkbeiner, Bernd and Piskac, Ruzica and Santolucito, Mark},
title = {Artifact Package for "Can Reactive Synthesis and Syntax-Guided Synthesis Be Friends?"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6330461},
abstract = {
    <p>Instructions to download and run the tool temos, the artifact for the paper “Can Reactive Synthesis and Syntax-Guided Synthesis Be Friends?”</p>

},
keywords = {Program Synthesis, Reactive Synthesis, Syntax-Guided Synthesis}
}

@software{10.5281/zenodo.6392272,
author = {Chen, Yishen and Mendis, Charith and Amarasinghe, Saman},
title = {Reproduction Package for "All You Need Is Superword-Level Parallelism: Systematic Control-Flow Vectorization with SLP"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6392272},
abstract = {
    <p>Artifact to reproduce the result in the paper.</p>

},
keywords = {Compiler, Optimization, SIMD, Vectorization}
}

@software{10.5281/zenodo.6413290,
author = {Cho, Minki and Lee, Sung-Hwan and Lee, Dongjae and Hur, Chung-Kil and Lahav, Ori},
title = {Coq Development for the article `Sequential Reasoning for Optimizing Compilers Under Weak Memory Concurrency`},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6413290},
abstract = {
    <p>This artifact contains Coq development of the promising semantics model extended with non-atomic accesses, the SEQ model and its soundness theorem, and the certified optimizer.</p>

},
keywords = {Compiler Optimizations, Operational Semantics, Relaxed Memory Concurrency}
}

@software{10.5281/zenodo.6413814,
author = {\v{Z}ikeli\'{c}, undefinedor\dj{}e and Chang, Bor-Yuh Evan and Bolignano, Pauline and Raimondi, Franco},
title = {Differential Cost Analysis with Simultaneous Potentials and Anti-potentials (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6413814},
abstract = {
    <p>The artifact contains a prototype tool for differential cost analysis of numerical C programs with polynomial arithmetic and possibly with non-determinism. Given two programs together with their input sets, the tool computes an upper bound on the maximal difference in cost usage between the two programs on any initial variable valuation that is contained in both input sets. Cost may take both positive and negative values, and we assume that each program has a special variable “cost” that is initialized to 0 and that is updated whenever cost is incurred in the program. It could be used to track program runtime, memory usage, the number of object allocations, or any other program property of interest that could be tracked by a program variable.</p>
<p>The artifact is provided both as a docker image and as a zip of all source files. The reason for providing both is that, in our experimental evaluation, we use Gurobi for linear programming (LP) which is licensed and is free only for academic use. Thus, we cannot install Gurobi in our docker image but replace it with the GLPK solver. GLPK allows reproducing our experimental results with slightly longer runtimes (details are provided in README). To reproduce our reported experimental results with Gurobi, one needs to build the tool from source files and instructions for doing so are provided in README.</p>

},
keywords = {Cost analysis, Differential cost analysis, Potential functions, Relational reasoning}
}

@software{10.5281/zenodo.6503045,
author = {Zha, Junpeng and Liang, Hongjin and Feng, Xinyu},
title = {Artifact of "Verifying Optimizations of Concurrent Programs in the Promising Semantics"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6503045},
abstract = {
    <p>This is the artifact of PLDI22-paper984 “Verifying Optimizations of Concurrent Programs in the Promising Semantics”. We package our artifact (mechanized proof of the verification framework introduced in our paper in the Coq) in the virtual machine VirtualBox-6.1.32 as <code>pldi22-paper984.ova</code>. Detailed descriptions of the artifact can be found in the README.txt.</p>

},
keywords = {Code optimizations, Concurrency, Coq, Verification, Weak memory models}
}

@software{10.5281/zenodo.6508992,
author = {Xu, Mingkuan and Li, Zikun and Padon, Oded and Lin, Sina and Pointing, Jessica and Hirth, Auguste and Ma, Henry and Palsberg, Jens and Aiken, Alex and Acar, Umut A. and Jia, Zhihao},
title = {Artifact for PLDI 2022 Paper: Quartz: Superoptimization of Quantum Circuits},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6508992},
abstract = {
    <p>Quartz is a quantum circuit optimizer that automatically generates and verifies circuit transformations for an arbitrary quantum gate set. To optimize an input quantum circuit, Quartz uses these auto-generated circuit transformations to construct a search space of functionally equivalent quantum circuits. Quartz uses a cost-based search algorithm to explore the space and discovers highly optimized quantum circuits.</p>
<p>Quartz is open-source and developed on GitHub: https://github.com/quantum-compiler/quartz.</p>
<p>This artifact supports the PLDI 2022 paper about Quartz, and contains the implementation and scripts used to obtain the results reported in the paper. See also the extended version of the paper at https://arxiv.org/abs/2204.09033.</p>

},
keywords = {quantum computing, superoptimization}
}

@software{10.5281/zenodo.6514315,
author = {Greenman, Ben},
title = {Deep and Shallow Types for Gradual Languages},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6514315},
abstract = {
    <p>Data, analysis scripts, and source code.</p>

},
keywords = {complete monitoring, gradual typing, migratory typing, type enforcement strategies}
}

@software{10.5281/zenodo.5785485,
author = {Tian, Linan and Shi, Yangyang and Chen, Liwei and Yang, Yanqi and Shi, Gang},
title = {Gadgets Splicing: Dynamic Binary Transformation for Precise Rewriting (CGO 2022 Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5785485},
abstract = {
    <p>This document describes the artifact for paper “Gadgets Splicing: Dynamic Binary Transformation for Precise Rewriting” at CGO 2022. The artifact is in the form of a virtual machine running Ubuntu 18.04. It contains all software dependencies and compiled GRIN rewriter, benchmark binaries and scripts. You can directly run the scripts for reproducing main experiments.</p>

},
keywords = {Binary analysis, Binary rewriting, Dynamic execution, Static analysis}
}

@software{10.5281/zenodo.5785832,
author = {Park, Sunghyun and Latifi, Salar and Park, Yongjun and Behroozi, Armand and Jeon, Byungsoo and Mahlke, Scott},
title = {SRTuner: Effective Compiler Optimization Customization by Exposing Synergistic Relations},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5785832},
abstract = {
    <p>SRTuner is a tuning strategy that searches for the best possible optimization setting for the given run-time environment. Within the tuning budget, SRTuner endeavors to expose important inter-relatonship between optimizations and leverage them to focus on the promising search subspace. To allow fast integration, SRTuner is built in the form of python library that provides tuning primitives. Users can build a standalone tuning framework with these primitives or adopt them into the existing tuning framework as a new tuning method. Latest version of SRTuner is available at: https://github.com/sunggg/SRTuner</p>

},
keywords = {autotuner, compiler, optimization}
}

@software{10.5281/zenodo.5786074,
author = {Bhat, Siddharth and Grosser, Tobias},
title = {Lambda the Ultimate SSA: Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5786074},
abstract = {
    <p>This is the artifact in the form of a docker image for our CGO’22 paper “Lambda the ultimate SSA”. It contains full source code of our compiler, benchmarks and scripts for reproducing main experiments of the paper. We supply instructions on how to run the artifact evaluation in the appendix of our paper.</p>

},
keywords = {compilers, functional programming}
}

@software{10.5281/zenodo.5788478,
author = {Kurhe, Vaibhav Kiran and Karia, Pratik and Gupta, Shubhani and Rose, Abhishek and Bansal, Sorav},
title = {Artifact for "Automatic Generation of Debug Headers through BlackBox Equivalence Checking"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5788478},
abstract = {
    <p>The artifact contains source code for our tool, along with shell scripts and a dockerfile to install it inside a docker container. It also contains the output files from an equivalence checker (the .proof files) that are taken as input by our tool, along with the source and object files for TSVC benchmarking suite compiled with three different compilers – gcc, clang/llvm and icc. It can be used to reproduce the experimental results in Tables 2 and 3 of our CGO’22 paper – <strong>Automatic Generation of Debug Headers through BlackBox Equivalence Checking</strong>.</p>

},
keywords = {Compiler Optimizations, Debug Headers, Equivalence Checking}
}

@software{10.5281/zenodo.5789400,
author = {Matni, Angelo and Deiana, Enrico Armenio and Su, Yian and Gross, Lukas and Ghosh, Souradip and Apostolakis, Sotiris and Xu, Ziyang and Tan, Zujun and Chaturvedi, Ishita and Homerding, Brian and McMichen, Tommy and August, David I. and Campanoni, Simone},
title = {Replication Package For Article: NOELLE Offers Empowering LLVM Extensions},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5789400},
abstract = {
    <p>This artifact generates three sets of results.</p>
<p>MINIMAL: Data that supports the version of the paper that was submitted in September. This experiment does not include HELIX and DSWP, which both take a significant amount of time to transform each benchmark.</p>
<p>SUBMISSION: HELIX and DSWP are included.</p>
<p>FINAL: New results that were not included in the submitted version of the paper (extra 5 days). Also, HELIX and DSWP are included in this experiment.</p>

},
keywords = {automatic parallelization, dependence analysis, loop invariant analysis}
}

@software{10.5281/zenodo.5791919,
author = {Huber, Joseph and Cornelius, Melanie and Georgakoudis, Giorgis and Tian, Shilei and Monslave Diaz, Jose M and Dinel, Kuter and Chapman, Barbara and Doerfert, Johannes},
title = {Replication Package for Article: Efficient Execution of OpenMP on GPUs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5791919},
abstract = {
    <p>Our artifact provides the benchmarks used to evaluate the inter-procedural OpenMP optimizations implemented for this work. These benchmarks were evaluated using LLVM 12.0.1 as the baseline against a development branch of LLVM containing our changes with CUDA version 11.0. All but one of these patches have landed upstream, so any build of LLVM containing the commit hash 29a3e3dd7bed should be sufficient for general testing. Evaluation was done on a single Nvidia V100 GPU node, only kernel time was considered for benchmarking to measure the impact of our optimizations on the GPU.</p>

},
keywords = {GPU, LLVM, Offloading, OpenMP, Optimization}
}

@software{10.5281/zenodo.6366579,
author = {Benzaken, V\'{e}ronique and Contejean, \'{E}velyne and Hachmaoui, Mohammed Houssem and Keller, Chantal and Mandel, Louis and Shinnar, Avraham and Sim\'{e}on, J\'{e}r\^{o}me},
title = {Translating Canonical SQL to Imperative Code in Coq Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6366579},
abstract = {
    <p>This artifact is associated to the paper <code>Translating Canonical SQL to Imperative Code in Coq</code> by V\'{e}ronique Benzaken, \'{E}velyne Contejean, Mohammed Houssem Hachmaoui, Chantal Keller, Louis Mandel, Avraham Shinnar, and J\'{e}r\^{o}me Sim\'{e}on published at OOPSLA 2022. It supports the following claims: - a new formal translation of SQLcoq to NRAe, - a new formal translation of NRAe to Imp, - a complete compiler for a large subset of SQL to JavaScript.</p>
<p>The artifact contains: - <code>dbcert.tar.gz</code> the docker image of the containing the installed artifact, - <code>oopsla22.pdf</code> the OOPSLA 2022 paper with appendix, - <code>dbcert-0.1.0</code> the source of the compiler, - <code>dbcert-0.1.0-no-float</code> the source of the compiler without support for floating point numbers (that does not requires axioms).</p>

},
keywords = {Coq, Formal proof, JavaScript, Query compiler, Semantics preserving compiler, SQL}
}

@software{10.5281/zenodo.6367565,
author = {Pelsmaeker, Daniel A. A. and van Antwerpen, Hendrik and Poulsen, Casper Bach and Visser, Eelco},
title = {Artifact for "Language-Parametric Static Semantic Code Completion"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6367565},
abstract = {
    <p>This is the artifact submitted alongside our OOPSLA’22 paper “Language-Parametric Static Semantic Code Completion”. The artifact contains a VirtualBox image and guide that were evaluated, and the relevant source and benchmark/test files.</p>

},
keywords = {code completion, semantics, Spoofax, Statix}
}

@software{10.5281/zenodo.6390003,
author = {Cl\'{e}ment, Basile and Cohen, Albert},
title = {Reproduction Package for Article `End-to-End Translation Validation for the Halide Language`},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6390003},
abstract = {
    <p>This artifact contains a checking tool that allows to verify the correctness of affine implementations of affine Halide specifications, using the techniques described in the paper “End-to-End Translation Validation for the Halide language”. It also contains a patched version of the Halide compiler that generates prophetic annotations as described in the paper, and the examples used in the experiments, adapted from the official Halide benchmark suite.</p>
<p>The artifact is intended for the reproduction of the results in the paper, and to allow further experimentation with the techniques of the paper.</p>

},
keywords = {affine program, Halide, ocaml, tensor compiler, translation-validation, verification}
}

@software{10.5281/zenodo.6335844,
author = {Shen, Weihai and khanna, Ansh and Angel, Sebastian and Sen, Siddhartha and Mu, Shuai},
title = {Implementation of the article "Rolis: a software approach to efficiently replicating multi-core transactions"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6335844},
abstract = {
    <p></p><p>Artifact appendix item for Eurosys22'</p><p></p>
}
}

@software{10.5281/zenodo.6336004,
author = {Li, Ning and Jiang, Hong and Che, Hao and Wang, Zhijun and NGUYEN, MINH},
title = {Implementation of the article "Improving Scalability of Database Systems by Reshaping User Parallel I/O"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6336004},
abstract = {
    <p></p><p>AppleS aims to improve database scalability by delivering the right amount and pattern of user parallel I/O requests to the database system under excessive user parallelism, aligning with the concurrency supported by the database and its underlying I/O stack. In doing so, AppleS improves user-level I/O performance in terms of user-level I/O fairness, throughput and latency stability. Implemented as a user-space module based on system call interception, AppleS is compatible with and portable to different types/versions of databases, different versions of OS kernels and their resource management tools, e.g., Cgroups.</p><p></p>
}
}

@software{10.5281/zenodo.6336103,
author = {Kuo, Hsuan-Chi and Chen, Kai-Hsun and Lu, Yicheng and Williams, Dan and Mohan, Sibin and Xu, Tianyin},
title = {Implementation of the article "Verified Programs Can Party: Optimizing Kernel Extensions via Post-Verification In-Kernel Merging"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6336103},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.6336200,
author = {Zhou, Xia and Li, Jiaqi and Zhang, Wenlong and Zhou, Yajin and Shen, Wenbo and Ren, Kui},
title = {Implementation of the article "OPEC: Operation-based Security Isolation for Bare-metal Embedded Systems"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6336200},
abstract = {
    <p></p><p>Keep consistent with zhouxzju/opec:v1.3</p><p></p>
}
}

@software{10.5281/zenodo.6336301,
author = {Kirth, Paul and Dickerson, Mitchel and Crane, Stephen and Larsen, Per and Dabrowski, Adrian and Gens, David and Na, Yeoul and Volckaert, Stijn and Franz, Michael},
title = {Implementation of the article "PKRU-Safe: Automatically Locking Down the Heap Between Safe and Unsafe Languages"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6336301},
abstract = {
    <p></p><p>Public release v1.0.0 of PKRU-Safe for EuroSys22.</p><p></p>
}
}

@software{10.5281/zenodo.6337102,
author = {Thalheim, Joerg and Okelmann, Peter and Unnibhavi, Harshavardhan and Gouicem, Redha and Bhatotia, Pramod},
title = {Implementation of the article "VMSH: Hypervisor-agnostic Guest Overlays for VMs"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6337102},
abstract = {
    <p></p><p>Source code of VMSH</p><p></p>
}
}

@software{10.5281/zenodo.6337790,
author = {Baranawal, Animesh and Simmhan, Yogesh},
title = {Implementation of the article "Optimizing the Interval-centric Distributed Computing Model for Temporal Graph Algorithms"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6337790},
abstract = {
    <p></p><p>This version was used for artifact evaluation of the paper "Optimizing the Interval-centric Distributed Computing Model for Temporal Graph Algorithms" to appear in Eurosys 2022.</p><p></p>
}
}

@software{10.5281/zenodo.6338745,
author = {Bozdoaan, Kartal Kaan and Stavrakakis, Dimitrios and Issa, Shady and Bhatotia, Pramod},
title = {Implementation of the article "SafePM: A Sanitizer for Persistent Memory"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6338745},
abstract = {
    <p></p><p>SafePM: Memory Safety for Persistent Memory --- Artifact Evaluation</p><p></p>
}
}

@software{10.5281/zenodo.6342303,
author = {Xiang, Lingfeng and Zhao, Xingsheng and Rao, Jia and Jiang, Song and Jiang, Hong},
title = {Implementation of the article "Characterizing the Performance of Intel Optane Persistent Memory -- A Close Look at its On-DIMM Buffering"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6342303},
abstract = {
    <p></p><p>Submitted version for EuroSys 2022 artifact evaluation</p><p></p>
}
}

@software{10.5281/zenodo.6344032,
author = {Stathakopoulou, Chrysoula and Pavlovic, Matej and Vukolic, Marko and Stathakopoulou, Chrysoula},
title = {Implementation of the article "State Machine Replication Scalability Made Simple"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6344032},
abstract = {
    <p></p><p>This is the research prototype of the ISS state machine replication protocol.
It was used to obtain the performance results published at EuroSys 2022.
Authors: @matejpavlovic @stchrysa</p><p></p>
}
}

@software{10.5281/zenodo.6344960,
author = {Lawall, Julia and Pandya, Himadri and Lozi, Jean-Pierre and Lepers, Baptiste and Zwaenepoel, Willy and Muller, Gilles},
title = {Implementation of the article "OS Scheduling with Nest: Keeping Tasks Close Together on Warm Cores"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6344960},
abstract = {
    <p></p><p>Nest is a scheduling policy built on the Linux kernel that is designed according to the principles of core reuse and keeping cores warm.&nbsp; This artifact contains instructions and tools necessary to replicate the experiments found in this paper.</p><p></p>
}
}

@software{10.5281/zenodo.6345303,
author = {Jiao, Yizheng and Porter, Don and Patel, Sagar and Zeller, Luke and Bennet, Rory and Bender, Michael and Condict, Michael and Conway, Alex and Farach-Colton, Martin and GE, XIONGZI and Jannen, William and Johnson, Rob and Yuan, Jun and Bertron, Simon and Mukherjee, Nirjhar},
title = {Implementation of the article "BetrFS: A Compleat File System for Commodity SSDs"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6345303},
abstract = {
    <p></p><p>Versions of scripts used to recreate the results from "BetrFS: A Compleat File System for Commodity SSDs".</p><p></p>
}
}

@software{10.5281/zenodo.6345350,
author = {Gog, Ionel and Kalra, Sukrit and Schafhalter, Peter and Gonzalez, Joseph and Stoica, Ion},
title = {Implementation of the article "D3: A Dynamic Deadline-Driven Approach for Building Autonomous Vehicles"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6345350},
abstract = {
    <p></p><p>Scripts to reproduce experiments and graphs from the <code>D3: A Dynamic Deadline-Driven Approach for Building Autonomous Vehicles</code> paper accepted at <code>EuroSys 2022</code>.</p><p></p>
}
}

@software{10.5281/zenodo.6345713,
author = {Chen, Chen and Zhong, Wenshao and Wu, Xingbo and Wu, Xingbo},
title = {Implementation of the article "Building an Efficient Key-Value Store in a Flexible Address Space"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6345713},
abstract = {
    <p></p><p>This is the Digital Object Identifier (DOI) page for persistently indexing the source code and artifact of FlexTree, FlexSpace and FlexDB. Their latest version could be found in the following GitHub repositories:</p>

<p>https://github.com/flexible-address-space/flexspace<br>
https://github.com/flexible-address-space/eurosys22-artifact</p><p></p>
}
}

@software{10.5281/zenodo.6345733,
author = {Xu, Ran and Lee, Jayoung and Wang, Pengcheng and Bagchi, Saurabh and Li, Yin and Chaterji, Somali},
title = {Implementation of the article "LiteReconfig: Cost and Content Aware Reconfiguration of Video Object Detection Systems for Mobile GPUs"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6345733},
abstract = {
    <p></p><p>The source code for the LiteReconfig paper at EuroSys 2022. Thanks to @StarsThu2016 @starpic414 @ChulanZhang for their contributions to this release.</p><p></p>
}
}

@software{10.5281/zenodo.6345869,
author = {Oh, Hyungjun and Lee, Junyeol and Seo, Jiwon},
title = {Implementation of the article "Out-Of-Order BackProp: An Effective Scheduling Technique for Deep Learning"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6345869},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.6347456,
author = {Yang, Jianbang and Tang, Dahai and Song, Xiaoniu and Wang, Lei and Yin, Qiang and Chen, Rong and Yu, Wenyuan and Zhou, Jingren},
title = {Implementation of the article "GNNLab: A Factored System for Sample-based GNN Training over GPUs"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6347456},
abstract = {
    <p>FGNN's artifact evaluation (EuroSys 2022)</p>
}
}

@software{10.5281/zenodo.6347736,
author = {Asyabi, Esmail and Wang, Yuanli and Liagouris, John and Kalavri, Vasiliki and Bestavros, Azer},
title = {Implementation of the article "A New Benchmark Harness for Systematic and Robust Evaluation of Streaming State Stores"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6347736},
abstract = {
    <p></p><p>No description provided.</p><p></p>
}
}

@software{10.5281/zenodo.6348174,
author = {Mehrab, A K M Fazla and Nikolaev, Ruslan and Ravindran, Binoy},
title = {Implementation of the article "Kite: Lightweight Critical Service Domains full strip note"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6348174},
abstract = {
    <p></p><p>Artifact for EuroSys'22 paper "Kite: Lightweight Critical Service Domains". Please see kite/README.md in Kite.zip for more information.&nbsp;Please also see the licensing terms in LICENSE.</p><p></p>
}
}

@software{10.5281/zenodo.6349596,
author = {Khandelwal, Anurag and Tang, Yupeng and Agarwal, Rachit and Akella, Aditya and Stoica, Ion and Akella, Aditya},
title = {Implementation of the article "Jiffy: Statistical Multiplexing for Disaggregated Memory full strip note"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6349596},
abstract = {
    <p></p><p>Artifact appendix item for Eurosys 2022.</p><p></p>
}
}

@software{10.5281/zenodo.6350453,
author = {Wanninger, Nicholas and Hale, Kyle and Bowden, Joshua},
title = {Implementation of the article "Isolating at the Hardware Limit with Virtines"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6350453},
abstract = {
    <p></p><p>Wasp: micro-hypervisor that enables lightweight, isolated virtines</p><p></p>
}
}

@software{10.5281/zenodo.6353717,
author = {Danezis, George and Kokoris-Kogias, Eleftherios and Sonnino, Alberto and Spiegelman, Alexander and Sonnino, Alberto},
title = {Implementation of the article "Narwhal and Tusk: A DAG-based Mempool and Efficient BFT Consensus"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6353717},
abstract = {
    <p></p><p>No changes, just a release to link with Zenodo</p><p></p>
}
}

@software{10.5281/zenodo.6354775,
author = {Hajkazemi, Mohammad Hossein and Aschenbrenner, Vojtech and Abdi, Mania and Kaynar, Emine Ugur and Mossayebzadeh, Amin and Krieger, Orran and Desnoyers, Peter},
title = {Implementation of the article "Beating the I/O bottleneck: A case for log-structured virtual disks"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6354775},
abstract = {
    <p>DIS: blockDevice over Immutable Storage</p>
}
}

@software{10.5281/zenodo.6359660,
author = {Athlur, Sanjith and Saran, Nitika and Sivathanu, Muthian and Ramjee, Ramachandran and Kwatra, Nipun and Athlur, Sanjith},
title = {Implementation of the article "Varuna: Scalable, Low-cost Training of Massive Deep Learning Models"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6359660},
abstract = {
    <p></p><p>&nbsp;</p>

<p><em>Varuna</em>&nbsp;is a tool for efficient training of large DNN models on commodity GPUs and networking. It implements a combination of pipeline parallelism and data parallelism in PyTorch, and enables training on a changing set of resources smoothly.</p><p></p>
}
}

@software{10.5281/zenodo.6360540,
author = {Iqbal, Md Shahriar and Krishna, Rahul and Javidian, Mohammad Ali and Ray, Baishakhi and Jamshidi, Pooyan},
title = {Implementation of the article "Unicorn: Reasoning about Configurable System Performance through the lens of Causality"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6360540},
abstract = {
    <p>Debugging Cross Stack Performance Faults using Causal Inference</p>
}
}

@software{10.5281/zenodo.5982794,
author = {Groce, Alex and van Tonder, Rijnard and Kalburgi, Goutamkumar Tulajappa and Le Goues, Claire},
title = {Making No-Fuss Compiler Fuzzing Effective: CC 2022 Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5982794},
abstract = {
    <p>This is the artifact for the paper “Making No-Fuss Compiler Fuzzing Effective” by Alex Groce, Rijnard van Tonder, Goutamkumar Tulajappa Kalburg, and Claire Le Goues, for the 2022 International Conference on Compiler Construction.</p>

},
keywords = {fuzzing mutation compilers}
}

@software{10.5281/zenodo.6337971,
author = {Ryu, Jaehun and Park, Eunhyeok and Sung, Hyojin},
title = {One-Shot Tuner for Deep Learning Compilers (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6337971},
abstract = {
    <p>Our artifact includes an implementation of the One-Shot Tuner predictor model and a variant of the TVM compiler modified to use One-Shot Tuner. We provide a fully trained One-Shot Tuner predictor model, along with model source codes, training data samples obtained using PGS and EBS methods, and scripts to use the data to re-train the model. For the compiler, we provide binaries and source codes for the TVM compiler modified to use the trained One-Shot Tuner predictor model for a single iteration of search and validation in place of its AutoTVM-based auto-tuning process. This will allow evaluation and reproduction of our results on the NVIDIA GPU and Intel CPU systems described in the paper.</p>

},
keywords = {autotuning, deep neural networks, optimizing compilers, performance models}
}

@software{10.1145/3462316,
author = {Gorjiara, Hamed and Xu, Guoqing Harry and Demsky, Brian},
title = {Replication Package for Article: Yashme: Detecting Persistency Races},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462316},
abstract = {
    <p>This artifact contains a vagrant repository that downloads and compiles the source code for Yashme, its companion compiler pass, and benchmarks. The artifact enables users to reproduce the bugs that are found by Yashme in PMDK, Memcached, and Redis, and RECIPE as well as the performance results to compare Yashme with Jaaru, the underlying model checker.</p>

},
keywords = {CCEH, Compiler, FastFair, Memcached, Persistency Race, PMDK, RECIPE, Redis, Software Verification, Yashme}
}

@software{10.1145/3462317,
author = {Du, Dong and Liu, Qingyuan and Jiang, Xueqiang and Xia, Yubin and Zang, Binyu and Chen, Haibo},
title = {Artifact for Paper: Serverless Computing on Heterogeneous Computers},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462317},
abstract = {
    <p>The artifact is the main repo for paper, Serverless Computing on Heterogeneous Computers. It contains the instructions to build and run the experiments, and the top directory of the project.</p>

},
keywords = {heterogeneous architecture, operating system, Serverless computing, smart computers}
}

@software{10.5281/zenodo.5733989,
author = {Zheng, Zhen and Yang, Xuanda and Zhao, Pengzhan and Long, Guoping and Zhu, Kai and Zhu, Feiwen and Zhao, Wenyi and Liu, Xiaoyong and Yang, Jun and Zhai, Jidong and Song, Shuaiwen Leon and Lin, Wei},
title = {ASPLOS22 Artifact - AStitch Machine Learning Optimizing Compiler},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5733989},
abstract = {
    <p>The artifact contains the necessary software components to validate the main results in AStitch paper. We provide a docker image to ease the environment setup. The docker image contains the compiled binary of AStitch, scripts to evaluate the inference and training performance, and scripts to draw the figures. It requires a Linux system with NVIDIA driver (capable to run CUDA 10.0) running on a NVIDIA V100 GPU equipped x86_64 machine to create the docker container. After launching the docker container, people can run one script to collect all performance numbers. It requires some manual finishing to fill the performance numbers into several python scripts to draw the most important figures in the paper, showing the speedup of AStitch and breakdown information.</p>

},
keywords = {Compiler Optimization, Kernel Fusion, Machine Learning System, Memory-intensive Computation}
}

@software{10.5281/zenodo.5735634,
author = {Zhao, Mark and Gao, Mingyu and Kozyrakis, Christos},
title = {Artifact for Article: ShEF: Shielded Enclaves for Cloud FPGAs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5735634},
abstract = {
    <p>In our artifact, we provide the entirety of the ShEF source code, including the Shield and implementations of the Secure Boot and Remote Attestation protocols. Our artifacts also include a number of reference benchmarks that we use to evaluate ShEF. We provide instructions on how to build, run, and evaluate Shield benchmarks on AWS F1 instances. Our archival and GitHub repository also provides a README containing more details on using ShEF.</p>

},
keywords = {cloud computing, enclaves, FPGAs, reconfigurable computing, trusted execution}
}

@software{10.5281/zenodo.5746392,
author = {Guo, Zhiyuan and Shan, Yizhou and Luo, Xuhao and Huang, Yutong and Zhang, Yiying},
title = {Replication Package for Article: Clio: A Hardware-Software Co-Designed Disaggregated Memory System},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5746392},
abstract = {
    <p>This artifact provides the source code of Clio, a hardware software co-designed disaggregated memory system. The Clio artifact has a C-based host-side library, a C-based ARM SoC management path, and a SpinalHDL-based FPGA data path along with a set of comprehensive FPGA building scripts. The artifact suite also has a set of microbenchmark examples and ported applications</p>

},
keywords = {FPGA, Hardware Software Co-design, Resource Disaggregation, Virtual Memory}
}

@software{10.5281/zenodo.5746505,
author = {Zhang, Haotian and Ren, Mengfei and Lei, Yu and Ming, Jiang},
title = {uTrimmer: Security Hardening of MIPS Embedded Systems via Static Binary Debloating for Shared Libraries},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5746505},
abstract = {
    <p>This abstract is used to evaluate performance of our debloating framework uTrimmer on SPEC CPU2017, MIPS firmware applications, and a real MIPS embedded application. uTrimmer is built on top of angr to identify and wipe out unused basic blocks from shared libraries’ binary code in MIPS firmware applications. For a given MIPS binary program and its dependent shared libraries, uTrimmer can export a debated shared libraries of the program. uTrimmer itself does not need additional software to work. However, to evaluate the debloating result, It requires IDA pro for function boundary detection and QEMU to emulate execution environment for programs under the test. The required execution scripts to reproduce the experiment results are provided in the VM image.</p>
<p>We performed several experiments to evaluate uTrimmer’s performance. The first experiment evaluates debloating capability of uTrimmer on SPEC CPU2017 and real firmware applications. The result is shown in Table 3 on page 10. The second experiment compares uTrimmer with the static linker about the debloating efficiency, which is shown in Table 4 on page 10. The third experiment demonstrates uTrimmer’s ability to reduce ROP gadgets on SPEC 2017 and firmware applications. We show the execution results in Table 5 on page 10. We also conducted an experiment on real firmware to evaluate uTrimmer’s performance, shown in Table 6 on page 12.</p>

},
keywords = {embeded system, shared library debloating, static binary analysis}
}

@software{10.5281/zenodo.5747666,
author = {Kannan, Tejas and Hoffmann, Henry},
title = {Replication Package for Article: Protecting Adaptive Sampling from Information Leakage on Low-Power Sensors},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5747666},
abstract = {
    <p>This artifact provides an implementation of Adaptive Group Encoding (AGE). AGE is a framework that protects adaptive sampling procedures on low-power sensors from leaking information through the size of batched messages. The system works by encoding all measurement batches as fixed-length messages, thereby breaking the relationship between the message size and the adaptive policy’s collection rate. This repository implements AGE both in a simulated environment and on a microcontroller (MCU). The simulator, written in Python, represents the sensor and server as individual processes. These components communicate using a local (encrypted) socket, and the simulator tracks the sensor’s energy consumption using traces from a TI MSP430 MCU. The hardware setting executes AGE on a TI MSP430 FR5994. The MCU transmits measurement batches to a separate server over a Bluetooth link. These experimental settings confirm AGE’s ability to maintain the low error of adaptive sampling while preventing information leakage and incurring negligible energy overhead. The repository https://github.com/tejaskannan/adaptive-group-encoding contains all the code for this work.</p>

},
keywords = {Adaptive Sampling, Data Privacy, Embedded Systems, Lossy Data Encoding}
}

@software{10.5281/zenodo.5748202,
author = {Chen, Yanju and Liu, Junrui and Feng, Yu and Bodik, Rastislav},
title = {Tree Traversal Synthesis Using Domain-Specific Symbolic Compilation},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5748202},
abstract = {
    <p>Tree Traversal Synthesis Using Domain-Specific Symbolic Compilation - Artifact for ASPLOS 2022 Submission</p>

},
keywords = {program synthesis, symbolic compilation, tree traversal}
}

@software{10.5281/zenodo.5748274,
author = {Pismenny, Boris and Liss, Liran and Morrison, Adam and Tsafrir, Dan},
title = {Artifact for 'The Benefits of General-Purpose On-NIC Memory'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5748274},
abstract = {
    <p>This repository contains scripts for ASPLOS’22 artifact evaluation of the The Benefits of General-Purpose on-NIC Memory paper by Boris Pismenny, Liran Liss, Adam Morrison, and Dan Tsafrir.</p>

},
keywords = {NFV acceleration, NIC memory, nicmem}
}

@software{10.5281/zenodo.5748410,
author = {Zhang, Qian and Wang, Jiyuan and Xu, Guoqing Harry and Kim, Miryung},
title = {Artifact for Article: HeteroGen: Transpiling C to Heterogeneous HLS Code with Automated Test Generation and Program Repair},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5748410},
abstract = {
    <p>This artifact includes an error study, a fuzzing-based test generation tool, and an automated code edit tool for error removal.</p>

},
keywords = {heterogeneous applications, program repair, test generation}
}

@software{10.5281/zenodo.5748606,
author = {Deutsch, Peter W. and Yang, Yuheng and Bourgeat, Thomas and Drean, Jules and Emer, Joel S. and Yan, Mengjia},
title = {Gem5/Rosette Simulation Packages for DAGguise},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5748606},
abstract = {
    <p>Our artifact comprises of two distinct parts: a unified gem5 / DRAMSim2 model (for performance evaluation), and a Rosette model (for security verification). The unified gem5/DRAMSim2 model is able to evaluate the performance of DAGguise and FS-BTA against an insecure baseline. We use gem5’s OoO core to perform baseline measurements, profile candidate rDAGs, and report final performance numbers. We also include the sample victim programs (DocDist and DNA) as described in the paper, in addition to an rDAG generation tool, and plotting scripts for Figures 7 and 9. The Rosette model symbolically executes the DAGguise system and verifies the Security Property with K-Induction as described in Section 5 of the paper.</p>

},
keywords = {dagguise, dramsim2, gem5, rosette}
}

@software{10.5281/zenodo.5748667,
author = {Roy, Rohan Basu and Patel, Tirthak and Tiwari, Devesh},
title = {IceBreaker: Warming Serverless Functions Better with Heterogeneity},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5748667},
abstract = {
    <p>IceBreaker is technique that reduces the service time and keep-alive cost of serverless functions, which are executed on a heterogeneous system consisting of costly and cheaper nodes. IceBreaker’s design consists of two major components: (1) Function Invocation Prediction Scheme (FIP), and (2) Placement Decision Maker (PDM). The FIP uses a Fourier transform based approach to determine the invocation concurrency of a function. The PDM decides where to warm up a serverless function: on a high-end server, or on a low- end server, or no warm up at all. This decision is made based upon an utility score which is calculated by considering several factors like probability of function invocation, speedup of a function on a high-end server, etc. Our artifact packages the scripts for setting up and invoking IceBreaker. It also contains the data obtained in our experimentation.</p>

},
keywords = {Cloud Computing, Cold Start, Heterogeneous Hardware, Keep-alive Cost, Serverless Computing}
}

@software{10.5281/zenodo.5780204,
author = {Li, Gushu and Wu, Anbang and Shi, Yunong and Javadi-Abhari, Ali and Ding, Yufei and Xie, Yuan},
title = {Artifact for Article: Paulihedral: A Generalized Block-Wise Compiler Optimization Framework for Quantum Simulation Kernels},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5780204},
abstract = {
    <p>See appendix for artifact description</p>

},
keywords = {compiler, quantum computing, quantum simulation}
}

@software{10.5281/zenodo.5785310,
author = {Wang, Bangyan and Deng, Lei and Sun, Fei and Dai, Guohao and Liu, Liu and Wang, Yu and Xie, Yuan},
title = {Replication package for paper "A One-for-All and $O(V\log(V))$-Cost Solution for Parallel Merge Style Operations on Sorted Key-Value Arrays"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5785310},
abstract = {
    <p>It contains the necessary source code to reproduce the result in paper “A One-for-All and <span class="math inline"><em>O</em>(<em>V</em>log (<em>V</em>))</span>-Cost Solution for Parallel Merge Style Operations on Sorted Key-Value Arrays”. It contains:</p>
<ol type="1">
<li>A modified GCC compiler that support the new SIMD primitives</li>
<li>A modified Gem5 simulator that support the new SIMD primitives</li>
<li>A collection of kernels written in C++ that use the new SIMD primitives. It should be compiled using the modified GCC.</li>
<li>A dockerfile to help you setup the environement.</li>
</ol>

},
keywords = {GCC, Gem5, Graph, Join, Key-value array, Merge sort, SIMD, Sparse linear algebra, SpGEMM}
}

@software{10.5281/zenodo.5790730,
author = {Chen, Zhangyu and Hua, Yu and Zhang, Yongle and Ding, Luochangqi},
title = {Replication Package for Article: Efficiently Detecting Concurrency Bugs in Persistent Memory Programs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5790730},
abstract = {
    <p>This is the finalized artifact of PMRace, a debugging tool for PM concurrency bugs. The artifact is maintained at <a href="https://github.com/yhuacode/pmrace-vagrant">GitHub</a> and developed by Zhangyu and Luochangqi.</p>

},
keywords = {Concurrency, Crash Consistency, Debugging, Persistent Memory, Testing}
}

@software{10.5281/zenodo.5792458,
author = {Zhao, Shixiong and Li, Fanxin and Chen, Xusheng and Shen, Tianxiang and Chen, Li and Wang, Sen and Zhang, Nicholas and Li, Cheng and Cui, Heming},
title = {Replication Package for Article: NASPipe: High Performance and Reproducible Pipeline Parallel Supernet Training via Causal Synchronous Parallelism},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5792458},
abstract = {
    <p>The artifact provides the availability, functionality, and key reproducible results of the paper (NASPipe: High Performance and Reproducible Pipeline Parallel Supernet Training via Causal Synchronous Parallelism): a causal parallel training execution framework. The artifact requires a host with at least 100GB CPU RAM and 4 Nvidia GPUs, and each GPU requires at least 11GB memory. The runtime environment is installed by docker with a few command lines. The experiments contain a throughput evaluation and reproducible training evaluation. The artifact provides one-click shell scripts to conduct the experiments.</p>

},
keywords = {Distributed Training, Neural Architecture Search, Pipeline training}
}

@software{10.5281/zenodo.5796083,
author = {Zhou, Keren and Hao, Yueming and Mellor-Crummey, John and Meng, Xiaozhu and Liu, Xu},
title = {Replication Package for Article: ValueExpert, Exploring Value Patterns in GPU-Accelerated Applications},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5796083},
abstract = {
    <p>Our artifact includes ValueExpert and benchmark code in this paper, along with instructions to use benchmarks to generate results for Figure 2, Figure 6, and Table 3 on NVIDIA A100 and RTX 2080 Ti GPUs. The speedup and overhead of each benchmark are averaged among 10 runs.</p>
<p>We provide a docker image with pre-installed prerequisites to simplify the experiment workflow. Users can also use a script to install all software from scratch.</p>

},
keywords = {GPU profilers, GPUs, Profiling Tools, Value Analysis, Value Patterns}
}

@software{10.5281/zenodo.5799180,
author = {Zhao, Zirui Neil and Ji, Houxiang and Morrison, Adam and Marinov, Darko and Torrellas, Josep},
title = {Pinned Loads: Taming Speculative Loads in Secure Processors},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5799180},
abstract = {
    <p>Our artifact provides a complete gem5 implementation of Pinned Loads, along with scripts to evaluate Pinned Loads’ performance on SPEC17, PARSEC, and SPLASH2X benchmark suites. We further provide access to a server with SPEC17 SimPoint checkpoints, PARSEC&amp;SPLASH2X checkpoints and disk images that allow a recreation of all the evaluation figures of the paper. Finally, we open sourced our implementation and scripts on GitHub.</p>

},
keywords = {Cache coherence protocol, Memory consistency, Processor design, Speculative execution defense}
}

@software{10.5281/zenodo.5802292,
author = {Cock, David and Ramdas, Abishek and Schwyn, Daniel and Giardino, Michael and Turowski, Adam and He, Zhenhao and Hossle, Nora and Korolija, Dario and Licciardello, Melissa and Martsenko, Kristina and Achermann, Reto and Alonso, Gustavo and Roscoe, Timothy},
title = {The Enzian Research Computer; Altium Design Sources},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5802292},
abstract = {
    <p>CAD design sources for the computer</p>

},
keywords = {cache coherence., FPGAs, heterogeneous systems}
}

@software{10.5281/zenodo.5826357,
author = {Yang, Boyuan and Chen, Ruirong and Huang, Kai and Yang, Jun and Gao, Wei},
title = {Replication package of paper: Eavesdropping User Credentials via GPU Side Channels on Smartphones},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5826357},
abstract = {
    <p>This repository contains artifacts of the paper Eavesdropping User Credentials via GPU Side Channels on Smartphones. It contains 1) the source codes of smartphone app and backend server program that are needed to launch the eavesdropping attack; 2）the mobile user apps that are listed as the victims of this attack; 3) the automated scripts that operate the attacking programs for replicating the experiment results reported in the paper.</p>

},
keywords = {Input Eavesdropping, Mobile GPU, Performance Counters, Side Channel, Smartphones}
}

@software{10.5281/zenodo.5830832,
author = {Miano, Sebastiano and Sanaee, Alireza and Risso, Fulvio and R\'{e}tv\'{a}ri, G\'{a}bor and Antichi, Gianni},
title = {Morpheus: Domain Specific Run Time Optimization for Software Data Planes - Artifact for ASPLOS'22},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5830832},
abstract = {
    <p>This is the artifact for the “Morpheus: Domain Specific Run Time Optimization for Software Data Planes” paper published at ASPLOS’22. This artifact contains the source code, the experimental workflow, and additional information to 1) compile and build Morpheus, 2) install the software dependencies and setup the testbed to run all the experiments, 3) the scripts that can be used to perform some of the experiments presented in the paper, and 4) the scripts to generate the plots based on the obtained results.</p>

},
keywords = {Data Plane Compilation, DPDK, eBPF, LLVM, XDP}
}

@software{10.5281/zenodo.5831327,
author = {Nikolaev, Ruslan and Nadeem, Hassan and Stone, Cathlyn and Ravindran, Binoy},
title = {Adelie: Continuous Address Space Layout Re-randomization for Linux Drivers - Artifact for ASPLOS'22},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5831327},
abstract = {
    <p>Artifact for ASPLOS’22 paper “Adelie: Continuous Address Space Layout Re-randomization for Linux Drivers”. The artifact contains source code, benchmark scripts, and preinstalled VM images that should be used with VirtualBox. The server VM image is in Adelie.zip, and the client (load generator) VM image is in Client.zip. Please see README.txt for more information. Please also see the licensing terms in LICENSE.</p>

},
keywords = {ASLR, PIC, ROP}
}

@software{10.5281/zenodo.5838527,
author = {Patel, Tirthak and Younis, Ed and Iancu, Costin and de Jong, Wibe and Tiwari, Devesh},
title = {QUEST (ASPLOS'22) Code and Data},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5838527},
abstract = {
    <p>This appendix describes the code and data artifacts related to QUEST. The artifacts are open-source at https://doi.org/10.5281/zenodo.5747894. They include the input files for the executed benchmarks, the code for partitioning, synthesis, dual annealing, and simulation, as well as a docker image set up with the code. Please see the following sections for more details, especially the Experiment Workflow section to read in detail about how the artifact directories and code files are organized.</p>

},
keywords = {Quantum Circuit Approximation, Quantum Circuit Synthesis, Quantum Computing}
}

@software{10.5281/zenodo.5842408,
author = {Mathur, Umang and Pavlogiannis, Andreas and Tun\c{c}, H\"{u}nkar Can and Viswanathan, Mahesh},
title = {Replication Package for Article: A Tree Clock Data Structure for Causal Orderings in Concurrent Executions},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5842408},
abstract = {
    <p>This artifact contains all the source codes and experimental data for replicating our evaluation in the paper. We implemented the analyses programs as part of the tool Rapid. The provided experimental data contains all the 153 trace logs used in our evaluation. In our artifact we also provide Python scripts that fully automate the process of replicating our evaluation.</p>

},
keywords = {concurrency, dynamic analyses, happens-before, vector clocks}
}

@software{10.5281/zenodo.5846419,
author = {Ahmad, Hammad and Huang, Yu and Weimer, Westley},
title = {CirFix: Automatically Repairing Defects in Hardware Design Code (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5846419},
abstract = {
    <p>We provide the public repository for CirFix, both on Zenodo and GitHub. The artifact includes instructions for installing and running CirFix, as well as scripts and instructions used to reproduce core results from our paper.</p>
<p>Please contact Hammad Ahmad (hammada@umich.edu) if you have any questions.</p>

},
keywords = {automated program repair, hardware bugs, hardware designs, HDL benchmark}
}

@software{10.5281/zenodo.5847956,
author = {Pandey, Shweta and Kamath, Aditya K and Basu, Arkaprava},
title = {Replication Package for Article: GPM: Leveraging Persistent Memory from a GPU},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5847956},
abstract = {
    <p>GPM is a system which allows a GPU to leverage Persistent Memory and enables writing highly performant recoverable GPU applications. The repository contains the source of our benchmark suite: GPMBench and a CUDA library: LibGPM. GPMBench comprises of 9 benchmarks categorized as transactional, native and checkpointing. LibGPM contains the source of our CUDA library which provides a user-friendly interface for GPU-accelerated recoverable applications. More details about the work can be found in our paper ASPLOS’22 paper: Leveraging Persistent Memory from a GPU. The artifact also allows a user to reproduce some of the key results published in the paper.</p>

},
keywords = {GPU, Persistent Memory}
}

@software{10.5281/zenodo.5848404,
author = {Bandara, Thilini Kaushalya and Wijerathne, Dhananjaya and Mitra, Tulika and Peh, Li-Shiuan},
title = {REVAMP: A Systematic Framework for Heterogeneous CGRA Realization},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5848404},
abstract = {
    <p>REVAMP artifact includes the complete framework comprising the heterogeneous architecture generator, heterogeneous CGRA mapper, parameterized RTL and scripts for power, area calculation. We elaborate on the REVAMP tool flow with an example of generating a pareto-optimal heterogeneous CGRA from a 4x4 homogeneous CGRA targeting five application kernels.</p>

},
keywords = {CGRA design space exploration, Coarse Grained Reconfigurable Arrays (CGRAs), Heterogeneous CGRAs}
}

@software{10.5281/zenodo.5848986,
author = {Theodoridis, Theodoros and Grosser, Tobias and Su, Zhendong},
title = {ASPLOS 2022 Artifact for "Understanding and Exploiting Optimal Function Inlining"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5848986},
abstract = {
    <p>The artifact contains the code and dataset we used for our experiments, as well as scripts to generate the numbers, figures, and tables of our evaluation. Specifically, it includes (a) the LLVM-IR files we used both for exhaustive search and autotuning (b) a modified LLVM that we use for exhaustive search and autotuning; (c) scripts to run exhaustive search and autotuning; (d) the expected outputs; (e) scripts to generate the tables and figures of our paper; (f) scripts to perform exhaustive search and autotuning only on smaller callgraphs and to validate the results against the provided ones. Everything is packaged and pre-built as a docker image. A standard X86 Linux machine running docker is necessary to evaluate this artifact.</p>

},
keywords = {autotuning, compiler optimization, optimal inlining, program size}
}

@software{10.5281/zenodo.5855030,
author = {Ma, Jiacheng and Zuo, Gefei and Loughlin, Kevin and Zhang, Haoyang and Quinn, Andrew and Kasikci, Baris},
title = {Replication Package for Paper: Debugging in the Brave New World of Reconfigurable Hardware},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5855030},
abstract = {
    <p>20 hardware bugs and the debugging tools mentioned in the paper “Debugging in the Brave New World of Reconfigurable Hardware”.</p>

},
keywords = {Bug Study, Debugging, FPGA, Reconfigurable Hardware}
}

@software{10.5281/zenodo.5856289,
author = {Erd\H{o}s, M\'{a}rton and Ainsworth, Sam and Jones, Timothy M.},
title = {Research data supporting "MineSweeper: a "clean sweep" for drop-in use-after-free prevention"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5856289},
abstract = {
    <p>This artifact contains our MineSweeper implementation, an allocator extension implemented on top of JeMalloc to mitigate use-after-free attacks, together with scripts to evaluate its running time and memory overheads on the SPEC CPU2006 benchmarks. The base implementation itself and a minimally modified JeMalloc memory allocator are fetched from their own repositories, compiled, and dynamically loaded in the SPEC config scripts. The dynamically linked libraries can be used to evaluate SPEC CPU2006 overheads using our scripts (benchmarks not included), or they can be loaded to protect a pre-compiled program from use-after-reallocate and double-free exploits.</p>

},
keywords = {programming language security, temporal safety, use-after-free}
}

@software{10.5281/zenodo.5863686,
author = {Asmussen, Nils and Haas, Sebastian and Weinhold, Carsten and Miemietz, Till and Roitzsch, Michael},
title = {ASPLOS'22 artifact for Efficient and Scalable Core Multiplexing with M³v},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5863686},
abstract = {
    <p>This is the artifact for the ASPLOS’22 paper “Efficient and Scalable Core Multiplexing with M³v”. The archive contains the source code of the software part, including the modified Linux kernel we compared M³v against, and all scripts to run the benchmarks. The archive also contains the FPGA bitfiles for the hardware platform.</p>

},
keywords = {communications management, operating systems, operating-systems security, process management, tiled architecture}
}

@software{10.5281/zenodo.5865606,
author = {Oleksenko, Oleksii and Fetzer, Christof and K\"{o}pf, Boris and Silberstein, Mark},
title = {Replication Package for Article: Revizor - Testing Black-Box CPUs against Speculation Contracts},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5865606},
abstract = {
    <p>The artifact includes the source code of Revizor, a set of scripts for reproducing the results, and a description of how to use them. They help to reproduce the contract violations described in the paper and validate the claimed fuzzing speed.</p>

},
keywords = {contracts, spectre, Speculation, testing}
}

@software{10.5281/zenodo.5870184,
author = {Theodoridis, Theodoros and Rigger, Manuel and Su, Zhendong},
title = {ASPLOS 2022 Artifact for "Finding Missed Optimizations through the Lens of Dead Code Elimination"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5870184},
abstract = {
    <p>The artifact contains the code and dataset we used for our experiments, as well as scripts to generate the numbers and tables of our evaluation. Specifically, it includes (a) the corpus of randomly generated programs that we used in Section 4’s evaluation; (b)scripts for generating a new corpus and validating the existing one; (c) our LLVM-based optimization marker instrumenter; (d) scripts for generating the missed optimization statistics presented in Section 4; (e) the full list of submitted bug reports with links to the respective compiler bug trackers; (f) end-to-end examples that led to bug reports. Everything is packaged and pre-built as a docker image. A standard X86 Linux machine running docker is necessary to evaluate this artifact.</p>

},
keywords = {compilers, missed optimizations, testing}
}

@software{10.5281/zenodo.5874548,
author = {Cheng, Xiang and Devecsery, David},
title = {Artifact for: Creating Concise and Efficient Dynamic Analyses with ALDA},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5874548},
abstract = {
    <p>This artifact description contains information about the complete workflow required to set up and reproduce experiments in ALDA. We describe how the software can be obtained and the build process as well as necessary preprocessing steps to generate the test program and baseline. All the programs and benchmarks are publicly available except for the SPEC 2006 benchmark. In addition, we provide a VM with all the programs and input data pre-pared and as well as instructions on how to build such a VM.</p>

},
keywords = {compiler optimization, domain specific language, dynamic analysis}
}

@software{10.5281/zenodo.5893373,
author = {Liu, Ziheng and Xia, Shihao and Liang, Yu and Song, Linhai and Hu, Hong},
title = {Replication Package for Article: Who Goes First? Detecting Go Concurrency Bugs via Message Reordering},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5893373},
abstract = {
    <p>The source code of GFuzz, an effective bug detector for Golang.</p>

},
keywords = {bug, concurrent, fuzzing, golang}
}

@software{10.5281/zenodo.5900766,
author = {Li, Zijun and Liu, Yushi and Guo, Linsong and Chen, Quan and Cheng, Jiagan and Zheng, Wenli and Guo, Minyi},
title = {Artifact for Article: FaaSFlow: Enable Efficient Workflow Execution for Function-as-a-Service},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5900766},
abstract = {
    <p>FaaSFlow is a serverless workflow engine that enables efficient workflow execution in 2 ways: a worker-side workflow schedule pattern to reduce scheduling overhead, and an adaptive storage library to use local memory to transfer data between functions on the same node.</p>

},
keywords = {FaaS, graph partition, master-worker, serverless workflows}
}

@software{10.5281/zenodo.5902507,
author = {Lefeuvre, Hugo and B\u{a}doiu, Vlad-Andrei and Jung, Alexander and Teodorescu, Stefan Lucian and Rauch, Sebastian and Huici, Felipe and Raiciu, Costin and Olivier, Pierre},
title = {FlexOS: Towards Flexible OS Isolation},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5902507},
abstract = {
    <p>This artifact contains the source code of FlexOS, the proof of-concept of our flexible isolation approach presented at ASPLOS’22 (“FlexOS: Towards Flexible OS Isolation”), along with all scripts necessary to reproduce the paper’s measurements and plots. The goal of this artifact is to allow readers to reproduce the paper’s results, and build new research on top of FlexOS.</p>
<p>Abstract of the paper:</p>
<p>At design time, modern operating systems are locked in a specific safety and isolation strategy that mixes one or more hardware/software protection mechanisms (e.g.&nbsp;user/kernel separation); revisiting these choices after deployment requires a major refactoring effort. This rigid approach shows its limits given the wide variety of modern applications’ safety/performance requirements, when new hardware isolation mechanisms are rolled out, or when existing ones break.</p>
<p>We present FlexOS, a novel OS allowing users to easily specialize the safety and isolation strategy of an OS at compilation/deployment time instead of design time. This modular LibOS is composed of fine-grained components that can be isolated via a range of hardware protection mechanisms with various data sharing strategies and additional software hardening. The OS ships with an exploration technique helping the user navigate the vast safety/performance design space it unlocks. We implement a prototype of the system and demonstrate, for several applications (Redis/Nginx/SQLite), FlexOS’ vast configuration space as well as the efficiency of the exploration technique: we evaluate 80 FlexOS configurations for Redis and show how that space can be probabilistically subset to the 5 safest ones under a given performance budget. We also show that, under equivalent configurations, FlexOS performs similarly or better than several baselines/competitors.</p>

},
keywords = {compartmentalization, isolation, operating system, operating system security}
}

@software{10.5281/zenodo.5942213,
author = {Saileshwar, Gururaj and Wang, Bolin and Qureshi, Moinuddin and Nair, Prashant J.},
title = {Randomized Row-Swap: Mitigating Row Hammer by Breaking Spatial Correlation between Aggressor and Victim Rows},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5942213},
abstract = {
    <p>This artifact presents the code and methodology to simulate Randomized Row-Swap (RRS), our defense against Rowhammer attacks. We provide the C code for the implementation of RRS which is encapsulated within the USIMM, a memory system simulator. The RRS structures and operations are implemented within the memory controller module in our artifact. We provide scripts to compile our simulator, and run the baseline and RRS. We also provide scripts to parse the results and collate the performance results.</p>

},
keywords = {DRAM, Fault-Injection Attacks, Memory System, Row Hammer}
}

@software{10.6084/m9.figshare.18480953.v3,
author = {Jangda, Abhinav and Huang, Jun and Liu, Guodong and Sabet, Amir Hossein Nodehi and Maleki, Saeed and Miao, Youshan and Musuvathi, Madanlal and Mytkowicz, Todd and Saarikivi, Olli},
title = {CoCoNet: Co-optimizing Computation and Communication for Distributed Neural Networks},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.18480953.v3},
abstract = {
    <p>CoCoNet is a domain specific language for expressing and optimizing distributed machine learning workloads. This artifact contains the CoCoNet implementation and our benchmark infrastructure.</p>

},
keywords = {CUDA, Distributed Machine Learning, MPI, NCCL}
}

@software{10.1145/3462307,
author = {Eichholz, Matthias and Campbell, Eric Hayden and Krebs, Matthias and Foster, Nate and Mezini, Mira},
title = {Software Artifact for Paper: Dependently-Typed Data Plane Programming},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462307},
abstract = {
    <p>This artifact contains the source code for the prototype implementation of the Pi4 type checker.</p>

},
keywords = {data plane programming, dependent types, P4, type checker}
}

@software{10.5281/zenodo.5703081,
author = {Padon, Oded and Wilcox, James R. and Koenig, Jason R. and McMillan, Kenneth L. and Aiken, Alex},
title = {Artifact for POPL 2022 Paper: Induction Duality: Primal-Dual Search for Invariants},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5703081},
abstract = {
    <p>The artifact is provided as a virtual machine, and includes input files (benchmarks) and results (log files) for all experiments reported in the paper. The VM also includes a version of mypyvy that matches the one used in the paper for the experiments of primal-dual Houdini and UPDR.</p>
<p>For more details, see induction-duality-popl-2022-artifact.txt.</p>

},
keywords = {counterexample-guided abstraction refinement, Houdini, IC3, induction duality, invariant inference, primal-dual Houdini, property directed reachability}
}

@software{10.1145/3506805,
author = {Kaiser, Magdalena and Roy, Rishiraj Saha and Weikum, Gerhard},
title = {Reinforcement Learning from Reformulations in Conversational Question Answering over Knowledge Graphs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3506805},
abstract = {
    <p>The rise of personal assistants has made conversational question answering (ConvQA) a very popular mechanism for user-system interaction. State-of-the-art methods for ConvQA over knowledge graphs (KGs) can only learn from crisp question-answer pairs found in popular benchmarks. In reality, however, such training data is hard to come by: users would rarely mark answers explicitly as correct or wrong. In this work, we take a step towards a more natural learning paradigm - from noisy and implicit feedback via question reformulations. A reformulation is likely to be triggered by an incorrect system response, whereas a new follow-up question could be a positive signal on the previous turn's answer. We present a reinforcement learning model, termed CONQUER, that can learn from a conversational stream of questions and reformulations. CONQUER models the answering process as multiple agents walking in parallel on the KG, where the walks are determined by actions sampled using a policy network. This policy network takes the question along with the conversational context as inputs and is trained via noisy rewards obtained from the reformulation likelihood. To evaluate CONQUER, we create and release ConvRef, a benchmark with about 11k natural conversations containing around 205k reformulations. Experiments show that CONQUER successfully learns to answer conversational questions from noisy reward signals, significantly improving over a state-of-the-art baseline.</p>
},
keywords = {Explanations, Influence functions, Recommendation Systems}
}

@software{10.1145/3506802,
author = {Draws, Tim Draws and Tintarev, Nava and Gadiraju, Ujwal and Bozzon, Alessandro and Timmermans, Benjamin},
title = {This Is Not What We Ordered: Exploring Why Biased Search Result Rankings Affect User Attitudes on Debated Topics},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3506802},
abstract = {
    In web search on debated topics, algorithmic and cognitive biases strongly influence how users consume and process information. Recent research has shown that this can lead to a search engine manipulation effect (SEME): when search result rankings are biased towards a particular viewpoint, users tend to adopt this favored viewpoint. To better understand the mechanisms underlying SEME, we present a pre-registered, 5 \texttimes{} 3 factorial user study investigating whether order effects (i.e., users adopting the viewpoint pertaining to higher-ranked documents) can cause SEME. For five different debated topics, we evaluated attitude change after exposing participants with mild pre-existing attitudes to search results that were overall viewpoint-balanced but reflected one of three levels of algorithmic ranking bias. We found that attitude change did not differ across levels of ranking bias and did not vary based on individual user differences. Our results thus suggest that order effects may not be an underlying mechanism of SEME. Exploratory analyses lend support to the presence of exposure effects (i.e., users adopting the majority viewpoint among the results they examine) as a contributing factor to users’ attitude change. We discuss how our findings can inform the design of user bias mitigation strategies.
},
keywords = {HCI design and evaluation methods, Human-centered computing, Information systems, User studies, Web searching and information discovery}
}

@software{10.1145/3506803,
author = {Ghosh, Avijit and Dutt, Ritam and Wilson, Christo},
title = {When Fair Ranking Meets Uncertain Inference},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3506803},
abstract = {
    <p>Existing fair ranking systems, especially those designed to be demographically fair, assume that accurate demographic information about individuals is available to the ranking algorithm. In practice, however, this assumption may not hold --- in real-world contexts like ranking job applicants or credit seekers, social and legal barriers may prevent algorithm operators from collecting peoples' demographic information. In these cases, algorithm operators may attempt to infer peoples' demographics and then supply these inferences as inputs to the ranking algorithm. <br> In this study, we investigate how uncertainty and errors in demographic inference impact the fairness offered by fair ranking algorithms. Using simulations and three case studies with real datasets, we show how demographic inferences drawn from real systems can lead to unfair rankings. Our results suggest that developers should not use inferred demographic data as input to fair ranking algorithms, unless the inferences are extremely accurate.</p>

},
keywords = {algorithmic fairness, demographic inference, ethical ai, noisy protected attributes, ranking algorithms, uncertainty}
}

@software{10.1145/3506804,
author = {Hiep Tran, Khanh and Ghazimatin, Azin and Roy, Rishiraj Saha},
title = {Counterfactual Explanations for Neural Recommenders},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3506804},
abstract = {
    <p>While neural recommenders have become the state-of-the-art in recent years, the complexity of deep models still makes the generation of tangible explanations for end users a challenging problem. Existing methods are usually based on attention distributions over a variety of features, which are still questionable regarding their suitability as explanations, and rather unwieldy to grasp for an end user. Counterfactual explanations based on a small set of the user's own actions have been shown to be an acceptable solution to the tangibility problem. However, current work on such counterfactuals cannot be readily applied to neural models. In this work, we propose ACCENT, the first general framework for finding counterfactual explanations for neural recommenders. It extends recently-proposed influence functions for identifying training points most relevant to a recommendation, from a single to a pair of items, while deducing a counterfactual set in an iterative process. We use ACCENT to generate counterfactual explanations for two popular neural models, Neural Collaborative Filtering (NCF) and Relational Collaborative Filtering (RCF), and demonstrate its feasibility on a sample of the popular MovieLens 100K dataset.</p>

},
keywords = {Explanations, Influence functions, Recommendation Systems}
}

@software{10.1145/3506572,
author = {Ca\~{n}amares, Roc\'{\i}o and Castells, Pablo},
title = {Should I Follow the Crowd?: A Probabilistic Analysis of the Effectiveness of Popularity in Recommender Systems},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3506572},
abstract = {
    <p>The use of IR methodology in the evaluation of recommender systems has become common practice in recent years. IR metrics have been found however to be strongly biased towards rewarding algorithms that recommend popular items "the same bias that state of the art recommendation algorithms display. Recent research has confirmed and measured such biases, and proposed methods to avoid them. The fundamental question remains open though whether popularity is really a bias we should avoid or not; whether it could be a useful and reliable signal in recommendation, or it may be unfairly rewarded by the experimental biases. We address this question at a formal level by identifying and modeling the conditions that can determine the answer, in terms of dependencies between key random variables, involving item rating, discovery and relevance. We find conditions that guarantee popularity to be effective or quite the opposite, and for the measured metric values to reflect a true effectiveness, or qualitatively deviate from it. We exemplify and confirm the theoretical findings with empirical results. We build a crowdsourced dataset devoid of the usual biases displayed by common publicly available data, in which we illustrate contradictions between the accuracy that would be measured in a common biased offline experimental setting, and the actual accuracy that can be measured with unbiased observations.</p>

},
keywords = {accuracy, bias, collaborative filtering, evaluation, non-random missing data, popularity, recommender systems}
}

@software{10.5281/zenodo.4836022,
author = {Ashkboos, Saleh and De Sensi, Daniele and Di Girolamo, Salvatore and Hoefler, Torsten and Li, Shigang},
title = {Implementation of the article "Flare: Flexible In-Network Allreduce"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4836022},
abstract = {
    <p></p><p>SC21 Artifact</p><p></p>
}
}

@software{10.5281/zenodo.4884852,
author = {Amvrosiadis, George and Cranor, Chuck and Ganger, Greg and Gibson, Garth and Grider, Gary and Settlemyer, Brad and Zheng, Qing},
title = {Implementation of the article "DeltaFS: A Scalable No-Ground-Truth Filesystem For Massively-Parallel Computing"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4884852},
abstract = {
    <p></p><p>First release.</p><p></p>
}
}

@software{10.5281/zenodo.4895203,
author = {Chard, Kyle and Foster, Ian and Huang, Lei and Huang, Qi and Pauloski, J. Gregory and Venkataraman, Shivaram and Zhang, Zhao},
title = {Implementation of the article "KAISA: An Adaptive Second-order Optimizer Framework for Deep Neural Networks"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4895203},
abstract = {
    <p>BERT for Distributed PyTorch + AMP Training</p>
}
}

@software{10.5281/zenodo.4899910,
author = {Ananthan, Shreyas and Li, Ruipeng and Mullowney, Paul and Mullowney, Paul and Rood, Jon and Sharma, Ashesh and Sprague, Michael and Thomas, Stephen and Willians, Alan},
title = {Implementation of the article "Preparing an Incompressible-Flow Fluid Dynamics Code for Exascale-Class Wind Energy Simulations"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4899910},
abstract = {
    <p></p><p>This release of Nalu-Wind can make use of an optimized Hypre GPU device assembly algorithm (<a href="https://doi.org/10.5281/zenodo.4899892">https://doi.org/10.5281/zenodo.4899892</a>).</p>
<p>Nalu-Wind can be built using the exawind-builder project (<a href="https://exawind.github.io/exawind-builder/">https://exawind.github.io/exawind-builder/</a>)</p>
<p>The following example, reg_tests/test_files/ablNeutralNGPHypreSegregated/ablNeutralNGPHypreSegregated.yaml, can be modified to use the optimized device assembly algorithm by setting:
  simple_hypre_matrix_assemble: yes
in the solver blocks</p><p></p>
}
}

@software{10.5281/zenodo.5003901,
author = {Ding, Xiaoning and Foster, Ian and Guo, Yanfei and Kurc, Tahsin and Shu, Tong and Wozniak, Justin},
title = {Implementation of the article "Bootstrapping In-situ Workflow Auto-Tuning via Combining Performance Models of Component Applications full strip note"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5003901},
abstract = {
    <p></p><p>This is the first release.</p><p></p>
}
}

@software{10.5281/zenodo.5116412,
author = {Hu, Qinghao and Sun, Peng and Wen, Yonggang and Yan, Shengen and Zhang, Tianwei},
title = {Implementation of the article "Characterization and Prediction of Deep Learning Workloads in Large-Scale GPU Datacenters"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5116412},
abstract = {
    <p></p><p>HeliosArtifact</p><p></p>
}
}

@software{10.5281/zenodo.5136675,
author = {Chen, Zhaodong and Ding, Yufei and Liu, Liu and Qu, Zheng and Xie, Yuan},
title = {Implementation of the article "Efficient Tensor Core-based GPU Kernels for Structured Sparsity under Reduced Precision"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5136675},
abstract = {
    <p></p><p>This is the artifact of our paper "Efficient Tensor Core-Based GPU Kernels for Structured Sparsity under Reduced Precision" accepted in SC21</p><p></p>
}
}

@software{10.5281/zenodo.5144378,
author = {Ding, Yufei and Feng, Boyuan and Feng, Boyuan and Geng, Tong and Li, Ang and WANG, YUKE},
title = {Implementation of the article "APNN-TC: Accelerating Arbitrary Precision Neural Networks on Ampere GPU Tensor Cores"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5144378},
abstract = {
    <p></p><p>This is the source code for the SC'21 paper:&nbsp;<strong>APNN-TC: Accelerating Arbitrary Precision Neural Networks on Ampere GPU Tensor Cores</strong></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p><p></p>
}
}

@software{10.5281/zenodo.5144438,
author = {Aluru, Srinivas and Aluru, Maneesha R. and Chockalingam, Sriram P. and Srivastava, Ankit},
title = {Implementation of the article "Parallel Construction of Module Networks"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5144438},
abstract = {
    <p></p><p>This release adds more details on reproducing the results in the publication.</p><p></p>
}
}

@software{10.5281/zenodo.5144709,
author = {Li, Kenli and Lin, Shengle and Tsai, Qinyun and Wang, Haotian and Yang, Wangdong},
title = {Implementation of the article "STM-Multifrontal QR: Streaming Task Mapping Multifrontal QR Factorization Empowered by GCN"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5144709},
abstract = {
    <p></p><p>This is the first release version of Streaming Task Map Multifrontal QR Factorization Empowered by GCN.</p><p></p>
}
}

@software{10.5281/zenodo.5144874,
author = {Fahringer, Thomas and Knorr, Fabian and Thoman, Peter},
title = {Implementation of the article "ndzip-gpu: Efficient Lossless Compression of Scientific Floating-Point Data on GPUs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5144874},
abstract = {
    <p></p><p>As accepted by the SC'21 artifact evaluation committee.</p><p></p>
}
}

@software{10.5281/zenodo.5147573,
author = {Churavy, Valentin and Doerfert, Johannes and H\"{u}ckelheim, Jan and Moses, William S. and Narayanan, Sri Hari Krishna and Paehler, Ludger and Schanen, Michel},
title = {Implementation of the article "Reverse-Mode Automatic Differentiation and Optimization of GPU Kernels via Enzyme full strip note"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5147573},
abstract = {
    <p>This repo contains the benchmarks for Enzyme on GPU's</p>
}
}

@software{10.5281/zenodo.5148715,
author = {Kung, H. T. and Natesh, Vikas and Sabot, Andrew},
title = {Implementation of the article "CAKE: Matrix Multiplication Using Constant-Bandwidth Blocks"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5148715},
abstract = {
    <p></p><p>First release for Zenodo archiving</p><p></p>
}
}

@software{10.5281/zenodo.5148797,
author = {Alabandi, Ghadeer and Burtscher, Martin and Rusnak, Lucas and Te\v{s}i\'{c}, Jelena},
title = {Implementation of the article "Discovering and Balancing Fundamental Cycles in Large Signed Graphs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5148797},
abstract = {
    <p></p><p>First release for reviewers.</p><p></p>
}
}

@software{10.5281/zenodo.5148930,
author = {Allen, Tyler and Ge, Rong},
title = {Implementation of the article "In-Depth Analyses of Unified Virtual Memory System for GPU Accelerated Computing"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5148930},
abstract = {
    <p></p><p>Artifact appendix item for SC2021.</p><p></p>
}
}

@software{10.5281/zenodo.5151491,
author = {Cao, Hang and Li, Kun and Lu, Pengqi and Yuan, Liang and Yue, Yue and Zhang, Yunquan},
title = {Implementation of the article "Temporal Vectorization for Stencils"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5151491},
abstract = {
    <p></p><p>first release</p><p></p>
}
}

@software{10.5281/zenodo.5152741,
author = {Manzano, Joseph and Ranganath, Kiran and Song, Shuaiwen Leon and Suetterlein, Joshua and Wong, Daniel},
title = {Implementation of the article "MAPA: Multi-Accelerator Pattern Allocation Policy for Multi-Tenant GPU Servers"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5152741},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.5154114,
author = {Halappanavar, Mahantesh and Khan, Arif and Serra, Edoardo and Rajam, Aravind Sukumaran and Xiang, Lizhi},
title = {Implementation of the article "cuTS: Scaling Subgraph Isomorphism on Distributed Multi-GPU Systems Using Trie Based Data Structure"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5154114},
abstract = {
    <p></p><p>This repository contains the code for the "cuTS: Scaling Subgraph Isomorphism on Distributed Multi-GPU Systems Using Trie Based Data Structure" framework. The cuTS framework is an efficient subgraph isomorphism solver for GPUs.</p><p></p>
}
}

@software{10.5281/zenodo.5155509,
author = {Ben-Nun, Tal and Calotoiu, Alexandru and De Matteis, Tiziano and Hoefler, Torsten and Lavarini, Luca and Schneider, Timo and Ziogas, Alexandos Nikolaos and de Fine Licht, Johannes},
title = {Implementation of the article "Productivity, Portability, Performance: Data-Centric Python"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5155509},
abstract = {
    <p></p><p>Artifact of SC'21 Paper "Productivity, Portability, Performance: Data-Centric Python".</p>

<p>The artifact can also be cloned from&nbsp;<a href="https://spclgitlab.ethz.ch/tim0s/ddace-lite-sc21">https://spclgitlab.ethz.ch/tim0s/ddace-lite-sc21</a></p><p></p>
}
}

@software{10.5281/zenodo.5155769,
author = {He, Ligang and He, Bingsheng and Jin, Hai and Liao, Xiaofei and Liu, Haikun and Zhang, Yu and Zhao, Jin},
title = {Implementation of the article "LCCG: A Locality-Centric Hardware Accelerator for High Throughput of Concurrent Graph Processing"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5155769},
abstract = {
    <p></p><p>This paper presents a locality-centric programmable accelerator LCCG, which can fundamentally address the challenge of the irregular accesses of the CGP jobs so as to achieve higher throughput for the execution of these jobs. By regularizing the graph traversals of the CGP jobs and fully consolidating the storage and accesses of the graph data, LCCG can minimize the data access cost for the execution of the CGP jobs and also achieve higher utilization of the cores. On a simulated 64-core processor, the experimental results show that LCCG improves the throughput of the state-of-the-<br>
art software system by up to 23.9 times with only 0.5\% extra area cost. In the future, we will research how to integrate some existing hardware techniques into LCCG to get better performance, and also research how to avoid the leaking of some private information of the jobs for the LCCG.</p><p></p>
}
}

@software{10.5281/zenodo.5156431,
author = {Hsu, Kuan-Chieh and Tseng, Hung-Wei},
title = {Implementation of the article "Accelerating Applications using Edge Tensor Processing Units"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5156431},
abstract = {
    <p></p><p>Alpha version of GPETPU Release</p><p></p>
}
}

@software{10.5281/zenodo.5156596,
author = {He, Yuxiong and Rajbhandari, Samyam and Rasley, Jeff and Ruwase, Olatunji and Smith, Shaden},
title = {Implementation of the article "ZeRO-Infinity: Breaking the GPU Memory Wall for Extreme Scale Deep Learning"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5156596},
abstract = {
    <p></p><p>DeepSpeed is a deep learning optimization library that makes distributed training easy, efficient, and effective. This repo contains the code used in the paper <a href="https://arxiv.org/abs/2104.07857">[2104.07857] ZeRO-Infinity: Breaking the GPU Memory Wall for Extreme Scale Deep Learning (arxiv.org)</a>.</p><p></p>
}
}

@software{10.5281/zenodo.5159333,
title = {Implementation of the article "3D Acoustic-Elastic Coupling with Gravity: The Dynamics of the 2018 Palu, Sulawesi Earthquake and Tsunami"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5159333},
abstract = {
    <p></p><p>This repository contains the supplementary files for our SC21 submission: "3D Acoustic-Elastic Coupling with Gravity: The Dynamics of the 2018 Palu, Sulawesi Earthquake and Tsunami".</p>

<p>It contains the input data for all simulations. For more details, please refer to the included README.md files.</p>

<p>&nbsp;</p>

<p>The directory "seissol-sc21-revision-source-code" contains the version of SeisSol that we used.</p>

<p>&nbsp;</p><p></p>
}
}

@software{10.5281/zenodo.5162688,
title = {Implementation of the article "Hardware-supported Remote Persistence for Distributed Persistent Memory"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5162688},
abstract = {
    <p></p><p>No description provided.</p><p></p>
}
}

@software{10.5281/zenodo.5163624,
author = {Brinkmann, Andr\'{e} and Cortes, Toni and Klopp, David and Moti, Nafiseh and R\"{u}ckert, Ulrich and Salkhordeh, Reza and Schimmelpfennig, Frederic},
title = {Implementation of the article "Simurgh: A Fully Decentralized and Secure NVMM User Space File System"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5163624},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.5163851,
author = {Ali-Eldin, Ahmed and Shenoy, Prashant and Wang, Bin},
title = {Implementation of the article "The Hidden cost of the Edge: A Performance Comparison ofEdge and Cloud Latencies"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5163851},
abstract = {
    <p></p><p>This is the image dataset used in our paper The Hidden Cost of the Edge: A Performance Comparison of Edge and Cloud Latencies (to appear in SC21). In our experiments it's used as the workload of a deep neural network (DNN) image classification application.</p><p></p>
}
}

@software{10.5281/zenodo.5164404,
author = {Aiken, Alex and Bauer, Michael and Lee, Wonchan and McCormick, Patrick S. and Papadakis, Manolis and Slaughter, Elliott and Soi, Rupanshu and Treichler, Sean},
title = {Implementation of the article "Index Launches: Scalable, Flexible Representation of Parallel Task Groups"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5164404},
abstract = {
    <p></p><p>This is the software artifact for "Index Launches: Scalable, Flexible Representation of Parallel Task Groups", published in SC'21. A copy of this artifact is also archived under the tag <a href="https://github.com/StanfordLegion/legion/blob/papers/index-launch-sc21/language/sc21_scripts/README.md">papers/index-launch-sc21</a> in the original GitHub repository.</p>

<p>To use this software artifact, unpack it and refer to the instructions under language/sc21_scripts/README.md.</p><p></p>
}
}

@software{10.5281/zenodo.5165333,
author = {Awan, Muaaz Gul and Buluc, Aydin and Deslippe, Jack and Ding, Nan and Egan, Rob and Hofmeyr, Steven and Oliker, Leonid and Yelick, Katherine},
title = {Implementation of the article "Accelerating large scale de novo metagenome assembly using GPUs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5165333},
abstract = {
    <p></p><p>We used the version of MetaHipMer2 available at: <a href="https://bitbucket.org/berkeleylab/mhm2/src/master/">https://bitbucket.org/berkeleylab/mhm2/src/master/</a> and integrated our GPU local assembly module in it. This release contains the GPU accelerated version of MetaHipMer2 that has been discussed and presented in the SC21 submission. If you are looking to reproduce the results as shown in the SC21 submission please use this repo and if you are a user looking to use the most recent and stable release of MetaHipMer2 please go to the link mentioned above.</p><p></p>
}
}

@software{10.5281/zenodo.5165762,
author = {Chen, Hongzheng and Shen, Minghua},
title = {Implementation of the article "Krill: A Compiler and Runtime System for Concurrent Graph Processing"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5165762},
abstract = {
    <p></p><p>Krill is an efficient graph system for processing concurrent graph jobs, which consists of a high-level compiler and a runtime system. Property buffer and its compiler are provided to easily manage the property data. The runtime system is equipped with graph kernel fusion that greatly reduces the number of memory accesses.</p><p></p>
}
}

@software{10.5281/zenodo.5167006,
author = {Uezato, Yuya},
title = {Implementation of the article "Accelerating XOR-based Erasure Coding using Program Optimization Techniques"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5167006},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.5167629,
author = {Bhalachandra, Sridutt and Gupta, Akshat and Kumar, Vivek and Kumar, Sunil},
title = {Implementation of the article "Cuttlefish: Library for Achieving Energy Efficiency in Multicore Parallel Programs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5167629},
abstract = {
    <p></p><p>This artifact is the software implementation of the paper titled "Cuttlefish: Library for Achieving Energy Efficiency in Multicore Parallel Programs" published at the SC '21 conference. Cuttlefish is a programming model oblivious C/C++ library for achieving energy efficiency in multicore parallel programs running over Intel processors. An online profiler periodically profiles model-specific registers to discover a running application’s memory access pattern. Using a combination of DVFS and UFS, Cuttlefish then dynamically adapts the processor’s core and uncore frequencies, thereby improving its energy efficiency.</p><p></p>
}
}

@software{10.5281/zenodo.5167980,
author = {Diffenderfer, James D. and Georgakoudis, Giorgis and Laguna, Ignacio and Menon, Harshitha and Osei-Kuffuor, Daniel and Parasyris, Konstantinos and Schordan, Markus},
title = {Implementation of the article "HPAC: Evaluating Approximate Computing Techniques on HPC OpenMP Applications."},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5167980},
abstract = {
    <p></p><p>This is a baseline implementation of the approximate programming model called HPAC. HPAC extends Clang/LLVM. HPAC supports two approximation techniques perforation and memoization. Perforation supports subclasses of the technique that define the pattern of the perforated loops. Memoization supports two sub-classes of approximate memoization, namely input (iACT), and output (TAF) memorization. Each sub-class can be further parameterized to fine-tune the behavior of the technique. Finally, the release contains a set of scripts that facilitate exploration of the approximation design space and identify opportunities for approximations.</p><p></p>
}
}

@software{10.5281/zenodo.5168027,
author = {Ben-Nun, Tal and Besta, Maciej and Gaillard, Andr\'{e} and Hoefler, Torsten and Kabic, Marko and Kozhevnikov, Anton and Kwasniewski, Grzegorz and Saethre, Jens Eirik and Schneider, Timo and VandeVondele, Joost and Ziogas, Alexandos Nikolaos},
title = {Implementation of the article "On the Parallel I/O Optimality of Linear Algebra Kernels: Near-Optimal Matrix Factorizations"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5168027},
abstract = {
    <p></p><p>The first release of the library for distributed, communication-optimal LU and Cholesky factorization algorithms, with the appendix and the results from the paper.</p><p></p>
}
}

@software{10.5281/zenodo.5168471,
author = {Huang, Jian and Snir, Marc and Sun, Jinghan},
title = {Implementation of the article "Pinpointing Crash-Consistency Bugs in the HPC I/O Stack: A Cross-Layer Approach"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5168471},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.5168853,
author = {Byna, Suren and Chen, Yong and Lee, Sangkeun and Sim, Hyogi and Sim, Hyogi and Vazhkudai, Sudharshan S. and Vazhkudai, Sudharshan and Zhang, Wei},
title = {Implementation of the article "Exploiting User Activeness for Data Retention in HPC Systems"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5168853},
abstract = {
    <p></p><p>Updated description on the relevant scripts in <code>bin</code> directory.</p>
<p>Also remove some irrelevant internal files from <code>bin</code>.</p><p></p>
}
}

@software{10.5281/zenodo.5171429,
author = {Enright Jerger, Natalie and Gratz, Paul and Krishna, Tushar and Parasar, Mayank and San Miguel, Joshua},
title = {Implementation of the article "SEEC: Stochastic Escape Express Channel"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5171429},
abstract = {
    <p>artifacteval eval repo for sc2021</p>
}
}

@software{10.5281/zenodo.5176097,
author = {Chen, Quan and Cui, Weihao and Guo, Minyi and Leng, Jingwen and Li, Chao and Zhao, Han and Zhao, Jieru and Zheng, Ningxin},
title = {Implementation of the article "Enable Simultaneous DNN Services Based on Deterministic Operator Overlap and Precise Latency Prediction"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5176097},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.5181820,
author = {Bernauer, Julie and Casper, Jared and Catanzaro, Bryan and Kashinkunti, Prethvi and Korthikanti, Vijay Anand and LeGresley, Patrick and Narayanan, Deepak and Patwary, Mostofa and Phanishayee, Amar and Shoeybi, Mohammad and Vainbrand, Dmitri and Zaharia, Matei},
title = {Implementation of the article "Efficient Large-Scale Language Model Training on GPU Clusters"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5181820},
abstract = {
    <p>Ongoing research training transformer language models at scale, including: BERT \&amp; GPT-2</p>
}
}

@software{10.5281/zenodo.5203181,
author = {Chen, Dexun and Cui, Lizhen and Duan, Xiaohui and Fu, Haohuan and Gao, Ping and Guo, Jiaxu and Li, Guohui and Liu, Weiguo and Liu, Xin and Ma, Ming and Meng, Xiangxu and Song, Zhenya and Wang, Jin and Xue, Wei and Yang, Guangwen and Zhang, Wusheng},
title = {Implementation of the article "LMFF: Efficient and Scalable Layered Materials Force Field on Heterogeneous Many-Core Processors"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5203181},
abstract = {
    <p></p><p>LAMMPS is one of the most popular Molecular Dynamic (MD) packages and is widely used in the field of physics, chemistry and materials simulation. Layered Materials Force Field (LMFF) is our expansion of the LAMMPS potential function based on the Tersoff potential and inter-layer potential (ILP) in LAMMPS. LMFF is designed to study layered materials such as graphene and boron hexanitride. It is universal and does not depend on any platform.</p><p></p>
}
}

@software{10.5281/zenodo.5204819,
author = {Arumugam, Kamesh and Paterno, Marc and Ranjan, Desh and Sakiotis, Ioannis and Sakiotis, Ioannis and Terzic, Balsa and Zubair, Mohammad},
title = {Implementation of the article "PAGANI: A Parallel Adaptive GPU Algorithm for Numerical Integration full strip note"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5204819},
abstract = {
    <p></p><p>This markdown file provides links to artifacts associated with the PAGANI integrator.</p><p></p>
}
}

@software{10.5281/zenodo.5206960,
author = {Krishnamoorthy, Sriram and Li, Ang},
title = {Implementation of the article "SV-Sim: Scalable PGAS-based State Vector Simulation of Quantum Circuits"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5206960},
abstract = {
    <p></p><p>This is a release for DOI generation for SC-21 publication.</p><p></p>
}
}

@software{10.5281/zenodo.5236852,
author = {Brandt, Jim and Costa, Emily and Patel, Tirthak and Schwaller, Benjamin and Tiwari, Devesh},
title = {Implementation of the article "Systematically Inferring I/O Performance Variability by Examining Repetitive Job Behavior"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5236852},
abstract = {
    <p></p><p>Fixed an input parameter error</p><p></p>
}
}

@software{10.5281/zenodo.5262865,
author = {Roy, Rohan Basu and Gadepally, Vijay and Gettings, Karen and Li, Baolin and Patel, Tirthak and Tiwari, Devesh},
title = {Implementation of the article "Ribbon: Cost-Effective and QoS-Aware Deep Learning Model Inference using a Diverse Pool of Cloud Computing Instances"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5262865},
abstract = {
    <p></p><p>Renamed SIMBO to Ribbon</p><p></p>
}
}

@software{10.5281/zenodo.5513082,
author = {Bian, Zhengda and Bian, Zhengda and Li, Shenggui and Wang, Wei and You, Yang},
title = {Implementation of the article "Online Evolutionary Batch Size Orchestration for Scheduling Deep Learning Workloads in GPU Clusters"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5513082},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.6084/m9.figshare.14396099,
author = {Canon, Richard Shane and Priedhorsky, Reid and Randles, Timothy and Younge, Andrew},
title = {Implementation of the article "Minimizing privilege for building HPC containers"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.14396099},
abstract = {
    <p></p>
}
}

@software{10.1145/3476481,
author = {Guo, Shengjian and Li, Guanpeng and Rahman, Md Hasanur and Shamji, Aabid},
title = {Implementation of the article "PEPPA-X: finding program test inputs to bound silent data corruption vulnerability in HPC applications"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3476481},
abstract = {
    <p>Peppa-X can efficiently finds a test input that can
              estimate the bound of program SDC(silent data corruption) resiliency. Generally with
              strawman method it takes days even month to find the input
              that provides the highest SDC probablilty with manually doing fault injection to every single input
              and check their SDC probabilty. But Peppa-X leverages genetic algorithm, along with our dynamic
              analysis technique described in the paper to guide the search towards the input which exercises the
              relatively much higher SDC probability among all other inputs. That means it can find the input that
              exercises the most vulnerable part of the program.</p>
}
}

@software{10.1145/3476482,
author = {Adelman, Menachem and Anderson, Cristina and Avancha, Sasikanth and Breuer, Alexander and Bruestle, Jeremy and Chaudhary, Narendra and Georganas, Evangelos and Heinecke, Alexander and Kalamkar, Dhiraj D. and Kundu, Abhisek and Kutnick, Denise and Laub, Frank and Md, Vasimuddin and Misra, Sanchit and Mohanty, Ramanarayan and Mohanty, Ramanarayan and Pabst, Hans and Ziv, Barukh},
title = {Implementation of the article "Tensor processing primitives: a programming abstraction for efficiency and portability in deep learning workloads"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3476482},
abstract = {
    <p>LIBXSMM is a library for specialized dense and sparse matrix operations as well as for deep learning primitives such as small convolutions. The library is targeting Intel Architecture with <span>Intel&nbsp;SSE</span>, <span>Intel&nbsp;AVX</span>, <span>Intel&nbsp;AVX2</span>, <span>Intel&nbsp;AVX‑512</span> (with VNNI and Bfloat16), and <span>Intel&nbsp;AMX</span> (Advanced Matrix Extensions) supported by future Intel processor code-named Sapphire Rapids. Code generation is mainly based on <span>Just‑In‑Time (JIT)</span> code specialization for compiler-independent performance (matrix multiplications, matrix transpose/copy, sparse functionality, and deep learning). LIBXSMM is suitable for "build once and deploy everywhere", i.e., no special target flags are needed to exploit the available performance. Supported GEMM datatypes are: `FP64`, `FP32`, `bfloat16`, `int16`, and `int8`.</p>
}
}

@software{10.1145/3476483,
author = {Ahmed, Nesreen and Avancha, Sasikanth and Georganas, Evangelos and Heinecke, Alexander and Kalamkar, Dhiraj D. and Ma, Guixiang and Md, Vasimuddin and Misra, Sanchit and Mohanty, Ramanarayan},
title = {Implementation of the article "DistGNN: scalable distributed training for large-scale graph neural networks"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3476483},
abstract = {
    <p>DGL is an easy-to-use, high performance and scalable Python package for deep learning on graphs. DGL is framework agnostic, meaning if a deep graph model is a component of an end-to-end application, the rest of the logics can be implemented in any major frameworks, such as PyTorch, Apache MXNet or TensorFlow.</p>
}
}

@software{10.1145/3476480,
author = {Frachtenberg, Eitan and Kaner, Rhody},
title = {Implementation of the article "Representation of Women in High-Performance Computing Conferences"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3476480},
abstract = {
    <p>These files represent all the raw and processed data, as well as the code to process it, to analyze some of the top systems conferences during 2017. Each subdirectory holds its own README.md file to describe the files in it.</p>
}
}

@software{10.1145/3476484,
author = {Ding, Caiwen and Gaihre, Anil and Li, Lingda and Li, Sherry and Liu, Hang and Song, Shuaiwen Leon and Weitze, Scott and Zheng, Da},
title = {Implementation of the article "Dr. Top-k: delegate-centric Top-k on GPUs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3476484},
abstract = {

}
}

@software{10.1145/3476485,
author = {Arafa, Yehia and Arafa, Yehia and Badawy, Abdel-Hameed A. and Barai, Atanu and Chennupati, Gopinath and ELWazir, Ammar Mohamed Amin Ahmed and Eidenbenz, Stephan and Eker, Ali and Santhi, Nandakishore},
title = {Implementation of the article "Hybrid, scalable, trace-driven performance modeling of GPGPUs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3476485},
abstract = {
    <p>PPT-GPU is a scalable and flexible framework to predict the performance of GPUs running general purpose workloads. PPT-GPU can use the virtual (PTX) or the native (SASS) ISAs without sacrificing accuracy, ease of use, or portability. The tool is currently focused on NVIDIA GPUs. We plan to extend our approach to model other vendors' GPUs such as AMD and Intel.</p>
}
}

@software{10.5281/zenodo.5090141,
author = {Dura, Alexandru and Reichenbach, Christoph and S\"{o}derberg, Emma},
title = {Replication Package for Article: 'JavaDL: Automatically Incrementalizing Java Bug Pattern Detection'},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5090141},
abstract = {
    <p>The artifact contains the implementation of the JavaDL language and the evaluation setup that reproduces the claims regarding: - the precision of the JavaDL analyses relative to state-of-the-practice tools; - the performance comparison between JavaDL and state-of-the-practice tools.</p>

},
keywords = {Datalog, Software Bugs, Static Analysis Frameworks, Syntactic Patterns}
}

@software{10.5281/zenodo.5091711,
author = {Roth, Ori},
title = {Treetop: A Context-Free Fluent API Generator for C#},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5091711},
abstract = {
    <p>Treetop is a proof-of-concept C# fluent API generator for context-free protocols. Treetop accepts a context-free grammar, specifying an API protocol or a domain-specific language, and embeds it in C# as a fluent API. The resulting API enforces the grammar at compile-time: A fluent API chain may compile if and only if it encodes a word derived from the grammar.</p>

},
keywords = {context-free grammars, domain-specific languages, fluent API, nominal subtyping with variance}
}

@software{10.5281/zenodo.5093839,
author = {Herklotz, Yann and Pollard, James D. and Ramanathan, Nadesh and Wickerson, John},
title = {Vericert},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5093839},
abstract = {
    <p>A formally verified high-level synthesis (HLS) tool written in Coq, building on top of CompCert. The implementation and proofs are described in the paper “Formal Verification of High-Level Synthesis”.</p>

},
keywords = {C, CompCert, Coq, high-level synthesis, Verilog}
}

@software{10.5281/zenodo.5130646,
author = {Zhou, Zhe and Dickerson, Robert and Delaware, Benjamin and Jagannathan, Suresh},
title = {OOPSLA2021 Artifact: Data-Driven Abductive Inference of Library Specifications},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5130646},
abstract = {
    <p>OOPSLA2021 Artifact: Data-Driven Abductive Inference of Library Specifications</p>

},
keywords = {data-driven inference, oopsla, specifications, verification}
}

@software{10.5281/zenodo.5139390,
author = {Park, Jiwon and Winterer, Dominik and Zhang, Chengyu and Su, Zhendong},
title = {OOPSLA 2021 Artifact for "Generative Type-Aware Mutation for Testing SMT Solvers"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5139390},
abstract = {
    <p>Software artifact for the paper Generative Type-Aware Mutation for Testing SMT Solvers, in a VirtualBox image. The artifact is realized as a single VirtualBox image of three main components: (1) yinyang, the tool which we created and extended, and in which we integrated TypeFuzz. TypeFuzz realizes generative type-aware mutation to find all reported bugs in the paper, (2) A database with statistics on the bugs and Coverage data.</p>

},
keywords = {SMT solving
Fuzzing
Formal methods}
}

@software{10.5281/zenodo.5141479,
author = {Phipps-Costin, Luna and Anderson, Carolyn Jane and Greenberg, Michael and Guha, Arjun},
title = {TypeWhich},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5141479},
abstract = {
    <p>See Zenodo for a description of the artifact.</p>

},
keywords = {typed, untyped}
}

@software{10.5281/zenodo.5394235,
author = {Goel, Aviral and Je\v{c}men, Jan and Krynski, Sebasti\'{a}n and Fl\"{u}ckiger, Olivier and Vitek, Jan},
title = {Replication Package for Article: "Promises Are Made to Be Broken: Migrating R to Strict Semantics"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5394235},
abstract = {
    <p>The artifact is a ZIP file containing code that analyzes R packages to migrate them from lazy to strict semantics. Details can be found in the README.pdf file accompanying the artifact.</p>

},
keywords = {Code Migration, Corpus Analysis, Delayed Or Lazy Evaluation, Empirical Study, R Language}
}

@software{10.5281/zenodo.5400508,
author = {Malewski, Stefan and Greenberg, Michael and Tanter, \'{E}ric},
title = {Gradually Structured Data: Typechecker and Interpreter},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5400508},
abstract = {
    <p>GSD is an interpreter for a gradually typed language with Gradually Structured Data.</p>
<p>It’s main features are the following: - It can typecheck and evaluate programs with different levels of datatype definitions. From no definitions at all (for dynamic programs) to fully defined static programs, and the levels in between those two extremes. - It works with three different matching strategies: sound, exact and complete.</p>

},
keywords = {algebraic datatypes, gradual typing, semi-structured data}
}

@software{10.5281/zenodo.5411667,
author = {Chaliasos, Stefanos and Sotiropoulos, Thodoris and Drosos, Georgios-Petros and Mitropoulos, Charalambos and Mitropoulos, Dimitris and Spinellis, Diomidis},
title = {Replication Package for Article: "Well-Typed Programs Can Go Wrong: A Study of Typing-Related Bugs in JVM Compilers"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5411667},
abstract = {
    <p>The purpose of this artifact is (1) to reproduce the results presented in the OOPSLA 2021 paper titled “Well-Typed Programs Can Go Wrong: A Study of Typing-Related Bugs in JVM Compilers”, and (2) to document the dataset and the proposed categorization in order to facilitate further research. Specifically, the artifact has the following structure:</p>
<ul>
<li><p><code>scripts/</code>: This is the directory that contains the scripts needed to reproduce the results, the figures, and the tables presented in the paper.</p></li>
<li><p><code>scripts/fetch/</code>: This is the directory that contains the scripts needed to construct the dataset of typing-related bugs as described in Section 2.1 of the main paper.</p></li>
<li><p><code>data/</code>: This is the “pre-baked” dataset of the 320 typing-related bugs under study.</p></li>
</ul>

},
keywords = {bug, compiler, Groovy, Java, Kotlin, Scala, static typing, study, testing}
}

@software{10.5281/zenodo.5415230,
author = {Goel, Aviral and Donat-Bouillud, Pierre and K\v{r}ikava, Filip and Kirsch, Christoph M. and Vitek, Jan},
title = {Replication Package for Article: "What We Eval in the Shadows: A Large-Scale Study of Eval in R Programs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5415230},
abstract = {
    <p>The artifact is a ZIP file containing code that performs dynamic analysis of R programs to study the use of eval. The insights yielded by this analysis are reported in the OOPSLA’21 paper - What We Eval in the Shadows: A Large-Scale Study of Eval in R Programs. The details can be found in the README.pdf file accompanying the artifact.</p>

},
keywords = {Dynamic Analysis, Empirical Studies, Eval, R, Scripting Languages}
}

@software{10.5281/zenodo.5415274,
author = {Br\"{a}m, Christian and Eilers, Marco and M\"{u}ller, Peter and Sierra, Robin and Summers, Alexander J.},
title = {Artifact of the paper "Rich Specifications for Ethereum Smart Contract Verification"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5415274},
abstract = {
    <p>This is the artifact accompanying the OOPSLA 2021 paper “Rich Specifications for Ethereum Smart Contract Verification”.</p>
<p>The artifact comes in the form of a VirtualBox VM image (2vyper-artifact.ova) and contains the paper’s implementation in the tool 2vyper as well as the benchmarks used in the evaluation. Instructions for running the VM image and using the artifact can be found in the README.</p>

},
keywords = {Ethereum, resources, smart contracts, software verification, specification}
}

@software{10.5281/zenodo.5421762,
author = {Ishimwe, Didier and Nguyen, KimHao and Nguyen, ThanhVu},
title = {Software Artifact for the OOPSLA'21 Paper Titled "Dynaplex: Analyzing Program Complexity using Dynamically Inferred Recurrence Relations"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5421762},
abstract = {
    <p>This artifact contains an implementation of the dynaplex algorithm and benchmark programs, as described in the paper: <em>Dynaplex: Analyzing Program Complexity using Dynamically Inferred Recurrence Relations</em>.</p>
<p>The development and experiment environment is provided as a single Docker image at <code>unsatx/dynaplex:oopsla21</code>. In addition to the image a <code>Dockerfile</code> as well as a zip containing the github repository are also provided as alternative source of the artifact. We recommend using the provided Docker image as it is self-contained with all the dependencies installed. A guide to set up and use this artifact from the docker image is provided in file <code>dynaplex.pdf</code>.</p>

},
keywords = {complexity analysis, dynamic analysis, invariants, recurrence relations}
}

@software{10.5281/zenodo.5424844,
author = {Brown, Michael D. and Pruett, Matthew and Bigelow, Robert and Mururu, Girish and Pande, Santosh},
title = {Artifact Package for Article: Not So Fast: Understanding and Mitigating Negative Impacts of Compiler Optimizations on Code Reuse Gadget Sets},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5424844},
abstract = {
    <p>Virtual Machine containing technical artifacts referenced in the article. Includes dataset of over 1000 binaries, recompiler passes, and evaluation tool (GSA).</p>

},
keywords = {binary recompilation, code reuse attacks, code reuse gadgets, compiler, optimization, recompiler, return-oriented programming, ROP}
}

@software{10.5281/zenodo.5442253,
author = {Emre, Mehmet and Schroeder, Ryan and Dewey, Kyle and Hardekopf, Ben},
title = {Artifact for "Translating C to Safer Rust"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5442253},
abstract = {
    <p>The purpose of the artifact is to reproduce the data presented in the paper. The artifact contains our prototype for the method presented in the paper along with evaluation tools and scripts. It can be used to reproduce the data in all tables except the performance data. It contains instructions for how to produce the data used for Figure 1, but the artifact does not generate the figure automatically (the user needs to use a spreadsheet or plotting program to create the figure from the data).</p>

},
keywords = {Automatic Translation, C, Empirical Study, Memory-Safety, Rust}
}

@software{10.5281/zenodo.5449078,
author = {Kazerounian, Milod and Foster, Jeffrey S. and Min, Bonan},
title = {Replication Package for Paper "SimTyper: Sound Type Inference for Ruby using Type Equality Prediction"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5449078},
abstract = {
    <p>This artifact can be used to reproduce the results presented in the paper “SimTyper: Sound Type Inference for Ruby using Type Equality Prediction.” It includes the type inference system SimTyper, and the eight programs which it is run on to produce results.</p>

},
keywords = {dynamic languages, machine learning, ruby, type inference}
}

@software{10.5281/zenodo.5459312,
author = {Nandi, Chandrakana and Willsey, Max and Zhu, Amy and Wang, Yisu Remy and Saiki, Brett and Anderson, Adam and Schulz, Adriana and Grossman, Dan and Tatlock, Zachary},
title = {Artifact for article: &nbsp;Rewrite Rule Inference Using Equality Saturation},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5459312},
abstract = {
    <p>This is the artifact for our paper “Rewrite Rule Inference Using Equality Saturation”. In our paper, we presented a framework, Ruler, that uses equality saturation to automatically infer small, expressive rulesets for a domain, given an interpreter. The artifact reproduces the following quantitative evaluations from the paper:</p>
<ul>
<li><p>Comparing with CVC4 (Section 4): We show that Ruler can infer smaller, powerful rulesets faster by comparing the rules inferred for bool, bv4, and bv32 with varying expression sizes (2, 3). The results are in Table 1.</p></li>
<li><p>Integrating with Herbie (Section 5): We show that Ruler’s rules can be used to replace human-written rules by comparing the Herbie tool’s results in fours different configurations: <code>None</code>, <code>Herbie</code>, <code>Ruler</code>, <code>Both</code>. The results are in Figure 7.</p></li>
<li><p>Search Parameter Analysis (Section 6.1): We profiled Ruler’s search algorithm to measure how much time is spent in each phase. Figure 8 shows the results for bv4, bv32, and rationals domains. We also compared different variations of <code>choose_eqs</code> by varying n in Figure 5, Line 3, whose default value is infinity. The results are shown in Figure 9a for bv4, bv32, and rationals. Importantly, we measure both running time and the number of rules learned. We also measured running time, number of rules learned, and number of e-classes in the egraph with and without invoking <code>run_rewrites</code> (Figure 4, Line 9) to study its effect. The results are shown in Figure 9b for bv4, bv32, and rationals.</p></li>
<li><p>Validation Analysis (Section 6.2): We compared different rule validation methods for bv4, bv32, and rationals. The results are shown in Table 2.</p></li>
</ul>

},
keywords = {e-graphs, equality saturation, program synthesis, rewrite rules}
}

@software{10.5281/zenodo.5468873,
author = {Iorga, Dan and Donaldson, Alastair F. and Sorensen, Tyler and Wickerson, John},
title = {The semantics of Shared Memory in Intel CPU/FPGA},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5468873},
abstract = {
    <p>The aim of this artefact is to demonstrate the claims made in the paper “The Semantics of Shared Memory in Intel CPU/FPGA Systems”.</p>
<p>This manual is divided into two parts:&nbsp;Getting Started Guide&nbsp;which should be finished in 30 minutes and a section where we will provide the&nbsp;Step by Step Instructions&nbsp;by which the paper instructions can be reproduced.</p>

},
keywords = {Core Cache Interface (CCI-P), CPU/FPGA, memory model}
}

@software{10.5281/zenodo.5476274,
author = {Honor\'{e}, Wolf and Kim, Jieung and Shin, Ji-Yong and Shao, Zhong},
title = {Artifact for "Much ADO about Failures: A Fault-Aware Model for Compositional Verification of Strongly Consistent Distributed Systems"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5476274},
abstract = {
    <p>This artifact includes the Coq source files for the Advert distributed system verification framework as well as the examples from the paper, a C implementation of multi-Paxos verified with CCAL, and the C source code for the multi-Paxos, Chain Replication, and Two-Phase Commit protocols used for the performance evaluations. Source files are included in artifact.tgz. See the README for build instructions.</p>

},
keywords = {Coq, distributed systems, formal verification, proof assistants}
}

@software{10.5281/zenodo.5482251,
author = {Xu, Haoran and Kjolstad, Fredrik},
title = {Artifact for Paper "Copy-and-Patch Compilation: A fast compilation algorithm for high-level languages and bytecode"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5482251},
abstract = {
    <p>This is the artifact corresponding to paper</p>
<pre><code>Copy-and-Patch Compilation: A fast compilation algorithm for high-level languages and bytecode</code></pre>
<p>to be published in OOPSLA 2021.</p>
<p>This artifact is judged by the Artifact Evaluation Committee as functional and reusable.</p>
<p>List of Files</p>
<pre><code> 'instruction.pdf' contains all instructions on how to use this artifact.
 'artifact_vm_image.ova' is the Virtual Box VM image containing the artifact.
 'artifact_vm_image.ova.md5sum' is the MD5 checksum for file 'artifact_vm_image.ova'.
 'draft_paper.pdf' is the paper referred to by 'instruction.pdf'. It is NOT the camera-ready version of the paper:  for camera-ready version, please check the OOPSLA 2021 publication website. This draft version is included only for consistency of this artifact.
 'LICENSE.txt' is the license of this artifact.</code></pre>
<p>How to Use this Artifact</p>
<p>Please refer to ‘instruction.pdf’ for all instructions on how to use this artifact.</p>

},
keywords = {Artifact}
}

@software{10.5281/zenodo.5482557,
author = {Wolff, Fabian and B\'{\i}l\'{y}, Aurel and Matheja, Christoph and M\"{u}ller, Peter and Summers, Alexander J.},
title = {Modular Specification and Verification of Closures in Rust (artefact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5482557},
abstract = {
    <p>This is the artefact accompanying our OOPSLA 2021 publication, “Modular Specification and Verification of Closures in Rust”. Please refer to the OOPSLA publication and the contained README file for more information.</p>

},
keywords = {closures, higher-order functions, Rust, software verification}
}

@software{10.5281/zenodo.5483138,
author = {Lanzinger, Florian and Weigl, Alexander and Ulbrich, Mattias and Dietl, Werner},
title = {Property Checker -- Scalability and Precision by Combining Expressive Type Systems and Deductive Verification},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5483138},
abstract = {
    <p>The Property Checker is a checker developed using the Checker Framework for Java. The Checker Framework allows programmers to leverage Java annotations to create pluggable Java type systems. Unlike other checkers in the CF, the Property Checker allows users to specify their own type qualifiers and qualifier hierarchies using a simple definition language.</p>
<p>If the Property Checker is not able to completely prove a program’s correctness, it outputs a JML translation, in which all property qualifiers are translated into specification clauses in the Java Modeling Language (JML). This translation can be given to a deductive verification tool like KeY or OpenJML to prove the parts of the program which the checker was not able to prove. This approach combines the scalability and easy-of-use of pluggable type system with the power of deductive verification.</p>
<p>This artifact includes the Property Checker itself and the JML deductive verification tools KeY and OpenJML. The example project in the directory property-checker-tutorial illustrates how the Property Checker can be run on your own projects; see that project’s readme for details. See this file for information on how to run KeY and OpenJML. In addition, there are some premade bash scripts to help you re-run the evaluation described in the paper; see the artifact documentation for more details.</p>

},
keywords = {Object-oriented languages, Program specification, Program verification, Type systems}
}

@software{10.5281/zenodo.5484436,
author = {Popescu, Natalie and Xu, Ziyang and Apostolakis, Sotiris and August, David I. and Levy, Amit},
title = {Artifact for 'Safer at Any Speed: Automatic Context-Aware Safety Enhancement for Rust'},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5484436},
abstract = {
    <p>This artifact is responsible for reproducing the experiments in the article “Safer at Any Speed: Automatic Context-Aware Safety Enhancement for Rust”. We populate a docker image with the open-source libraries, applications, and application-specific data that we eventually use for running experiments, as well as a driver and supporting scripts that instantiates each experiment. The experiments help support the claims we make in the paper.</p>

},
keywords = {bounds checks, Rust, safety-performance trade-off}
}

@software{10.5281/zenodo.5491895,
author = {Tan, Tian and Li, Yue and Ma, Xiaoxing and Xu, Chang and Smaragdakis, Yannis},
title = {Making Pointer Analysis More Precise by Unleashing the Power of Selective Context Sensitivity (Artifact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5491895},
abstract = {
    <p>This artifact is provided to reproduce the results of research questions (RQ1 and RQ2) in Section 6 of our companion paper. The artifact contains Baton (our tool, as well as Collection, Zipper-e and Scaler which are used by Baton), Doop (a state-of-the-art pointer analysis framework for Java), and the Java programs and the library used in our evaluation.</p>

},
keywords = {Alias Analysis, Context Sensitivity, Java, Pointer Analysis}
}

@software{10.5281/zenodo.5493554,
author = {Yan, Pengbo and Murray, Toby},
title = {SecRSL: Security Separation Logic for C11 Release-Acquire Concurrency - Coq Formalisation},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5493554},
abstract = {
    <p>Formalisation, soundness proof, and example applications of SecRSL: Security Relaxed Separation Logic, a logic for reasoning about information flow security of programs in the Release-Acquire fragment of C11.</p>
<p>Includes the Coq sources (for Coq version 8.8.1) as well as a Ubuntu Linux virtual machine in which the theories and the required Coq version are already installed.</p>
<p>See README for instructions; LICENSE for licensing information.</p>
<p>This artifact accompanies the paper: Pengbo Yan and Toby Murray, “SecRSL: Security Separation Logic for C11 Release-Acquire Concurrency”, OOPSLA 2021</p>

},
keywords = {Axiomatic Semantics, Information-flow Security, Separation Logic, Weak Memory Consistency}
}

@software{10.5281/zenodo.5494504,
author = {Yamaguchi, Masaomi and Matsuda, Kazutaka and David, Cristina and Wang, Meng},
title = {Synbit: Synthesizing Bidirectional Programs using Unidirectional Sketches (Implementation)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5494504},
abstract = {
    <p>This is the artifact of a paper “Synbit: Synthesizing Bidirectional Programs using Unidirectional Sketches”. This artifact includes the implementation of Synbit and scripts for reproducing the experiments in the paper.</p>

},
keywords = {Bidirectional Transformation, Program Synthesis}
}

@software{10.5281/zenodo.5494813,
author = {Smaragdakis, Yannis and Grech, Neville and Lagouvardos, Sifis and Triantafyllou, Konstantinos and Tsatiris, Ilias},
title = {Symbolic Value-Flow Static Analysis: Deep, Precise, Complete Modeling of Ethereum Smart Contracts (Artifact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5494813},
abstract = {
    <p>This artifact can be used to support all claims made in the evaluation section of the corresponding paper. In particular it can be used to reproduce the results of the Controlled Evaluation Section of the paper (Section 7). These examples require running 3 analysis tools: our proposed Symvalic analysis, Manticore, and Mythril on two sets of smart contracts.</p>

},
keywords = {ethereum, EVM, static analysis, symbolic execution}
}

@software{10.5281/zenodo.5496104,
author = {Patel, Nisarg and Krishna, Siddharth and Shasha, Dennis and Wies, Thomas},
title = {Replication Package for Article: Verifying Concurrent Multicopy Search Structures},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5496104},
abstract = {
    <p>Artifact for OOPSLA’21 paper: Verifying Concurrent Multicopy Search Structures</p>
<p>The artifact is packaged as a VirtualBox Image based on Ubuntu 20.04.2. The login is <code>templates:templates</code>.</p>
<p>This artifact relies on two tools: Iris (a high-order concurrent separation logic built on top of Coq) and GRASShopper (a program verification tool). The artifact is packaged with these software preinstalled and the necessary files precompiled.</p>
<p>See README for further information on how to use the artifact. See LICENSE for the license-related information.</p>

},
keywords = {concurrent data structures, flow framework, log-structured merge trees, logic and verification, separation logic, shared memory algorithms, template-based verification, theory of computation}
}

@software{10.5281/zenodo.5496483,
author = {Lahav, Ori and Namakonov, Egor and Oberhauser, Jonas and Podkopaev, Anton and Vafeiadis, Viktor},
title = {Making Weak Memory Models Fair: OOPSLA 2021 artifact},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5496483},
abstract = {
    <p>This artifact provides the supplementary Coq development for the Making Weak Memory Models Fair paper from OOPSLA’21: source code and VirtualBox image.</p>

},
keywords = {concurrency, fairness, software verification, weak memory models}
}

@software{10.5281/zenodo.5497628,
author = {Fu, Weili and Krause, Fabian and Thiemann, Peter},
title = {Artifact for Label Dependent Lambda Calculus and Gradual Typing},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5497628},
abstract = {
    <p>This artifact contains two parts corresponding to our claim at the end of section 1 in the paper “Label Dependent Lambda Calculus and Gradual Typing” appearing in OOPSLA 2021.</p>
<ol type="1">
<li>An implementation of the type checker for LDLC corresponding to section 3.2 from the paper and its gradual extension for GLDLC described in section 5.1. It does <em>not</em> contain the translation described in section 5.2.</li>
<li>A formalization of the cast calculus CCLDLC (a proper extension of LDLC) described in section 4 and an implementation of the progress proof of theorem 4.6 in Agda.</li>
</ol>

},
keywords = {dependent types, gradual types, subtyping}
}

@software{10.5281/zenodo.5497862,
author = {Karachalias, Georgios and Koprivec, Filip and Pretnar, Matija and Schrijvers, Tom},
title = {Compiler and replication of results: "Efficient Compilation of Algebraic Effect Handlers"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5497862},
abstract = {
    <p>Artifact consists of Dockerfile, instructions document and compressed docker image. The docker image includes Eff compiler presented in the paper, benchmark files and a helper scripts to run the benchmarks and produce both human readable benchmark outputs and data used to generate plots in the paper. Full instructions on building and use are available in the documentation in pdf or markdown format.</p>

},
keywords = {Algebraic effects, Compilers, Eff, Focus on specific PL, Handlers, Transformations, Types}
}

@software{10.5281/zenodo.5500548,
author = {Pelenitsyn, Artem and Belyakova, Julia and Chung, Benjamin and Tate, Ross and Vitek, Jan},
title = {Type Stability in Julia: Avoiding Performance Pathologies in JIT Compilation (Artifact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5500548},
abstract = {
    <p>This artifact aims to give exact directions on how to reproduce experiments reported in Section 5 (Empirical Study) of the Type Stability in Julia paper presented at OOPSLA ’21; in particular: Tables 1 and 2, Figure 11.</p>
<p>The artifact consists of a number of scripts in Bash and Julia and have instructional comments inside. We submit the Git history of the project: the submitted version lives on the artifact branch. The same repository is available on Github (prl-julia/julia-type-stability).</p>

},
keywords = {compilation, dynamic languages, method dispatch, type inference}
}

@software{10.5281/zenodo.5501522,
author = {Sorensen, Tyler and Salvador, Lucas F. and Raval, Harmit and Evrard, Hugues and Wickerson, John and Martonosi, Margaret and Donaldson, Alastair F.},
title = {Artifact for "Specifying and Testing GPU Workgroup Progress Models" (OOPSLA 2021)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5501522},
abstract = {
    <p>A collection of software and data from the OOPSLA 2021 paper: Specifying and Testing GPU Workgroup Progress Models. It is provided as a docker container with as many pre-installed dependencies as possible.</p>
<p>Software includes: formal specifications for the CADP model checker; formal specifications for synthesizing progress litmus tests; a compiler from xml litmus tests to a variety of GPU backends, including Metal, CUDA, and Vulkan.</p>
<p>Data includes all of the test cases found after running the test case synthesis for 5 weeks. It includes running the progress litmus tests in 3 different configurations across 8 different GPUs. It also includes the results of running the progress litmus tests under various formal semi-fair models in the CADP model checker.</p>

},
keywords = {forward progress, GPGPU, model checking, test case synthesis}
}

@software{10.5281/zenodo.5501650,
author = {Jaber, Nouraldin and Wagner, Christopher and Jacobs, Swen and Kulkarni, Milind and Samanta, Roopsha},
title = {QuickSilver},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5501650},
abstract = {
    <p>This artifact contains a VirtualBox VM that can be used to replicate the results in “QuickSilver: Modeling and Parameterized Verification for Distributed Agreement-Based Systems”. It includes the source code of the QuickSilver tool.</p>

},
keywords = {modular verification., parameterized verification, QuickSilver}
}

@software{10.5281/zenodo.5502210,
author = {Gokhale, Satyajit and Turcotte, Alexi and Tip, Frank},
title = {Automatic Migration from Synchronous to Asynchronous JavaScript APIs (Artifact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5502210},
abstract = {
    <p>This artifact contains information on setting up and evaluating the results for Desynchronizer, a tool for automatic refactoring of Synchronous Javascript API to their Asynchronous equivalents. The entire source code for the tool is also included.</p>

},
keywords = {async/await, JavaScript, promises, refactoring, static analysis}
}

@software{10.5281/zenodo.5504155,
author = {Paraskevopoulou, Zoe and Grover, Anvay},
title = {Accompanying Coq Development for the OOPLSA'21 Paper: Compiling With Continuations, Correctly.},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5504155},
abstract = {
    <p>This artifact is the source code of the CertiCoq project, part of which is the proved correct continuation-passing style transformation covered in the OOPSLA’21 paper “Compiling With Continuations Correctly”.</p>

},
keywords = {continuation-passing style, Coq, formal verification, logical relations, simulation relations, verified compilation}
}

@software{10.5281/zenodo.5504159,
author = {Atkinson, Eric and Baudart, Guillaume and Mandel, Louis and Yuan, Charles and Carbin, Michael},
title = {Statically Bounded-Memory Delayed Sampling for Probabilistic Streams},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5504159},
abstract = {
    <p>This artifact accompanies the paper “Statically Bounded-Memory Delayed Sampling for Probabilistic Streams” from OOPSLA 2021. It contains the code of the implementation and benchmarks, as well as a virtual machine that can be used to run the implementation.</p>

},
keywords = {Probabilistic programming, program analysis, reactive programming, semantics, streaming inference}
}

@software{10.5281/zenodo.5504362,
author = {Verbruggen, Gust and Le, Vu and Gulwani, Sumit},
title = {Replication Package for Article: "Semantic programming by example with pre-trained models"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5504362},
abstract = {
    <p>This archive contains the code for our paper “Semantic programming by example with pre-trained models”. It contains the code and data required to execute the experiments, as well as cached GPT-3 output in case no key is available.</p>

},
keywords = {flashfill, gpt-3, programming by example}
}

@software{10.5281/zenodo.5507442,
author = {Barbar, Mohamad and Sui, Yulei},
title = {Compacting Points-To Sets through Object Clustering (Artifact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5507442},
abstract = {
    <p>Artifact packaged as a Docker image for reproducing the evaluation of “Compacting Points-To Sets Through Object Clustering” by Mohamad Barbar and Yulei Sui published at OOPSLA ’21.</p>

},
keywords = {bit-vectors, hierarchical clustering., points-to sets, staged points-to analysis}
}

@software{10.5281/zenodo.5510036,
author = {De Porre, Kevin and Ferreira, Carla and Pregui\c{c}a, Nuno and Gonzalez Boix, Elisa},
title = {Artifact for: ECROs: Building Global Scale Systems from Sequential Code},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5510036},
abstract = {
    <p>Complete software artifact for our submission “ECROs: Building Global Scale Systems from Sequential Code” by De Porre K., Ferreira C., Pregui\c{c}a N., and Gonzalez Boix E. at OOPSLA 2021. This version contains the complete artifact, i.e.&nbsp;the scripts to reproduce the benchmarks and the portfolio of ECROs.</p>

},
keywords = {data structures, eventual consistency, replication}
}

@software{10.5281/zenodo.5518181,
author = {Muehlboeck, Fabian and Tate, Ross},
title = {Transitioning from Structural to Nominal Code with Efficient Gradual Typing: Artifact},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5518181},
abstract = {
    <p>This is the software artifact for the OOPSLA 2021 paper “Transitioning from Structural to Nominal Code with Efficient Gradual Typing”.</p>
<p>It contains the source code for MonNom, the setup to reproduce all benchmark results shown in the paper, and the data for the plots presented in the paper. The artifact is a virtual machine where everything is already compiled and set up to run the benchmarks. For up-to-date source code, please check https://github.com/fabianmuehlboeck/monnom/tree/release/oopsla21 . The password for the user of the virtual machine is “monnom”. The artifact was packaged with Oracle VirtualBox 6.1.22 .</p>

},
keywords = {Gradual Typing, MonNom}
}

@software{10.5281/zenodo.5519606,
author = {He, Paul and Westbrook, Eddy and Carmer, Brent and Phifer, Chris and Robert, Valentin and Smeltzer, Karl and \c{S}tef\u{a}nescu, Andrei and Tomb, Aaron and Wick, Adam and Yacavone, Matthew and Zdancewic, Steve},
title = {Artifact: A Type System for Extracting Functional Specifications from Memory-Safe Imperative Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5519606},
abstract = {
    <p>The artifact is a docker image which contains the Coq formalization of the metatheory presented in the paper, as well as the source code for the Heapster tool described in the paper. The example code that the Heapster tool is included along with the source code.</p>

},
keywords = {memory safety, pointers, Specification extraction, type systems}
}

@software{10.1145/3462298,
author = {Huang, Xuejing and Oliveira, Bruno C. d. S.},
title = {Replication Package for Article: Distributing Intersection and Union Types with Splits and Duality (Functional Pearl)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462298},
abstract = {
    <p>This artifact includes the Haskell code discussed in the paper and mechanical proofs that support the paper’s claims. For demonstration and reuse purposes, it contains a Coq library for the subtyping formulation presented in the paper, and three Haskell implementations of the subtyping algorithm. A Debian QEmu image is also provided with all the dependencies installed.</p>

},
keywords = {Coq, distributivity, Haskell, intersection types, subtyping, union types}
}

@software{10.1145/3462299,
author = {Serrano, Manuel},
title = {Replication package for article: Of JavaScript AOT Compilation Performance},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462299},
abstract = {
    <p>The artifact contains the Hop distribution where the Hopc ahead-of-time JavaScript compiler is included and the two benchmark suites that are described in the paper. The artifact installation procedure builds the compiler, compiles the benchmarks, and runs them all.</p>

},
keywords = {ahead-of-time, compilation, JavaScript, Scheme}
}

@software{10.1145/3462300,
author = {Fromherz, Aymeric and Rastogi, Aseem and Swamy, Nikhil and Gibson, Sydney and Mart\'{\i}nez, Guido and Merigoux, Denis and Ramananandro, Tahina},
title = {Artifact for Steel: Proof-Oriented Programming in a Dependently Typed Concurrent Separation Logic},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462300},
abstract = {
    <p>This artifact contains the F* development of the Steel framework presented in the corresponding ICFP 21 paper</p>

},
keywords = {Concurrency, Program Proofs, Separation Logic}
}

@software{10.1145/3462301,
author = {Krauter, Nicolas and Raaf, Patrick and Braam, Peter and Salkhordeh, Reza and Erdweg, Sebastian and Brinkmann, Andr\'{e}},
title = {Replication Package for Article: "Persistent Software Transactional Memory in Haskell"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462301},
abstract = {
    <p>This artifact provides the Haskell PSTM solution described in the article “Persistent Software Transactional Memory in Haskell”, as well as benchmark and demo applications that allow to reproduce our results and verify our claims. More specifically, the sources contain multiple components in separate sub-directories:</p>
<ul>
<li><em>ghc_pm</em> contains the adapted GHC version that offers PSTM and the persistent heap</li>
<li><em>ghc-8.10.1</em> provides the reference GHC version, slightly adapted to capture STM commit statistics</li>
<li><em>pstm</em> contains the Haskell definitions of our STM extension</li>
<li><em>haskell-benchs</em> contains the Haskell benchmark applications</li>
<li><em>mnemosyne-gcc</em> contains the used Mnemosyne benchmark applications we compared with</li>
<li><em>Onefile</em> contains the used Onefile benchmark applications we compared with</li>
<li><em>benchmarks</em> contains the scripts to run the benchmarks and is the entry point for reproducing the benchmark figures/tables</li>
<li><em>demos</em> contains some example applications showing how to use PSTM and demonstrate its laziness and persistence capabilities</li>
</ul>
<p>Building the complete environment from the sources, especially the contained GHC versions, can be very time-consuming. To avoid this process and allow long-term reproducibility, the QEMU-VM image (Debian) located in the <em>prebuilt</em> directory provides a ready-to-run environment for the benchmark and demo applications. Moreover, the directory contains a prebuilt Singularity container image that provides all OS-level dependencies for building from the sources directly. For more information on how to build, run or use the artifact, please refer to the contained README file(s).</p>

},
keywords = {non-volatile heap, persistent transactions, PM library comparison benchmarks}
}

@software{10.5281/zenodo.4771438,
author = {Li, Yao and Xia, Li-yao and Weirich, Stephanie},
title = {Artifact for Reasoning about the Garden of Forking Paths},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4771438},
abstract = {
    <p>This is the artifact for the ICFP’21 paper&nbsp;Reasoning about the garden of forking paths.</p>
<p>The source file of the artifact can also be found at:&nbsp;https://github.com/lastland/ClairvoyanceMonad</p>
<p>The artifact contains two files: the source Coq files (ClairvoyanceSrc.tar.gz) and a QEMU-based VM image that contains everything you need to run the proof scripts (ClairvoyanceVM.tar.gz). Detailed instructions on how to use them&nbsp;can be found in a README file within each individual package.</p>
<p>The abstract of the paper:</p>
<p>Lazy evaluation is a powerful tool for functional programmers. It enables the concise expression of on-demand computation and a form of compositionality not available under other evaluation strategies. However, the stateful nature of lazy evaluation makes it hard to analyze a program’s computational cost, either informally or formally. In this work, we present a novel and simple framework for formally reasoning about lazy computation costs based on a recent model of lazy evaluation: clairvoyant call-by-value. The key feature of our framework is its simplicity, as expressed by our definition of the clairvoyance monad. This monad is both simple to define (around 20 lines of Coq) and simple to reason about. We show that this monad can be effectively used to mechanically reason about the computational cost of lazy functional programs written in Coq.</p>

},
keywords = {computation cost, Coq, formal verification, lazy evaluation, monad}
}

@software{10.5281/zenodo.4774332,
author = {Chlipala, Adam},
title = {Code for "Skipping the Binder Bureaucracy with Mixed Embeddings in a Semantics Course (Functional Pearl)"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4774332},
abstract = {
    <p>The associated conference paper introduces a technique used in a course on mechanized semantics and program proof. This artifact is a snapshot of the course’s online textbook, including Coq code illustrating all the main ideas with examples.</p>

},
keywords = {binder encodings, Coq, mechanized semantics, program verification, proof assistants}
}

@software{10.5281/zenodo.4776802,
author = {Handa, Shivam and Kallas, Konstantinos and Vasilakis, Nikos and Rinard, Martin C.},
title = {Artifact for ``An Order-Aware Dataflow Model for Parallel Unix Pipelines''},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4776802},
abstract = {
    <p>The artifact contains the frozen icfp-ae branch of the PaSh git repository. PaSh aims at the correct and automated parallelization of POSIX shell scripts, and was used to generate the results presented in the paper. It includes three key components: (1) a compiler that, given as input a POSIX shell script, emits a POSIX shell script that includes explicit data-parallel fragments for which PaSh has deemed such parallelization semantics-preserving, (2) a set of PaSh-related runtime primitives for supporting the execution of the parallel script fragments, available as in the PATH as normal commands, and (3) a crowd-sourced library of annotations characterizing several properties of common Unix/Linux commands relevant to parallelization.</p>

},
keywords = {Dataflow, Order-awareness, Parallelism, POSIX, Scripting, Shell, Unix}
}

@software{10.5281/zenodo.4777196,
author = {Zakowski, Yannick and Beck, Calvin and Yoon, Irene and Zaichuk, Ilia and Zaliva, Vadim and Zdancewic, Steve},
title = {Specific release of the Vellvm project for the ICFP'21 paper titled: "Modular, Compositional, and Executable Formal Semantics for LLVM IR"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4777196},
abstract = {
    <p>This artifact contains a snapshot of the stable parts of the Vellvm project as described at the time of ICFP’21 in the “Modular, Compositional, and Executable Formal Semantics for LLVM IR”. It contains in particular: - the definition of our formal semantics for LLVM IR - the definition of the executable interpreter for LLVM IR - all the surrounding infrastructure (unverified parsers and interpreters, test suite, etc..) - the associated meta-theory: equational theory of the language, rewriting-based symbolic interpreter, proof of correctness of the interpreter w.r.t. the semantics - QuickChick-based test-infrastructure - Elementary verified optimizations</p>

},
keywords = {Coq, Denotational Semantics, LLVM IR, Verified Compiler}
}

@software{10.5281/zenodo.4777648,
author = {Li, John M. and Appel, Andrew W.},
title = {Replication Package for Article: Deriving Efficient Program Transformations from Rewrite Rules},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4777648},
abstract = {
    <p>The artifact contains (1) an implementation of the tool described in the paper “Deriving Efficient Program Transformations from Rewrite Rules”, (2) three examples that illustrate the use of the tool, and (3) a benchmark suite that supports claims in Section 5 of the paper. The tool is implemented in Coq and is bundled along with the Certicoq compiler.</p>

},
keywords = {compiler correctness, compiler optimization, domain-specific languages, interactive theorem proving, metaprogramming, shrink reduction}
}

@software{10.5281/zenodo.4885001,
author = {Oh, Jeho and Y\i{}ld\i{}ran, Necip Faz\i{}l and Braha, Julian and Gazzillo, Paul},
title = {Artifact from "Finding Broken Linux Configuration Specifications by Statically Analyzing the Kconfig Language"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4885001},
abstract = {
    <p>Artifact from “Finding Broken Linux Configuration Specifications by Statically Analyzing the Kconfig Language”</p>

},
keywords = {formal verification, Kconfig, software configuration, static analysis}
}

@software{10.5281/zenodo.4895186,
author = {Kahn, David M. and Hoffmann, Jan},
title = {Prototype Tool from Automatic Amortized Resource Analysis with the Quantum Physicist's Method},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4895186},
abstract = {
    <p>This is a QEmu image and source tarball for running the typechecker from “Automatic Amortized Resource Analysis with the Quantum Physicist’s Method”. The image comes with RaML and the Coin-Or LP solver pre-installed to recreate the experiments from the paper.</p>

},
keywords = {AARA, amortized analysis, automatic amortized resource analysis, physicist's method, potential method, quantum physicist's method, RaML, resource, resource aware ml, type, type inference, typechecker}
}

@software{10.5281/zenodo.4901843,
author = {Patra, Jibesh and Pradel, Michael},
title = {Source code package for 'Semantic Bug Seeding: A Learning-Based Approach for Creating Realistic Bugs'},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4901843},
abstract = {
    <p>The package contains source code and documentation that may be used to run experiments mentioned in the paper.</p>

},
keywords = {bug injection, bugs, dataset, machine learning, token embeddings}
}

@software{10.5281/zenodo.4902806,
author = {Vasilakis, Nikos and Ntousakis, Grigoris and Heller, Veit and Rinard, Martin C.},
title = {Efficient Module-Level Dynamic Analysis for Dynamic Languages with Module Recontextualization (Lya Artifact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4902806},
abstract = {
    <p>Lya uses a novel set of module transformation techniques, collectively termed module recontextualization, to bolt a high-performance analysis and instrumentation infrastructure onto a conventional production runtime. Lya achieves high performance by analyzing code at a coarser-that-usual granularity, meaning that Lya’s analyses operate at a lower resolution than conventional analysis frameworks but at a significantly better performance—enabling always-on operation on production environments. Such coarse-grained, high-performance analyses have been shown to infer useful information about the execution of multi-library programs. Examples include identifying security vulnerabilities, highlighting performance bottlenecks, and applying corrective actions.</p>

},
keywords = {Analysis, Dynamic, Instrumentation, Performance, Recontextualization, Runtime, Security}
}

@software{10.5281/zenodo.4902828,
author = {Chen, Tianyi and Heo, Kihong and Raghothaman, Mukund},
title = {Boosting Static Analysis Accuracy With Instrumented Test Executions (Paper Artifact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4902828},
abstract = {
    <p>Artifact associated with the paper “Boosting Static Analysis Accuracy with Instrumented Test Executions”, recently accepted to FSE 2021.</p>

},
keywords = {alarm ranking, Bayesian inference, belief networks, dynamic analysis, Static analysis}
}

@software{10.5281/zenodo.4968451,
author = {Houshmand, Farzin and Lesani, Mohsen and Vora, Keval},
title = {Artifact for article: "Grafs: Declarative Graph Analytics"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4968451},
abstract = {
    <p>Grafs is a synthesizer that automatically generates graph analytics code for five graph processing frameworks: Ligra [Shun and Blelloch 2013], GridGraph [Zhu et al.&nbsp;2015], PowerGraph [Gonzalez et al.&nbsp;2012], Gemini [Zhu et al. 2016], and GraphIt [Zhang et al.&nbsp;2018]. The package already contains the runtime for the frameworks.</p>

},
keywords = {Fusion, Graph Analytics, Synthesis}
}

@software{10.5281/zenodo.4975033,
author = {Biswas, Sumon and Rajan, Hridesh},
title = {Replication Package for "Fair Preprocessing: Towards Understanding Compositional Fairness of Data Transformers in Machine Learning Pipeline"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4975033},
abstract = {
    <p>The artifact contains the benchmark, source code and data used in our ESEC/FSE 2021 paper on “Fair Preprocessing”. The benchmark can be used by other researchers and practitioners to evaluate the fairness of real-world machine learning (ML) pipelines collected from Kaggle. In addition, we released our implementation of the novel metrics proposed to measure component level fairness in the pipelines. The artifact also contains five popular datasets used in fairness research.</p>

},
keywords = {fairness, machine learning, models, pipeline, preprocessing}
}

@software{10.5281/zenodo.4988150,
author = {Kellogg, Martin and Shadab, Narges and Sridharan, Manu and Ernst, Michael D.},
title = {Artifact for "Lightweight and Modular Resource Leak Verification"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4988150},
abstract = {
    <p>This upload is a docker image containing the artifact accompanying our ESEC/FSE’21 paper “Lightweight and Modular Resource Leak Verification”.</p>
<p>To run the image,</p>
<p>0.) Install Docker following the directions at [https://www.docker.com/get-started] for your OS, if it is not already installed. We have tested the artifact with Docker Desktop on MacOS, but it should work for other operating systems.</p>
<p>1.) Unzip the provided Docker image. <code>gunzip -c path/to/resource-leak-checker.tar.gz &gt; resource-leak-checker.tar</code></p>
<p>2.) Load it into Docker. <code>docker load &lt; resource-leak-checker.tar</code></p>
<p>3.) Run the image. This should open a bash shell, at the home directory of user <code>fse</code>. <code>docker run -it msridhar/rlc:latest</code></p>
<p>Instructions for how to run the paper’s experiments are inside the container in the <code>object-construction-checker/fse-2021/README.md</code> file in the <code>fse</code> user’s home directory.</p>

},
keywords = {accumulation analysis, Pluggable type systems, resource leaks, static analysis, type- state analysis}
}

@software{10.5281/zenodo.5005829,
author = {Watanabe, Yasunari and Gopinathan, Kiran and P\^{\i}rlea, George and Polikarpova, Nadia and Sergey, Ilya},
title = {Certified SuSLik (ICFP 2021 Artifact): Code and Benchmarks},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5005829},
abstract = {
    <p>Artifact accompanying the the paper “Certifying the Synthesis of Heap-Manipulating Programs”, published in proceedings of ICFP 2021.</p>

},
keywords = {Mechanized Proofs, Program Synthesis, Proof Assistants, Separation Logic}
}

@software{10.5281/zenodo.5035645,
author = {Koparkar, Chaitanya and Rainey, Mike and Vollmer, Michael and Kulkarni, Milind and Newton, Ryan R.},
title = {Artifact for "Efficient Tree-Traversals: Reconciling Parallelism and Dense Data Representations"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5035645},
abstract = {
    <p>The artifact for our paper is the Gibbon compiler. Where the paper makes a distinction between “Parallel Gibbon” and “Sequential Gibbon”, here we will enable parallel execution by passing in command-line flags to the compiler, as the work presented in our paper was in fact an extension of work on the Gibbon project, but this was obscured by the double-blind requirement.</p>
<p>Besides the compiler, this artifact includes the benchmarks presented in the paper, and some scripts to run them on your machine.</p>

},
keywords = {compilers, data representation, parallelism}
}

@software{10.5281/zenodo.5037493,
author = {Rocha, Pedro and Caires, Lu\'{\i}s},
title = {Propositions-as-Types and Shared State (Artifact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5037493},
abstract = {
    <p>This is the companion artifact for the <em>Propositions-as-Types and Shared State</em> (submission #97).</p>
<p>The artifact consists of a proof-of-concept type-checker and an interpreter for the language described in the paper. The interpreter is a fully (fine grain) concurrent runtime system, using the java threads library.</p>
<p>The artifact is distributed as a Debian QEmu image that bundles the source code, all its dependencies, the code examples from the paper and many other additional code examples and tests.</p>

},
keywords = {Propositions-as-Types, Session Types, Shared State}
}

@software{10.5281/zenodo.5043233,
author = {Yanovski, Joshua and Dang, Hoang-Hai and Jung, Ralf and Dreyer, Derek},
title = {GhostCell: Separating Permissions from Data in Rust (Artifact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5043233},
abstract = {
    <p>This contains a snapshot of the GhostCell development. More updated information can be found at http://plv.mpi-sws.org/rustbelt/ghostcell/.</p>
<p>PAPER ABSTRACT</p>
<p>The Rust language offers a promising approach to safe systems programming based on the principle of aliasing XOR mutability: a value may be either aliased or mutable, but not both at the same time. However, to implement pointer-based data structures with internal sharing, such as graphs or doubly-linked lists, we need to be able to mutate aliased state. To support such data structures, Rust provides a number of APIs that offer so-called interior mutability: the ability to mutate data via method calls on a shared reference. Unfortunately, the existing APIs sacrifice flexibility, concurrent access, and/or performance, in exchange for safety.</p>
<p>In this paper, we propose a new Rust API called GhostCell which avoids such sacrifices by separating permissions from data: it enables the user to safely synchronize access to a collection of data via a single permission. GhostCell repurposes an old trick from typed functional programming: branded types (as exemplified by Haskell’s ST monad), which combine phantom types and rank-2 polymorphism to simulate a lightweight form of state-dependent types. We have formally proven the soundness of GhostCell by adapting and extending RustBelt, a semantic soundness proof for a representative subset of Rust, mechanized in Coq.</p>

},
keywords = {Coq, Iris, Rust, RustBelt}
}

@software{10.5281/zenodo.5054898,
author = {Birkedal, Lars and Dinsdale-Young, Thomas and Gu\'{e}neau, Arma\"{e}l and Jaber, Guilhem and Svendsen, Kasper and Tzevelekos, Nikos},
title = {Theorems for Free from Separation Logic Specifications: ICFP'21 artifact},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5054898},
abstract = {
    <p>This artifact contains the Coq formalization associated with the paper “Theorems for Free from Separation Logic Specifications”. It provides both a zip archive containing the source files (free-theorems-sl-archive.zip) and a QEmu VM image (VM.zip) which has been setup with the required dependencies and the source files, and can be used to run Coq to check the proof scripts.</p>

},
keywords = {coq, iris, linearizability, separation logic}
}

@software{10.5281/zenodo.5060213,
author = {Stucki, Sandro and Giarrusso, Paolo G.},
title = {A Theory of Higher-Order Subtyping with Type Intervals — Agda Formalization},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5060213},
abstract = {
    <p>This artifact contains the mathematical proofs for the associated paper, formalized in the Agda proof assistant, both as a source archive, and as a virtual machine image containing the necessary dependencies to check the proofs.</p>

},
keywords = {Agda, bounded polymorphism, bounded type operators, dependent kinds, hereditary substitution, higher-kinded types, Scala, singleton kinds, subtyping, type intervals, type safety}
}

@software{10.5281/zenodo.5064045,
author = {M\'{e}vel, Glen and Jourdan, Jacques-Henri},
title = {Formal Verification of a Concurrent Bounded Queue in a Weak Memory Model — proof artifact},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5064045},
abstract = {
    <p>This is the artifact that accompanies the paper “Formal Verification of a Concurrent Bounded Queue in a Weak Memory Model“, published at the ICFP 2021 conference.</p>
<p>The artifact consists in a set of Coq proof scripts. A plain source code archive is provided, as well as a virtual machine in which all dependencies are already installed and the project already compiled.</p>
<p>This project is developped in this git repository, which also contains the paper: https://gitlab.inria.fr/gmevel/cosmo</p>

},
keywords = {concurrency, concurrent queue, Coq, program verification, separation logic, weak memory}
}

@software{10.5281/zenodo.5092307,
author = {Rahaman, Sydur and Neamtiu, Iulian and Yin, Xin},
title = {Replication package for article: Algebraic-Datatype Taint Tracking, with Applications to Understanding Android Identifier Leaks},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5092307},
abstract = {
    <p>Given a list of sources, this TaintTracker tool produces algebric leak signatures of the sources and also categorize the leak as third party or own code leak.</p>
<p>CFG-Generator.jar (extension of Amandroid) will generate CFG (Control Flow Graph) given an apk</p>
<p>App_Wise_Signature.py will create the leak signature given the CFG file as text input</p>

},
keywords = {android, fingerprinting, identifier leak, mobile security, static analysis, taint analysis}
}

@software{10.5281/zenodo.5094851,
author = {Chowdhary, Sangeeta and Nagarakatte, Santosh},
title = {PFPSanitizer - A Parallel Shadow Execution Tool for Debugging Numerical Errors},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5094851},
abstract = {
    <p>This is the artifact for the FSE 2021 paper - Parallel Shadow Execution to Accelerate the Debugging of Numerical Errors appearing at FSE 2021. This artifact provides the link to the source code and step-by-step instructions to reproduce the performance graphs and case study from the accepted paper. We also provide the test harness to evaluate the correctness of our tool. In this artifact, we provide the scripts and instructions required to execute the different parts of the experiment automatically.</p>

},
keywords = {FPSanitizer, numerical errors, parallel execution, PFPSanitizer}
}

@software{10.5281/zenodo.5103655,
author = {Paraskevopoulou, Zoe and Li, John M. and Appel, Andrew W.},
title = {Source code and Proof Mechanization for the Article: Compositional Optimizations for CertiCoq},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5103655},
abstract = {
    <p>The source code of the CertiCoq compiler, containing the formally verified λANF pipeline, which is presented in this article</p>

},
keywords = {compilers, compositional compiler correctness, Coq, formal verification, logical relations}
}

@software{10.5281/zenodo.5111183,
author = {Wang, Xiao and Xiao, Lu and Yu, Tingting and Woepse, Anne and Wong, Sunny},
title = {JMocker: An Automatic Refactoring Framework for ReplacingTest-Production Inheritance by Mocking Mechanism},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5111183},
abstract = {
    <p>JMocker is an Eclipse plugin for automatically identifying and refactoring the usage of inheritance for mocking by using Mockito-a well received mocking framework. The refactoring performed by JMocker can improve the quality of the unit test cases in various aspects, including improving the cohesion/concise, readability/understandability, and maintainability of unit test cases.</p>

},
keywords = {Software Refactoring, Software Testing}
}

@software{10.5281/zenodo.5111541,
author = {Zhang, Wuqi and Wei, Lili and Li, Shuqing and Liu, Yepang and Cheung, Shing-Chi},
title = {Implementation of the Detection Tool: \DH{}Archer: Detecting On-Chain-Off-Chain Synchronization Bugs in Decentralized Applications},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5111541},
abstract = {
    <p>undefinedArcher is an automated testing framework aiming to test on-chain-off-chain synchronization bugs in decentralized applications (DApps). A detailed introduction to undefinedArcher can be found in the README.md file inside the artifact.</p>

},
keywords = {dapp, ethereum, testing, testing-framework, testing-tools}
}

@software{10.6084/m9.figshare.13712827.v2,
author = {Hort, Max and Zhang, Jie M. and Sarro, Federica and Harman, Mark},
title = {Replication package for article: Fairea: A Model Behaviour Mutation Approach to Benchmarking Bias Mitigation Methods},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.13712827.v2},
abstract = {
    <p>This on-line appendix is supplementary to the paper entitled “Fairea: A Model Behaviour Mutation Approach to Benchmarking Bias Mitigation Methods”, which has been accepted at FSE’21. It contains the data used in the study, raw results, Python code for the proposed approach, and scripts to replicate our experiments.</p>

},
keywords = {software fairness}
}

@software{10.1145/3462277,
author = {Renner, John and Sanchez-Stern, Alex and Brown, Fraser and Lerner, Sorin and Stefan, Deian},
title = {Source Code and Case Studies for Scooter \&amp; Sidecar: A Domain-Specific Approach to Writing Secure Database Migrations},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462277},
abstract = {
    <p>The artifact contains the full source code for scooter and sidecar as they were originally submitted to artifact evaluation. Furthermore, the artifact contains several case studies which are discussed in the paper.</p>

},
keywords = {database migration, scooter, sidecar, SMT, verification}
}

@software{10.1145/3462281,
author = {Paluri, Pavan Kumar and Dai, Guangli and Cheng, Albert Mo Kim},
title = {Replication Package for ARINC 653-Inspired Regularity-Based Resource Partitioning on Xen},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462281},
abstract = {
    <p>Artifact Description: This artifact encompasses the RRP-Xen Domain-0 user-space packages along with RRP-Xen compliant single and multi-core ARINC 653 scheduler prototypes that are to be run in Xen hypervisor kernel. In addition, this package also includes the tools and scripts for performing RRP-Xen latency throughput experiments.</p>

},
keywords = {ARINC 653, Operating Systems, Real-Time Systems, RRP, Virtualization, Xen}
}

@software{10.5281/zenodo.4744197,
author = {Oh, Deok-Jae and Moon, Yaebin and Lee, Eojin and Ham, Tae Jun and Park, Yongjun and Lee, Jae W. and Ahn, Jung Ho},
title = {Replication Package for Article: MaPHeA: A Lightweight Memory Hierarchy-Aware Profile-Guided Heap Allocation Framework},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4744197},
abstract = {
    <p>MaPHeA (pronounced like “mafia”) is a lightweight memory hierarchy-aware profile-guided heap allocation framework. It is lightweight as it profiles the memory access information of an application via hardware-event sampling instead of heavyweight instrumentation. MaPHeA is memory hierarchy-aware by utilizing a data access profile, which provides detailed information of a memory access, such as the address and the type of the access as well as where the data resides. Using this profiling information, it analyzes which heap objects are performance-critical. For example, MaPHeA can identify the objects that are frequently accessed (i.e., hot) from a certain memory hierarchy (e.g., LLC or main memory) or cause frequent TLB misses. Then, it can guide these hot data to be allocated to fast memory or allocate the TLB-miss-prone objects to a huge page. To realize this, we modify the intermediate representation of the gcc compiler and use a wrapper to replace the default malloc functions with the ones supporting tiered memory.</p>

},
keywords = {heap allocation, heterogeneous memory system, huge page, Profile-guided optimization}
}

@software{10.6084/m9.figshare.14544477,
author = {Rocha, Rodrigo C. O. and Petoumenos, Pavlos and Wang, Zheng and Cole, Murray and Hazelwood, Kim and Leather, Hugh},
title = {Replication Package for Article, "HyFM: Function Merging for Free"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.14544477},
abstract = {
    <p>This artifact contains a description of how to download and replicate the results achieved by the LCTES paper, titled “HyFM: Function Merging for Free”. It also includes the LLVM source code with the SalSSA and HyFM implementation.</p>

},
keywords = {Code-Size Reduction, Function Merging, Interprocedural Optimization, Link-Time Optimization, LLVM}
}

@software{10.1145/3410284,
author = {Szab\'{o}, Tam\'{a}s and Erdweg, Sebastian and Bergmann, G\'{a}bor},
title = {Replication Package for Article: Incremental Whole-Program Analysis in Datalog with Lattices},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410284},
abstract = {
    <p>This is an Ubuntu-based virtual machine with the IncA program analysis framework and benchmark Java programs already set up on it. The artifact can be used to execute the incremental static analyses described in the paper “Incremental Whole-Program Analysis in Datalog with Lattices” and to reproduce the presented measurement results.</p>

},
keywords = {Datalog, Incremental Computing, Static Analysis}
}

@software{10.1145/3410285,
author = {Guria, Sankha Narayan and Foster, Jeffrey S. and Van Horn, David},
title = {Replication Package for Article: RbSyn: Type- and Effect-Guided Program Synthesis},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410285},
abstract = {
    <p>The artifact is a Docker image that contains all of the source code, benchmarks, and experiment harnesses used in the development of the paper (set-up and ready to run). The README contains instructions to reproduce results from the paper, as well as pointers for how to extend or modify the tool and benchmarks.</p>

},
keywords = {program synthesis, Ruby, type and effect systems}
}

@software{10.1145/3410286,
author = {Erdweg, Sebastian and Szab\'{o}, Tam\'{a}s and Pacak, Andr\'{e}},
title = {Artifact: Concise, Type-Safe, and Efficient Structural Diffing},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410286},
abstract = {
    <p>Implementation of the algorithm in Scala; benchmark code and data.</p>

},
keywords = {incremental computing, tree diffing}
}

@software{10.1145/3410287,
author = {Bonaert, Gregory and Dimitrov, Dimitar I. and Baader, Maximilian and Vechev, Martin},
title = {Artifact for PLDI'21 paper #156 "Fast and Precise Certification of Transformers"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410287},
abstract = {
    <p>We present DeepT, a novel method for certifying Transformer networks based on abstract interpretation. The key idea behind DeepT is our new multi-norm Zonotope abstract domain, an extension of the classical Zonotope designed to handle L1 and L2-norm bound perturbations. This artifact contains the source code, Transformer networks, scripts and Jupyter notebooks for the DeepT verifier and can be used to reproduce the core results of the paper “Fast and Precise Certification of Transformers”, published at the PLDI’21 conference.</p>

},
keywords = {Abstract Interpretation, Adversarial attacks, Deep Learning, Robustness Certification, Transformer Networks}
}

@software{10.1145/3410288,
author = {Montagu, Beno\^{\i}t and Jensen, Thomas},
title = {Static Control-Flow Analyzers for the Article: Trace-Based Control-Flow Analysis},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410288},
abstract = {
    <p>The artifact contains prototype implementations of the static analyzers for control-flow analysis (CFA) described in the PLDI’21 article “Trace-Based Control-Flow Analysis”, a collection of program examples, and a procedure to reproduce the experimental results presented in the article. The artifact is a TAR.XZ archive, that contains a README file, a LICENSE file and two components. The first component is the OCaml source code of the analyzers. We also provide a version of the analyzers that runs in a web browser directly. The second component is a docker container that embeds the same sources and a minimal Linux environment so that you can compile the sources and execute the analyzers. The README file describes with details the procedure to build and run the artifact using the docker container.</p>

},
keywords = {CFA, control-flow analysis, lambda-calculus, static analysis, widening}
}

@software{10.1145/3410289,
author = {Baudart, Guillaume and Burroni, Javier and Hirzel, Martin and Mandel, Louis and Shinnar, Avraham},
title = {Replication package for the article: Compiling Stan to Generative Probabilistic Languages and Extension to Deep Probabilistic Programming},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410289},
abstract = {
    <p>This artifact contains the <a href="https://mc-stan.org">Stan</a> (+ extensions) to Pyro and NumPyro compiler presented in the paper, and the code to reproduce the evaluation.</p>
<p>The artifact comprises 3 main parts corresponding to the 3 top-level directories. - <code>stanc3</code>: the fork of the <a href="https://github.com/stan-dev/stanc3">Stanc3 compiler</a> with two new backends targeting <a href="http://pyro.ai/">Pyro</a> and <a href="https://github.com/pyro-ppl/numpyro">NumPyro</a> (clone of https://github.com/deepppl/stanc3) - <code>stan-num-pyro</code>: the Pyro and NumPyro runtime libraries to execute the program (clone of https://github.com/deepppl/stan-num-pyro) - <code>evaluation</code>: code and data to reproduce the evaluation section of the paper (clone of https://github.com/deepppl/evaluation)</p>
<p>In addition the artifact also contains: - <code>README.md</code>: this file - <code>deepstan.tar.gz</code>: a Docker image with the compiler and runtime installed - <code>pldi2021.pdf</code>: the paper - <code>coin.stan</code>: a simple Stan program - <code>coin_infer.py</code>: a Python script to compile and execute <code>coin.stan</code> - <code>requirements.txt</code>: the list of Python dependencies - <code>deepstan.docker</code>: the docker file used to build the image.</p>
<p>To summarize this artifact: - Demonstrates that it is possible to compile Stan programs to generative probabilistic programming languages by providing a modified version of the Stanc3 compiler with two new backends targeting Pyro and NumPyro. - Demonstrates the extension of Stan with deep probabilistic programming and variational inference with explicit guides. - Provides the code used in the evaluation section of the paper to answer the following research questions: - RQ1: Can we compile and run all Stan models? - RQ2: What is the impact of the compilation on accuracy? - RQ3: What is the impact of the compilation on speed? - RQ4: Are explicit variational guides useful? - RQ5: For deep probabilistic models, how does DeepStan compare to hand-written Pyro code?</p>

},
keywords = {Compilation, Deep probabilistic programming, NumPyro, Probabilistic programming, Pyro, Stan, Variational inference}
}

@software{10.1145/3410290,
author = {Anderson, Daniel and Blelloch, Guy E. and Wei, Yuanhao},
title = {Artifact for "Concurrent Deferred Reference Counting with Constant-Time Overhead"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410290},
abstract = {
    <p>This artifact contains a preliminary version of our C++ library for atomic reference-counted pointers and a benchmark suite that evaluates its performance against existing reference-counted pointers and manual SMR techniques.</p>

},
keywords = {automatic memory management, concurrent algorithms, memory reclamation, reference counting}
}

@software{10.1145/3410291,
author = {Yu, Nengkun and Palsberg, Jens},
title = {Software artifact for the paper "Quantum Abstract Interpretation"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410291},
abstract = {
    <p>The artifact allows a user to reproduce the experimental results in the paper “Quantum Abstract Interpretation”.</p>

},
keywords = {abstract interpretation., Quantum programming, scalability}
}

@software{10.1145/3410292,
author = {Cho, Kyeongmin and Lee, Sung-Hwan and Raad, Azalea and Kang, Jeehoon},
title = {Mechanized Proof and Model Checker for Article: Revamping Hardware Persistency Models},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410292},
abstract = {
    <h2 id="revamping-hardware-persistency-models-view-based-and-axiomatic-persistency-models-for-intel-x86-and-armv8">Revamping Hardware Persistency Models: View-Based and Axiomatic Persistency Models for Intel-x86 and Armv8</h2>
<p>This is the artifact for the following paper:</p>
<p>Kyeongmin Cho, Sung-Hwan Lee, Azalea Raad, and Jeehoon Kang. Revamping Hardware Persistency Models: View-Based and Axiomatic Persistency Models for Intel-x86 and Armv8. PLDI 2021.</p>
<h3 id="contributions-paper-1">Contributions (paper §1)</h3>
<ul>
<li>We discuss the shortcomings of the existing persistency models of Intel-x86/Armv8 and present an intuitive account of our solution as view-based models (§2).</li>
<li>We develop x86_view, a new view-based model for Intelx86 concurrency (§3).</li>
<li>We develop Px86_view (§3.5) and PArmv8_view (§6.2), respectively extending the x86_view and Armv8_view models to account for persistent memory.</li>
<li>We present Px86_axiom (§4) and PArmv8_axiom (§6.3), our axiomatic models of Intel-x86 and Armv8 persistency that simplify and repair the state-of-the-art models of the respective architectures. We prove that our axiomatic models are equivalent to the authoritative semantics reviewed by Intel and Arm engineers, modulo our proposed fixes (§4.4 and §6.3). Our proposed fix in PArmv8_axiom has been reviewed by Arm engineers.</li>
<li>We prove that Px86_view and PArmv8_view are equivalent to Px86_axiom and PArmv8_axiom, respectively. The equivalence proof is mechanized in Coq (§5 and §6.4).</li>
<li>We develop a model checker for persistency and use it to verify several representative examples under PArmv8view (§7). We conclude with related and future work (§8).</li>
</ul>
<h3 id="artifacts">Artifacts</h3>
<ul>
<li>Coq formalization (§2-6) of the hardware persistency models (Px86-{view, axiom}, PArmv8-{view, axiom}) and their equivalence proofs</li>
<li>Model checker (§7) for Armv8 persistency</li>
</ul>
<h3 id="getting-started-guide">Getting Started Guide</h3>
<p>Each of Coq formalization and model checker has its own repository: - Coq formalization’s <a href="https://github.com/kaist-cp/view-hw/blob/master/README.md">repository</a> - Model checker’s <a href="https://github.com/kaist-cp/rmem-persistency">repository</a>.</p>
<p>These repositories are forks of <a href="https://github.com/snu-sf/promising-arm">snu-sf/promising-arm</a> and <a href="https://github.com/rems-project/rmem">rems-project/rmem</a>, respectively.</p>
<p>For each repository, you can either manually build it or reuse docker images in which the projects are already built.</p>
<h4 id="manual-build">Manual build</h4>
<p>Please read each repository’s README:</p>
<ul>
<li>Coq formalization’s <a href="https://github.com/kaist-cp/view-hw/blob/master/README.md#installation">README</a></li>
<li>Model checker’s <a href="https://github.com/kaist-cp/rmem-persistency#build">README</a></li>
</ul>
<h4 id="docker-image">Docker image</h4>
<p>Each repository contains a <code>Dockerfile</code>:</p>
<ul>
<li>Coq formalization’s <a href="https://github.com/kaist-cp/view-hw/blob/master/Dockerfile">Dockerfile</a></li>
<li>Model checker’s <a href="https://github.com/kaist-cp/rmem-persistency/blob/master/Dockerfile">Dockerfile</a></li>
</ul>
<p>You can download the prebuilt docker images <a href="https://drive.google.com/drive/folders/1HCojYdChl1qsSTHDrjWdAzS8SE2NRuLC?usp=sharing">here</a>.</p>
<h3 id="step-by-step-instructions">Step-by-Step Instructions</h3>
<ul>
<li>Coq formalization’s <a href="https://github.com/kaist-cp/view-hw/blob/master/README.md#our-results">README</a> explains which part of codes matches one of definitions, lemmas and theorems in the paper.</li>
<li>Model checker’s <a href="https://github.com/kaist-cp/rmem-persistency#run-an-example">README</a> exlains how to run the program to verify each example in the paper. It’s expected that all results come out within 1 second as mentioned in the paper.</li>
</ul>

},
keywords = {Armv8, mechanized proof, model checker, non-volatile random-access memory, NVRAM, persistency semantics, persistent memory, x86}
}

@software{10.1145/3410293,
author = {Wang, Di and Hoffmann, Jan and Reps, Thomas},
title = {Replication Package for Article: Central Moment Analysis for Cost Accumulators in Probabilistic Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410293},
abstract = {
    <p>This artifact provides an implementation of a static analyzer for higher (raw or central) moments of cost accumulators (e.g., running time) in probabilistic programs.</p>

},
keywords = {central moments, cost analysis, Probabilistic programs, tail bounds}
}

@software{10.1145/3410294,
author = {Sotoudeh, Matthew and Thakur, Aditya V.},
title = {Replication Package for Article: Provable Repair of Deep Neural Networks},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410294},
abstract = {
    <p>The zip file contains our artifact as a virtual machine as well as a README with instructions. An updated version of this artifact is stored at https://github.com/95616ARG/PRDNN</p>

},
keywords = {deep learning, machine learning, program repair}
}

@software{10.1145/3410295,
author = {Erbsen, Andres and Gruetter, Samuel and Choi, Joonwon and Wood, Clark and Chlipala, Adam},
title = {Replication Package for Article: Integration Verification across Software and Hardware for a Simple Embedded System},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410295},
abstract = {
    <p>This artifact includes the Coq development described in the paper and all dependencies for generating the FPGA bitstream. All this is packaged as a .vdi disk image that boots into a Linux terminal environment accessible over SSH. The artifact was evaluated by running it in VirtualBox as described in README.txt.</p>

},
keywords = {Embedded Systems, Formal Verification, Hardware-Software Interface, Proof Assistants, RISC-V Instruction-Set Family}
}

@software{10.1145/3410296,
author = {Stanford, Caleb and Veanes, Margus and Bj\o{}rner, Nikolaj},
title = {dZ3: Artifact for "Symbolic Boolean Derivatives for Efficiently Solving Extended Regular Expression Constraints"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410296},
abstract = {
    <p>This is the artifact for the paper: Symbolic Boolean Derivatives for Efficiently Solving Extended Regular Expression Constraints. This artifact is provided as a Docker container for the artifact evaluation for PLDI 2021.</p>
<p>If convenient, you can also view the artifact files online on GitHub at https://github.com/cdstanford/dz3-artifact. The GitHub repository contains everything in the Docker container except the solver binaries, which are too large.</p>

},
keywords = {regex, regular expression, SMT, string, Z3}
}

@software{10.1145/3410297,
author = {Hu, Xiaowen and Zhao, David and Jordan, Herbert and Scholz, Bernhard},
title = {Artifact for Paper: An Efficient Interpreter for Datalog by De-specializing Relations},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410297},
abstract = {
    <p>The artifact provides source code, experiments input and necessary instructions for reproducing the primary results in the paper “An Efficient Interpreter for Datalog by De-specializing Relations”.</p>

},
keywords = {Datalog, interpreter, static analysis}
}

@software{10.1145/3410298,
author = {Koenig, Jason R. and Padon, Oded and Aiken, Alex},
title = {Replication Package for Article: Adaptive Restarts for Stochastic Synthesis},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410298},
abstract = {
    <p>This artifact contains the synthesis evaluation program and Superoptimization Benchmark of synthesis problems, experimental data, code for scraping new synthesis problems, input binaries for scraping, chart generating scripts, and other support scripts.</p>

},
keywords = {binary code, program synthesis, restart algorithms, superoptimization}
}

@software{10.1145/3410299,
author = {Acay, Co\c{s}ku and Recto, Rolph and Gancher, Joshua and Myers, Andrew C. and Shi, Elaine},
title = {Replication Package for Viaduct: An Extensible, Optimizing Compiler for Secure Distributed Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410299},
abstract = {
    <p>This artifact contains code and instructions necessary to replicate experimental results in the article “Viaduct: An Extensible, Optimizing Compiler for Secure Distributed Programs.” We provide a Docker image with the Viaduct compiler and all its dependencies installed, as well as the code samples used in the evaluation. The image also includes scripts for running the experiments from the paper.</p>

},
keywords = {information flow, multiparty computation, zero knowledge}
}

@software{10.1145/3410300,
author = {Wang, Di and Hoffmann, Jan and Reps, Thomas},
title = {Replication Package for Article: Sound Probabilistic Inference via Guide Types},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410300},
abstract = {
    <p>This artifact provides an implementation of a probabilistic programming language that (i) features a coroutine-based paradigm for implementing generative models and custom inference guides (e.g., proposals for importance sampling), and (ii) uses a novel guide-type system to ensure that the distributions specified by a model and its guide have the same support; as a consequence, the model-guide pair is provably sound for probabilistic inference.</p>

},
keywords = {Bayesian inference, coroutines, Probabilistic programming, type systems}
}

@software{10.1145/3410301,
author = {Saad, Feras A. and Rinard, Martin C. and Mansinghka, Vikash K.},
title = {System Implementation and Experiments for SPPL: Probabilistic Programming with Fast Exact Symbolic Inference},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410301},
abstract = {
    <p>This artifact contains an implementation of the SPPL programming language (version 2.0.0), as well as code for experimental results and tutorial figures described in the paper.</p>

},
keywords = {probabilistic programming, symbolic execution}
}

@software{10.1145/3410302,
author = {Ellis, Kevin and Wong, Catherine and Nye, Maxwell and Sabl\'{e}-Meyer, Mathias and Morales, Lucas and Hewitt, Luke and Cary, Luc and Solar-Lezama, Armando and Tenenbaum, Joshua B.},
title = {DreamCoder software and data},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410302},
abstract = {
    <p>Source code for DreamCoder, pretrained checkpoints, and documentation</p>

},
keywords = {artificial intelligence, deep learning, program synthesis}
}

@software{10.1145/3410303,
author = {Nikolaev, Ruslan and Ravindran, Binoy},
title = {Replication Package for Article: Snapshot-Free, Transparent, and Robust Memory Reclamation for Lock-Free Data Structures},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410303},
abstract = {
    <p>The artifact contains a VM image (VirtualBox) with preinstalled Ubuntu 18.04 and the (precompiled) benchmark. The artifact also contains source code and instructions for manual (bare-metal) installations. The artifact also includes our data measurements and scripts for generating plots. Please see README.txt for more details.</p>

},
keywords = {epoch-based reclamation, hazard pointers, lock-free, memory reclamation, non-blocking}
}

@software{10.1145/3410304,
author = {Chatterjee, Krishnendu and Goharshady, Ehsan Kafshdar and Novotn\'{y}, Petr and \v{Z}ikeli\'{c}, undefinedor\dj{}e},
title = {RevTerm},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410304},
abstract = {
    <p>RevTerm is a static analysis tool for proving non-termination of integer C programs (possibly with non-determinism). RevTerm is an implementation of our method for non-termination proving presented in the paper “Proving Non-termination by Program Reversal”.</p>

},
keywords = {Program Termination, Static Analysis}
}

@software{10.1145/3410305,
author = {Malik, Raghav and Singhal, Vidush and Gottfried, Benjamin and Kulkarni, Milind},
title = {COPSE artifact for Vectorized Secure Evaluation of Decision Forests},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410305},
abstract = {
    <p>The artifact is a Docker image that contains prebuilt versions of the benchmarks used to evaluate the paper, as well as a set of scripts to automatically run them and collect data.</p>

},
keywords = {Fully homomorphic encryption, vectorization}
}

@software{10.1145/3410306,
author = {Koenig, J\'{e}r\'{e}mie and Shao, Zhong},
title = {Source code and virtual machine image for CompCertO: Compiling Certified Open C Components},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410306},
abstract = {
    <p>This artifact contains the source code for CompCertO v0.1 and a virtual machine image where all required dependencies have been installed on a Debian GNU/Linux system. The virtual machine image also contains a pre-built version of CompCertO and its documentation, which can immediately be browsed in CoqIDE and Firefox.</p>

},
keywords = {CompCert, Compilers, Compositional compiler correctness, Game semantics, Language interface, Simulation convention, Software verification}
}

@software{10.1145/3410307,
author = {Thakkar, Aalok and Naik, Aaditya and Sands, Nathaniel and Alur, Rajeev and Naik, Mayur and Raghothaman, Mukund},
title = {Example-Guided Synthesis of Relational Queries},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410307},
abstract = {
    <p>Tool for end-to-end automated synthesis of relational queries from input-output examples.</p>

},
keywords = {Program Synthesis, Programming-by-example}
}

@software{10.1145/3410308,
author = {Mirman, Matthew and H\"{a}gele, Alexander and Bielik, Pavol and Gehr, Timon and Vechev, Martin},
title = {Replication Package for Robustness Certification with Generative Models},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410308},
abstract = {
    <p>This is the code necessary to reproduce the experiments found within the paper.</p>

},
keywords = {Abstract Interpretation, Deep Learning, Verification}
}

@software{10.1145/3410310,
author = {Wang, Jinyi and Sun, Yican and Fu, Hongfei and Chatterjee, Krishnendu and Goharshady, Amir Kafshdar},
title = {Replication Package for Article: Quantitative Analysis of Assertion Violations in Probabilistic Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410310},
abstract = {
    <p>This artifact contains our implementation of three synthesis algorithms as described in the paper. Algorithm 1&amp;2 are listed in section 5.1 \&amp; 5.2 and Algorithm 3 is in section 6.</p>

},
keywords = {Assertion, Automated Verification, Probabilistic Programs}
}

@software{10.1145/3410311,
author = {Basu, Nilanjana and Montanari, Claudio and Eriksson, Jakob},
title = {Replication Package for Frequent Background Polling on a Shared Thread, using Light-Weight Compiler Interrupts},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410311},
abstract = {
    <p>The artifact contains the libraries for a Compiler Interrupt pass, \&amp; the code for all experiments reported in the paper.</p>

},
keywords = {Compiler Interrupts, interrupt accuracy and overhead}
}

@software{10.1145/3410312,
author = {Sivaramakrishnan, KC and Dolan, Stephen and White, Leo and Kelly, Tom and Jaffer, Sadiq and Madhavapeddy, Anil},
title = {Replication Package for Article: Retrofitting Effect Handlers onto OCaml},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410312},
abstract = {
    <p>The artifact contains all the materials needed to reproduce and extend the results of the work. It includes the Multicore OCaml compiler, package dependencies, benchmarks, and the scripts to run and produce the results from the paper.</p>

},
keywords = {Concurrency, Effect handlers, Generators, OCaml, Web server}
}

@software{10.1145/3410313,
author = {Zhu, Shaowei and Kincaid, Zachary},
title = {Replication Package for Article: Termination Analysis without the Tears},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410313},
abstract = {
    <p>The artifact is a virtual machine that contains ComPACT, a compositional and monotone termination analysis for C programs. The virtual machine also contains all softwares and their dependencies required to replicate the experimental results of PLDI 2021 paper “Termination Analysis without the Tears”.</p>

},
keywords = {algebraic path problems, Algebraic program analysis, loop summarization, termination analysis}
}

@software{10.1145/3462276,
author = {Omar, Cyrus and Moon, David and Blinn, Andrew and Voysey, Ian and Collins, Nick and Chugh, Ravi},
title = {Evaluted Artifact for: Filling Typed Holes with Live GUIs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462276},
abstract = {
    <p>Agda proofs and snapshot of Hazel implementation described in the paper.</p>

},
keywords = {GUIs, live programming, macros, typed holes}
}

@software{10.1184/R1/14356976,
author = {Takashima, Yoshiki and Martins, Ruben and Jia, Limin and P\u{a}s\u{a}reanu, Corina S.},
title = {SyRust Artifact: PLDI2021 Artifact},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1184/R1/14356976},
abstract = {
    <p>This artifact contains software required to replicate the results of the paper “SyRust: Automatic Testing of Rust Libraries with Semantic-Aware Program Synthesis” published at PLDI 2021.</p>
<p>The artifact consists of SyRust source code, configuration files to fully replicate our experiments, post-processing scripts to summarize data, and docker images for maintaining and environment for replicability.</p>

},
keywords = {API Testing, Rust, Security, Software Engineering, Synthesis}
}

@software{10.5281/zenodo.4649822,
author = {Sammler, Michael and Lepigre, Rodolphe and Krebbers, Robbert and Memarian, Kayvan and Dreyer, Derek and Garg, Deepak},
title = {Artifact and Appendix of "RefinedC: Automating the Foundational Verification of C Code with Refined Ownership Types"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4649822},
abstract = {
    <p>This is the artifact for the PLDI’21 paper “RefinedC: Automating the Foundational Verification of C Code with Refined Ownership Types”. It contains the RefinedC tool including its Coq development and the appendix for the paper.</p>

},
keywords = {C programming language, Coq, Iris, ownership types, proof automation, refinement types, separation logic}
}

@software{10.5281/zenodo.4663105,
author = {Kostyukov, Yurii and Mordvinov, Dmitry and Fedyukovich, Grigory},
title = {Artifact Evaluation for "Beyond the Elementary Representations of Program Invariants over Algebraic Data Types" paper},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4663105},
abstract = {
    <p>An <code>Ubuntu20.04.ova</code> file provided is the VM snapshot with an artifact installed.</p>
<p>The artifact is provided to support the result of the Evaluation section of the paper “Beyond the Elementary Representations of Program Invariants over Algebraic Data Types” submitted to PLDI 2021.</p>
<p>Paper results reproduction instructions are contained in the <code>README.txt</code> file.</p>

},
keywords = {algebraic data types, finite models, first-order definability, invariant representation, invariants, tree automata}
}

@software{10.5281/zenodo.4663292,
author = {Stein, Benno and Chang, Bor-Yuh Evan and Sridharan, Manu},
title = {Artifact for Article: Demanded Abstract Interpretation},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4663292},
abstract = {
    <p>The artifact is a docker image containing source code and binaries needed to reproduce the paper’s experiments.</p>

},
keywords = {Abstract interpretation, demand-driven analysis, incremental analysis}
}

@software{10.5281/zenodo.4665859,
author = {Paradis, Anouk and Bichsel, Benjamin and Steffen, Samuel and Vechev, Martin},
title = {Replication Package for Article: Unqomp: Synthesizing Uncomputation in Quantum Circuits},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4665859},
abstract = {
    <p>This is a snapshot of Unqomp, providing the artifact for the PLDI’21 paper “Unqomp: Synthesizing Uncomputation in Quantum Circuits”. For the latest version of Unqomp, refer to https://github.com/eth-sri/Unqomp.</p>
<p>It contains the implementation of Unqomp for Qiskit, as well as all the necessary material to reproduce the evaluation of our paper.</p>

},
keywords = {Quantum Circuits, Synthesis, Uncomputation}
}

@software{10.5281/zenodo.4668317,
author = {Shariffdeen, Ridwan and Noller, Yannic and Grunske, Lars and Roychoudhury, Abhik},
title = {Replication Package for: Concolic Program Repair},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4668317},
abstract = {
    <p>This is the artifact for the PLDI’2021 submission “Concolic Program Repair”. It includes the following content: * the tool CPR, which implements our concolic program repair concept, * all benchmark subjects and scripts to reproduce our evaluation, and * additional documentation to allow the re-usage of CPR, as well as helpful examples.</p>

},
keywords = {patch overfitting, program repair, program synthesis, symbolic execution}
}

@software{10.5281/zenodo.4671078,
author = {Ringer, Talia and Porter, RanDair and Yazdani, Nathaniel and Leo, John and Grossman, Dan},
title = {PUMPKIN Pi},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4671078},
abstract = {
    <p>This is the artifact for the PLDI 2021 paper “Proof Repair Across Type Equivalences.” The anonymized version has been vetted by AEC as functional and reusable. A deanonymized version corresponding to the links in the paper has been uploaded as a second version (version “deanonymized”).</p>

},
keywords = {Coq, interactive theorem provers, proof assistants, proof engineering, proof evolution, proof repair}
}

@software{10.5281/zenodo.4674301,
author = {P\^{\i}rlea, George and Kumar, Amrit and Sergey, Ilya},
title = {CoSplit (PLDI 2021 Artefact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4674301},
abstract = {
    <p>Virtual machine: The CoSplit.ova file is a virtual machine image containing the full artefact, including the CoSplit static analysis, its integration with the Zilliqa blockchain, the benchmark suite used for evaluation, the Ethereum dataset, and the Jupyter notebook used to analyse the dataset. This is the artefact that was evaluated during the PLDI 2021 Artifact Evaluation process.</p>
<p>The virtual machine image was generated using Virtual Box Version 6.1.18 r142142 and is known to work with that version of the software.</p>
<p>Source code: Please download cosplit-artefact-archive.zip. This includes the full source code, including dependencies, and the Ethereum dataset. The archive produced by GitHub (dranov/cosplit-artefact-v0.1-beta.zip) does not include the dependencies and dataset.</p>

},
keywords = {automatic parallelisation, blockchain, sharding, smart contracts, static analysis}
}

@software{10.5281/zenodo.4678051,
author = {Ye, Guixin and Tang, Zhanyong and Tan, Shin Hwei and Huang, Songfang and Fang, Dingyi and Sun, Xiaoyang and Bian, Lizhong and Wang, Haibo and Wang, Zheng},
title = {COMFORT: v1.0},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4678051},
abstract = {
    <p>COMFORT is a deep-learning-based compiler fuzzer for testing JavaScript engine bugs, including conformance bugs (JS compiler implementations that violate a specification defined in the relevant ECMAScript-262 standard). The corresponding research paper, “Automated Conformance Testing for JavaScript Engines via Deep Compiler Fuzzing,” appeared in PLDI 2021.</p>

},
keywords = {Compiler Fuzzing, Conformance bugs, Deep Learning, JavaScript}
}

@software{10.5281/zenodo.4678459,
author = {Tao, Runzhou and Shi, Yunong and Yao, Jianan and Hui, John and Chong, Frederic T. and Gu, Ronghui},
title = {Artifact for PLDI 2021 Paper Gleipnir: Toward Practical Error Analysis for Quantum Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4678459},
abstract = {
    <p>Artifact for PLDI 2021 Paper Gleipnir: Toward Practical Error Analysis for Quantum Programs The artifact contains the docker image file needed to reproduce the results presented in the paper.</p>

},
keywords = {approximate computing, error analysis, Quantum programming}
}

@software{10.5281/zenodo.4678520,
author = {Xu, Dongpeng and Liu, Binbin and Feng, Weijie and Ming, Jiang and Zheng, Qilong and Li, Jing and Yu, Qiaoyan},
title = {Artifact Evaluation for "Boosting SMT Solver Performance on Mixed-Bitwise-Arithmetic Expressions"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4678520},
abstract = {
    <p>The artifact is for evaluating the result from the paper “Boosting SMT Solver Performance on Mixed-Bitwise-Arithmetic Expressions.” Please read the README file before you run the program.</p>

},
keywords = {Mixed Boolean Arithmetic, Simplification, SMT Solvers}
}

@software{10.5281/zenodo.4679316,
author = {Kalhauge, Christian Gram and Palsberg, Jens},
title = {Artifact from "Logical Bytecode Reduction"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4679316},
abstract = {
    <p>The artifact is a Virtual Box containing the results and everything to reproduce the results of the paper. Furthermore, it contains the source code of jreduce.</p>
<p>More information can be found in the REAMDE file in the artifact or at https://github.com/ucla-pls/pldi21-artifact/blob/master/README.md</p>

},
keywords = {input reduction}
}

@software{10.5281/zenodo.4679743,
author = {Itzhaky, Shachar and Peleg, Hila and Polikarpova, Nadia and Rowe, Reuben N. S. and Sergey, Ilya},
title = {Cypress (PLDI 2021 Artifact): Code and Benchmarks},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4679743},
abstract = {
    <p>Artifact accompanying the the paper Cyclic Program Synthesis published in proceedings of PLDI 2021.</p>

},
keywords = {cyclic proofs, program synthesis, program verification, separation logic}
}

@software{10.5281/zenodo.4679931,
author = {Cho, Minki and Lee, Sung-Hwan and Hur, Chung-Kil and Lahav, Ori},
title = {Artifact for the paper "Modular Data-Race-Freedom Guarantees in the Promising Semantics"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4679931},
abstract = {
    <p>The artifact for the paper “Modular Data-Race-Freedom Guarantees in the Promising Semantics” (PLDI 2021). It contains mechanized proofs in Coq and script code for performance evaulation.</p>

},
keywords = {Compiler Optimizations, Data Race Freedom, Operational Semantics, Relaxed Memory Concurrency}
}

@software{10.5281/zenodo.4679983,
author = {Christensen, Michael and Sherwood, Timothy and Balkind, Jonathan and Hardekopf, Ben},
title = {Replication Package for Artifact: "Wire Sorts: A Language Abstraction for Safe Hardware Composition"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4679983},
abstract = {
    <p>This artifact contains the code for reproducing the results in the paper “Wire Sorts: A Language Abstraction for Safe Hardware Composition.” Its purpose is to demonstrate how our tool can analyze and annotate hardware modules in order to determine their input and output wire sorts (and check these sorts against any user ascriptions), as well as use these sorts to improve intermodular connection checks.</p>

},
keywords = {combinational cycle detection, composition, hardware description languages, modules}
}

@software{10.5281/zenodo.4680045,
author = {Vega, Luis and McMahan, Joseph and Sampson, Adrian and Grossman, Dan and Ceze, Luis},
title = {Replication package for Reticle: A Virtual Machine for Programming Modern FPGAs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4680045},
abstract = {
    <p>Virtual machine image containing all necessary dependencies for running the evaluation in the paper</p>

},
keywords = {compilers, FPGAs}
}

@software{10.5281/zenodo.4680245,
author = {Friedman, Michal and Petrank, Erez and Ramalhete, Pedro},
title = {Mirror: Making Lock-Free Data Structures Persistent},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4680245},
abstract = {
    <p>This artifact provides a way to test different concurrent, persistent and lock-free data structures that were specifically designed for non-volatile memory.</p>

},
keywords = {concurrent data structures, lock-free, Non-volatile memory}
}

@software{10.5281/zenodo.4680470,
author = {Donaldson, Alastair F. and Thomson, Paul and Teliman, Vasyl and Milizia, Stefano and Maselco, Andr\'{e} Perez and Karpi\'{n}ski, Antoni},
title = {Artifact for "Test-Case Reduction and Deduplication Almost for Free with Transformation-Based Compiler Testing", PLDI 2021},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4680470},
abstract = {
    <p>Artifact associated with PLDI paper, providing the version of the spirv-fuzz tool that was used for evaluation in the paper, together with the ability to reproduce a number of results using the SwiftShader implementation of SPIR-V, as well as data sets associated with the full set of experiments reported in the paper.</p>

},
keywords = {Compilers, metamorphic testing, SPIR-V}
}

@software{10.5281/zenodo.4680746,
author = {Spies, Simon and G\"{a}her, Lennard and Gratzer, Daniel and Tassarotti, Joseph and Krebbers, Robbert and Dreyer, Derek and Birkedal, Lars},
title = {Coq Development for "Transfinite Iris: Resolving an Existential Dilemma of Step-Indexed Separation Logic"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4680746},
abstract = {
    <p>This is the artifact for the paper “Transfinite Iris: Resolving an Existential Dilemma of Step-Indexed Separation Logic”. It contains the Coq mechanization of Transfinite Iris, in particular its soundness proof, program logics, and the examples presented in the paper. The artifact contains the Transfinite Iris development both in a VM image with pre-built sources and as a .zip source archive.</p>

},
keywords = {Coq, Iris, mechanized proofs, separation logic, transfinite step-indexing}
}

@software{10.5281/zenodo.4681027,
author = {Castro-Perez, David and Ferreira, Francisco and Gheri, Lorenzo and Yoshida, Nobuko},
title = {Zooid: a DSL for Certified Multiparty Computation},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4681027},
abstract = {
    <p>This is the implementation and Coq mechanisation of the metathory of Multiparty Session Types (MPST) as described on the paper.</p>

},
keywords = {concur- rent processes, Coq, deadlock freedom, liveness, mechanisation, multiparty session types, protocol compliance}
}

@software{10.5281/zenodo.4681598,
author = {Lasser, Sam and Casinghino, Chris and Fisher, Kathleen and Roux, Cody},
title = {CoStar parser implementation, correctness proofs, and performance evaluation},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4681598},
abstract = {
    <p>Artifact submitted for evaluation along with the PLDI 2021 paper "CoStar: A Verified ALL(*) Parser."</p>

},
keywords = {interactive theorem proving, parsing}
}

@software{10.5281/zenodo.4682081,
author = {Liu, Bozhen and Liu, Peiming and Li, Yanze and Tsai, Chia-Che and Da Silva, Dilma and Huang, Jeff},
title = {Artifact: When Threads Meet Events: Efficient and Precise Static Race Detection with Origins},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4682081},
abstract = {
    <p>This is the artifact of O2 from paper “When Threads Meet Events: Efficient and Precise Static Race Detection with Origins” published in PLDI’21 (https://doi.org/10.1145/3453483.3454073). O2 detects data races in large complex multithreaded and event-driven software. O2 is powered by “origins”, an abstraction that unifies threads and events by treating them as entry points of code paths attributed with data pointers. We have implemented O2 for both C/C++ and JVM applications and applied it to a wide range of open source software (e.g., DaCapo Benchmarks, HDFS, Yarn, Zookeeper, Firefox Focus, Memcached, Linux kernel).</p>

},
keywords = {Data Race Detection, Origins, Pointer Analysis, Static Analysis}
}

@software{10.5281/zenodo.4682172,
author = {Bruno, Rodrigo and Jovanovic, Vojin and Wimmer, Christian and Alonso, Gustavo},
title = {Compiler-Assisted Object Inlining with Value Fields},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4682172},
abstract = {
    <p>Object Oriented Programming has flourished in many areas ranging from web-oriented microservices, data processing, to databases. However, while representing domain entities as objects is appealing to developers, it leads to high data fragmentation as data is loaded into applications as large collections of data objects, resulting in high memory footprint and poor locality.</p>
<p>To minimize memory footprint and increase memory locality, embedding the payload of an object into another object (object inlining) has been considered before but existing techniques present severe limitations that prevent it from becoming a widely adopted technique. We argue that object inlining is mostly useful to optimize the application data-path and that objects in the data-path have value semantics, which unlocks great potential for inlining objects. We therefore propose value fields, an abstraction which allows fields to be marked as having value semantics.</p>
<p>We implement value fields for GraalVM Native Image. Object inlining is implemented as a compiler pipeline phase that mutates both object layouts and application code to access inlined fields. Experimental evaluation shows that applying value fields in real-world frameworks such as Apache Spark, Spring Boot, and Micronaut, requires minimal or even no effort at all from developers. Results show improvements in throughput of up to 3x, memory footprint reduction of up to 40\% and reduced GC pause times of up to 35\%.</p>

},
keywords = {Compiler Optimization, Language Implementation, Memory Management, Object Oriented, Programming Runtime Systems}
}

@software{10.5281/zenodo.4682681,
author = {Prabhu, Sumanth and Fedyukovich, Grigory and Madhukar, Kumar and D'Souza, Deepak},
title = {Artifact for the paper Specification Synthesis with Constrained Horn Clauses},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4682681},
abstract = {
    <p>The artifact is a zip file consisting of: pldi21.ova - a VirtualBox image consisting of tools to reproduce the data from the paper pldi21.md5 - md5sum of pldi21.ova README - instructions on how to use the artifact</p>

},
keywords = {automated verification, inductive invariants, SMT solvers, specification synthesis}
}

@software{10.5281/zenodo.4682811,
author = {Beutner, Raven and Ong, Luke},
title = {Probabilistic Termination Analysis Tools for: On Probabilistic Termination of Functional Programs with Continuous Distributions},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4682811},
abstract = {
    <p>Tools for computing lower bounds on the probability of termination (called LowerBound) and verification of AST of non-affine recursive programs (called astnar) for programs with continuous distributions. The tools build upon the theoretical results in the PLDI paper “On Probabilistic Termination of Functional Programs with Continuous Distributions”.</p>

},
keywords = {almost-sure termination, functional programs, lower bounds, Probabilistic programs, termination}
}

@software{10.5281/zenodo.4685966,
author = {Lim, Jay P. and Nagarakatte, Santosh},
title = {High Performance Correctly Rounded Math Libraries for 32-bit Floating Point Representations},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4685966},
abstract = {
    <p>RLIBM-32 is both a math library that provides correctly rounded result for all inputs and tools used to generate the correct polynomials. The techniques behind the tools will be appearing at PLDI 2021. Currently, RLIBM-32 supports a number of elementary functions for float and posit32 representations.</p>
<h4 id="list-of-float-functions-supported-by-rlibm-32">List of float functions supported by RLIBM-32</h4>
<ol type="1">
<li><p>log(x), log2(x), log10(x)</p></li>
<li><p>exp(x), exp2(x), exp10(x)</p></li>
<li><p>sinh(x), cosh(x)</p></li>
<li><p>sinpi(x), cospi(x)</p></li>
</ol>
<h4 id="list-of-posit32-functions-supported-by-rlibm-32">List of posit32 functions supported by RLIBM-32</h4>
<ol type="1">
<li><p>log(x), log2(x), log10(x)</p></li>
<li><p>exp(x), exp2(x), exp10(x)</p></li>
<li><p>sinh(x), cosh(x)</p></li>
</ol>

},
keywords = {correctly rounded results, elementary functions, floating point, posits}
}

@software{10.5281/zenodo.4763118,
author = {Farzan, Azadeh and Nicolet, Victor},
title = {Phased Synthesis of Divide and Conquer Programs (Software Artifact)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4763118},
abstract = {
    <p>This software artifact implements the automatic methodology described in the paper. A README.md file has been provided with instructions on how to reproduce the results presented in the paper, as well as instructions on how to build the software from the provided sources.</p>

},
keywords = {Divide-And-Conquer Algorithms, Program Synthesis}
}

@software{10.1145/3365462,
author = {Garc\'{\i}a, Sergio and Pelliccione, Patrizio and Menghi, Claudio and Berger, Thorsten and Bures, Tomas},
title = {PROMISE: A DSL for Controlling Teams of Mobile Robots},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3365462},
abstract = {
    <p>PROMISE (simPle RObot MIssion SpEcification) is a Domain Specific Language (DSL) to specify missions for teams of multiple robots. PROMISE 1) supports the user with a user-friendly syntax while having well-defined (translational) semantics; 2) enables a rigorous and precise specification, required for the use of planners, analysis tools, simulators or other modules; 3) allows the specification of complex missions by providing executable, combinable tasks and operators; 4) is platform-independent and highly customizable. The DSL is implemented as an Eclipse plugin and it is integrated into a software framework that allows mission decomposition, generation, and execution. We provide PROMISE’s implementation, the framework, and tools as plugins. The package contains a Guidelines.pdf file that contains more information regarding the artifact’s components, installation, and workflow.</p>
<p>This artifact was retrospectively published and linked to the paper.</p>

},
keywords = {domain-specific language, mission specification, Multi-robot}
}

@software{10.5281/zenodo.1307248,
author = {Wei, Guannan and Decker, James and Rompf, Tiark},
title = {Kraks/RefuncAAM: Release v1.0.0},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1307248},
abstract = {
    <p>This is the release for the camera-ready submission of ICFP ’18.</p>

},
keywords = {Artifact, Functional Programming}
}

@software{10.5281/zenodo.1400702,
author = {Henkel, Jordan and Lahiri, Shuvendu K. and Liblit, Ben and Reps, Thomas},
title = {Artifact for Code Vectors: Understanding Programs Through Embedded Abstracted Symbolic Traces},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1400702},
abstract = {
    <p>This release is to track the Code Vectors: Understanding Programs Through Embedded Abstracted Symbolic Traces artifact submission. Updated to align with camera ready version.</p>

},
keywords = {Embeddings, Program Understanding, Software Engineering Research}
}

@software{10.5281/zenodo.1419788,
author = {Valiev, Marat and Vasilescu, Bogdan and Herbsleb, James},
title = {Ecosystem-Level Determinants of Sustained Activity in Open-Source Projects: A Case Study of the PyPI Ecosystem},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1419788},
abstract = {
    <p>Replication pack, FSE2018 submission #164</p>

},
keywords = {Software Engineering}
}

@software{10.5281/zenodo.3898483,
author = {Xu, Rongchen and He, Fei and Wang, Bow-Yaw},
title = {xurongchen/fse20: Artifacts for FSE2020 paper#633},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3898483},
abstract = {
    <p>artifacts track, fse20</p>

},
keywords = {Software Engineering}
}

@software{10.5281/zenodo.3903727,
author = {Mirhosseini, Samim and Parnin, Chris},
title = {docable/docable v1.1},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3903727},
abstract = {
    <p>No description provided.</p>

},
keywords = {Software Engineering}
}

@software{10.5281/zenodo.3907232,
author = {Sharma, Vaibhav and Hussein, Soha and Whalen, Michael W. and McCamant, Stephen and Visser, Willem},
title = {java-ranger: v1.0.0},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3907232},
abstract = {
    <p>This is the version of Java Ranger that was used in the evaluation accepted to FSE 2020.</p>

},
keywords = {Java, Software Engineering, Software Verification}
}

@software{10.5281/zenodo.3923023,
author = {Palmer, Zachary and Park, Theodore and Smith, Scott and Weng, Shiwei},
title = {Higher-Order Demand-Driven Symbolic Evaluation},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3923023},
abstract = {
    <p>The artifact for the paper includes the source code and a ready-to-use qemu image.</p>

},
keywords = {Functional Programming, OCaml}
}

@software{10.1145/3342530,
author = {Maillard, Kenji and Ahman, Danel and Atkey, Robert and Mart\'{\i}nez, Guido and Hri\c{t}cu, C\u{a}t\u{a}lin and Rivas, Exequiel and Tanter, \'{E}ric},
title = {Accompanying development for the paper: Dijkstra monads for all},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342530},
abstract = {
    <p>The archive contains a docker image and original source files supporting the paper “Dijkstra monads for all”. The source files comport (1) a modified version of the F* compiler implementing the extension of the paper and examples of F* sources using these extensions (2) a Coq development of Dijkstra monads, implementations of the examples from the paper as well as an implementation of a DSL to derive monad transformers. See <code>ArtifactOverview.md</code> in the archive for more information.</p>

},
keywords = {Coq, Dijkstra monads, F*, monadic effects, program verification}
}

@software{10.1145/3410278,
author = {Luo, Weiyu and Demsky, Brian},
title = {C11Tester Artifact},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410278},
abstract = {
    <p>The artifact contains a c11tester-vagrant directory and a tsan11-tsan11rec-docker directory. The c11tester-vagrant directory is a vagrant repository that compiles source codes for C11Tester, LLVM, the companion compiler pass, and benchmarks for C11Tester. The tsan11-tsan11rec-docker directory contains benchmarks and a docker image with prebuilt LLVMs for tsan11 and tsan11rec.</p>

},
keywords = {C++11, concurrency, data races, memory models}
}

@software{10.1145/3410279,
author = {Ustiugov, Dmitrii and Petrov, Plamen and Kogias, Marios and Bugnion, Edouard and Grot, Boris},
title = {Benchmarking, Analysis, and Optimization of Serverless Function Snapshots},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410279},
abstract = {
    <p>This artifact contains the source code of the vHive-CRI host orchestrator and includes the necessary binary files of its dependencies, namely Firecracker-Containerd shim binaries, Firecracker hypervisor and jailer, default rootfs for Firecracker MicroVMs, MinIO object store server, and client binaries. The reviewers require Ubuntu 18.04 with root access and hardware virtualization support (e.g., VT-x), a platform with the root partition mounted on an SSD is preferred. The artifact lists the instructions to reproduce Fig. 8 for the configuration that uses vanilla Firecracker snapshots and the configuration that uses REAP-based snapshots. The reviewers can run functions from the representative FunctionBench suite, using pre-built Docker images.</p>

},
keywords = {cloud computing, datacenters, serverless, snapshots, virtualization}
}

@software{10.1145/3410280,
author = {Neal, Ian and Quinn, Andrew and Kasikci, Baris},
title = {Replication Package for Article: HIPPOCRATES: Healing Persistent Memory Bugs without Doing Any Harm},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410280},
abstract = {
    <p>This package contains the artifact for HIPPOCRATES. The artifact includes instructions for building and running HIPPOCRATES, as well as scripts and instructions used to reproduce the core results from the original article.</p>

},
keywords = {persistent memory, program repair}
}

@software{10.1145/3410281,
author = {Di, Bang and Liu, Jiawen and Chen, Hao and Li, Dong},
title = {Artifact for PMDebugger: Fast, Flexible, and Comprehensive Bug Detection for Persistent Memory Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410281},
abstract = {
    <p>This is the open-source site for PMDebugger&nbsp;(ASPLOS’21). For the latest version, please see our GitHub page: https://github.com/PASAUCMerced/PMDebugger.</p>

},
keywords = {Crash Consistency, Debugging, Persistent Memory, Testing}
}

@software{10.1145/3410283,
author = {Landgraf, Joshua and Yang, Tiffany and Lin, Will and Rossbach, Christopher J. and Schkufza, Eric},
title = {Artifact for Paper: Compiler-Driven FPGA Virtualization with SYNERGY},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410283},
abstract = {
    <p>This artifact contains the code for all the currently-available SYNERGY (Cascade) backends, including the experimental new backend for F1. The artifact also includes the benchmarks from the paper, data files to run them with, and experiment files to replicate the experiments shown in the paper on the SW and F1 backends. Instructions are documented in README.md, ARTIFACT.md, and experiments/README.md.</p>

},
keywords = {Compilers, FPGAs, Operating Systems, Virtualization}
}

@software{10.5281/zenodo.4321197,
author = {Margaritov, Artemiy and Ustiugov, Dmitrii and Shahab, Amna and Grot, Boris},
title = {Artifact evaluation pack for PTEMagnet (paper #111 in ASPLOS'21)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4321197},
abstract = {
    <p>The artifact contains a Linux kernel patch for enabling PTEMagnet, shell scripts for Linux kernel compilation, a virtual machine disk image with precompiled benchmarks, and Python/shell scripts that are expected to reproduce the results presented in Figure 6 of <a href="https://ease-lab.github.io/ease_website/pubs/PTEMagnet_ASPLOS21.pdf">the paper</a> for non-SPEC benchmarks.</p>

},
keywords = {operating system, virtual memory, virtualization}
}

@software{10.5281/zenodo.4321310,
author = {Panwar, Ashish and Achermann, Reto and Basu, Arkaprava and Bhattacharjee, Abhishek and Gopinath, K. and Gandhi, Jayneel},
title = {Fast Local Page-Tables for Virtualized NUMA Servers with vMitosis},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4321310},
abstract = {
    <p>This repository contains artifacts of the paper Fast Local Page-Tables for Virtualized NUMA Servers with vMitosis by Ashish Panwar, Reto Achermann, Arkaprava Basu, Abhishek Bhattacharjee, K. Gopinath, and Jayneel Gandhi to appear in the 26th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS’21).</p>

},
keywords = {ASPLOS'21, NUMA, Page-Tables, VMItosis-Linux}
}

@software{10.5281/zenodo.4321431,
author = {Sartakov, Vasily A. and Vilanova, Llu\'{\i}s and Pietzuch, Peter},
title = {Replication Package for Article: "CubicleOS: A Library OS with Software Componentisation for Practical Isolation"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4321431},
abstract = {
    <p>This artefact contains the library OS, two applications, the isolation monitor, and scripts to reproduce the experiments from the ASPLOS 2021 paper by V. A. Sartakov, L. Vilanova, R. Pietzuch — ``CubicleOS: A Library OS with Software Componentisation for Practical Isolation’’, which isolates components of a monolithic library OS without the use of message-based IPC primitives.</p>

},
keywords = {compartments, Intel MPK, inter-process communication, isolation}
}

@software{10.5281/zenodo.4321760,
author = {Jia, Zhipeng and Witchel, Emmett},
title = {Nightcore: Efficient and Scalable Serverless Computing for Latency-Sensitive, Interactive Microservices (Artifacts)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4321760},
abstract = {
    <p>Our artifact includes the prototype implementation of Nightcore, the DeathStarBench and HipsterShop microservices ported to Nightcore, and the experiment workflow to run these workloads on AWS EC2 instances.</p>

},
keywords = {Cloud computing, function-as-a-service, microservices, serverless computing}
}

@software{10.5281/zenodo.4321945,
author = {Huang, Yipeng and Holtzen, Steven and Millstein, Todd and Van den Broeck, Guy and Martonosi, Margaret},
title = {Noisy Variational Quantum Algorithm Simulation via Knowledge Compilation for Repeated Inference},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4321945},
abstract = {
    <p>This artifact demonstrates a new way to perform quantum circuit simulation. We convert quantum circuits into probabilistic graphical models, which are then compiled into a format that enables efficient repeated queries.</p>
<p>The artifact consists of a Docker image which includes Google Cirq, a quantum programming framework, which we have extended to use our proposed approach as a quantum circuit simulation backend. Also in the Docker image are two quantum circuit simulators based on existing approaches which we compare against as evaluation baselines.</p>
<p>We offer the Docker image via three routes: a hosted version on Docker Hub provides the latest version of our software and requires minimal setup; a Dockerfile is provided to show how to replicate our environment from scratch; and finally a stable archival version is available on Zenodo.</p>
<p>With minimal setup, you can run test cases in our Docker container showing the validity of our approach. We test our quantum circuit simulation approach using the randomized test harness that Google Cirq uses to test its quantum circuit simulation back ends. We also demonstrate correct simulation results for a benchmark suite of quantum algorithms.</p>
<p>The Docker image contains performance benchmarking experiments that replicate results of our paper at reduced input problem sizes. The experiment scripts generate PDFs showing graphs that plot simulation wall clock time against input quantum circuit sizes. The input problem sizes are large enough to show that our proposed approach achieves a speedup versus existing simulation tools.</p>

},
keywords = {Bayesian networks, knowledge compilation, quantum circuit simulation, quantum computing}
}

@software{10.5281/zenodo.4322031,
author = {Li, Rui and Xu, Yufan and Sukumaran-Rajam, Aravind and Rountev, Atanas and Sadayappan, P.},
title = {Replication Package for Article: Analytical Characterization and Design Space Exploration for Optimization of CNNs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4322031},
abstract = {
    <p>This artifact includes a software implementation and benchmark specification for reproducing experiment results for paper “Analytical Characterization and Design Space Exploration for Optimization of CNNs”</p>

},
keywords = {Design space exploration, Neural networks, Performance modeling, Tile size optimization}
}

@software{10.5281/zenodo.4322033,
author = {Saileshwar, Gururaj and Fletcher, Christopher W. and Qureshi, Moinuddin},
title = {Code for Streamline Attack: A Fast, Flushless Cache Covert-Channel Attack byEnabling Asynchronous Collusion},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4322033},
abstract = {
    <p>This artifact presents the code and methodology to run the Streamline cache covert-channel attack. We provide the C++ code for the sender and receiver processes engaged in covert communication. Although the attack itself is not specific to an OS, ISA, or micro- architecture, the code is written with the assumption of an x86 Linux system and an Intel CPU that is a Skylake or a newer generation model. The code may be compiled with a standard compiler and run natively to execute the covert-communication. We also provide scripts to run the attack in several configurations demon- strated in Section-IV of our paper (with and without ECC, varying the shared array size and the synchronization period) and provide a Jupyter notebook to visualize the results.</p>
<p>Please use the public GitHub repository of the project https://github.com/gururaj-s/streamline for the most updated version of the code.</p>

},
keywords = {Asynchronous Protocol, Cache Side-Channels, Covert-channel Attacks, Last-Level Cache, Shared Caches}
}

@software{10.5281/zenodo.4322105,
author = {Kasampalis, Theodoros and Park, Daejun and Lin, Zhengyao and Adve, Vikram S. and Ro\c{s}u, Grigore},
title = {Language-Parametric Compiler Validation with Application to LLVM - Artifact Evaluation for ASPLOS 2020},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4322105},
abstract = {
    <p>A VirtualBox VM image that is fully set up to reproduce experiments mentioned in the ASPLOS 2021 paper titled “Language-Parametric Compiler Validation with Application to LLVM”. The included README.md file contains detailed instructions on how to use the artifact both for reproduction of experiments and for general use.</p>

},
keywords = {Compilers, Program Equivalence, Simulation, Translation Validation}
}

@software{10.5281/zenodo.4322233,
author = {Xu, Yi and Izraelevitz, Joseph and Swanson, Steven},
title = {Clobber-NVM: Log Less, Re-execute More},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4322233},
abstract = {
    <p>Clobber-NVM is a failure-atomicity library that ensures data consistency by reexecution. Clobber-NVM’s novel logging strategy, clobber logging, records only those transaction inputs that are overwritten during transaction execution. Then, after a failure, it recovers to a consistent state by restoring overwritten inputs and reexecuting any interrupted transactions. Clobber-NVM utilizes a clobber logging compiler pass for identifying the minimal set of writes that need to be logged.</p>
<p>This artifact includes the Clobber-NVM compiler passes, as well as necessary runtime components. It contains code of all seven benchmarks (four data structures and three applications) reported in the paper. The evaluation results can be reproduced by running the experiments on a machine equipped with at least 24 physical cores per socket and 32 GB of memory. In absence of access to real NVMM (e.g., Intel Optane DC), you need to reserve 32 GB of memory to emulate NVMM. The artifacts also includes a script to download and install main software dependencies. We have evaluated Clobber-NVM on Ubuntu 18.04, with GNU7.3.1, and LLVM 7.0.0.</p>

},
keywords = {Clobber Logging, Compiler, Non-volatile Memory, Persistent Memory, Storage Systems, Undo Logging}
}

@software{10.5281/zenodo.4322285,
author = {Liu, Sihang and Mahar, Suyash and Ray, Baishakhi and Khan, Samira},
title = {PMFuzz: Test Case Generation for Persistent Memory Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4322285},
abstract = {
    <p>PMFuzz is a test case generator for PM programs, aiming to generate high-value test cases for PM testing tools. The generated test cases include both program inputs and initial PM images (normal images and crash images). The key idea of PMFuzz is to perform a targeted fuzzing on PM-related code regions and generate valid PM images by reusing the program logic. After generating the test cases, PMFuzz feeds them to the PM program and uses existing testing tools (XFDetector and PMemcheck) to detect crash consistency and performance bugs. The archived version of this artifact can be accessed using this DOI. We also maintain a GitHub repository at https://pmfuzz.persistentmemory.org/. For the latest version, please check our GitHub repository.</p>

},
keywords = {Crash Consistency, Debugging, Fuzzing, Persistent Memory, Testing}
}

@software{10.5281/zenodo.4329804,
author = {Tang, Wei and Tomesh, Teague and Suchara, Martin and Larson, Jeffrey and Martonosi, Margaret},
title = {Replication Package for Article: CutQC: Using Small Quantum Computers for Large Quantum Circuit Evaluations},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4329804},
abstract = {
    <p>Our artifact provides the source codes for the end-to-end CutQC toolflow. We also provide the benchmarking codes for several sample runtime and fidelity experiments. The HPC parallel version of the code is not provided, as different HPC platforms require very different setups.</p>

},
keywords = {Hybrid Computing, Quantum Circuit Cutting, Quantum Computing (QC)}
}

@software{10.5281/zenodo.4331404,
author = {VanHattum, Alexa and Nigam, Rachit and Lee, Vincent T. and Bornholt, James and Sampson, Adrian},
title = {Diospyros Software Artifact: Vectorization for Digital Signal Processors via Equality Saturation},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4331404},
abstract = {
    <p>Our artifact packages an environment to reproduce the main empirical results of our paper. Specifically, we package: (1) the Diospyros compiler: a search-aided compiler for generating vectorized DSP kernels, (2) implementations of a range of benchmarks in Diospyros, (3) implementation of the Theia open-source application case study, and (4) scripts for recreating the experiments and charts in the paper.</p>

},
keywords = {DSPs, Equality Saturation, Program Synthesis, Vectorization}
}

@software{10.5281/zenodo.4331660,
author = {Jayarajan, Anand and Hau, Kimberly and Goodwin, Andrew and Pekhimenko, Gennady},
title = {LifeStream},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4331660},
abstract = {
    <p>This artifact contains code and a synthetic data set to evaluate LifeStream, Trill, and numerical library-based data processing pipelines.</p>

},
keywords = {LifeStream, Numpy, Python, Scikit-learn, SciPy, stream data analytics, temporal query processing, Trill}
}

@software{10.5281/zenodo.4429956,
author = {Skarlatos, Dimitrios and Zhao, Zirui Neil and Paccagnella, Riccardo and Fletcher, Christopher W. and Torrellas, Josep},
title = {Replication for article: Jamais Vu: Thwarting Microarchitectural Replay Attacks},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4429956},
abstract = {
    <p>Our artifact provides a complete gem5 implementation of Jamais Vu, along with scripts to evaluate the SPEC’17 benchmarks. We also provide a GitHub repository with the gem5 implementation and required scripts to reproduce our simulation results. Finally, we provide a binary analysis infrastructure based on Radare2 that allows the compilation of binaries with the proposed Epoch markings.</p>

},
keywords = {Gem5, Processor design, Replay attack, Side-channel countermeasures}
}

@software{10.5281/zenodo.4432747,
author = {Nigam, Rachit and Thomas, Samuel and Li, Zhijing and Sampson, Adrian},
title = {Replication Package for Article: Compiler Infrastructure for Accelerator Generators},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4432747},
abstract = {
    <p>Our artifact packages an environment that can be used to reproduce the figures in the paper and perform similar evaluations. It is available at the following link:https://zenodo.org/record/4432747</p>
<p>It includes the following: - futil: The Calyx compiler. - fud: Driver for the futil compiler and hardware tools. - Linear algebra PolyBench written in Dahlia</p>

},
keywords = {Accelerator Design, Intermediate Language}
}

@software{10.5281/zenodo.4435970,
author = {Farshin, Alireza and Barbette, Tom and Roozbeh, Amir and Maguire Jr., Gerald Q. and Kosti\'{c}, Dejan},
title = {PacketMill: Toward Per-Core 100-Gbps Networking - Artifact for ASPLOS'21},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4435970},
abstract = {
    <p>This is the artifact for the “PacketMill: Toward per-core 100-Gbps Networking” paper published at ASPLOS’21.</p>
<p>PacketMill is a system that optimizes the performance of network functions via holistic inter-stack optimizations. More specifically, PacketMill provides a new metadata management model, called X-Change, enabling the packet processing frameworks to provide their custom buffer to DPDK and fully bypass rte_mbuf. Additionally, PacketMill performs a set of source-code \&amp; intermediate representation (IR) code optimizations.</p>
<p>Our paper’s artifact contains the source code, the experimental workflow, and additional information to (i) set upPacketMill \&amp; its testbed, (ii) perform some of the experiments presented in the paper, and (iii) validates the reusability \&amp; effectiveness of PacketMill.</p>
<p>For more information, please refer to https://github.com/aliireza/packetmill</p>

},
keywords = {DPDK., FastClick, LLVM, Middleboxes, Packet Processing, PacketMill, X-Change}
}

@software{10.5281/zenodo.4446702,
author = {Bl\"{o}cher, Marcel and Wang, Lin and Eugster, Patrick and Schmidt, Max},
title = {Switches for HIRE: Resource Scheduling for Data Center In-Network Computing},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4446702},
abstract = {
    <p>The artifact consists of three parts. (1) the source code of the HIRE simulator, including the implementations of Yarn++, Sparrow++, K8++, and CoCo++; (2) the runner tool (a Python3 program) that runs the experiments with the configurations presented in the paper and plotting scripts; and (3) Docker configurations to ease the setup. Users can reproduce all simulation results (Fig. 8 and Fig. 7). Furthermore, the artifact can be easily extended/modified to bench- mark other schedulers, INC configurations, and workloads.</p>

},
keywords = {data center, heterogeneity, in-network computing, non-linear resource usage, scheduling}
}

@software{10.5281/zenodo.4501773,
author = {Chen, Daming D. and Lim, Wen Shih and Bakhshalipour, Mohammad and Gibbons, Phillip B. and Hoe, James C. and Parno, Bryan},
title = {Artifact for 'HerQules: Securing Programs via Hardware-Enforced Message Queues'},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4501773},
abstract = {
    <p>Source code, experiment data, and virtual machines with precompiled benchmarks</p>

},
keywords = {compiler, fpga, ipc, llvm, nginx, ripe, spec, zsim}
}

@software{10.5281/zenodo.4504602,
author = {Calciu, Irina and Imran, M. Talha and Puddu, Ivan and Kashyap, Sanidhya and Maruf, Hasan Al and Mutlu, Onur and Kolli, Aasheesh},
title = {Artifacts for Article: Rethinking Software Runtimes for Disaggregated Memory},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4504602},
abstract = {
    <p>These artifacts have been developed for the ASPLOS 2021 article “Rethinking Software Runtimes for Disaggregated Memory”. The artifacts provide tools to track applications and determine their memory accesses: cache-line granularity memory writes and average memory access time (AMAT).</p>

},
keywords = {average memory access time, cache-line granularity dirty data tracking}
}

@software{10.5281/zenodo.4527305,
author = {Patel, Tirthak and Tiwari, Devesh},
title = {QRAFT ASPLOS 21 Code and Dataset},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4527305},
abstract = {
    <p>The artifacts can be divided into three categories: (1) Raw data: circuit metadata and output generated as a direct result of running quantum circuits. (2) Processed and Trained data: the data processed to be fed as input to the machine learning model training, as well as the output data of testing samples using the trained model. (3) Tools: code and scripts used for running circuits on quantum computers, processing the output, as well as training models and generating the final output (prediction of state probabilities).</p>

},
keywords = {NISQ Computing, Quantum Computing, Quantum Error Mitigation}
}

@software{10.5281/zenodo.4537132,
author = {Zhang, Yanqi and Hua, Weizhe and Zhou, Zhuangzhuang and Suh, G. Edward and Delimitrou, Christina},
title = {Replication package for article: Sinan: ML-Based and QoS-Aware Resource Management for Cloud Microservices},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4537132},
abstract = {
    <p>The artifact includes codes and documentation to reproduce the google cloud experiments presented in Sinan: ML-Based and QoS-Aware Resource Management for Cloud Microservices</p>

},
keywords = {cloud computing, cluster management, datacenter, machine learn-ing for systems, mi-croservices, quality of service, resource efficiency, tail latency}
}

@software{10.5281/zenodo.4539728,
author = {Zhang, Mengchi and Alawneh, Ahmad and Rogers, Timothy G.},
title = {Replication package for Article: Judging a Type by Its Pointer: Optimizing Virtual Function Calls on GPUs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4539728},
abstract = {
    <p>The artifact contains the source code for the SharedOA, COAL, and TypePointer that applied to all workloads. We also include the instructions to configure, build, run, and acquire the workload’s performance. Users can reproduce the results in Figure 6. We also contain a tutorial with examples to apply SharedOA, COAL and TypePointer to show that the three techniques are reusable on other CUDA applications.</p>

},
keywords = {GPU, Object-oriented Programming, Virtual Function Call}
}

@software{10.5281/zenodo.4539743,
author = {Hoseinzadeh, Morteza and Swanson, Steven},
title = {Replication Package for Artifact: Corundum: Statically-Enforced Persistent Memory Safety},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4539743},
abstract = {
    <p>Corundum is a persistent memory programming library in Rust which enforces safety rules statically. The artifact contains the source code of Corundum, the installation scripts for Corundum and other libraries listed in the paper, source code of the workloads, and experiments run scripts.</p>

},
keywords = {debugging, formal verification, persistent memory programming}
}

@software{10.5281/zenodo.4540633,
author = {Meng, Xiaozhu and Liu, Weijie},
title = {Software Artifact for Incremental CFG Patching for Binary Rewriting},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4540633},
abstract = {
    <p>Software artifact needed for paper “Incremental CFG Patching for Binary Rewriting”. It includes scripts for setting environments, software dependencies, and running experiments, and template configuration files for SPEC CPU 2017.</p>

},
keywords = {Docker, Dyninst, Firefox, Spack}
}

@software{10.5281/zenodo.4540866,
author = {Li, Guangpu and Chen, Dongjie and Lu, Shan and Musuvathi, Madanlal and Nath, Suman},
title = {SherLock-v2},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4540866},
abstract = {
    <p>Synchronizations are fundamental to the correctness and performance of concurrent software. They determine which operations can execute concurrently and which can-not—the key to detecting and fixing concurrency bugs, as well as understanding and tuning performance. Unfortunately, correctly identifying all synchronizations has become extremely difficult in modern software systems due to the various forms of concurrency and various types of synchronizations.</p>
<p>Previous work either only infers specific type of synchronization by code analysis or relies on manual effect to annotate the synchronization. This paper proposes SherLock, a tool that automatically infers synchronizations without code analysis or annotation. SherLock leverages the fact that most synchronizations appear around the conflicting operations and encodes the inference problem into a linear system with properties and hypotheses about how synchronizations are typically used. To collect useful observations, SherLock runs the target problem for a small number of runs with feedback-guided delay injection.</p>
<p>We have applied SherLock on 8 C# open-source applications. Without any prior knowledge, SherLock automatically inferred more than 120 unique synchronizations, with few false positives. These inferred synchronizations cover a wide variety of types, including lock operations, fork-join operations, asynchronous operations, framework synchronization, and custom synchronization.</p>

},
keywords = {Happens-before inducing, Synchronization Detection}
}

@software{10.5281/zenodo.4541351,
author = {Duta, Victor and Giuffrida, Cristiano and Bos, Herbert and van der Kouwe, Erik},
title = {Replication Package for Article "PIBE: Practical Kernel Control-Flow Hardening with Profile-Guided Indirect Branch Elimination"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4541351},
abstract = {
    <p>Our artifact provides x86-64 kernel binaries for most of the kernel configurations we evaluated in the paper, along with scripts to configure LMBench, run and benchmark each kernel configuration and regenerate the syscall latencies and overheads discussed in the main tables of the paper. This allows the evaluation of our results on an Intel i7-8700K (Skylake) CPU or similar micro-architectures.</p>
<p>We also provide source code for the tools used during the kernel build process (e.g., binutils, LLVM 10), the code of our LLVM optimization passes and the kernel source code to regenerate the kernel binaries used in the workflow of our evaluation. We sup- ply the user with scripts to regenerate our Apache and LMBench profiling workloads, rebuild the kernel binaries provided in the evaluation or customize the kernels with a user-specified selection of transient mitigations and optimization strategies.</p>
<p>Furthermore, we also provide portable Apache and LMBench profiling workloads to speedup the customization process without the necessity of creating your own profiling workloads.</p>

},
keywords = {kernel, LMBench, profile-guided optimizations, transient execution}
}

@software{10.5281/zenodo.4546175,
author = {Hadidi, Ramyad and Asgari, Bahar and Jijina, Sam and Amyette, Adriana and Shoghi, Nima and Kim, Hyesoon},
title = {Paper Quantifying the Design-Space Tradeoffs in Autonomous Drones artifact, including software, data, and build giude for the open-source drone},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4546175},
abstract = {
    <p>This artifact describes our open-source experimental drone framework that is customizable across its hardware-software stack. The main and first portion of the artifact focuses on building the drone, which compliments the beginning sections of the paper. The build guide consists of two parts: hardware and software. Second, as an example of possible experiments, we provide sample scripts for important metrics measurements such as Linux perf and SLAM. Third, the artifact contains raw data for graphs in the paper.</p>

},
keywords = {autonomous drones, build guide, design-space analysis, open-source platform, power measurements, SLAM}
}

@software{10.5281/zenodo.4556045,
author = {Qiu, Junqiao and Sun, Xiaofan and Sabet, Amir Hossein Nodehi and Zhao, Zhijia},
title = {Replication Package for Article: Scalable FSM Parallelization via Path Fusion and Higher-Order Speculation},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4556045},
abstract = {
    <p>This artifact contains the source code of BoostFSM, including the five FSM parallelization schemes discussed in the paper and some benchmarks along with their inputs used for evaluation. In addition, this artifact provides bash scripts to compile the source code and reproduce the key experimental results reported in the paper. Considering the software dependencies, a software environment with Linux Centos 7 or other similar Linux distributions, GCC, Bash, Pthread, CMake and Boost library, is needed before the evaluation. Moreover, to reproduce all results reported in the paper, especially the speedup comparison and scalability analysis, the artifact needs to run on Intel Xeon Phi processor (Knights Landing/KNL).</p>

},
keywords = {Finite State Machine, FSM, Parallelization, Scalability, Speculation}
}

@software{10.6084/m9.figshare.13392338,
author = {Gorjiara, Hamed and Xu, Guoqing Harry and Demsky, Brian},
title = {Replication Package for Article: Jaaru: Efficiently Model Checking Persistent Memory Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.13392338},
abstract = {
    <p>This artifact contains a vagrant repository that downloads and compiles the source code for Jaaru, its companion compiler pass, and benchmarks. The artifact enables users to reproduce the bugs that are found by in PMDK (i.e., Figure 11 of the paper) and RECIPE (i.e., Figure 12) as well as the performance results to compare with Yat (i.e., Figure 13).</p>

},
keywords = {Crash Consistency, Debugging, Jaaru, Persistent Memory, Testing}
}

@software{10.1145/3410275,
author = {L\"{u}cke, Martin and Steuwer, Michel and Smith, Aaron},
title = {Replication Package for Article: Integrating a Functional Pattern-Based IR into MLIR},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410275},
abstract = {
    <p>The artifact for this paper includes the MLIR infrastructure with the Rise dialect and corresponding passes. IR to reproduce the experiments of the paper is included. A Dockerfile and scripts are provided to enable easy installation, execution, and plotting of results.</p>

},
keywords = {Intermediate Representation, MLIR, Rise}
}

@software{10.5281/zenodo.4451492,
author = {Panchenko, Maksim and Auler, Rafael and Sakka, Laith and Ottoni, Guilherme},
title = {Replication Package for Article: Lightning BOLT: Powerful, Fast, and Scalable Binary Optimization},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4451492},
abstract = {
    <p>This artifact contains the software required to reproduce the experimental findings of the paper “Lightning BOLT: Powerful, Fast, and Scalable Binary Optimization”, CC 2021. This package is a copy of https://github.com/facebookincubator/BOLT/tree/master/paper/reproduce-bolt-cc2021 revision 4990ee5. Please access the github page for an updated version of this artifact, if available.</p>
<p>The open-source workloads evaluated for this paper are clang 11 and gcc 10. These two workloads need to be bootstrapped (built with themselves). Our goal is to demonstrate reductions in wall time and memory consumption when running BOLT on these workloads with different techniques: parallelization and selective optimizations. This is accomplished with the first experiment (exp1.sh script, Figures 3, 4 and 5 in the paper). The second experiment (exp2.sh script, Figures 6 and 7 in the paper) shows how can we trade BOLT speed for output binary performance.</p>

},
keywords = {Binary Optimization, Compilers, Performance}
}

@software{10.1145/3410258,
author = {Kim, Jinwoo and Hu, Qinheping and D'Antoni, Loris and Reps, Thomas},
title = {Software artifact for paper: Semantics-Guided Synthesis},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410258},
abstract = {
    <p>This artifact is the software repository for the 2021 POPL paper ‘Semantics-Guided Synthesis’. It consists of the tool Messy described in the paper, which converts SemGuS problems into solvable CHCs, as well as the benchmarks used in the paper.</p>
<p>This version of the tool is a prototype, and does not contain a separate front-end; SemGuS problems and benchmarks are written in our own DSL.</p>

},
keywords = {Program Synthesis, Semantics-Guided Synthesis (SemGuS), Unrealizability}
}

@software{10.1145/3410259,
author = {Rosemann, Julian and Moll, Simon and Hack, Sebastian},
title = {Docker Image for Quantitative Evaluation},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410259},
abstract = {
    <p>This is a x86_64 docker image. It contains the source code, pre-built binaries and evaluation data sets used in the quantative evaluation of the paper “An Abstract Interpretation for SPMD Divergence on Reducible Control Flow Graphs”. SPEC ACCEL is not included in the image for licensing issues but there are instructions to copy your own version of it into the docker container.</p>

},
keywords = {Analysis, LLVM, RV}
}

@software{10.1145/3410260,
author = {de Vilhena, Paulo Em\'{\i}lio and Pottier, Fran\c{c}ois},
title = {Artifact for A Separation Logic for Effect Handlers},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410260},
abstract = {
    <p>This artifact contains the Coq/Iris proofs that accompany the paper “A Separation Logic for Effect Handlers”.</p>

},
keywords = {Coq, effect handlers, Iris, program verification, separation logic}
}

@software{10.1145/3410262,
author = {Doenges, Ryan and Arashloo, Mina Tahmasbi and Bautista, Santiago and Chang, Alexander and Ni, Newton and Parkinson, Samwise and Peterson, Rudy and Solko-Breslin, Alaia and Xu, Amanda and Foster, Nate},
title = {Artifact for "Petr4: Formal Foundations for P4 Data Planes"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410262},
abstract = {
    <p>This artifact includes source code and tests for Petr4. For more information visit https://cornell-netlab.github.io/petr4/, where a full VM is also available, or check out the gh-pages branch of the artifact.</p>

},
keywords = {p4}
}

@software{10.1145/3410263,
author = {Barri\`{e}re, Aur\`{e}le and Blazy, Sandrine and Fl\"{u}ckiger, Olivier and Pichardie, David and Vitek, Jan},
title = {CoreJIT: a Replication Package for Article "Formally Verified Speculation and Deoptimization in a JIT Compiler "},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410263},
abstract = {
    <p>This is the development of CoreJIT, a formally verified JIT compiler.</p>

},
keywords = {just-in-time compilation, verified compilation}
}

@software{10.1145/3410264,
author = {Vassena, Marco and Disselkoen, Craig and Gleissenthall, Klaus von and Cauligi, Sunjay and K\i{}c\i{}, Rami G\"{o}khan and Jhala, Ranjit and Tullsen, Dean and Stefan, Deian},
title = {Replication package for article: Automatically Eliminating Speculative Leaks from Cryptographic Code with Blade},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410264},
abstract = {
    <p>See README.pdf included in the artifact for reviewer instructions. Included are the instructions and the VM image representing the artifact. Alternately, to set up the software on your own machine, see https://github.com/PLSysSec/blade-benchmarks/blob/master/README.md.</p>

},
keywords = {Constant-time, Lucet, Spectre, Speculative execution, WebAssembly}
}

@software{10.1145/3410265,
author = {Choudhury, Pritam and Eades III, Harley and Eisenberg, Richard A. and Weirich, Stephanie},
title = {Artifact for "A Graded Dependent Type System with a Usage-Aware Semantics"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410265},
abstract = {
    <p>This artifact contains Coq proofs for the type soundness proof described in Section 7.2.</p>

},
keywords = {dependent types, graded modal types, type soundness}
}

@software{10.1145/3410266,
author = {Sherman, Benjamin and Michel, Jesse and Carbin, Michael},
title = {Implementation of $\lambda_S$: Computable Semantics for Differentiable Programming with Higher-Order Functions and Datatypes},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410266},
abstract = {
    <p>This is the artifact for the paper “<span class="math inline"><em>λ</em><sub><em>S</em></sub></span>: Computable semantics for differentiable programming with higher-order functions and datatypes”. This repository contains the implementation of <span class="math inline"><em>λ</em><sub><em>S</em></sub></span> as an embedded language within Haskell. We name this library “smooth”.</p>

},
keywords = {Automatic Differentiation, Constructive Analysis, Diffeological Spaces}
}

@software{10.1145/3410267,
author = {Margalit, Roy and Lahav, Ori},
title = {Rocker},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410267},
abstract = {
    <p>Robustness Checker</p>

},
keywords = {C++11, C/C++11, C11, D, RC20, robustness, weak memory models}
}

@software{10.1145/3410268,
author = {Barthe, Gilles and Chadha, Rohit and Krogmeier, Paul and Sistla, A. Prasad and Viswanathan, Mahesh},
title = {Software Artifact for Deciding Accuracy of Differential Privacy Schemes},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410268},
abstract = {
    <p>This artifact is a tool for verifying accuracy of differential privacy mechanisms. The main code is written in C++ and some auxiliary functions are written in OCaml. Running the tool requires Mathematica. The tool’s code consists of two parts. The first part reads a program from a file and generates a table that captures the program’s I/O behavior. The second part analyzes the program and uses the I/O table to write a Mathematica script that contains verification conditions for accuracy. Lastly, the tool runs Mathematica on the generated script.</p>

},
keywords = {accuracy, decidability, differential privacy, logic, verification}
}

@software{10.5281/zenodo.4067194,
author = {Lim, Jay P. and Aanjaneya, Mridul and Gustafson, John and Nagarakatte, Santosh},
title = {Artifact for the paper: An Approach to Generate Correctly Rounded Math Libraries for New Floating Point Variants},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4067194},
abstract = {
    <p>RLibm is a math library generator and a library that provides the correctly rounded result for all inputs. Currently, RLibm supports a number of elementary functions for bfloat16, posit16, and float representations.</p>

},
keywords = {elementary functions, floating point, polynomial approximation, posits}
}

@software{10.5281/zenodo.4068078,
author = {Gregersen, Simon Oddershede and Bay, Johan and Timany, Amin and Birkedal, Lars},
title = {Mechanized Logical Relations for Termination-Insensitive Noninterference (Artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4068078},
abstract = {
    <p>A mechanized logical relations model for an expressive information-flow control type system with recursive types, existential types, label polymorphism, and impredicative type polymorphism for a higher-order programming language with higher-order state. The semantic model of the type system can be used to show that well-typed programs satisfy termination-insensitive noninterference but also to show that composing syntactically well-typed and syntactically ill-typed—but semantically sound—components is secure.</p>
<p>The model is defined using the Iris program logic framework. To capture termination-insensitivity, we make us of our theory of Modal Weakest Precondition. All of the theory and examples are formalized in the Coq proof assistant.</p>

},
keywords = {Coq, Information-Flow Control, Iris, Logical Relations, Program Logics}
}

@software{10.5281/zenodo.4071954,
author = {Rouvoet, Arjen and Krebbers, Robbert and Visser, Eelco},
title = {Intrinsically Typed Compilation with Nameless Labels: Virtual Machine},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4071954},
abstract = {
    <p>We present the library for separation logic, the model of nameless labels, and the implementation of the compiler backend in Agda.</p>

},
keywords = {Agda, Co-de-Bruijn, Compilation, Intrinsically-Typed, Labels, Proof relevant, Separation Logic}
}

@software{10.5281/zenodo.4072013,
author = {Willsey, Max and Nandi, Chandrakana and Wang, Yisu Remy and Flatt, Oliver and Tatlock, Zachary and Panchekha, Pavel},
title = {Artifact for "Fast and Extensible Equality Saturation"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4072013},
abstract = {
    <p>https://zenodo.org/record/4072013</p>

},
keywords = {e-graphs, equality saturation}
}

@software{10.5281/zenodo.4074932,
author = {Moy, Cameron and Nguy\~{\^e}n, Ph\'{u}c C. and Tobin-Hochstadt, Sam and Van Horn, David},
title = {Artifact: Corpse Reviver},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4074932},
abstract = {
    <p>This artifact contains a virtual machine appliance containing the SCV-CR tool and accompanying utilities for reproducing the experimental results reported in the paper.</p>

},
keywords = {contract verification, gradual typing, Typed Racket}
}

@software{10.5281/zenodo.4075076,
author = {Jacobs, Jules},
title = {Paradoxes of Probabilistic Programming: Artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4075076},
abstract = {
    <p>A Julia implementation of the probabilistic programming DSL using infinitesimal probabilities, as described in the associated paper.</p>

},
keywords = {Probabilistic programming}
}

@software{10.5281/zenodo.4118715,
author = {Farka, Franti\v{s}ek and Nanevski, Aleksandar and Banerjee, Anindya and Delbianco, Germ\'{a}n Andr\'{e}s and F\'{a}bregas, Ignacio},
title = {On Algebraic Abstractions for Concurrent Separation Logics (artefact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4118715},
abstract = {
    <p>The artefact contains Coq sources of the developments presented in the paper. The artefact supports the developments in both a theoretical and practical way. First, it provides a complete bottom-up mechanization of partial commutative monoids (PCM), separating relations, PCM morphisms, and the related constructions. The artefact formalizes all the concepts defined in the paper, Secondly, the artifact demonstrate practical utilisation of the theory of PCMs. Using FCSL (Nanevski et al, 2019) as the opaque type theory, the artefact provides mechanical verification of Ticket lock, the running example developed in the paper. The artefact also contains additional examples that the main body submission does not discuss.</p>

},
keywords = {Coq, Hoare/Separation Logics, Program Logics for Concurrency}
}

@software{10.5281/zenodo.4123035,
author = {Kokologiannakis, Michalis and Kaysin, Ilya and Raad, Azalea and Vafeiadis, Viktor},
title = {Replication Package for "PerSeVerE: Persistency Semantics for Verification under Ext4"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4123035},
abstract = {
    <p>This is the artifact accompanying the paper “PerSeVerE: Persistency Semantics for Verification under Ext4” which is accepted in POPL’21.</p>
<p>We consider our paper’s artifact to be the set of benchmarks and stress tests we used in the paper, as well as the results we got by running a particular version of Persevere (and its naive counterparts) on the benchmarks set. We do not consider the artifact of the paper to be Persevere itself, as it will evolve over time, and the results obtained by running the same benchmarks may differ in the future.</p>
<p>We have made Persevere publicly available on Github (https://github.com/MPI-SWS/genmc), as part of the GenMC tool. For any bugs, comments, or feedback regarding Persevere, please do not hesitate to contact us.</p>

},
keywords = {Filesystems, Persistency, Software Model Checking, Weak Memory Models}
}

@software{10.5281/zenodo.4139601,
author = {Gondelman, L\'{e}on and Gregersen, Simon Oddershede and Nieto, Abel and Timany, Amin and Birkedal, Lars},
title = {Distributed Causal Memory: Modular Specification and Verification in Higher-Order Distributed Separation Logic (Artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4139601},
abstract = {
    <p>A specification and verification of an implementation of a causally-consistent distributeddatabase that supports modular verification of full functional correctness properties of clients and servers. We specify and reason about the causally-consistent distributed database in Aneris, a higher-order distributed separation logic for an ML-like programming language with network primitives for programming distributed systems. We demonstrate that our specifications are useful, by proving the correctness of small, but tricky,synthetic examples involving causal dependency and by verifying a session manager library implemented on top of the distributed database. We use Aneris’s facilities for modular specification and verification to obtain a highly modular development, where each component is verified in isolation, relying only on the specifications(not the implementations) of other components. We have used the Coq formalization of the Aneris logic to formalize all the results presented in the paper in the Coq proof assistant.</p>

},
keywords = {causal consistency, concurrency, Coq, Distributed systems, formal verification, higher-order logic, Iris, separation logic}
}

@software{10.5281/zenodo.4141684,
author = {Jones, Eddie and Ramsay, Steven},
title = {Intensional Datatype Refinement Checker},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4141684},
abstract = {
    <p>The Intensional Datatype Refinement tool is a GHC plugin that checks whether it is possible to type the program according to the refinement type system specified in our paper. This provides a guarantee of pattern-match safety but the complexity of inference is only linear in the size of the program. In addition to reporting a yes/no-instance, it also enable the user to explore a set-constraint style analysis of their program.</p>

},
keywords = {higher-order program verification, refinement types}
}

@software{10.5281/zenodo.4161748,
author = {Angiuli, Carlo and Cavallo, Evan and M\"{o}rtberg, Anders and Zeuner, Max},
title = {Internalizing Representation Independence with Univalence - Artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4161748},
abstract = {
    <p>This artifact is a Docker image containing the Cubical Agda code for the paper “Internalizing Representation Independence with Univalence”.</p>
<p>The image also includes the source code of Agda (2.6.2 prerelease) and the agda/cubical standard library, which are both needed to build our code.</p>

},
keywords = {Cubical Type Theory, Higher Inductive Types, Proof Assistants, Representation Independence, Univalence}
}

@software{10.5281/zenodo.4246174,
author = {Jacobs, Koen and Timany, Amin and Devriese, Dominique},
title = {Artifact POPL21 - Fully Abstract from Static to Gradual},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4246174},
abstract = {
    <p>This artifact contains a Coq/Iris proof of the fact that the embedding of STLCmu (the simply typed lambda calculus with equirecursive types) into GTLCmu (its gradualization) is fully abstract. It accompanies the paper “Fully abstract from Static to Gradual”.</p>

},
keywords = {Coq, full abstraction, gradual typing, GTLC}
}

@software{10.5281/zenodo.4265963,
author = {Ahman, Danel and Pretnar, Matija},
title = {Software artefact for the POPL 2021 paper "Asynchronous Effects"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4265963},
abstract = {
    <p>This is a software artefact for the POPL 2021 paper:</p>
<p>Danel Ahman and Matija Pretnar. 2021. Asynchronous Effects. Proc. ACM Program. Lang. 5, POPL, Article 24 (January 2021), 28 pages.</p>
<p>This software artefact comprises:</p>
<ul>
<li>an Agda formalisation of the core calculus presented in the POPL submission;</li>
<li>a prototype implementation of the core calculus in OCaml, called \AE{}ff; and</li>
<li>a Docker image that includes all necessary dependencies to use the artefact.</li>
</ul>
<p>For more information about the artefact and how to use it, see the README.md file in the attached archive.</p>

},
keywords = {Algebraic effects, Asynchrony, Concurrency, Interrupt handling, Signals}
}

@software{10.5281/zenodo.4268196,
author = {Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {Replication package for article: Optimal Prediction of Synchronization Preserving Races},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4268196},
abstract = {
    <p>The artifact contains the implementation of the race detection algorithm presented in the above paper, as well as the experimental evaluation of the algorithm against other algorithms in the literature</p>

},
keywords = {complexity, concurrency, dynamic analysis, race detection}
}

@software{10.5281/zenodo.4268852,
author = {Arora, Jatin and Westrick, Sam and Acar, Umut A.},
title = {Replication Instructions for Article: Provably Space Efficient Parallel Functional Programming},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4268852},
abstract = {
    <p>Replication of the results presented in the article: Provably Space Efficient Parallel Functional Programming</p>

},
keywords = {disentanglement, functional programming, memory management, parallel computing}
}

@software{10.5281/zenodo.4268896,
author = {Hietala, Kesha and Rand, Robert and Hung, Shih-Han and Wu, Xiaodi and Hicks, Michael},
title = {A Verified Optimizer for Quantum Circuits -- Software Artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4268896},
abstract = {
    <p>Artifact virtual machine for “A Verified Optimizer for Quantum Circuits.” Paper available at https://arxiv.org/pdf/1912.02250.pdf. See https://github.com/inQWIRE/SQIR/tree/POPL2021 for information on running our tool.</p>

},
keywords = {Certified Compilation, Circuit Optimization, Formal Verification, Programming Languages, Quantum Computing}
}

@software{10.5281/zenodo.4269171,
author = {Lee, Woosuk},
title = {Artifacts for "Combining the Top-down Propagation and Bottom-up Enumeration for Inductive Program Synthesis"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4269171},
abstract = {
    <p>This artifact includes all things necessary􏰛 for reproducing experimental results in the paper “Combining the Top-down Propagation and Bottom-up Enumeration for Inductive Program Synthesis”. The source code for Duet, which is the tool presented in the paper, and the other baseline synthesizers (EUSolver, CVC4, and Euphony), and the scripts for running the experiments are contained.</p>

},
keywords = {Programming-by-example, Syntax-guided synthesis}
}

@software{10.5281/zenodo.4270313,
author = {Chen, Chao-Hong and Sabry, Amr},
title = {Artifact for A Computational Interpretation of Compact Closed Categories: Reversible Programming with Negative and Fractional Types},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4270313},
abstract = {
    <p>This artifact contains formalization of the abstract machines, interpreters, examples and proof of theorems in the paper.</p>

},
keywords = {Agda}
}

@software{10.5281/zenodo.4271370,
author = {Cockx, Jesper and Tabareau, Nicolas and Winterhalter, Th\'{e}o},
title = {Coq formalisation for The Taming of the Rew},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4271370},
abstract = {
    <p>Fork of the MetaCoq repository extended with rewrite rules. The README explains how to build and what files are important with respect to the paper “The Taming of the Rew: A Type Theory with Computational Assumptions”.</p>

},
keywords = {coq, foramlisation, metacoq, proof, rewrite rules}
}

@software{10.5281/zenodo.4273768,
author = {Reynaud, Alban and Scherer, Gabriel and Yallop, Jeremy},
title = {Artifact accompanying the paper "A practical mode system for recursive definitions".},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4273768},
abstract = {
    <p>The paper studies a specific feature of some functional programming languages, namely recursive definitions of things that are not immediate functions (recursive records, functions preceded by local declarations or various other language constructs, etc.). We propose a new system of inference rules to characterize valid definitions, to avoid runtime errors when evaluating the definitions. An algorithm can be directly derived from our inference rules to check the validity of recursive definitions. The check has been integrated in the OCaml compiler – more precisely, the implementation work for the OCaml compiler led to the present paper.</p>
<p>The artifact provides evidence for the claims in the paper, principally:</p>
<p>Do the formal system presented in the paper and the implementation in OCaml compiler correspond to each other?</p>
<p>The artifact contains various versions of the OCaml compiler (and compilers for some other languages discussed in the paper), instructions for confirming that our system fixes the bugs claimed in the paper, examples that illustrate how the system works, references to the parts of the implementation that correspond to parts of the formal system, and evidence for the empirical claims that the paper makes about the prevalence and character of recursive value definitions in existing programs.</p>

},
keywords = {call-by-value, functional programming, ML, OCaml, recursion, semantics, types}
}

@software{10.5281/zenodo.4283027,
author = {Georges, A\"{\i}na Linn and Gu\'{e}neau, Arma\"{e}l and Van Strydonck, Thomas and Timany, Amin and Trieu, Alix and Huyghebaert, Sander and Devriese, Dominique and Birkedal, Lars},
title = {Artifact of Conference Paper: Efficient and Provable Local Capability Revocation using Uninitialized Capabilities},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4283027},
abstract = {
    <p>The artifact is composed of two parts. The first part is the Iris formalization. It contains all the definitions and proofs presented in the paper, mechanized in the Iris framework of Coq. The second part of the artifact corresponds to a CHERI implementation of uninitialized capabilities. The CHERI implementation has been extended with uninitialized capabilities.</p>

},
keywords = {CHERI, Coq, Iris}
}

@software{10.5281/zenodo.4284088,
author = {Silver, Lucas and Zdancewic, Steve},
title = {Dijkstra Monads Forever: Termination-Sensitive Specifications for Interaction Trees},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4284088},
abstract = {
    <p>This artifact contains formal definitions and machine checked proofs for the objects and theorems presented in the paper.</p>

},
keywords = {Algebraic Effects, Coinduction, Coq, Monads, Specifications}
}

@software{10.5281/zenodo.4323505,
author = {Muller, Stefan K. and Hoffmann, Jan},
title = {RaCUDA software and Coq Proofs for "Modeling and Analyzing Evaluation Cost of CUDA Kernels"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4323505},
abstract = {
    <p>Software and proof artifacts for the POPL 2021 paper “Modeling and Analyzing Evaluation Cost of CUDA Kernels”. The artifact is packaged as a virtual machine image in ova format.</p>

},
keywords = {CUDA, performance analysis, program logics, resource-aware type system, thread-level parallelism}
}

@software{10.1145/3410252,
author = {Fritsche, Lars and Kosiol, Jens and M\"{o}ller, Adrian and Sch\"{u}rr, Andy and Taentzer, Gabriele},
title = {Artifact Evaluation for 'A Precedence-Driven Approach for Concurrent Model Synchronization Scenarios using Triple Graph Grammars'},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410252},
abstract = {
    <p>This artifact contains the evaluation of our paper ‘A Precedence-Driven Approach for Concurrent Model Synchronization Scenarios using Triple Graph Grammars’ in the form of a virtual machine and a step-by-step guide.</p>

},
keywords = {concurrent model synchronization, eMoflon, model-driven engineering, triple graph grammar}
}

@software{10.1145/3410254,
author = {Ghzouli, Razan and Berger, Thorsten and Johnsen, Einar Broch and Dragule, Swaib and W\k{a}sowski, Andrzej},
title = {Replication package for article: Behavior Trees in Action: A Study of Robotics Applications},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410254},
abstract = {
    <p>In the submitted artifact, you can find the scripts to replicate our paper results under “notebooks” folder. Check the “artifacts-instructions” document on how to run the scripts. Also, you can find the behavior tree models that were analyzed in our paper under “rawdata” folder.</p>

},
keywords = {Behavior tree models, Behavior trees, BehaviorTree.CPP, pyTreesRos}
}

@software{10.13020/D6QX07,
author = {Kramer, Lucas and Van Wyk, Eric},
title = {Silver artifacts for strategic tree rewriting and monadifiation in attribute grammars},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.13020/D6QX07},
abstract = {
    <p>Silver artifacts for strategic tree rewriting in attribute grammars and the monadification of attribute grammars.</p>

},
keywords = {attribute grammars, monadification, strategic tree rewriting}
}

@software{10.5281/zenodo.3973073,
author = {Fl\"{u}ckiger, Olivier and Chari, Guido and Yee, Ming-Ho and Je\v{c}men, Jan and Hain, Jakob and Vitek, Jan},
title = {Artifact of "Contextual Dispatch for Function Specialization},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3973073},
abstract = {
    <p>This is the artifact to accompany our OOPSLA 2020 submission on “Contextual Dispatch for Function Specialization”. The artifact consists of a virtual machine for the R language, called \v{R}, a suite of benchmarks written in R, as well as an R script to interpret and plot the results.</p>

},
keywords = {benchmark, contextual dispatch, R, specialization, virtual machine, \v{R}}
}

@software{10.5281/zenodo.3975566,
author = {Turo\v{n}ov\'{a}, Lenka and Hol\'{\i}k, Luk\'{a}\v{s} and Leng\'{a}l, Ond\v{r}ej and Saarikivi, Olli and Veanes, Margus and Vojnar, Tom\'{a}\v{s}},
title = {Artifact for the OOPSLA'20 paper "Regex Matching with Counting-Set Automata"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3975566},
abstract = {
    <p>The artifact contains a regular expression matching engine (called CsA) optimized for regular expressions with counters. It also includes other tools—RE2, grep, SRM, and the .NET default regular expression matcher—and provides comparison of CsA with these tools.</p>

},
keywords = {counting-set automata, derivatives, malware detection, regex, regular expression matching}
}

@software{10.5281/zenodo.4032185,
author = {Urban, Caterina and Christakis, Maria and W\"{u}stholz, Valentin and Zhang, Fuyuan},
title = {Perfectly Parallel Fairness Certification of Neural Networks - Artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4032185},
abstract = {
    <p>This is the artifact accompanying the published paper.</p>

},
keywords = {Abstract Interpretation, Fairness, Neural Networks, Static Analysis}
}

@software{10.5281/zenodo.4032401,
author = {Rigger, Manuel and Su, Zhendong},
title = {OOPSLA 20 Artifact for "Finding Bugs in Database Systems via Query Partitioning"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4032401},
abstract = {
    <p>The artifact consists of two main components:</p>
<ol type="1">
<li>SQLancer, the tool which we created and extended, and in which we implemented Ternary Logic Partitioning (TLP), to find all bugs reported in the paper.</li>
<li>A SQLite database with a list of bugs that we reported and additional meta information.</li>
</ol>

},
keywords = {Query Partitioning, SQLancer, Ternary Logic Partitioning}
}

@software{10.5281/zenodo.4032445,
author = {Smits, Jeff and Visser, Eelco},
title = {Replication image for paper: Gradually Typing Strategies},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4032445},
abstract = {
    <p>This is the artifact for the paper Gradually Typing Strategies, accepted at International Conference on Software Language Engineering.</p>
<h3 id="table-of-contents">Table of Contents</h3>
<ul>
<li>Preliminary PDF version of the accepted paper.</li>
<li>VirtualBox image, containing:
<ul>
<li>A linux installation,</li>
<li>Spoofax 2.5.11 (the latest stable Spoofax version) pre-installed,</li>
<li>The StrategoGT Spoofax project, a prototype alternative Stratego language definition with the gradual type system,</li>
<li>The StrategoGT Spoofax tests project with example and test files, including the examples from the paper and the case study from the paper.</li>
</ul></li>
</ul>

},
keywords = {gradual types, gradual typing, Spoofax, Stratego}
}

@software{10.5281/zenodo.4032454,
author = {Zhou, Fangyi and Ferreira, Francisco and Hu, Raymond and Neykova, Rumyana and Yoshida, Nobuko},
title = {Statically Verified Refinements for Multiparty Protocols},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4032454},
abstract = {
    <p>Our paper presents Session<em>, a toolchain for specifying message passing protocols using Refined Multiparty Session Types and safely implementing the distributed endpoint programs in F</em>. This is the accompanying artifact containing the toolchain sources, and examples and sources used in the evaluation of the paper. For a more detailed description, see https://github.com/sessionstar/oopsla20-artifact/blob/master/README.md</p>

},
keywords = {Code Generation, F*, Multiparty Session Types (MPST), Refinement Types}
}

@software{10.5281/zenodo.4032625,
author = {Flanagan, Cormac and Freund, Stephen N.},
title = {Software Artifact for "The Anchor Verifier for Blocking and Non-Blocking Concurrent Software"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4032625},
abstract = {
    <p>This is the software artifact accompanying the paper “The Anchor Verifier for Blocking and Non-Blocking Concurrent Software” published at OOPSLA 2020.</p>

},
keywords = {Anchor verifier, concurrent program verification, reduction, synchronization}
}

@software{10.5281/zenodo.4033001,
author = {Kallas, Konstantinos and Niksic, Filip and Stanford, Caleb and Alur, Rajeev},
title = {Artifact for DiffStream: Differential Output Testing for Stream Processing Programs},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4033001},
abstract = {
    <p>A differential testing library for Apache Flink programs. This artifact is provided as a VM.</p>
<p>The tool and the underlying methodology are described in the OOPSLA paper: DiffStream: Differential Output Testing for Stream Processing Programs</p>
<p>For further information and instructions, see the README after opening the VM.</p>

},
keywords = {Apache Flink, Differential Testing, Runtime Verification, Stream Processing}
}

@software{10.5281/zenodo.4033220,
author = {Verano Merino, Mauricio and van der Storm, Tijs},
title = {Kogi– Block-Based Syntax from Context-Free Grammars},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4033220},
abstract = {
    <p>The current artifact contains Kogi’s implementation, as described in the SLE paper (Block-Based Syntax from Context-Free Grammars). Kogi is a tool for deriving a block-based environment from a context-free grammar specification described in our SLE paper. Kogi uses Google Blockly for rendering block-based environments and Rascal’s concrete syntax formalism for describing context-free grammars. Remarkably, this release contains an optimization to make BBEs more usable by simplifying grammar chain rules.</p>

},
keywords = {app inventor, block-based environments, Blockly, DSLs, google blockly, grammars, language workbenches, Rascal, scratch, syntax, visual languages}
}

@software{10.5281/zenodo.4033367,
author = {Andersen, Leif and Ballantyne, Michael and Felleisen, Matthias},
title = {Artifact: Adding Interactive Visual Syntax to Textual Code},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4033367},
abstract = {
    <p>Many programming problems call for coding geometrical thoughts: tables, hierarchical structures, nests of objects, trees, forests, graphs, and so on. Linear text does not do justice to such thoughts. But, it has been the dominant programming medium for the past and will remain so for the foreseeable future.</p>
<p>This paper proposes a mechanism for conveniently extending textual programming languages with problem-specific visual syntax. It argues the necessity of this language feature, demonstrates the feasibility with a robust prototype, and sketches a design plan for adapting the idea to other languages.</p>

},
keywords = {Domain Specific Language}
}

@software{10.5281/zenodo.4033626,
author = {Pit-Claudel, Cl\'{e}ment},
title = {Artifact for Alectryon paper at SLE 2020 (Untangling Mechanized Proofs)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4033626},
abstract = {
    <p>A virtual machine submitted to SLE 2020’s artifact evaluation committee. Includes a snapshot of the Alectryon repository and datasets and scripts to reproduce the paper’s listings and figures.</p>

},
keywords = {formal verification, literate programming, proof presentation, proofbrowsing}
}

@software{10.5281/zenodo.4034438,
author = {Zhou, Yaoda and Oliveira, Bruno C. d. S. and Zhao, Jinxu},
title = {Revisiting Iso-Recursive Subtyping},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4034438},
abstract = {
    <p>This artifact contains the Coq formulation associated with the paper “Revisiting Iso-Recursive Subtyping”. For details, please refer to readme.</p>

},
keywords = {Coq, Formulation, Iso-recursive types}
}

@software{10.5281/zenodo.4034724,
author = {Zhang, Hengchu and Roth, Edo and Haeberlen, Andreas and Pierce, Benjamin C. and Roth, Aaron},
title = {Replication Package for Article: Testing Differential Privacy with Dual Interpreters},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4034724},
abstract = {
    <p>This package contains the Haskell implementation of DPCheck — an automated testing framework for differential privacy.</p>

},
keywords = {differential privacy, symbolic execution}
}

@software{10.5281/zenodo.4035150,
author = {Coblenz, Michael and Aldrich, Jonathan and Myers, Brad A. and Sunshine, Joshua},
title = {Replication Package for Article: Can Advanced Type Systems Be Usable? An Empirical Study of Ownership, Assets, and Typestate in Obsidian},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4035150},
abstract = {
    <p>The artifact consists of all the materials one would need to replicate the experiment in the paper. It includes a copy of the Obsidian repository as well as all of the materials the experiment participants received. It also includes the data generated by the participants during the study.</p>

},
keywords = {assets, blockchain, empirical studies of programming languages, linear types, Obsidian, ownership, permissions, smart contracts, typestate}
}

@software{10.5281/zenodo.4036303,
author = {Brody, Shaked and Alon, Uri and Yahav, Eran},
title = {A Structural Model for Contextual Code Changes articat},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4036303},
abstract = {
    <p>This artifact contains the PyTorch implementation of the neural network C3PO, along with all the required code and data to reproduce our results of the paper. Our code can be easily extended to other programming languages since the PyTorch network is agnostic to the input programming language. We also provide a with C# extractor for preprocessing the (raw) input code and explain how to implement such an extractor for other input programming languages.</p>

},
keywords = {Edit Completions, Machine Learning, Neural Models of Code}
}

@software{10.5281/zenodo.4037278,
author = {Turcotte, Alexi and Goel, Aviral and K\v{r}ikava, Filip and Vitek, Jan},
title = {Designing Types for R, Empirically (Data, Software, and Experiment Artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4037278},
abstract = {
    <p>This artifact supports the paper “Designing Types for R, Empirically”, which appears at OOPSLA’20. The purpose of this artifact is to showcase the tools used to infer R function types, to showcase contractr, our function-types-as-contracts assertion package for R, and detail and replicate the experiments from the paper. In the artifact, you’ll find a “Getting Started Guide” to quickly sanity check the installation, and a detailed set of instructions on how to use our tracer (Typetracer), contractr, and how to replicate the experiments at whichever scale you like.</p>

},
keywords = {contracts, corpus analysis, dynamic analysis, empirical study, language design, R, type systems, types}
}

@software{10.5281/zenodo.4038334,
author = {Peleg, Hila and Gabay, Roi and Itzhaky, Shachar and Yahav, Eran},
title = {Artifact for: Programming with a Read-Eval-Synth Loop},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4038334},
abstract = {
    <p>Contains the RESL tool and reproduction of empirical experiments.</p>

},
keywords = {program synthesis, resl}
}

@software{10.5281/zenodo.4039085,
author = {Bembenek, Aaron and Greenberg, Michael and Chong, Stephen},
title = {Formulog: Datalog for SMT-Based Static Analysis (OOPSLA 2020 Artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4039085},
abstract = {
    <p>This artifact corresponds to the paper “Formulog: Datalog for SMT-Based Static Analysis” by Aaron Bembenek, Michael Greenberg, and Stephen Chong, which has been accepted at OOPSLA 2020. It includes the Formulog runtime and material for running the empirical experiments described in the paper.</p>

},
keywords = {Datalog, Formulog, SMT solving}
}

@software{10.5281/zenodo.4039224,
author = {Barke, Shraddha and Peleg, Hila and Polikarpova, Nadia},
title = {Source Code Artifact for the paper: Just-in-Time Learning for Bottom-Up Enumerative Synthesis},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4039224},
abstract = {
    <p>The artifact replicates the experiments in the first revision of the paper.</p>

},
keywords = {Domain-specific languages, Probabilistic models, Program Synthesis}
}

@software{10.5281/zenodo.4039826,
author = {Sprenger, Christoph and Klenze, Tobias and Eilers, Marco and Wolf, Felix A. and M\"{u}ller, Peter and Clochard, Martin and Basin, David},
title = {Artifact for "Igloo: Soundly Linking Compositional Refinement and Separation Logic for Distributed System Verification"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4039826},
abstract = {
    <p>This artifact contains the entire Igloo framework formalized in Isabelle/HOL 2020 as well as our case studies (in Isabelle/HOL, VeriFast and Nagini). All necessary tools are pre-installed in the virtual machine.</p>

},
keywords = {distributed systems, formal methods, modeling, program verification, proof assistants}
}

@software{10.5281/zenodo.4040341,
author = {Jeon, Minseok and Lee, Myungho and Oh, Hakjoo},
title = {Learning Graph-based Heuristics for Pointer Analysis without Handcrafting Application-Specific Features},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4040341},
abstract = {
    <p>This is the artifact of our technique Graphick in the paper “Learning Graph-based Heuristics for Pointer Analysis without Handcrafting Application-Specific Features”.</p>
<p>The zip file (Graphick.zip) contains a bootable VirtualBox image (Graphick.ova) with all of the necessary libraries installed. To reproduce the majority of our evaluations, 50 GB of free storage and 32 GB of free memory are required. Using a smaller size of memory may not be able to reproduce the analysis results for the large programs (e.g., briss) used in our evaluation.</p>
<p>The manual pdf file (manual.pdf) in Graphick.zip provides a getting started guide (Section 1) and step by step instructions (Section 2). Please, follow the instructions to reproduce the evaluation results.</p>
<p>Note that this artifact is exactly the version that we submitted to OOPSLA Artifact when our paper was first conditionally accepted; the table numbers do not match with our latest revised paper. To reduce the confusion, we also include the corresponding old version of our paper (Graphick-old.pdf) in the zip file that the table numbers are matched. For the newly added evaluations of our final paper, we will upload a new implementation that reproduces all the evaluations.</p>

},
keywords = {Context sensitivity, Data-driven static analysis, Heap abstraction, Machine learning for program analysis, Pointer analysis}
}

@software{10.5281/zenodo.4043041,
author = {Mukherjee, Suvam and Deligiannis, Pantazis and Biswas, Arpita and Lal, Akash},
title = {Learning-Based Controlled Concurrency Testing},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4043041},
abstract = {
    <p>Concurrency bugs are notoriously hard to detect and reproduce. Controlled concurrency testing (CCT) techniques aim to offer a solution, where a scheduler explores the space of possible interleavings of a concurrent program looking for bugs. Since the set of possible interleavings is typically very large, these schedulers employ heuristics that prioritize the search to “interesting” subspaces. However, current heuristics are typically tuned to specific bug patterns, which limits their effectiveness in practice.</p>
<p>In this artifact, we present QL, a learning-based CCT framework where the likelihood of an action being selected by the scheduler is influenced by earlier explorations. We leverage the classical Q-learning algorithm to explore the space of possible interleavings, allowing the exploration to adapt to the program under test, unlike previous techniques. We have implemented and evaluated QL on a set of microbenchmarks, complex protocols, as well as production cloud services. In our experiments, we found QL to consistently outperform the state-of-the-art in CCT.</p>

},
keywords = {concurrency, model checking, reinforcement learning, testing}
}

@software{10.5281/zenodo.4043646,
author = {Marntirosian, Koar and Schrijvers, Tom and Oliveira, Bruno C. d. S. and Karachalias, Georgios},
title = {Resolution as Intersection Subtyping via Modus Ponens},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4043646},
abstract = {
    <p>This artifact consists of supplementary material for the article “Resolution as Intersection Subtyping via Modus Ponens”.</p>
<p>It contains a prototype implementation of λiMP, a mechanization of the metatheory of our calculus (declarative) and a mechanization of the metatheory for the subtyping algorithm of our calculus.</p>

},
keywords = {coherence, family polymorphism, intersection types, modus ponens, nested composition, resolution}
}

@software{10.5281/zenodo.4046893,
author = {Castro-Perez, David and Yoshida, Nobuko},
title = {CAMP: Cost-Aware Multiparty Session Protocols (artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4046893},
abstract = {
    <p>This is the artifact for the paper ‘CAMP: Cost-Aware Multiparty Session Protocols’. The artifact comprises:</p>
<ul>
<li>A library for specifying cost-aware multiparty protocols.</li>
<li>The raw data used for comparing the cost models with real execution costs.</li>
<li>The cost-aware protocol specifications of the benchmarks that we studied.</li>
</ul>
<p>The library for specifying cost-aware protocols also provides functions for extracting cost equations from them, and for estimating recursive protocol latencies (i.e.&nbsp;average cost per protocol iteration). We provide a script for extracting cost equations, and instantiating them using the parameters used in the paper.</p>

},
keywords = {cost models, message optimisations, parallel programming, session types}
}

@software{10.5281/zenodo.4048298,
author = {Griesemer, Robert and Hu, Raymond and Kokke, Wen and Lange, Julien and Taylor, Ian Lance and Toninho, Bernardo and Wadler, Philip and Yoshida, Nobuko},
title = {Featherweight Go (Artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4048298},
abstract = {
    <p>This paper presents Featherweight Go (FG) and Featherweight Generic Go (FGG), a core calculus of Go and a proposal for extending it with generics. The calculi are in the same vein as Featherweight Java (FJ), but where Featherweight Generic Java (FGJ) was translated into FJ via erasure, FGG translates into FG via monomorphisation (which is also formalised). The two calculi are proven sound using the normal progress and preservation arguments. Additionally a bisimulation is shown to exist between a FGG program and its monomorphisation (if it exists); in other words that monomorphisation preserves the semantics of the program.</p>
<p>The artifact consists of an implementation of type checkers and interpreters for FG and FGG, as well as a monomorphisation procedure (including the check if it is possible). It includes the examples from the paper, and a comparison using the Go compiler as reference. Type preservation and bisimulation for these programs are tested dynamically. Additionally, the same is tested for all well-typed programs up to a certain size (which are generated in a manner similar to property-based testing).</p>

},
keywords = {Generics, Go, Monomorphisation}
}

@software{10.5281/zenodo.4051784,
author = {Majumdar, Rupak and Yoshida, Nobuko and Zufferey, Damien},
title = {Multiparty Motion Coordination: From Choreographies to Robotics Programs (Artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4051784},
abstract = {
    <p>Software artifact for the paper “Multiparty Motion Coordination: From Choreographies to Robotics Programs” submitted to OOPSLA 2020</p>
<p>The artifact has been packaged into a virtual machine (Ubuntu 20.04). The username and password for the virtual machine is “pgcd”.</p>

},
keywords = {Message-passing, Motion Primitives, Robotics, Session Types and Choreography, Verification}
}

@software{10.5281/zenodo.4059797,
author = {Lagouvardos, Sifis and Grech, Neville and Tsatiris, Ilias and Smaragdakis, Yannis},
title = {Precise Static Modeling of Ethereum "Memory" (artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4059797},
abstract = {
    <p>Our artifact is bundled as a Docker image, containing the gigahorse decompiler, as well as our client analyses for tainted ERC20 Token <code>transfer</code>, Gas of Fallback Functions, Repeated Calls. The artifact also contains the contract sources and bytecodes for the contracts that were manually inspected for the evaluation of our paper.</p>

},
keywords = {ethereum, EVM, static analysis}
}

@software{10.5281/zenodo.4060109,
author = {Kabir, Ifaz and Li, Yufeng and Lhot\'{a}k, Ond\v{r}ej},
title = {ιDOT: A DOT Calculus with Object Initialization (Coq Formalization)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4060109},
abstract = {
    <p>This is the artifact for our OOPSLA’20 paper that presents ιDOT, a Dependent Object Types calculus with a type and effect system to ensure safe initialization of objects. This artifact contains the proof of type safety for the ιDOT calculus, formalized in the Coq proof assistant.</p>

},
keywords = {Coq, dependent object types, DOT, effect systems, iDOT, initialization, Scala, type safety, type soundness, type systems}
}

@software{10.5281/zenodo.4060132,
author = {Holtzen, Steven and Van den Broeck, Guy and Millstein, Todd},
title = {Software Artifact for: Scaling Exact Inference for Discrete Probabilistic Programs},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4060132},
abstract = {
    <p>This artifact contains a working copy of the software described in the paper, along with a guide for reproducing the key experimental results.</p>

},
keywords = {probabilistic programming}
}

@software{10.5281/zenodo.4060186,
author = {Bartell, Sean and Dietz, Will and Adve, Vikram S.},
title = {Artifact for Guided Linking: Dynamic Linking Without the Costs},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4060186},
abstract = {
    <p>Artifact for the paper “Guided Linking: Dynamic Linking Without the Costs”, conditionally accepted to OOPSLA 2020. This is the accepted version of the artifact, but the final version of the paper will include major terminology changes and improvements to the evaluation (such as Profile-Guided Optimization). An updated artifact, suitable for reproducing the results in the final paper, will be available at a later date.</p>

},
keywords = {compiler, dynamic linking, guided linking, ld.so, llvm, nixos, nixpkgs, optimization, shared libraries}
}

@software{10.5281/zenodo.4061106,
author = {Xiang, Tongtong and Luo, Jeff Y. and Dietl, Werner},
title = {PUnits: Precise Inference of Expressive Units of Measurement Types},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4061106},
abstract = {
    <p>PUnits is a pluggable type system for expressive units of measurement types and a precise, whole-program inference approach for these types. It can be used in three modes: (1) modularly check the correctness of a program, (2) ensure a possible unit typing exists, (3) annotate a program with units. Annotation mode allows human inspection and is essential since having a valid typing does not guarantee that the inferred specification expresses design intent. PUnits is the first units type system with this capability. This artifact is a docker image containing all required software and benchmarks to reproduce the results of the paper.</p>

},
keywords = {Dimensional analysis, Pluggable type system, Scientific computing, Type inference, Units of measurements}
}

@software{10.5281/zenodo.4063694,
author = {Sotiropoulos, Thodoris and Chaliasos, Stefanos and Mitropoulos, Dimitris and Spinellis, Diomidis},
title = {Replication Package for Article: A Model for Detecting Faults in Build Specifications},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4063694},
abstract = {
    <p>This artifact contains the source code of the system, namely BuildFS, described in the article “A Model for Detecting Faults in Build Specifications”. BuildFS was designed to detect faults in Make and Gradle build specifications. In addition to that, the artifact includes all the scripts used to re-run the evaluation of BuildFS as described in the article. Specifically, these scripts apply BuildFS to 612 open-source Make and Gradle projects taken from the Github and Debian ecosystems, and evaluate BuildFS in terms of</p>
<ul>
<li>Effectiveness</li>
<li>Efficiency</li>
<li>Comparison with the-state-of-the-art</li>
</ul>

},
keywords = {Build, Fault, Gradle, Make}
}

@software{10.5281/zenodo.4067001,
author = {Ballantyne, Michael and King, Alexis and Felleisen, Matthias},
title = {Artifact for OOPSLA '20 "Macros For Domain-Specific Languages"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4067001},
abstract = {
    <p>This artifact contains the library, case studies, and examples presented in the paper.</p>

},
keywords = {extensible domain specific languages, hygiene, macros}
}

@software{10.5281/zenodo.4068065,
author = {Rouvoet, Arjen and van Antwerpen, Hendrik and Bach Poulsen, Casper and Krebbers, Robbert and Visser, Eelco},
title = {Knowing when to Ask: MiniStatix implementation and case studies},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4068065},
abstract = {
    <p>We implement the small-step operational semantics of the core constraint language of Statix in Haskell and present ‘MiniStatix’. We evaluate this semantics using three case studies specifying name binding aspects of Java, Scala and Rust.</p>

},
keywords = {case study, Haskell, MiniStatix, Name binding, Statix}
}

@software{10.5281/zenodo.4081681,
author = {Geisler, Dietrich and Yoon, Irene and Kabra, Aditi and He, Horace and Sanders, Yinnon and Sampson, Adrian},
title = {Replication Package for Article: Geometry Types for Graphics Programming},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4081681},
abstract = {
    <p>The purpose of this package is to replicate the results of the paper “Geometry Types for Graphics Programming” and provide a research compiler from the Gator language to GLSL. This artifact includes, in a VM, the results included with the above paper, the tools for replicating these results, and a work-in-progress compiler from Gator to GLSL. The intent of this package is to help with replication and make the Gator language available and useable for those interested.</p>

},
keywords = {Compilers, Graphics Programming, Language Design, Programming Languages}
}

@software{10.5281/zenodo.4088252,
author = {Atkinson, Eric and Carbin, Michael},
title = {Artifact for "Programming and Reasoning with Partial Observability"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4088252},
abstract = {
    <p>This is the artifact that accompanies the OOPSLA 2020 paper “Programming and Reasoning with Partial Observability”.</p>

},
keywords = {partial observability, uncertainty}
}

@software{10.5281/zenodo.4139038,
author = {Perianez-Pascual, Jorge and Rodriguez-Echeverria, Roberto and Burgue\~{n}o, Loli and Cabot, Jordi},
title = {Towards the Optical Character Recognition of DSLs - Artifact (img2DSL)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4139038},
abstract = {
    <p>img2DSL is an image recognition toolkit designed to study how Optical Character Recognition can be applied to images that contain DSL snippets. Using the Object Constraint Language (OCL) as an example of textual DSL and given a dataset of Ecore models (and its OCL expressions), this toolkit encodes the OCL expressions into images and tests how different strategies improve the default OCR quality. In this project we use Tesseract as OCR engine and the different strategies are different OCR models and custom algorithms.</p>
<p>In order to evaluate the toolkit and the quality of its different strategies, we load the recognized expressions in the USE tool to measure of how many expressions are valid after the recognition</p>

},
keywords = {domain-specific-languages, optical character recognition, text recognition}
}

@software{10.5281/zenodo.4160965,
author = {Rossouw, Christoff and Fischer, Bernd},
title = {Software Artifact for article: Test Case Generation from Context-Free Grammars using Generalized Traversal of LR-Automata},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4160965},
abstract = {
    <p>Python scripts used to reproduce results from paper. Output files from evaluation and grammars used.</p>

},
keywords = {mutation testing, push-down automata, test case generation}
}

@software{10.5281/zenodo.4240798,
author = {de Medeiros, S\'{e}rgio Queiroz and Olarte, Carlos},
title = {RESPEG: Rewriting Semantics for PEGs},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4240798},
abstract = {
    <p>We give a rewriting logic semantics for Paring Expression Grammars (PEGs) and implement such rewrite theory in Maude (a rewriting engine). The proposed rewrite theory formalizes the notion of local and global cuts that may help the designer of the grammar to control the backtracks during parsing.</p>

},
keywords = {Parsing Expression Grammars, Rewriting logic}
}

@software{10.5281/zenodo.4244899,
author = {Coulon, Fabien and Auvolat, Alex and Combemale, Benoit and Bromberg, Y\'{e}rom-David and Ta\"{\i}ani, Fran\c{c}ois and Barais, Olivier and Plouzeau, No\"{e}l},
title = {Artifact for the Paper: Modular and distributed IDE},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4244899},
abstract = {
    <p>This artifact includes Eclipse plugins allowing to generates microservices from DSL specifications, the necessary to setup a local Kubernetes cluster, and a Web application embedding a configurator to manage the deployment of the microservices on the local cluster and embedding a program editor interacting with the microservices.</p>

},
keywords = {Generative approach, IDE, Microservice}
}

@software{10.1145/3410246,
author = {Trabish, David and Kapus, Timotej and Rinetzky, Noam and Cadar, Cristian},
title = {Replication Package for Article: Past-Sensitive Pointer Analysis for Symbolic Execution},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410246},
abstract = {
    <p>The artifact contains the docker image with the source code and the evaluation-related data, and instructions for replicating the experiments.</p>

},
keywords = {Pointer Analysis, Symbolic Execution}
}

@software{10.1145/3410247,
author = {Babakol, Timur and Canino, Anthony and Mahmoud, Khaled and Saxena, Rachit and Liu, Yu David},
title = {Experimental Replication of Experiments for Article: Calm Energy Accounting for Multithreaded Java Applications},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410247},
abstract = {
    <p>Contained in this artifact is a Docker image that reproduces the data with instructions for usage and a link to our public repository where our source and data are stored.</p>

},
keywords = {Concurrency, Energy Accounting, Energy Profiling, Power Disturbance, Software Performance}
}

@software{10.1145/3410248,
author = {Ghamizi, Salah and Cordy, Maxime and Gubri, Martin and Papadakis, Mike and Boystov, Andrey and Le Traon, Yves and Goujon, Anne},
title = {Replication package for "Search-Based Adversarial Testing and Improvement of Constrained Credit Scoring Systems", accepted at ESEC/FSE 2020},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410248},
abstract = {
    <p>CoEva2 is a multi-objective search technique to generate adversarial attacks against real-life systems. It uses domain specific constraints and domain specific objectives to craft the attacks. The paper tackles an industrial system and dataset under NDA that we cannot disclose (related to overdraft and credit scoring). In accordance with the Artifact Chair, we are providing a replication study on a public dataset called <em>Lending Club Loan data</em>. It shows both how to implement our approach on available datasets and that our results are valid for other contexts.</p>

},
keywords = {Adversarial attacks, Credit Scoring, FinTech, Random Forest, Search-based}
}

@software{10.1145/3410249,
author = {Liu, Ye and Li, Yi and Lin, Shang-Wei and Zhao, Rong},
title = {Replication Data for Article: Towards Automated Verification of Smart Contract Fairness},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410249},
abstract = {
    <p>This package contains the dataset, raw logs, and instructions for replicating the experiments in the paper titled “Towards Automated Verification of Smart Contract Fairness”.</p>

},
keywords = {fairness, program verification, Smart contract}
}

@software{10.1145/3410251,
author = {She, Dongdong and Krishna, Rahul and Yan, Lu and Jana, Suman and Ray, Baishakhi},
title = {Replication package for MTFuzz: Fuzzing with a Multi-Task Neural Network},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410251},
abstract = {
    <p>We provide source code for MTFuzz to foster further research in this area. We also provide 10 tested programs to reproduce results reported in our paper.</p>

},
keywords = {Fuzzing, Machine learning, Mutli-task learning}
}

@software{10.1184/R1/12543308.v1,
author = {Zhang, Changjian and Garlan, David and Kang, Eunsuk},
title = {Software for Paper: A Behavioral Notion of Robustness for Software Systems},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1184/R1/12543308.v1},
abstract = {
    <p>The prototype implementation for FSE 2020 paper: A Behavioral Notion of Robustness for Software Systems.</p>

},
keywords = {Formal methods, Software modeling and design, Software robustness, Specification and modeling languages}
}

@software{10.17605/OSF.IO/CHM2K,
author = {Badihi, Sahar and Akinotcho, Faridah and Li, Yi and Rubin, Julia},
title = {Implementation for ARDiff: Scaling Program Equivalence Checking via Iterative Abstraction and Refinement of Common Code},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.17605/OSF.IO/CHM2K},
abstract = {
    <p>This contains the implementation of three equivalence checking techniques: two state-of-the-art, Differential Symbolic Execution (DSE) and one based on Impacted Summaries, as well our novel technique ARDiff</p>

},
keywords = {abstraction-refinement, constraint solver, DSE, equivalence checking, impacted, JPF-symbc, static analysis, symbolic execution, z3}
}

@software{10.5281/zenodo.3843611,
author = {Zhang, Yuhao and Ren, Luyao and Chen, Liqian and Xiong, Yingfei and Cheung, Shing-Chi and Xie, Tao},
title = {DEBAR: Detecting Numerical Bugs in Neural Network Architectures},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3843611},
abstract = {
    <p>This artifact contains the implementation of DEBAR and the evaluation in our ESEC/FSE 2020 paper: Detecting Numerical Bugs in Neural Network Architectures.</p>

},
keywords = {Neural Network, Numerical Bugs, Static Analysis}
}

@software{10.5281/zenodo.3872848,
author = {Helm, Dominik and K\"{u}bler, Florian and Reif, Michael and Eichberg, Michael and Mezini, Mira},
title = {Artifact for Modular Collaborative Program Analysis in OPAL},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3872848},
abstract = {
    <p>This is the artifact that was used to obtain the results of “Modular Collaborative Program Analysis in OPAL”, published at ESEC/FSE 2020.</p>
<p>The Docker container contains the necessary tools (OPAL and DOOP), benchmarks (XCorpus, DoopBenchmarks), scripts to run the tools for the experiments performed in the paper and scripts to clean up the output of these experiments to reproduce the tables from the paper.</p>
<p>Please note that the artifact refers to OPAL as ‘BlaSt’ as this name was used during double-blind review.</p>

},
keywords = {Blackboard System, Composition, Modularization, Parallelization, Static Analysis}
}

@software{10.5281/zenodo.3872902,
author = {Gaaloul, Khouloud and Menghi, Claudio and Nejati, Shiva and Briand, Lionel C. and Wolfe, David},
title = {Replication Package for Article: Mining Assumptions for Software Components using Machine Learning},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3872902},
abstract = {
    <p>EPIcuRus (assumPtIon geneRation approach for CPS) automatically synthesizes environment assumptions for a component under analysis. EPIcuRus combines search-based testing, machine learning, and model checking. The core of EPIcuRus is a decision tree algorithm that infers environment assumptions from a test suite including test cases and their verdicts. The test cases are generated using search-based testing, and the assumptions inferred by decision trees are validated through model checking. To improve the efficiency and effectiveness of the assumption generation process, EPIcuRus implements a novel test case generation technique, namely Important Features Boundary Test (IFBT), that guides the test generation based on the feedback produced by machine learning.</p>

},
keywords = {Decision trees, Environment assumptions, Machine learning, Model checking, Search-based software testing}
}

@software{10.5281/zenodo.3874077,
author = {Pan, Rangeet and Rajan, Hridesh},
title = {Replication Package for the Article: On Decomposing a Deep Neural Network into Modules},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3874077},
abstract = {
    <p>This repository has the source code for the paper “On Decomposing a Deep Neural Network into Modules”</p>

},
keywords = {decomposing, deep neural networks, modularity, modules}
}

@software{10.5281/zenodo.3876048,
author = {Ben Khadra, M. Ammar and Stoffel, Dominik and Kunz, Wolfgang},
title = {Supplemental artifacts of the paper: Efficient Binary-Level Coverage Analysis},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3876048},
abstract = {
    <p>The archive contains the artifacts accompanying the paper: “Efficient Binary-Level Coverage Analysis”. The artifacts are organized as follows:</p>
<ul>
<li><p><code>sample-binaries</code>. Folder that contains sample binaries patched with bcov.</p></li>
<li><p><code>dataset.tar.gz</code>. Package that contains experimental data in csv format.</p></li>
<li><p><code>figures</code>. Folder that contains the python script used to generate the figures of our paper. It assumes that the dataset was first extracted to the folder <code>dataset</code>.</p></li>
<li><p><code>install.sh</code>. This script builds and installs bcov together with its dependencies.</p></li>
<li><p><code>experiment-01.sh</code>. This script patches our sample binaries and shows how coverage data can be collected. It assumes that bcov was installed using the previous script.</p></li>
<li><p><code>bcov.tar.gz</code>. Source code of the first public version of <code>bcov</code>. The tool is distributed under an MIT license.</p></li>
</ul>

},
keywords = {code coverage analysis, experimental dataset, jump table analysis, reverse engineering, static binary instrumentation, supplemental artifacts}
}

@software{10.5281/zenodo.3876969,
author = {Gopinath, Rahul and Mathis, Bj\"{o}rn and Zeller, Andreas},
title = {Replication package for Mining Input Grammars from Dynamic Control Flow},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3876969},
abstract = {
    <p>A vagrant virtual box that is sufficient for reproduction of the results in Mining Input Grammars from Dynamic Control Flow</p>

},
keywords = {context-free grammar, fuzzing, mining, software testing}
}

@software{10.5281/zenodo.3877079,
author = {Terragni, Valerio and Jahangirova, Gunel and Tonella, Paolo and Pezz\`{e}, Mauro},
title = {Gassert: Evolutionary Improvement of Assertion Oracles},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3877079},
abstract = {
    <p>Gassert tool, presented in the paper “Evolutionary Improvement of Assertion Oracles” published at ESEC/FSE 2020.</p>

},
keywords = {esec-fse2020, gasser, oracle improvement, software testing, test generation}
}

@software{10.5281/zenodo.3877326,
author = {Chen, Qingrong and Wang, Teng and Legunsen, Owolabi and Li, Shanshan and Xu, Tianyin},
title = {Artifacts of Paper "Understanding and Discovering Software Configuration Dependencies in Cloud and Datacenter Systems"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3877326},
abstract = {
    <p>This package contains all the artifacts (i.e.&nbsp;codes \&amp; datasets) we use in our paper “Understanding and Discovering Software Configuration Dependencies in Cloud and Datacenter Systems” accepted to FSE 2020.</p>

},
keywords = {configuration dependencies, Hadoop, OpenStack, static analysis tools}
}

@software{10.5281/zenodo.3878164,
author = {Vassallo, Carmine and Proksch, Sebastian and Jancso, Anna and Gall, Harald C. and Di Penta, Massimiliano},
title = {Replication Package for "Configuration Smells in Continuous Delivery Pipelines: A Linter and A Six-Month Study on GitLab"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3878164},
abstract = {
    <p>This is the replication package of the paper “Configuration Smells in Continuous Delivery Pipelines: A Linter and A Six-Month Study on GitLab” accepted for publication at ESEC/FSE 2020. We describe the artifacts of our paper and how to use them to replicate the results of our study. When appropriate, we also link the description of the artifacts to relevant sections in the paper.</p>

},
keywords = {Anti-patterns, Configuration, Continuous Delivery, Continuous Integration, DevOps, GitLab, Linter}
}

@software{10.5281/zenodo.3895761,
author = {Shanker, Kripa and Joseph, Arun and Ganapathy, Vinod},
title = {Replication package for "An evaluation of methods to port legacy code to SGX enclaves"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3895761},
abstract = {
    <p>This artifact contains the code of the benchmarks used in the evaluation, as well as the source code of Porpoise, the instruction wrapper prototype used in the experiments reported in the paper.</p>

},
keywords = {enclaves, Porpoise, porting, programming, SGX}
}

@software{10.5281/zenodo.3896795,
author = {Mandrioli, Claudio and Maggio, Martina},
title = {Replication package for article: Testing Self-Adaptive Software with Probabilistic Guarantees on Performance Metrics},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3896795},
abstract = {
    <p>The artifact contains the code to replicate the experiments from the paper “Testing Self-Adaptive Software with Probabilistic Guarantees on Performance Metrics”. The experiments concerns two different adaptive softwre: Self -Adaptive Video Encoder, and Tele-Assistance System. The two subdirectories of the repository contain the code for the two artifacts.</p>

},
keywords = {Self-Adaptive Software, Testing}
}

@software{10.5281/zenodo.3902978,
author = {Cha, Sooyoung and Oh, Hakjoo},
title = {Replication Package for Article: Making Symbolic Execution Promising by Learning Aggressive State-Pruning Strategy},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3902978},
abstract = {
    <p>This is an artifact for the paper “Making Symbolic Execution Promising by Learning Aggressive State-Pruning Strategy” submitted to FSE 2020. It provides a VirtualBox image containing all resources to reproduce the main experimental results in our paper.</p>

},
keywords = {Online Learning, Symbolic Execution}
}

@software{10.5281/zenodo.3905204,
author = {Zhai, Yizhuo and Hao, Yu and Zhang, Hang and Wang, Daimeng and Song, Chengyu and Qian, Zhiyun and Lesani, Mohsen and Krishnamurthy, Srikanth V. and Yu, Paul},
title = {seclab-ucr/UBITect: First release of UBITect},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3905204},
abstract = {
    <p>This is the first release of UBITect, please follow the README.md to install and conduct the experiment.</p>

},
keywords = {bug detection, symbolic execution, type qualifier, Use-before-Initialization}
}

@software{10.5281/zenodo.3908793,
author = {Yan, Shenao and Tao, Guanhong and Liu, Xuwei and Zhai, Juan and Ma, Shiqing and Xu, Lei and Zhang, Xiangyu},
title = { 'Replication Package for Article: Correlations between Deep Neural Network Model Coverage Criteria and Model Quality'},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3908793},
abstract = {
    <p>This artifact includes two parts: ‘all-data.zip’ and ‘DNN/Testing/CovTesting-v1.1.zip’. ‘all-data.zip’ contains the data used for the experiments. ‘DNN/Testing/CovTesting-v1.1.zip’ contains the necessary codes. Please refer to the ‘README.md’ in ‘DNN/Testing/CovTesting-v1.1.zip’ to use this software. You can also refer to https://github.com/RU-System-Software-and-Security/CovTesting for more information.</p>

},
keywords = {Deep Neural Networks, Software Testing}
}

@software{10.5281/zenodo.3911750,
author = {Uesbeck, P. Merlin and Peterson, Cole S. and Sharif, Bonita and Stefik, Andreas},
title = {A Randomized Controlled Trial on the Effects of EmbeddedComputer Language Switching Replication Packet},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3911750},
abstract = {
    <p>A replication packet for the paper “A Randomized Controlled Trial on the Effects of Embedded Computer Language Switching” please review the README inside the zip archive.</p>

},
keywords = {analysis, computer language switching, data, database programming, experience, experiment software, polyglot programming, productivity, programming languages, randomized controlled trial, software}
}

@software{10.5281/zenodo.3912064,
author = {Biswas, Sumon and Rajan, Hridesh},
title = {Accepted Artifact Package for ESEC/FSE 2020 paper: Do the Machine Learning Models on a Crowd Sourced Platform Exhibit Bias? An Empirical Study on Model Fairness},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3912064},
abstract = {
    <p>The artifact contains code and data for the machine learning models used to analyze fairness.</p>

},
keywords = {fairness, machine learning, models}
}

@software{10.5281/zenodo.3923232,
author = {Zhang, Mingxue and Meng, Wei},
title = {Compiled Binary and Analysis Scripts of JSObserver on macOS 10.14 and Debian 9.11 (stretch)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3923232},
abstract = {
    <p>This is a pre-built version of JSObserver, which is a browser-based analysis framework that collects JavaScript write operation logs and function definition logs. It also contains analysis scripts that detect JavaScript global identifier conflicts (i.e., variable value conflicts, variable type conflicts and function definition conflicts) using the logs.</p>

},
keywords = {Analysis scripts, Compiled binary, JSObserver, Python}
}

@software{10.5281/zenodo.3947858,
author = {Rigger, Manuel and Su, Zhendong},
title = {ESEC/FSE 20 Artifact for "Detecting Optimization Bugs in Database Engines via Non-Optimizing Reference Engine Construction"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3947858},
abstract = {
    <p>The artifact consists of two main components:</p>
<ol type="1">
<li>SQLancer, the tool which we created, and in which we implemented NoREC, to find all bugs reported in the associated paper.</li>
<li>A SQLite database with a list of bugs that we reported and additional meta information.</li>
</ol>

},
keywords = {NoREC, SQLancer}
}

@software{10.5281/zenodo.3949286,
author = {Zhao, Yixue and Chen, Justin and Sejfia, Adriana and Schmitt Laser, Marcelo and Zhang, Jie and Sarro, Federica and Harman, Mark and Medvidovic, Nenad},
title = {FrUITeR's artifacts},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3949286},
abstract = {
    <p>FrUITeR’s artifacts accepted at ESEC/FSE 2020 for the paper “FrUITeR: A Framework for Evaluating UI Test Reuse”</p>

},
keywords = {Mobile Application, Open Science, Software Testing, Test Reuse}
}

@software{10.5281/zenodo.3949340,
author = {Wang, Zan and Yan, Ming and Chen, Junjie and Liu, Shuang and Zhang, Dongdi},
title = {Replication Packages for Article &nbsp;"Deep Learning Library Testing via Effective Model Generation"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3949340},
abstract = {
    <p>This artifact includes the code and datasets of LEMON. File named LEMON-V1.0.0.zip includes all the scripts in LEMON, and file named LEMON_datasets_models.zip includes datasets sampled from ImageNet or collected from GitHub by authors. More details can be seen in https://github.com/Jacob-yen/LEMON</p>

},
keywords = {Deep Learning Testing, Library Testing, Model Generation, Mutation, Search-based Software Testing}
}

@software{10.5281/zenodo.3951724,
author = {Hermann, Ben and Winter, Stefan and Siegmund, Janet},
title = {Community Expectations for Research Artifacts and Evaluation Processes (Additional Material)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3951724},
abstract = {
    <p>Raw and derived data on calls for artifacts and a survey conducted with artifact reviewers. The purpose of the artifact is to support the replicability of the conducted study, but also to allow for future studies in the same area.</p>

},
keywords = {Artifact Evaluation, Replicability, Reproducibility, Study}
}

@software{10.5281/zenodo.3966486,
author = {Trimananda, Rahmadi and Aqajari, Seyed Amir Hossein and Chuang, Jason and Demsky, Brian and Xu, Guoqing Harry and Lu, Shan},
title = {IoTCheck},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3966486},
abstract = {
    <p>IoTCheck is a framework that model-checks smart home apps. Please see https://github.com/uci-plrg/iotcheck for further instructions for downloads and installation.</p>

},
keywords = {concurrency, model checking, program analysis, smart home apps}
}

@software{10.5281/zenodo.4016963,
author = {Riccio, Vincenzo and Tonella, Paolo},
title = {Replication Package for Article: "Model-Based Exploration of the Frontier of Behaviours for Deep Learning System Testing"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4016963},
abstract = {
    <p>This artifact contains the tools and the data of the paper “Model-Based Exploration of the Frontier of Behaviours for Deep Learning System Testing” by V. Riccio and P. Tonella, published in the Proceedings of the ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE 2020). It is structured as follows: - DeepJanus-MNIST: contains the DeepJanus tool adapted to the handwritten digit classification case study and the instructions on how to use it; - DeepJanus-BNG: contains the DeepJanus tool adapted to the self-driving car case study and the instructions on how to use it; - experiments: contains the raw experimental data reported in the paper and the scripts to obtain the data.</p>

},
keywords = {deep learning, model based testing, search based software engineering, software testing}
}

@software{10.5281/zenodo.4021473,
author = {Harel-Canada, Fabrice and Wang, Lingxiao and Gulzar, Muhammad Ali and Gu, Quanquan and Kim, Miryung},
title = {Replication Package for Article: Is Neuron Coverage a Meaningful Measure for Testing Deep Neural Networks?},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4021473},
abstract = {
    <p>This artifact contains the code which generates adversarial test suites and measures its attack success, naturalness (IS + FID), and output impartiality. It also includes the notebooks used to generate figures and the correlations, which were then extracted into a google sheet. The MNIST and CIFAR10 data can be easily downloaded from source, but the udacity driving dataset was included as it may not always be available through the original competition github repo.</p>
<p>Any potential updates will be maintained here: https://github.com/fabriceyhc/nc_diversity_attacks</p>

},
keywords = {Adversarial Attack, Machine Learning, Neuron Coverage, Software Engineering, Testing}
}

@software{10.5281/zenodo.4022892,
author = {Erlenhov, Linda and Neto, Francisco Gomes de Oliveira and Leitner, Philipp},
title = {Replication package to An Empirical Study of Bots in Software Development – Characteristics and Challenges from a Practitioner's Perspective},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4022892},
abstract = {
    <p>Replication package for the analysis from the survey results in the paper “An Empirical Study of Bots in Software Development – Characteristics and Challenges from a Practitioner’s Perspective” Read the README.MD for instructions The replication package contains both R scripts and original data collected in the study.</p>

},
keywords = {Empirical study, Software bot, Software engineering}
}

@software{10.5281/zenodo.4023299,
author = {Cha, Alan and Wittern, Erik and Baudart, Guillaume and Davis, James C. and Mandel, Louis and Laredo, Jim A.},
title = {A Principled Approach to GraphQL Query Cost Analysis Research Paper Artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4023299},
abstract = {
    <p>The artifact contains 1) a GraphQL query-response corpus, containing 10,000 anonymized query and response pairs against the GitHub and Yelp APIs that were used in our experiments, 2) a randomized GraphQL query generator that was used to create the corpus, 3) configurations for the static analyses (ours as well as those we compared against) that were used in our experiments, 4) experiment data and the scripts that were used to create our plots, 5) scripts to fetch the GraphQL schemas that were used in our experiments, and 6) scripts that will use the aforementioned components to rerun our experiments.</p>

},
keywords = {API management, cost estimation, GraphQL, query complexity, random query generation}
}

@software{10.5281/zenodo.4024268,
author = {Beyer, Dirk and Friedberger, Karlheinz},
title = {Replication Artifact for Article 'Domain-Independent Interprocedural Program Analysis using Block-Abstraction Memoization'},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4024268},
abstract = {
    <p>This file is the replication package for the article “Domain-Independent Interprocedural Program Analysis using Block-Abstraction Memoization”, Proc. ESEC/FSE 2020. ACM. It contain the necessary tools and tasks to re-evaluate the benchmark results of the article. More details can be found in the artifact’s readme file.</p>

},
keywords = {CPAchecker, Interprocedural Analysis, Procedure Summary, Program Analysis, Software Verification}
}

@software{10.5281/zenodo.4028454,
author = {Baranov, Eduard and Legay, Axel and Meel, Kuldeep S.},
title = {Baital},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4028454},
abstract = {
    <p>Baital is a sampler generator for configurable systems. It generates a set of testing samples for large configurable systems with high t-wise coverage. The tool takes a set of constraints on features of the configurable system represented as a CNF formula in Dimacs format and provides a set of configurations of a specified size and computes their t-wise coverage.</p>

},
keywords = {Configurable software, t-wise coverage, Weighted sampling}
}

@software{10.5281/zenodo.4031225,
author = {Cambronero, Jos\'{e} P. and Cito, J\"{u}rgen and Rinard, Martin C.},
title = {AMS Artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4031225},
abstract = {
    <p>Software artifact for AMS (Generating AutoML Search Spaces from Weak Specifications), camera-ready modifications incorporated.</p>

},
keywords = {automated machine learning, search-based software engineering, software engineering}
}

@software{10.5522/04/11927208.v2,
author = {Guizzo, Giovani and Sarro, Federica and Harman, Mark},
title = {Replication package for "Cost Measures Matter for Mutation Testing Study Validity", accepted at FSE 2020},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5522/04/11927208.v2},
abstract = {
    <p>This is a replication package for the experiments reported in 2020 FSE paper “Cost Measures Matter for Mutation Testing Study Validity”.</p>
<p>It contains all the subject programs, experimental scripts, and results data.</p>

},
keywords = {Cost Reduction, Execution Time, Mutant Reduction, Mutation Analysis, Mutation Testing, Number of Mutants, Software Testing}
}

@software{10.6084/m9.figshare.11948619.v1,
author = {Mahajan, Sonal and Abolhassani, Negarsadat and Prasad, Mukul R.},
title = {Data Artifacts for the Paper, "Recommending Stack Overflow Posts for Fixing Runtime Exceptions using Failure Scenario Matching"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.11948619.v1},
abstract = {
    <p>We present the artifacts for our ESEC/FSE 2020 paper, “Recommending Stack Overflow Posts for Fixing Runtime Exceptions using Failure Scenario Matching”. In this artifact package, we present our data repository including the input and output artifacts of our MAESTRO tool. Particularly, the package the includes raw survey data, input benchmark, indexed Stack Overflow posts, scripts for reproducing key results in the paper, configurations used for running competitors, and steps to verify user ratings.</p>

},
keywords = {code search, crowd intelligence, data artifact, runtime exceptions, stack overflow, static analysis}
}

@software{10.6084/m9.figshare.12376931.v1,
author = {Garc\'{\i}a, Sergio and Str\"{u}ber, Daniel and Brugali, Davide and Berger, Thorsten and Pelliccione, Patrizio},
title = {Replication Package for Article "Robotics Software Engineering: A Perspective from the Service Robotics Domain"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.12376931.v1},
abstract = {
    <p>This is a replication package for the article “Robotics Software Engineering: A Perspective from the Service Robotics Domain.”</p>
<p>We provide several artifacts within the same package, divided into two categories: “Interview material” and “Survey material.” The first contains the artifacts related to our interviews, that is, the interviews’ guidelines (pdf format) and our codebook (docx format). The later contains the artifacts related to our online survey, i.e., the questionnaire (pdf format), the raw (anonymized) data in CSV format, and the R script we used to format, analyze, and represent such data.</p>

},
keywords = {challenges, empirical study, interviews, practices, robotics, software engineering, survey}
}

@software{10.6084/m9.figshare.12415622.v2,
author = {B\"{o}hme, Marcel and Man\`{e}s, Valentin J. M. and Cha, Sang Kil},
title = {Source and Results of "Boosting Fuzzer Efficiency An Information-Theoretic Perspective"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.12415622.v2},
abstract = {
    <p>Entropic is an information-theoretic power schedule implemented into LibFuzzer. It boosts performance by changing how weights are assigned to the seeds in the corpus. Seeds revealing more ‘‘information’’ about globally rare features are assigned a higher weight.</p>

},
keywords = {efficiency, entropy, fuzzing, information theory, software testing}
}

@software{10.6084/m9.figshare.12435542.v1,
author = {Bruce, Bobby R. and Zhang, Tianyi and Arora, Jaspreet and Xu, Guoqing Harry and Kim, Miryung},
title = {Replication Package for "JShrink: In-depth Investigation into Debloating Modern Java Applications"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.12435542.v1},
abstract = {
    <p>JShrink is a tool used to reduce the size of (debloat) Java bytecode. The tool was primarily developed to test previously discussed Java bytecode debloating techniques, by incorporating them in a single tool (JShrink) and evaluating their performance on modern Java applications.</p>
<p>The artifact contains the JShrink code, instructions for complilation, scripts to replicate experiment execution, and documentation where appropriate.</p>

},
keywords = {debloating, Java bytecode, reachability analysis, size reduction}
}

@software{10.5281/zenodo.3692205,
author = {Muller, Stefan K. and Singer, Kyle and Goldstein, Noah and Acar, Umut A. and Agrawal, Kunal and Lee, I-Ting Angelina},
title = {Responsive Parallelism with Futures and State - Software Artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3692205},
abstract = {
    <p>This artifact contains a prototype of the I-Cilk runtime for scheduling parallel code with task priorities, a C++ type system for preventing priority inversions, and benchmarks using both of the former. The artifact demonstrates the practicality of the type system in implementing performant parallel code that uses task priorities. The prototype I-Cilk runtime is in the interactive-cilk directory, with the type system located in interactive-cilk/include/cilk/cilk_priority.h.</p>

},
keywords = {futures, Interactive Cilk, priority inversion, responsiveness, task parallelism, type systems}
}

@software{10.5281/zenodo.3742225,
author = {Chowdhary, Sangeeta and Lim, Jay P. and Nagarakatte, Santosh},
title = {PositDebug Artifact: Debugging and Detecting Numerical Errors in Computation with Posits},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3742225},
abstract = {
    <p>This artifact contains a shadow execution framework for finding numerical errors in applications using both posits and floating point. The prototype for posits is called PositDebug and the prototype for floating point programs is called FPSsanitizer.</p>

},
keywords = {cancellation, CORDIC, floating point, FPSanitizer, numerical errors, PositDebug, posits}
}

@software{10.5281/zenodo.3742711,
author = {Antoniadis, Anastasios and Filippakis, Nikos and Krishnan, Paddy and Ramesh, Raghavendra and Allen, Nicholas and Smaragdakis, Yannis},
title = {Artifact: Static Analysis of Enterprise Applications: Frameworks and Caches, the Elephants in the Room},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3742711},
abstract = {
    <p>This artifact contains the evaluation benchmarks for the paper "Static Analysis of Java Enterprise Applications: Frameworks and Caches, the Elephants in the Room" , accepted in the Programming Language Design and Implementation Conference (PLDI'20).</p>
<p>Link to paper preprint</p>
<p>Abstract:</p>
<p>Enterprise applications are a major success domain of Java, and Java</p>
<p>is the default setting for much modern static analysis research. It</p>
<p>would stand to reason that high-quality static analysis of Java</p>
<p>enterprise applications would be commonplace, but this is far from</p>
<p>true. Major analysis frameworks feature virtually no support for</p>
<p>enterprise applications and offer analyses that are woefully</p>
<p>incomplete and vastly imprecise, when at all scalable.</p>
<p>In this work, we present two techniques for drastically enhancing</p>
<p>the completeness and precision of static analysis for Java</p>
<p>enterprise applications. The first technique identifies</p>
<p>domain-specific concepts underlying all enterprise application</p>
<p>frameworks, captures them in an extensible, declarative form, and</p>
<p>achieves modeling of components and entry points in a largely</p>
<p>framework-independent way. The second technique offers precision and</p>
<p>scalability via a sound-modulo-analysis modeling of standard data</p>
<p>structures.</p>
<p>In realistic enterprise applications (an order of magnitude larger than</p>
<p>prior benchmarks in the literature) our techniques achieve high degrees of</p>
<p>completeness (on average more than 4x higher than conventional techniques) and</p>
<p>speedups of about 6x compared to the most precise conventional analysis, with</p>
<p>higher precision on multiple metrics. The result is JackEE, an</p>
<p>enterprise analysis framework that can offer precise, high-completeness</p>
<p>static modeling of realistic enterprise applications.</p>

},
keywords = {Java EE, points-to analysis, static analysis}
}

@software{10.5281/zenodo.3743160,
author = {Premtoon, Varot and Koppel, James and Solar-Lezama, Armando},
title = {Yogo},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3743160},
abstract = {
    <p>Docker container with an executable copy of Yogo, and source code for the Haskell portion (frontend)</p>

},
keywords = {code search, equational reasoning}
}

@software{10.5281/zenodo.3750961,
author = {Ji, Ruyi and Liang, Jingjing and Xiong, Yingfei and Zhang, Lu and Hu, Zhenjiang},
title = {Artifact for paper "Question Selection for Interactive Program Synthesis"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3750961},
abstract = {
    <p>This artifact is comprised of the appendix, source code and experiment scripts of paper "Question Selection for Interactive Program Synthesis". Readers can use them to reproduce the experiment results listed in our paper.</p>

},
keywords = {Interaction, Program Synthesis}
}

@software{10.5281/zenodo.3751586,
author = {Apostolakis, Sotiris and Xu, Ziyang and Tan, Zujun and Chan, Greg and Campanoni, Simone and August, David I.},
title = {SCAF: A Speculation-Aware Collaborative Dependence Analysis Framework},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3751586},
abstract = {
    <p>Artifact archive for the artifact evaluation of the PLDI 2020 paper, titled "SCAF: A Speculation-Aware Collaborative Dependence Analysis Framework". It contains a Dockerfile along with relevant to this paper software to create a docker image used to reproduce the evaluation results presented in this PLDI 2020 paper.</p>

},
keywords = {compilers, program analysis, speculation}
}

@software{10.5281/zenodo.3752546,
author = {Gen\c{c}, Kaan and Bond, Michael D. and Xu, Guoqing Harry},
title = {Artifact for Article: Crafty: Efficient, HTM-Compatible Persistent Transactions},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3752546},
abstract = {
    <p>The artifact contains the source code of our implementation, including the microbenchmarks we evaluated and the code required to generate the graphs seen in the paper. It also contains a Docker image that includes all requirements for building and running the code. Using the Docker image is optional but highly recommended. A README file detailing how to reproduce our results is included.</p>

},
keywords = {Crafty, non-volatile memory, persistent memory, persistent transactions}
}

@software{10.5281/zenodo.3753963,
author = {Huang, Kangjing and Qiu, Xiaokang and Shen, Peiyuan and Wang, Yanjun},
title = {DryadSynth: Release as PLDI 2020 Artifact: Reconciling Enumerative and Deductive Program Synthesis},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3753963},
abstract = {
    <p>DryadSynth: A syntax-guided synthesizer</p>

},
keywords = {deductive synthesis, divide-and-conquer, enumerative synthesis, syntax-guided synthesis}
}

@software{10.5281/zenodo.3754772,
author = {Kragl, Bernhard and Enea, Constantin and Henzinger, Thomas A. and Mutluergil, Suha Orhun and Qadeer, Shaz},
title = {Inductive Sequentialization of Asynchronous Programs (Evaluated Artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3754772},
abstract = {
    <p>Inductive sequentialization is implemented as an extension of the CIVL verifier. This implementation and all examples listed in Table 1 of the paper are part of the open-source project Boogie. This artifact is for long-term archiving purposes and contains a snapshot of Boogie version 2.6.4. Since the project is under active development, we recommend to obtain the most recent version from https://github.com/boogie-org/boogie.</p>
<p>For further information and instructions, see the included README.md file.</p>

},
keywords = {abstraction, asynchrony, concurrency, induction, invariants, layers, movers, reduction, refinement, verification}
}

@software{10.5281/zenodo.3756283,
author = {Dasgupta, Sandeep and Dinesh, Sushant and Venkatesh, Deepan and Adve, Vikram S. and Fletcher, Christopher W.},
title = {Artifact for "Scalable Validation of Binary Lifters"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3756283},
abstract = {
    <p>Snapshot of peer-evaluated artifact corresponding to the published conference paper [1].</p>
<p>[1] Sandeep Dasgupta, Sushant Dinesh, Deepan Venkatesh, Vikram S. Adve, and Christopher W. Fletcher 2020. Scalable Validation of Binary Lifters. In Proceedings of the 2020 ACM SIGPLAN Conference on Programming Language Design and Implementation. ACM. https://doi.org/10.1145/3385412.3385964</p>

},
keywords = {compiler-optimization, detecting-bugs, evaluation, formal-semantics, graph-matching, language-semantics, llvm-ir, mcsema, pldi, reproducing-bugs, reverse-engineering, symbolic-execution-engine, symbolic-summaries, translation-validation, validation, verification-conditions, verification-queries, virtualbox, x86-64}
}

@software{10.5281/zenodo.3756301,
author = {Qin, Boqin and Chen, Yilun and Yu, Zeming and Song, Linhai and Zhang, Yiying},
title = {Replication Package for Article: Understanding Memory and Thread Safety Practices and Issues in Real-World Rust Programs},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3756301},
abstract = {
    <p>The artifact is to support the data in our paper with programs. It contains five directories related to the corresponding sections in the paper. section-2-background-and-related-work contains scripts and raw data to plot Fig. 1 and Fig. 2. section-4-unsafe-usages contains a bench testing for safe and unsafe code, and a script to count unsafe statistics. section-5-memory-safety-issues contains the fix commits of our studied memory bugs, and our reproduced memory bugs. section-6-thread-safety-issues contains the fix commits of our studied blocking and non-blocking bugs, our reproduced blocking and non-blocking bugs, and the code to count cases where locks are manually dropped. section-7-bug-detection contains our detection tools for use-after-free and double-lock.</p>

},
keywords = {Bug Study, Concurrency Bug, Memory Bug, Rust}
}

@software{10.5281/zenodo.3756416,
author = {Wu, Zhenwei and Lu, Kai and Nisbet, Andrew and Zhang, Wenzhe and Luj\'{a}n, Mikel},
title = {PMThreads: Persistent Memory Threads Harnessing Versioned Shadow Copies (Artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3756416},
abstract = {
    <p>This is the artifact for the paper "PMThreads: Persistent Memory Threads Harnessing Versioned Shadow Copies", which is set to be published in PLDI 2020. The artifact contains code, and a Dockerfile for assembling a Docker image with all required dependencies to run the code and reproduce the paper results.</p>

},
keywords = {memory persistence, non-volatile memory}
}

@software{10.5281/zenodo.3756609,
author = {Lee, DongKwon and Lee, Woosuk and Oh, Hakjoo and Yi, Kwangkeun},
title = {Lobster - Optimizing Homomorphic Evaluation Circuits by Program Synthesis and Term Rewriting},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3756609},
abstract = {
    <p>Lobster optimizes homomorphic encryption circuit using aggressive rewrite rules automatically learned by program synthesis technique.</p>

},
keywords = {Homomorphic encryption circuit, Program synthesis, Term rewriting}
}

@software{10.5281/zenodo.3759110,
author = {Vila, Pepe and Ganty, Pierre and Guarnieri, Marco and K\"{o}pf, Boris},
title = {Polca: a tool for learning cache replacement policies as automata models},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3759110},
abstract = {
    <p>Polca implements the automata interface to LearnLib for automatically learning cache replacement policies. It can be connected to CacheQuery for directly interacting with hardware caches. It also contains the learned models, instructions to generate them, and the templates (and results) for (from) the program synthesis evaluation.</p>

},
keywords = {automata, cache, cachequery, learning, learnlib, program synthesis, replacement policy, sketch}
}

@software{10.5281/zenodo.3760403,
author = {Brent, Lexi and Grech, Neville and Lagouvardos, Sifis and Scholz, Bernhard and Smaragdakis, Yannis},
title = {Ethainter: A Smart Contract Security Analyzer for Composite Vulnerabilities},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3760403},
abstract = {
    <p>The artifact is composed of: - A decompiler (modified Gigahorse) - Ethainter implementation - Data for recreating experiments</p>

},
keywords = {Program Analysis, Smart Contracts}
}

@software{10.5281/zenodo.3764961,
author = {Bichsel, Benjamin and Baader, Maximilian and Gehr, Timon and Vechev, Martin},
title = {silq-artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3764961},
abstract = {
    <p>Artifact for PLDI'20 paper "Silq: A High-level Quantum Programming Language with Safe Uncomputation and Intuitive Semantics".</p>

},
keywords = {Quantum Language, Semantics, Uncomputation}
}

@software{10.5281/zenodo.3765314,
author = {Gehr, Timon and Steffen, Samuel and Vechev, Martin},
title = {lpsi-artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3765314},
abstract = {
    <p>Artifact for PLDI'20 paper "λPSI: Exact Inference for Higher-Order Probabilistic Programs".</p>

},
keywords = {Exact, Higher-order, Probabilistic Programming}
}

@software{10.5281/zenodo.3833964,
author = {Fourtounis, George and Triantafyllou, Leonidas and Smaragdakis, Yannis},
title = {Identifying Java Calls in Native Code via Binary Scanning (artifact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3833964},
abstract = {
    <p>This is the artifact for the paper "Identifying Java Calls in Native Code via Binary Scanning" (ISSTA 2020). It contains a Doop installation, the benchmarks used in the "Evaluation" section of the paper, and instructions on how to replicate the paper results.</p>

},
keywords = {binary, Java, native code, static analysis}
}

@software{10.5281/zenodo.3862978,
author = {Vanover, Jackson and Deng, Xuan and Rubio-Gonz\'{a}lez, Cindy},
title = {FPDiff: Discvovering Discrepancies in Numerical Libraries},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3862978},
abstract = {
    <p>FPDiff is a tool for automated, end-to-end differential testing that, given only library source code as input, extracts numerical function signatures, synthesizes drivers, creates equivalence classes of functions that are synonymous, and executes differential tests over these classes to detect meaningful numerical discrepancies between implementations. FPDiff's current scope covers special functions across numerical libraries written in different programming languages. This artifact in particular includes the following libraries: the C library GSL (The GNU Scientific Library, version 2.6), the Python libraries SciPy (version 1.3.1) and mpmath (version 1.1.0), and the JavaScript library jmat (commit 21d15fc3eb5a924beca612e337f5cb00605c03f3).</p>

},
keywords = {correctness, differential testing, floating point, numerical libraries, numerical methods, software testing}
}

@software{10.5281/zenodo.3895271,
author = {Busse, Frank and Nowack, Martin and Cadar, Cristian},
title = {Replication package for: Running Symbolic Execution Forever},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3895271},
abstract = {
    <p>The artefact contains a Docker image with MoKlee, our memoization extension of KLEE, all benchmarks in LLVM bitcode format, the raw experiment results and scripts to re-create our evaluation and to re-run all experiments.</p>

},
keywords = {binutils, coreutils, findutils, grep, KLEE, libspng, memoization, MoKlee, software testing, symbolic execution, tcpdump}
}

@software{10.5281/zenodo.3895414,
author = {Fang, Chunrong and Liu, Zixi and Shi, Yangyang and Huang, Jeff and Shi, Qingkai},
title = {Replication Package for Article: Functional Code Clone Detection with Syntax and Semantics Fusion Learning},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3895414},
abstract = {
    <p>The FCDetector is a functional code clone detection tool with syntax and semantics fusion learning.</p>

},
keywords = {code clone detection, code representation, functional clone detection}
}

@software{10.5281/zenodo.3895797,
author = {Gopinath, Rahul and Kampmann, Alexander and Havrikov, Nikolas and Soremekun, Ezekiel O. and Zeller, Andreas},
title = {Replication package for Abstracting Failure Inducing Inputs},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3895797},
abstract = {
    <p>This artifact contains the implementation of the algorithm in the paper "Abstracting Failure Inducing Inputs". The artifact is a Vagrant box (a virtual machine) that contains the complete implementation and the subjects that can be evaluated directly. A complete worked out example in a Jupyter notebook is included in the VM along with a complete Jupyter installation so that the notebook can be viewed directly.</p>

},
keywords = {debugging, error diagnosis, failure-inducing inputs, grammars}
}

@software{10.5281/zenodo.3897315,
author = {Riganelli, Oliviero and Mottadelli, Simone Paolo and Rota, Claudio and Micucci, Daniela and Mariani, Leonardo},
title = {DLD: Data Loss Detector},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3897315},
abstract = {
    <p>Android apps must work correctly even if their execution is interrupted by external events. For instance, an app must work properly even if a phone call is received, or after its layout is redrawn because the smartphone has been rotated. Since these events may require destroying, when the execution is interrupted, and recreating, when the execution is resumed, the foreground activity of the app, the only way to prevent the loss of state information is to save and restore it. This behavior must be explicitly implemented by app developers, who often miss to implement it properly, releasing apps affected by data loss problems, that is, apps that may lose state information when their execution is interrupted. Although several techniques can be used to automatically generate test cases for Android apps, the obtained test cases seldom include the interactions and the checks necessary to exercise and reveal data loss faults. Data Loss Detector (DLD) is a test case generation technique that integrates an exploration strategy, data-loss-revealing actions, and two customized oracle strategies for the detection of data loss failures.</p>

},
keywords = {Android, Data Loss, Mobile Apps, Test Case Generation, Validation}
}

@software{10.5281/zenodo.3901626,
author = {Hildebrandt, Carl and Elbaum, Sebastian and Bezzo, Nicola and Dwyer, Matthew B.},
title = {Feasible and Stressful Trajectory Generation for Mobile Robots - Artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3901626},
abstract = {
    <p>This artifact can be used to replicate the results found in the paper: "Feasible and Stressful Trajectory Generation for Mobile Robots". For more information on the content consult the readme file.</p>

},
keywords = {Kinematic and Dynamic Models, Robotics, Stress Testing, Test Generation}
}

@software{10.6084/m9.figshare.12089217,
author = {Rocha, Rodrigo C. O. and Petoumenos, Pavlos and Wang, Zheng and Cole, Murray and Leather, Hugh},
title = {Artifact for "Effective function merging in the SSA form"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.12089217},
abstract = {
    <p>This artifact includes a modified version of the open-source LLVM compiler framework. It includes a prototype implementation of our novel function merging technique, called SalSSA. It also includes an implementation of the state-of-the-art function merging technique. This artifact also provides Makefile scripts to run spec2006 using these function merging techniques and scripts to compare them.</p>

},
keywords = {code size, compiler optimization, function merging, link-time optimization, LTO}
}

@software{10.17863/CAM.52533,
author = {Licker, Nandor and Jones, Timothy M.},
title = {Replication Package for the Duplo post-link optimiser},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.17863/CAM.52533},
abstract = {
    <p>This artifact contains the sources of the Duplo post-link optimiser, including all of its forked dependencies, along with the benchmarking utilities required to reproduce the results presented in "Duplo: A Framework for OCaml Post-Link Optimisation". The benchmarks evaluate the reduction in code size and increase in performance on widely-used OCaml applications, along with a sizeable subset of the standard operf-macro and operf-micro benchmark suites. The artifact is split into two components. Firstly, it provides a source bundle with instructions to set up the framework and run the optimiser on illustrative examples. Secondly, a QEMU disk image which contains pre-installed versions of the framework and benchmarks, with instructions to reproduce the results reported in the paper.</p>

},
keywords = {LLVM, OCaml, post-link optimiser}
}

@software{10.5281/zenodo.3926703,
author = {Giarrusso, Paolo G. and Stefanesco, L\'{e}o and Timany, Amin and Birkedal, Lars and Krebbers, Robbert},
title = {Scala Step-by-Step: Soundness for DOT with Step-Indexed Logical Relations in Iris — Coq Formalization},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3926703},
abstract = {
    <p>This package contains the mathematical proofs for the associated paper, formalized in the Coq proof assistant, both as a source archive, and as a virtual machine containing the right dependencies to build the proofs.</p>

},
keywords = {Coq, data abstraction, DOT, Iris, logical relations, Scala, step-indexing, type soundness}
}

@software{10.5281/zenodo.3926830,
author = {Lubin, Justin and Collins, Nick and Omar, Cyrus and Chugh, Ravi},
title = {Implementation of Program Sketching with Live Bidirectional Evaluation},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3926830},
abstract = {
    <p>This artifact is the implementation of Smyth, the program synthesizer described in "Program Sketching with Live Bidirectional Evaluation."</p>

},
keywords = {Bidirectional Evaluation, Examples, Program Synthesis, Sketches}
}

@software{10.1145/3410223,
author = {Darragh, Pierce and Adams, Michael D.},
title = {Parsing with Zippers (Functional Pearl) Paper Artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410223},
abstract = {
    <p>This is the artifact associated with the ICFP 2020 paper "Parsing with Zippers (Functional Pearl)" by Pierce Darragh and Michael D Adams.</p>
<h3 id="organization">Organization</h3>
<p>This artifact is organized into three top-level directories:</p>
<ul>
<li><code>benchmark</code> provides the code for running the benchmarking tests we use in the paper.</li>
<li><code>interact</code> provides a minimal implementation of the Parsing with Zippers algorithm and a set of example grammars that can be used for interactive testing.</li>
<li><code>appendix</code> contains a copy of the code listed in the appendix of the paper.</li>
</ul>
<p>Instructions for compilation, setup, and use appear in the <code>README.md</code> files located within each of these directories.</p>

},
keywords = {Derivatives, Parsing, Parsing with Derivatives, Zippers}
}

@software{10.1145/3410224,
author = {Swamy, Nikhil and Rastogi, Aseem and Fromherz, Aymeric and Merigoux, Denis and Ahman, Danel and Mart\'{\i}nez, Guido},
title = {Replication package for Article: "SteelCore: An Extensible Concurrent Separation Logic for Effectful Dependently Typed Programs"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410224},
abstract = {
    <p>This artifact contains the mechanized proofs for the model presented in the SteelCore paper. More precisely, we implement here a version of our effectful CSL semantics complete with monotonic state, non-determinism and pre- and post-conditions. Examples presented in the paper are also included.</p>
<p>We include both the plain sources with instructions for local installation in the steel-artifact folder, as well as a VM with the full development and Emacs installed in the steel-artifact-vm folder. READMEs with relevant instructions and explanations can be found in each folder.</p>

},
keywords = {Concurrency, Dependent types, Domain-specific languages, Formal semantics, Program verification}
}

@software{10.1145/3410225,
author = {Parreaux, Lionel},
title = {Simple-sub source code, including comparison tests with MLsub},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410225},
abstract = {
    <p>This artifact contains the complete source code of the Simple-sub type inference engine, as presented in our paper "The Simple Essence of Algebraic Subtyping: Principal Type Inference with Subtyping Made Easy (Functional Pearl)". It also includes the source code of the existing MLsub system, as well as some code for generating expressions and systematically testing them against MLsub.</p>

},
keywords = {principal types, subtyping, type inference}
}

@software{10.1145/3410226,
author = {Haudebourg, Timoth\'{e}e and Genet, Thomas and Jensen, Thomas},
title = {Timbuk 4: Regular Language Type Inference with Term Rewriting},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410226},
abstract = {
    <p>Provides Timbuk 4, an implementation of Regular Language Type Inference with Term Rewriting.</p>

},
keywords = {Functional Languages, Higher-Order, Program Verification, Regular Languages, Term Rewriting, Type Inference}
}

@software{10.1145/3410227,
author = {Hagedorn, Bastian and Lenfers, Johannes and Kundefinedhler, Thomas and Qin, Xueying and Gorlatch, Sergei and Steuwer, Michel},
title = {Software Artifact for: Achieving High-Performance the Functional Way - A Functional Pearl on Expressing High-Performance Optimizations as Rewrite Strategies},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410227},
abstract = {
    <p>This artifact contains the source code described in our ICFP'20 publication: Achieving High-Performance the Functional Way - A Functional Pearl on Expressing High-Performance Optimizations as Rewrite Strategies. It contains the RISE and ELEVATE implementations, the Agda code for proving the correctnes of the discussed rewrite rules, and the examples discussed in the paper. Please read the README file for more information.</p>

},
keywords = {ELEVATE, Optimization Strategies, Rewrite Rules, Strategy Languages}
}

@software{10.1145/3410228,
author = {Kov\'{a}cs, Andr\'{a}s},
title = {Implementation of the article "Elaboration with First-Class Implicit Function Types"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410228},
abstract = {
    <p>Implementation for a small dependent type theory with enhanced inference for implicit function types.</p>

},
keywords = {elaboration, impredicative polymorphism, type inference, type theory}
}

@software{10.1145/3410229,
author = {M\'{e}vel, Glen and Jourdan, Jacques-Henri and Pottier, Fran\c{c}ois},
title = {Coq Proof Scripts for Article: Cosmo: A Concurrent Separation Logic for Multicore OCaml},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410229},
abstract = {
    <p>This is the machine-checked implementation of the program logic described in the article “Cosmo: A Concurrent Separation Logic for Multicore OCaml”. It consists of definitions and proofs — including soundness of the said logic — carried in the Coq proof assistant with the Iris Concurrent Separation Logic framework. It also provides a “proof mode”, under the form of a set of tactics, which allows interactive verification within Coq of programs written in the toy language of the article.</p>

},
keywords = {concurrency, program verification, separation logic, weak memory}
}

@software{10.1145/3410230,
author = {Graf, Sebastian and Peyton Jones, Simon and Scott, Ryan G.},
title = {Artifact for "Lower Your Guards: A Compositional Pattern-Match Coverage Checker"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410230},
abstract = {
    <p>The artifact accompanying the ICFP 2020 paper "Lower Your Guards: A Compositional Pattern-Match Coverage Checker". This is packaged as a Docker image that contains a patched version of the Glasgow Haskell Compiler (referred to as GHC-LYG) which implements the Lower Your Guards (LYG) algorithm for pattern-matching coverage checking. The Docker image contains runnable programs corresponding to each of the code examples in the paper along with a Readme file that describes the expected outputs. The image also describes how to reproduce other results from the paper, including the head.hackage results, the compiler performance tests, and the coverage warnings for OCaml and Idris code.</p>
<p>The source code for the Docker image is included in artifact05-source-<md5sum>.tgz, where <md5sum> contains the md5sum checksum of the tarball. Also included is artifact05-image-<md5sum>.tgz, which contains a QEmu virtual machine image that comes with the Docker image pre-installed.</md5sum></md5sum></md5sum></p>

},
keywords = {guards, Haskell, pattern matching, strictness}
}

@software{10.1145/3410231,
author = {Hillerstr\"{o}m, Daniel and Lindley, Sam and Longley, John},
title = {Experiments with Generic Search using Delimited Control},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410231},
abstract = {
    <h3 id="artifact-instructions">Artifact Instructions</h3>
<p>The provided artifact contains the source files along with the raw and processed data for the experiments reported in Section 8 of the paper. The experiments were conducted on a Intel Xeon CPU E5-1620 v2 @ 3.70GHz powered workstation running Ubuntu 16.04 LTS using <a href="https://www.smlnj.org/dist/working/110.97/index.html">SML/NJ v110.97 64-bit</a> and <a href="https://github.com/MLton/mlton/releases/tag/on-20180207-release">MLton 20180207</a> both with factory settings.</p>
<h4 id="directory-structure">Directory structure</h4>
<ul>
<li><code>src/</code> contains the SML source files for the <code>n</code>-Queens and integration benchmarks.</li>
<li><code>raw-data/</code> contains the data generated by running the experiments on our reference machine.</li>
<li><code>data/</code> contains the processed data. The data has been processed using LibreOffice Calc.</li>
</ul>
<h4 id="sources">Sources</h4>
<p>The file <code>src/bench.sml</code> contains some auxiliary functions for configuring and running the benchmarks. The files <code>src/platform_{mlton,smlnj}.sml</code> provide compatibility interfaces to account for the differences in the <code>Cont</code> and <code>GC</code> modules between SML/NJ and MLton. The file <code>src/mlton_driver.sml</code> provides the main entry point for the benchmarks compiled with the MLton. The file <code>src/catchcont.sml</code> contains the implementation of John Longley's <code>catch-with-continue</code> delimited control operator which we use to in place of an effect handler. The file <code>src/genericSearch.sml</code> contains the implementations of the generic search procedures used in the <code>n</code>-Queens benchmarks:</p>
<ul>
<li><code>NaiveSearch</code> is the search procedure referred to as "Na\"{\i}ve" in the paper.</li>
<li><code>FunSearch</code> is the search procedure referred to as "Berger" in the paper.</li>
<li><code>ModSearch</code> is the search procedure referred to as "Pruned" in the paper.</li>
<li><code>CcSearch</code> is the search procedure referred to as "Effectful" in the paper.</li>
</ul>
<p>In addition the <code>n</code>-Queens benchmark file <code>src/queens.ml</code> contains a bespoke implementation.</p>
<p>The <code>queens.cm</code> and <code>integration.cm</code> files are compilation manager files used by the SML/NJ compiler to build the benchmarks, whilst <code>queens.mlb</code> and <code>integration.mlb</code> are ML basis files used by the MLton compiler to build the benchmarks.</p>
<h5 id="queens-benchmarks">Queens benchmarks</h5>
<p>The file <code>src/queens.sml</code> contains source code for the <code>n</code>-Queens benchmarks. There are two predicates: * <code>nQueens</code>: This predicate does not refrain from querying the proposed solution p repeatedly on the same argument <code>i</code>. E.g. <code>(p    0)</code> is evaluated afresh for each comparison with some <code>(p i)</code>, <code>i&gt;0</code>. * <code>nQueens'</code>: This remembers results of earlier queries to <code>p</code>, and in fact asks for each of <code>p 0</code>, <code>p 1</code>, etc once only, in this order.</p>
<h5 id="integration-benchmarks">Integration benchmarks</h5>
<p>The file <code>src/integration.sml</code> contains the source code for the integration benchmarks.</p>
<h4 id="benchmark-execution">Benchmark execution</h4>
<p>SML/NJ and MLton compilers are required in order to build and run the benchmark suite. To build the benchmark programs navigate to the <code>src/</code> directory and type</p>
<pre class="shell"><code>$ make</code></pre>
<p>As a result of the above command the following binary files should be produced: <code>queens.mlton</code>, <code>integration.mlton</code>, <code>queens.amd64-linux</code>, and <code>integration.amd64-linux</code>. The first two are the binaries produced by MLton and the last two are the binaries produced by SML/NJ's compilation manager which suffixes the target binaries with a platform-identifier. Thus if you are using a platform other than amd64 Linux then the target binaries will have different suffixes.</p>
<p>To run either of the MLton binaries type</p>
<pre><code>$ ./queens.mlton
$ ./integration.mlton</code></pre>
<p>To run either of the SML/NJ type (replace the suffix <code>amd64-linux</code> with the identifier for your platform)</p>
<pre><code>$ sml @SMLload queens.amd64-linux
$ sml @SMLload integration.amd64-linux</code></pre>
<p>We provide a simple script to run all benchmarks, simply type</p>
<pre><code>$ ./run_all</code></pre>
<p>If your SML/NJ installation is not amd64 or x86 Linux then you will have to modify lines 4-21 in <code>run_all</code> such that the filenames have the proper suffixes.</p>
<p>Note that every benchmark program has exponential time complexity, so you may want to go brew more than one coffee whilst you wait for them to finish. The expected run-time with the paper configuration is roughly ½-1 day.</p>

},
keywords = {generic search, mlton, sml/nj}
}

@software{10.1145/3410232,
author = {Radanne, Gabriel and Saffrich, Hannes and Thiemann, Peter},
title = {The Affe typechecker},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410232},
abstract = {
    <p>Prototype typechecker for the Affe language, and associated examples</p>

},
keywords = {Functional programming, Linear types, Ownership, Type inference}
}

@software{10.1145/3410233,
author = {Wang, Di and Kahn, David M. and Hoffmann, Jan},
title = {Resource Aware ML},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410233},
abstract = {
    <p>This artifact extends Resource Aware ML (RaML) with the ability to automatically derive worst-case bounds on the expected cost of probabilistic functional programs. RaML is a resource-aware version of a considerable subset of the OCaml programming language, and its frontend accepts input programs in OCaml syntax. This artifact extends the language with (i) a new flip expression for probabilistic branching, and (ii) a new type for <em>symbolic</em> probabilities. This artifact implements a type-based expected cost analysis that infers symbolic bounds, which can be functions of the sizes of values of inductive datatypes and the values of symbolic probabilities.</p>

},
keywords = {analysis of probabilistic programs, expected execution cost, resource-aware type system}
}

@software{10.1145/3410234,
author = {Matsuda, Kazutaka and Wang, Meng},
title = {A prototype implementation and proof scripts for Sparcl: A Language for Partially-Invertible Computation},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410234},
abstract = {
    <p>This artifact consists of two implementations: one is an implementation of the system presented in the paper, and the other is Agda scripts mentioned in Section 3.6.4 to prove type-safety and bijectivity.</p>

},
keywords = {Agda, domain-specific language, Haskell, linear types}
}

@software{10.1145/3410235,
author = {Montagu, Beno\^{\i}t and Jensen, Thomas},
title = {Coq Development for the Article: Stable Relations and Abstract Interpretation of Higher-Order Programs},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410235},
abstract = {
    <p>This is the Coq formalization of the definitions and theorems found in the article ICFP'20 "Stable Relations and Abstract Interpretation of Higher-Order Programs". The artifact contains the sources of the development, and also a QEMU image on which a Debian system is installed, and in which the same development can be built directly.</p>

},
keywords = {abstract interpretation, Coq, lambda-calculus, nominal techniques, relations, static analysis}
}

@software{10.1145/3410236,
author = {Knoth, Tristan and Wang, Di and Reynolds, Adam and Hoffmann, Jan and Polikarpova, Nadia},
title = {Artifact for Liquid Resource Types},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410236},
abstract = {
    <p>A typechecker and set of examples showcasing the liquid resource type system.</p>

},
keywords = {Automated amortized resource analysis, Refinement types, Resource analysis}
}

@software{10.1145/3410237,
author = {Polikarpova, Nadia and Stefan, Deian and Yang, Jean and Itzhaky, Shachar and Hance, Travis and Solar-Lezama, Armando},
title = {Replication package for article: Liquid Information Flow Types},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410237},
abstract = {
    <p>This package contains: 1) a VM image for reproducing the experiments in the paper, and 2) an archive of the source code of the tool.</p>

},
keywords = {information flow control, liquid types, Program synthesis}
}

@software{10.1145/3410238,
author = {Sekiyama, Taro and Tsukada, Takeshi and Igarashi, Atsushi},
title = {Interpreter Artifact for "Signature Restriction for Polymorphic Algebraic Effects"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410238},
abstract = {
    <p>This artifact provides an interpreter of a functional programming language MLSR that supports let-polymorphism, Hindley-Milner type inference, and polymorphic algebraic effects and handlers with signature restriction. The interpreter implements the extended type system in Sections 4 \&amp; 5 of our paper. This artifact does not support the type-and-effect system in Section 6.</p>

},
keywords = {Algebraic Effects and Handlers, Parametric Polymorphism, Polymorphic Effects, Polymorphic Type Assignment}
}

@software{10.1145/3406882,
author = {Tizpaz-Niari, Saeid and \v{C}ern\'{y}, Pavol and Trivedi, Ashutosh},
title = {DPFuzz: Fuzzing and Debugging for Differential Performance Bugs in Machine Learning Libraries},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3406882},
abstract = {
    <p>DPFuzz is a tool for fuzzing and debugging differential performance bugs. The paper and its overview are included in this folder. Please see the 'DPFuzz-Overview.pdf' to have an overall picture of DPFuzz.</p>

},
keywords = {Debugging, Differential Performance Bugs, Fuzzing, Machine Learning Libraries, Performance}
}

@software{10.1145/3406883,
author = {Ghaleb, Asem and Pattabiraman, Karthik},
title = {Artifact for Article &nbsp;"How Effective Are Smart Contract Analysis Tools? Evaluating Smart Contract Static Analysis Tools using Bug Injection"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3406883},
abstract = {
    <p>This is the artifact for the ISSTA'20 paper "How Effective Are Smart Contract Analysis Tools? Evaluating Smart Contract Static Analysis Tools using Bug Injection". Two main things are covered in the artifact</p>
<ol style="list-style-type: decimal">
<li>How to use the introduced tool, SolidiFI, for injecting bugs and evaluating smart contract static analysis tools</li>
<li>How to reproduce the evaluation experiments presented in the paper.</li>
</ol>

},
keywords = {bug injection, Ethereum, Ethereum security, fault injection, smart
contracts dataset, smart contracts, smart contracts analysis, smart contracts security, solidity code analysis, static analysis tools evaluation}
}

@software{10.1145/3406885,
author = {Mathis, Bj\"{o}rn and Gopinath, Rahul and Zeller, Andreas},
title = {Replication Package for lFuzzer - Learning Input Tokens for Effective Fuzzing},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3406885},
abstract = {
    <p>This package contains the data and tools used for the experiments run to evaluate lFuzzer. The artifact contains two packages, one for reproducing the evaluation and conducting new experiments and one containing the evaluation results of the paper. The reproduction package is a docker container in which the experiments from the paper as well as new experiments can be performed.</p>

},
keywords = {fuzzing, parser, test input generation}
}

@software{10.1145/3406886,
author = {Li, Hui and Wang, Dong and Huang, Tianze and Gao, Yu and Dou, Wensheng and Xu, Lijie and Wang, Wei and Wei, Jun and Zhong, Hua},
title = {Replication Package for Article: Detecting Cache-Related Bugs in Spark Applications},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3406886},
abstract = {
    <p>This artifact contains the source code of CacheCheck. It provides general instructions to use CacheCheck and evaluates experimental results in our paper. More details and newest version is provided on Github (https://github.com/Icysandwich/cachecheck).</p>

},
keywords = {bug detection, cache, performance, Spark}
}

@software{10.1145/3406888,
author = {Lee, Seokhyun and Cha, Sooyoung and Lee, Dain and Oh, Hakjoo},
title = {Replication Package for Article: Effective White-box Testing of Deep Neural Networks with Adaptive Neuron-Selection Strategy},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3406888},
abstract = {
    <p>This article contains source codes and data for the paper "Effective White-box Testing of Deep Neural Networks with Adaptive Neuron-Selection Strategy". It also contains experiment scripts that can reproduce the results in the paper.</p>

},
keywords = {Deep neural networks, Online learning, White-box testing}
}

@software{10.1145/3406889,
author = {Lou, Yiling and Ghanbari, Ali and Li, Xia and Zhang, Lingming and Zhang, Haotian and Hao, Dan and Zhang, Lu},
title = {Tool Package for paper "Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach "},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3406889},
abstract = {
    <p>The package includes the tool in the paper "Can Automated Program Repair Refine Fault Localization? A Unified Debugging Approach ", including the installation and execution document. More updates please refer to the tool homepage "https://github.com/yilinglou/proFL"</p>

},
keywords = {Automated Debugging Tool, Automated Program Repair, Fault Localization, Unified Debugging}
}

@software{10.1145/3395630,
author = {Kang, Jeehoon and Jung, Jaehwang},
title = {Implementation and Benchmark suite for Article: A Marriage of Pointer- and Epoch-Based Reclamation},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395630},
abstract = {
    <h2 id="a-marriage-of-pointer--and-epoch-based-reclamation">A Marriage of Pointer- and Epoch-Based Reclamation</h2>
<p>This is the artifact for</p>
<p>Jeehoon Kang and Jaehwang Jung, A Marriage of Pointer- and Epoch-Based Reclamation, PLDI 2020.</p>
<p>The latest developments are on <a href="https://github.com/kaist-cp/pebr-benchmark" class="uri">https://github.com/kaist-cp/pebr-benchmark</a>.</p>
<h3 id="summary">Summary</h3>
<p>On Ubuntu 18.04,</p>
<pre><code>sudo apt install build-essential python3-pip
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
pip3 install --user pandas plotnine
python3 bench.py
python3 plot.py</code></pre>
<h3 id="dependencies">Dependencies</h3>
<ul>
<li>Linux &gt;= 4.14 for <a href="http://man7.org/linux/man-pages/man2/membarrier.2.html"><code>MEMBARRIER_CMD_PRIVATE_EXPEDITED</code> and <code>MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED</code></a>, used in the implementation of PEBR.
<ul>
<li><strong>IMPORTANT</strong>: Docker disables this feature by default. To enable, please use <code>--security-opt seccomp:unconfined</code> option when launching Docker.</li>
</ul></li>
<li><a href="https://rustup.rs/"><code>rustup</code></a> for building the implementation of NR, EBR, PEBR and data structures
<ul>
<li>Rust requires GCC for linking in Linux.</li>
</ul></li>
<li>Python &gt;= 3.6, pandas and plotnine for benchmark runner and plotting scripts</li>
</ul>
<h3 id="usage">Usage</h3>
<p>To build the benchmark,</p>
<pre><code>git submodule update --init --recursive # not needed if you got the archived source code
cargo build --release                   # remove --release for debug build</code></pre>
<p>To run a single test,</p>
<pre><code>./target/release/pebr-benchmark -d &lt;data structure&gt; -m &lt;reclamation scheme&gt; -t &lt;threads&gt;</code></pre>
<p>where</p>
<ul>
<li>data structure: HList, HMList, HHSList, HashMap, NMTree, BonsaiTree</li>
<li>reclamation scheme: NR, EBR, PEBR</li>
</ul>
<p>For detailed usage information,</p>
<pre><code>./target/release/pebr-benchmark -h</code></pre>
<p>To run the entire benchmark,</p>
<pre><code>python3 bench.py</code></pre>
<p>This takes several hours and creates raw CSV data under <code>./results/</code>.</p>
<p>To generate plots,</p>
<pre><code>python3 plot.py</code></pre>
<p>This creates plots presented in the paper under <code>./results/</code>.</p>
<h3 id="debug">Debug</h3>
<p>We used <code>./sanitize.sh</code> to debug our implementation. This script runs the benchmark with <a href="https://github.com/japaric/rust-san">LLVM address sanitizer for Rust</a> and uses parameters that impose high stress on PEBR by triggering more frequent ejection.</p>
<p>Note that sanitizer may report memory leaks when used against <code>-m EBR</code>. This is because of a minor bug in original Crossbeam but it doesn't affect performance of our benchmark.</p>
<h3 id="project-structure">Project structure</h3>
<ul>
<li><p><code>./crossbeam-pebr</code> is the fork of <a href="https://github.com/crossbeam-rs/crossbeam">Crossbeam</a> that implements PEBR. The main implementation of PEBR lies under <code>./crossbeam-pebr/crossbeam-epoch</code>.</p></li>
<li><p><code>./crossbeam-ebr</code> is the original Crossbeam source code.</p></li>
<li><p><code>./src</code> contains the benchmark driver (<code>./src/main.rs</code>) and the implementation of data structures based on PEBR (<code>./src/pebr/</code>) and original Crossbeam (<code>./src/ebr/</code>).</p></li>
</ul>
<h3 id="results">Results</h3>
<p><code>./paper-results</code> contains the raw results and graphs used in the paper.</p>
<h3 id="note">Note</h3>
<ul>
<li><p>On Windows, the benchmark uses the default memory allocator instead of jemalloc since <a href="https://crates.io/crates/jemallocator">the Rust library for jemalloc</a> does not support Windows.</p></li>
<li><p>The benchmark run by <code>./sanitize.sh</code> will generate inaccurate memory usage report since it uses the default memory allocator instead of jemalloc. The memory tracker relies on jemalloc's functionalities which doesn't keep track of allocations by the default allocator.</p></li>
</ul>

},
keywords = {epoch-based reclamation, garbage collection, hazard pointer, pointer-based reclamation, safe memory reclamation}
}

@software{10.1145/3395631,
author = {Hu, Qinheping and Cyphert, John and D'Antoni, Loris and Reps, Thomas},
title = {Artifact for article: Exact and Approximate Methods for Proving Unrealizability of Syntax-Guided Synthesis Problems},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395631},
abstract = {
    <p>This artifact contains Nay, a synthesizer which can prove unrealizability of unrealizable SyGuS problems. For detail can be found in this paper:https://arxiv.org/abs/2004.00878</p>

},
keywords = {program synthesis, syntax guided synthesis, unrealizability}
}

@software{10.1145/3395632,
author = {Flatt, Matthew and Dybvig, R. Kent},
title = {Replication Package for Article: Compiler and Runtime Support for Continuation Marks},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395632},
abstract = {
    <p>The artifact contains the full source code for Racket and Chez Scheme and variants as described in the paper, and it provides benchmarks that can be used to support the following claims:</p>
<ul>
<li><p>The implementation of continuation marks is compatible with a high-performance implementation of first-class, delimited continuations.</p></li>
<li><p>Compiler and runtime support for continuation marks can improve the performance of applications.</p></li>
<li><p>Specific optimizations described in the paper improve the performance of continuation marks and applications that use them.</p></li>
</ul>

},
keywords = {context inspection, Dynamic binding}
}

@software{10.1145/3395633,
author = {Durst, David and Feldman, Matthew and Huff, Dillon and Akeley, David and Daly, Ross and Bernstein, Gilbert Louis and Patrignani, Marco and Fatahalian, Kayvon and Hanrahan, Pat},
title = {Replication Package for Article: Type-Directed Scheduling of Streaming Accelerators},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395633},
abstract = {
    <p>This is the artifact for the PLDI 2020 paper "Type-Directed Scheduling of Streaming Accelerators". The artifact is a virtual machine that supports the claims, including reproducing the results, of the submission version of the paper. Please go to https://aetherling.org for the latest version of the code.</p>

},
keywords = {FPGAs, hardware description languages, image processing, scheduling, space-time types}
}

@software{10.1145/3395634,
author = {Berry, G\'{e}rard and Serrano, Manuel},
title = {Replication package for: HipHop.js: (A)Synchronous Reactive Web Programming},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395634},
abstract = {
    <p>Our artifact consists of:</p>
<ul>
<li><p>The current HipHop.js implementation, which you can either download fully constructed in the docker file available from the PLDI artifact site (see Part 1 below) or entirely rebuild from the public Hop/HipHop sources files (see Part 3) if you find the 1.3 GB docker file too big or if you want to do it yourself. Once the docker image is downloaded or built, you can validate it by running the standard HipHop implementation test suite (see Part 4).</p></li>
<li><p>The implementation and step-by-step simulation of our Lisinopril medical prescription application described in the paper (Part 2 below). The main Lisinopril HipHop reactive module is exacly the one in the paper. The complete source files can be accessed within the docker image or dowloaded from the web.</p></li>
</ul>

},
keywords = {JavaScript, Reactive Programming, Synchronous Programming, Web Programming}
}

@software{10.1145/3395635,
author = {Phulia, Ankush and Bhagee, Vaibhav and Bansal, Sorav},
title = {Replication package for OOElala: Order-of-Evaluation Based Alias Analysis for Compiler Optimization},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395635},
abstract = {
    <p>This artifact contains the implementation for the algorithm described in the paper, <em>OOElala: Order-of-Evaluation Based Alias Analysis for Compiler Optimization</em>, accepted at PLDI 2020.</p>
<h3 id="terminology">Terminology</h3>
<ul>
<li>We use <code>OOElala</code>, <code>ooelala</code> and <code>clang-unseq</code> interchangeably to refer to the tool/binary which we have implemented and produced as a part of this work.</li>
<li><code>&lt;artifact-home&gt;</code> refers to <code>/home/$USER/ooelala-project</code></li>
</ul>
<h3 id="structure-of-the-artifact">Structure of the artifact</h3>
<p>This artifact directory is structured into the following subdirectories, each of which is described subsequently:</p>
<ul>
<li><em>litmus_tests</em> - This directory contains the implementation of the two examples, which have been introduced in Section 1.1 of the paper, to spearhead the discussion about the key idea of the paper. The makefile is used to run these two examples, as described in detail in the later sections.
<ul>
<li><em>array_min_max</em> - This subdirectory contains the code, for the first example, on the left of the figure.</li>
<li><em>nested_loop</em> - This subdirectory contains the code for an example, which isolates the kernel initialization code described in the second image on the right. The implementation captures the basic idea for the SPEC 2017 example, as discussed in section 1.1 of the paper.</li>
</ul></li>
<li><em>ooelala</em> - This directory contains the source code for our tool, OOELala, which has been implemented over clang/llvm 8.0.0.
<ul>
<li><em>src</em> - This sub-directory contains the source code for the optimizing compiler implementation which includes the AST analysis to identify the must-not-alias predicates and the Alias Analysis which utilises the must-not-alias information to enable further optimisations. This has been added as a sub-module and the specific implementation details can be found in the commit history and commit messages of this sub-module.</li>
<li><em>ubsan</em> - This sub-directory contains the source code for the implementation of the UB Sanitizer which uses the must-not-alias predicates generated after the AST analysis to implement the runtime checks. This has been added as a sub-module and the specific implementation details can be found in the commit history and commit messages of this sub-module.</li>
</ul></li>
<li><em>spec</em> - This directory contains the resources which we use to run the SPEC CPU 2017 benchmarks, with clang and OOELala.
<ul>
<li><em>configs</em> - This subdirectory contains the config files <code>clang-unseq.cfg</code> and <code>clang.cfg</code>, which are used when we build and run the SPEC CPU 2017 suite with OOELala and clang respectively. Additionally, this directory also contains config files <code>clang-ubsan.cfg</code> and <code>clang-ubsan-unseq.cfg</code>, which are used to specify that SPEC should be built and run with clang and OOELala respectively, with UB Sanitizer checks enabled and no optimisations.</li>
<li><em>makefiles</em> - This subdirectory contains the makefiles, which are used to compile and run specific SPEC benchmarks or generate object/LLVM files for some specific source files, in some specific benchmarks. These have been used to identify the patterns discussed in figure 2 of the paper. For running these on SPEC refrate inputs refer to <code>Readme.md</code> in the subdirectory.</li>
<li><em>scripts</em> - This subdirectory contains the scripts which are used to build and run the SPEC 2017 benchmarks and generate the performance numbers presented in table 6 of the paper. This also contains the post processing python script which is used to generate the summary of the aliasing stats, which are presented in Table 5 of the paper. The list of scripts and their functionality is described in the Readme.md file present in this subdirectory.</li>
</ul></li>
<li><em>polybench</em> - This directory contains the resources which we use to run the Polybench benchmark suite, with clang and OOELala
<ul>
<li><em>common</em> - This subdirectory contains the Polybench header file which needs to be included in the benchmarks.</li>
<li><em>scripts</em> - This subdirectory contains the scripts used to build and run the Polybench benchmarks to obtain the speedups listed in Table 4 of the paper. Comparisons between various compilers have been drawn.</li>
<li><em>selected_benchmarks</em> - This represents the selected subset of benchmarks which we have annotated with custom <code>RESTRICT</code> macro predicates (corresponding to <code>CANT_ALIAS</code> used in the paper), used to provide the additional aliasing information, but in no way modifying the behaviour of the program</li>
</ul></li>
<li><em>sample_outputs</em> - This directory contains a set of sample outputs which are obtained on running the SPEC CPU 2017 and the polybench benchmarks. These can be used by the developers to verify the output format
<ul>
<li><em>spec</em> - This contains the results and stats obtained for a sample run of SPEC CPU 2017, with clang and clang-unseq</li>
<li><em>polybench</em> - This contains the results and stats obtained for a sample run of Polybench, with clang and clang-unseq</li>
</ul></li>
<li><em>CANT_ALIAS.md</em> - This is a tutorial which discusses the <em>CANT_ALIAS</em> predicate described in the paper. It outlines the use of the macro and the subtleties associated with that.</li>
</ul>

},
keywords = {Alias Analysis, Clang, Compiler Optimization, LLVM, Polybench, SPEC CPU 2017, Undefined behaviour}
}

@software{10.1145/3395636,
author = {Farvardin, Kavon and Reppy, John},
title = {Replication Package for Article: From Folklore to Fact: Comparing Implementations of Stacks and Continuations},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395636},
abstract = {
    <p>This artifact contains all materials needed to reproduce or extend the results of this work. It includes the raw data and plots corresponding to the results presented in the paper, the full source code of Manticore \&amp; LLVM (plus the benchmark programs and plotting scripts), a Docker image that contains the entire system pre-built, and an extensive README that describes how to build and run our benchmark suite to replicate the experiments in the paper.</p>

},
keywords = {Call stacks, Compilers, Concurrency, Continuations, Functional Programming}
}

@software{10.1145/3395637,
author = {Lahav, Ori and Boker, Udi},
title = {Coq proofs for: Decidable Verification under a Causally Consistent Shared Memory},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395637},
abstract = {
    <p>The artifact consists of the Coq development accompanying the paper. The main result is the equivalence between loSRA (called SRAL in the Coq development) and opSRA (called SRAG in the Coq development) that is given in Lemmas 5.15 and 5.16 in the paper. This final result is included in "SRAL_SRAG.v".</p>

},
keywords = {causal consistency, concurrency, Coq, decidability, release/acquire, shared-memory, verification, weak memory models, well-structured transition systems}
}

@software{10.1145/3395638,
author = {Miltner, Anders and Padhi, Saswat and Millstein, Todd and Walker, David},
title = {Replication Package for Artifact: Data-Driven Inference of Representation Invariants},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395638},
abstract = {
    <p>This archive contains the code and benchmarks for the paper Data-Driven Inference of Representation Invariants.</p>
<p>Instructions for installation and build, instructions for reproduction of the results, and a description of the structure of the repository, are all available in the file $/README.pdf.</p>

},
keywords = {Abstract Data Types, Logical Relations, Type-Directed Synthesis}
}

@software{10.1145/3395639,
author = {Emrich, Frank and Lindley, Sam and Stolarek, Jan and Cheney, James and Coates, Jonathan},
title = {Virtual Machine for paper "FreezeML: Complete and Easy Type Inference for First-Class Polymorphism"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395639},
abstract = {
    <p>The artifact is a virtual machine that contains an implementation of the FreezeML system described in the paper. The artifact also contains a collection of examples presented in the paper so that the results can be easily reproduced.</p>

},
keywords = {first-class polymorphism, impredicative types, type inference}
}

@software{10.1145/3395640,
author = {Sakkas, Georgios and Endres, Madeline and Cosman, Benjamin and Weimer, Westley and Jhala, Ranjit},
title = {Replication Package for Article: Type Error Feedback via Analytic Program Repair},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395640},
abstract = {
    <p>The artifact contains all the necessary code and data in order to reproduce the results from the paper "Type Error Feedback via Analytic Program Repair" as appeared in PLDI 2020. Instructions for installing and running the artifact can be found in the provided README file.</p>

},
keywords = {Machine Learning, Program Repair, Program Synthesis, Type Error Feedback}
}

@software{10.1145/3395641,
author = {Baudart, Guillaume and Mandel, Louis and Atkinson, Eric and Sherman, Benjamin and Pouzet, Marc and Carbin, Michael},
title = {Replication package for Article: Reactive Probabilistic Programming},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395641},
abstract = {
    <p>This is the artifact of the PLDI 2020 paper <em>Reactive Probabilistic Programming</em> by Guillaume Baudart, Louis Mandel, Eric Atkinson, Benjamin Sherman, Marc Pouzet, and Michael Carbin. The archive contains - <code>pldi2020.pdf</code>: Paper with appendices - <code>README.md</code>: Details on how the code is linked to the paper and how to run the code and the benchmarks - <code>ProbZelus-PLDI20.ova</code>: Linux image in the Open Virtualization Format with the ProbZelus compiler and benchmarks - <code>LICENSE.txt</code>: ProbZelus license.</p>
<p>The artifact can be used to check the implementation of the algorithms presented in the paper and to reproduce the evaluation.</p>

},
keywords = {Benchmark, Compiler, Delayed sampling, Inference, Probabilistic programming, Runtime, Sequential Monte Carlo, Synchronous programming}
}

@software{10.1145/3395642,
author = {Brown, Fraser and Renner, John and N\"{o}tzli, Andres and Lerner, Sorin and Shacham, Hovav and Stefan, Deian},
title = {Towards a Verified Range Analysis for JavaScript JITs: Artifact},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395642},
abstract = {
    <p>Artifact for "Towards a Verified Range Analysis for JavaScript JITS"</p>

},
keywords = {verification}
}

@software{10.1145/3395643,
author = {Lee, Sung-Hwan and Cho, Minki and Podkopaev, Anton and Chakraborty, Soham and Hur, Chung-Kil and Lahav, Ori and Vafeiadis, Viktor},
title = {Replication Package for Article: Promising 2.0: Global Optimizations in Relaxed Memory Concurrency},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395643},
abstract = {
    <p>The artifact is a Coq development of the paper Promising 2.0: Global Optimizations and Relaxed Memory Concurrency. It includes (i) a Coq development of Promising 2.0 memory model and (ii) compilation correctness proof of Promising 2.0 to IMM. See README.md for more detail.</p>

},
keywords = {Compiler Optimizations, Operational Semantics, Relaxed Memory Concurrency}
}

@software{10.1145/3395644,
author = {Zhu, Shaopeng and Hung, Shih-Han and Chakrabarti, Shouvanik and Wu, Xiaodi},
title = {Replication Package for: On the Principles of Differentiable Quantum Programming Languages},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395644},
abstract = {
    <p>The artifact includes two parts: (1) A parser and compiler that implements the rules for autodifferentiaton; (2) A simulation that demonstrates the advantage of differentiating quantum programs with control flow. Classical simulation of quantum programs is used in this part for evaluation.</p>

},
keywords = {autodifferentiation, differentiable programming, quantum computing, quantum machine learning, quantum programming languages}
}

@software{10.1145/3395645,
author = {Nandi, Chandrakana and Willsey, Max and Anderson, Adam and Wilcox, James R. and Darulova, Eva and Grossman, Dan and Tatlock, Zachary},
title = {Szalinski: A Tool for Synthesizing Structured CAD Models with Equality Saturation and Inverse Transformations},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395645},
abstract = {
    <h2 id="paper-pldi20main-p471-p">Paper pldi20main-p471-p</h2>
<h3 id="goals-of-the-artifact">Goals of the artifact</h3>
<p>In our paper, we evaluated the following about Szalinski (<code>Section 7</code>):</p>
<ol style="list-style-type: decimal">
<li><p>End-to-End: we ran Szalinski on the flat CSG outputs of a mesh decompiler (Reincarnate). The results are in <code>Table 2</code>.</p></li>
<li><p>Scalability: we evaluated Szalinski on a large dataset of models scraped from a popular online repository (Thingiverse). The results are in <code>Figure    14</code> (first three box plots).</p></li>
<li><p>Sensitivity: we evaluated the usefulness of Szalinski's two main features: CAD rewrites and Inverse Transformations. The results are in <code>Figure 14</code> (last two box plots).</p></li>
</ol>
<p>In support of these results, this artifact reproduces <code>Table 2</code> and <code>Figure 14</code>. In addition, it also generates the output programs in <code>Figure 15</code> that are used in the case studies.</p>
<p>This document contains the following parts:</p>
<ul>
<li><p>System requirements</p></li>
<li>How to run Szalinski</li>
<li>Reproducing Table 2 (takes &lt; 5 minutes)</li>
<li>Reproducing Figure 14 (takes approx. 1.5 hour)</li>
<li>Reproducing Figure 15 (takes &lt; 5 minutes)</li>
<li><p>Validation</p></li>
<li>Reusability</li>
<li>How to set up Szalinski on a different machine (this is also how we set up the VM we submitted for PLDI 2020 AEC)</li>
<li><p>Description of the code and how to modify it</p></li>
<li><p>Notes and remarks</p></li>
</ul>
<h3 id="system-requirements">System requirements</h3>
<ul>
<li>Specs of the machine where we ran the VM: Intel i7-8700K (12 threads @ 4.7GHz), 32GiB RAM</li>
</ul>
<h3 id="running-the-tools">Running the tools</h3>
<h4 id="reproducing-table-2">Reproducing Table 2</h4>
<p>Navigate to the directory that contains the <code>Makefile</code> and type <code>make out/aec-table2/table2.csv</code>. This should take about 3 minutes. This will reproduce <code>Table 2</code> from the paper. To view the content of the table, type <code>cat out/aec-table2/table2.csv | column -t -s,</code> and compare the numbers with <code>Table 2</code> in the paper.</p>
<p><strong>NOTE:</strong> - We suspect that different versions of OpenSCAD use different triangulation algorithms for compiling to mesh which can affect the numbers in the <code>#Tri</code> column.</p>
<h4 id="reproducing-figure-14">Reproducing Figure 14</h4>
<p>We have included in the repo the 2,127 examples from Thingiverse that we evaluated on in the paper. The remainder of the 12,939 scraped from Thingiverse were either malformed or used features not supported by Szalinski. The script (<code>scripts/scrape-thingiverse.sh</code>) scrapes models under the <code>customizable</code> category, from the first 500 pages.</p>
<p><em>NOTE:</em> Running this part takes about an hour. We recommend first reproducing <code>Figure 15</code> and <code>Table 2</code>, both of which take much less time.</p>
<p>Navigate to the directory that contains the <code>Makefile</code> and type <code>make out/fig14.pdf</code>. Open the generated file in a pdf viewer and compare with <code>Figure 14</code> in the paper.</p>
<h4 id="reproducing-figure-15-programs">Reproducing Figure 15 programs</h4>
<p>Navigate to the directory that contains the <code>Makefile</code> and type <code>make aec-fig15</code>. This should take less than a minute. Then look in the <code>out/aec-fig15</code> directory. The optimized programs generated by Szalinski are in the files with extensions <code>normal.csexp.opt</code>. There should be 6 such files. Open them and compare the content with the programs listed in <code>Figure 15</code> of the paper.</p>
<p><strong>NOTE:</strong> - The programs in the paper are sugared and represented more compactly for space. - <code>MapI</code> found in the artifact results corresponds to <code>Tabulate</code> in the paper. - When comparing the results generated by the artifact to the programs in <code>Figure 15</code> of the paper, it is most important to check that the high-level structure in terms of <code>Fold</code> and <code>MapI</code> synthesized by the artifact matches that reported in the paper.</p>
<h4 id="validation">Validation</h4>
<p><code>Section 6</code> of our paper describes Szalinski's validation process. We use OpenSCAD to compile CSG programs to meshes and use CGAL to compute the Hausdorff distance between two meshes.</p>
<p>To validate the programs in <code>Figure 15</code>, run <code>make out/aec-fig15/hausdorff</code>. This should terminate in less than 3 minutes. It should show you the names of the 6 examples in <code>Figure 15</code> and the corresponding Hausdorff distances which are close to zero.</p>
<p>We have also validated all our other results reported in the paper. However, our experience indicates that OpenSCAD's compilation step is often very slow. Therefore, the other commands mentioned in the instruction for reproducing the results do not perform validation by default.</p>
<p>You can validate any example from our evaluation by typing: <code>make out/dir_name/example_name.normal.diff</code>, where <code>dir_name</code> can be <code>aec-table2</code>, <code>aec_fig15</code> or <code>thingiverse</code>, and <code>example_name</code> is the name of whatever example you choose. Then open the generated <code>.diff</code> file and check that the Hausdorff distance is within some epsilon of 0.</p>
<p><strong>NOTE:</strong> For many example, CGAL crashes or is slow at computing the Hausdorff distance. For these, we recommend a manual validation if you are interested. In order to validate an example, type the following: <code>make out/dir_name/example_name.diff.scad</code>. You can open the generated <code>.scad</code> file in OpenSCAD (already installed in the VM). In OpenSCAD, click on the <code>Render</code> button (the second button from the right) in the toolbar. You should either see nothing rendered or some residual thin walls that are artifacts of rounding error prevalent in OpenSCAD.</p>
<h3 id="reusability">Reusability</h3>
<p>Here we provide instructions on how to start using Szalinski including installation and changing the rules and features of the Caddy language.</p>
<h4 id="setup-instructions">Setup instructions</h4>
<p>Following are the steps for setting up Szalinski from scratch on a machine that runs Ubuntu 19.10.</p>
<ul>
<li><p>Install rust. Type <code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code> in the terminal and follow the subsequent instructions. The version we used is <code>1.41.0</code>. See<code>https://www.rust-lang.org/tools/install</code> for more information.</p></li>
<li><p>Make sure you configure your current shell by typing: <code>source $HOME/.cargo/env</code> (the Rust installation will prompt you to do this).</p></li>
<li><p>Install make by typing: <code>sudo apt-get install make</code></p></li>
<li><p>Install g++ by typing: <code>sudo apt-get install g++</code></p></li>
<li><p>Install jq by typing: <code>sudo apt-get install jq</code></p></li>
<li><p>Install <a href="https://www.cgal.org/download/linux.html">CGAL</a> by typing <code>sudo apt-get install libcgal-dev</code></p></li>
<li><p>Install <a href="https://www.openscad.org/">OpenSCAD</a> by typing <code>sudo apt-get install openscad</code></p></li>
<li><p>Install git by typing <code>sudo apt install git</code></p></li>
<li><p>Install pip by typing <code>sudo apt install python3-pip</code> and then install <code>numpy</code> by typing <code>pip3 install numpy</code> and <code>matplotlib</code> by typing <code>pip3 install matplotlib</code></p></li>
<li><p>We have made a <a href="https://github.com/uwplse/szalinski/tree/pldi2020-aec">github release</a> for the PLDI AEC from where you can get the source.</p></li>
<li><p>Navigate to the project directory where the <code>Makefile</code> is and run the tool as described above.</p></li>
</ul>
<h4 id="changing-caddy-and-modifying-the-rules">Changing Caddy and modifying the rules</h4>
<ul>
<li><p>The Caddy language is defined in <code>cad.rs</code> in the <code>src</code> directory. A simple feature you can add is support for a new primitive or new transformations. You can also change the costs of various language constructs. The definition of the <code>cost</code> function starts at line <code>267</code>.</p></li>
<li><p>As we described in the paper, to verify the correctness of Szalinski, we evaluate Caddy programs to flat Core Caddy and pretty print to CSG. This code is in <code>eval.rs</code>.</p></li>
<li><p><code>solve.rs</code> and <code>permute.rs</code> contains code that solves for first and second degree polynomials in Cartesian and Spherical coordinates, and performs partitioning and permutations of lists.</p></li>
<li><p>The rewrites rules are in <code>rules.rs</code>. Syntactic rewrites are written using the <code>rw!</code> macro. Each rewrite has a name, a left hand side, and a right hand side. You can add / remove rules to see how that affects the final Caddy output of Szalinski. For example, if you comment out the rules for inverse transformations, they will not be propagated and eliminated, and therefore the quality of Szalinski's output will not be as good.</p></li>
</ul>
<h3 id="notes-and-remarks">Notes and remarks</h3>
<p>Szalinski is implemented in <a href="https://www.rust-lang.org/">Rust</a>. As mentioned in <code>Section 6</code> of the paper, it uses <a href="https://www.openscad.org/">OpenSCAD</a> to compile CSG programs to triangular meshes, and <a href="https://www.cgal.org/">CGAL</a> to compute the Hausdorff distance between two meshes.</p>

},
keywords = {CAD, Compiler Optimization, Computational Geometry, Synthesis}
}

@software{10.1145/3395646,
author = {Fragoso Santos, Jos\'{e} and Maksimovi\'{c}, Petar and Ayoun, Sacha-\'{E}lie and Gardner, Philippa},
title = {Gillian, Part I: A Multi-language Platform for Symbolic Execution},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395646},
abstract = {
    <p>This artifact contains the Gillian platform, as it was for the submission of the corresponding PLDI'20 paper.</p>
<p>Note: This artifact is licensed under the GNU General Public License v3.0 and can only be used for academic purposes. The Gillian platform itself is not licensed under the same license.</p>

},
keywords = {bounded verification, bug-finding, C, JavaScript, parametric semantics, Symbolic execution}
}

@software{10.1145/3395647,
author = {Usman, Muhammad and Wang, Wenxi and Vasic, Marko and Wang, Kaiyuan and Vikalo, Haris and Khurshid, Sarfraz},
title = {Replication Package for Article: A Study of the Learnability of Relational Properties: Model Counting Meets Machine Learning (MCML) - PLDI 2020},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395647},
abstract = {
    <p>The artifact contains datasets and code which were used to compute results for this paper (A Study of the Learnability of Relational Properties: Model Counting Meets Machine Learning (MCML) - PLDI 2020). Detailed instructions can be found in README.txt file.</p>

},
keywords = {Alloy, ApproxMC, machine learning, model counting, ProjMC, Relational Properties, SAT solving}
}

@software{10.1145/3395648,
author = {He, Jingxuan and Singh, Gagandeep and P\"{u}schel, Markus and Vechev, Martin},
title = {Reproduction Package for Article: Learning Fast and Precise Numerical Analysis},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395648},
abstract = {
    <p>This material is the artifact for paper "Learning Fast and Precise Numerical Analysis" at PLDI 2020. It contains raw data for main experiments, benchmarks, full source code, and scripts for reproducing main experiments.</p>

},
keywords = {Abstract interpretation, Machine learning, Numerical domains, Performance optimization.}
}

@software{10.1145/3395649,
author = {Porter, Chris and Mururu, Girish and Barua, Prithayan and Pande, Santosh},
title = {Replication Package for article: BlankIt Library Debloating: Getting What You Want Instead of Cutting What You Don’t},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395649},
abstract = {
    <p>These are the docker containers to reproduce the main results of the paper.</p>

},
keywords = {software debloating}
}

@software{10.1145/3395650,
author = {Koenig, Jason R. and Padon, Oded and Immerman, Neil and Aiken, Alex},
title = {Artifact for Article: First-Order Quantified Separators},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395650},
abstract = {
    <p>This artifact contains implementations of the separation algorithm from Section 5, the IC3/PDR implementation from Section 6.3, and the evaluation data from Section 7. This artifact can be used to both reproduce the results of the article as well as run these algorithms on novel distributed protocols.</p>

},
keywords = {first-order logic, invariant inference, software verification}
}

@software{10.1145/3395651,
author = {Cauligi, Sunjay and Disselkoen, Craig and Gleissenthall, Klaus v. and Tullsen, Dean and Stefan, Deian and Rezk, Tamara and Barthe, Gilles},
title = {Pitchfork-Angr},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395651},
abstract = {
    <p>Pitchfork is a static analysis tool, built on angr (https://github.com/angr/angr), which performs speculative symbolic execution. That is, it not only executes the "correct" or "sequential" paths of a program, but also the "mispredicted" or "speculative" paths, subject to some speculation window size. Pitchfork finds paths where secret data is used in either address calculations or branch conditions (and thus leaked), even speculatively - these paths represent Spectre vulnerabilities. Pitchfork covers Spectre v1, Spectre v1.1, and Spectre v4.</p>

},
keywords = {spectre, speculative execution, static analysis, symbolic execution}
}

@software{10.1145/3395652,
author = {Giannarakis, Nick and Loehr, Devon and Beckett, Ryan and Walker, David},
title = {Software Artifact for NV: An Intermediate Language for Verification of Network Control Planes},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395652},
abstract = {
    <p>The artifact contains a VirtualBox VM image with the source code and the binary for the NV framework (the simulator, SMT verifier, etc.). Also included is a modified version of Batfish that can translate router configurations to NV source files.</p>

},
keywords = {intermediate verification language, network simulation, network verification, static analysis}
}

@software{10.1145/3395653,
author = {Lorch, Jacob R. and Chen, Yixuan and Kapritsos, Manos and Parno, Bryan and Qadeer, Shaz and Sharma, Upamanyu and Wilcox, James R. and Zhao, Xueyuan},
title = {Replication Package for Article "Armada: Low-Effort Verification of High-Performance Concurrent Programs"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395653},
abstract = {
    <p>This artifact contains the materials necessary for replication of the paper "Armada: Low-Effort Verification of High-Performance Concurrent Programs". It contains a Docker image containing the source code, executables, external dependencies, and examples. It also contains documentation of the artifact and a description of the Armada language.</p>

},
keywords = {refinement, weak memory models, x86-TSO}
}

@software{10.1145/3395654,
author = {Schuiki, Fabian and Kurth, Andreas and Grosser, Tobias and Benini, Luca},
title = {Replication Package for Paper: LLHD: A Multi-level Intermediate Representation for Hardware Description Languages},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395654},
abstract = {
    <p>A Docker image with the necessary toolchains pre-installed and source codes pre-loaded to reproduce the main results of the LLHD paper, and to serve as a starting point for individual exploration.</p>

},
keywords = {domain-specific languages, hardware, language design, language implementation, new programming models or languages, parallelism}
}

@software{10.1145/3395655,
author = {Krishna, Siddharth and Patel, Nisarg and Shasha, Dennis and Wies, Thomas},
title = {Mechanized proofs accompanying paper: Verifying Concurrent Search Structure Templates},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395655},
abstract = {
    <p>Our artifact consists of two parts: the proofs of template algorithms, to be verified by Iris/Coq, and the proofs of implementations, to be verified by GRASShopper.</p>

},
keywords = {concurrent search structures, Coq, functional correctness, Grasshopper, Iris, mechanized proofs, memory safety}
}

@software{10.1145/3395656,
author = {Breck, Jason and Cyphert, John and Kincaid, Zachary and Reps, Thomas},
title = {Artifact for "Templates and Recurrences: Better Together"},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395656},
abstract = {
    <p>This is the artifact for the PLDI 2020 paper, "Templates and Recurrences: Better Together." The artifact is a virtual machine in OVA (Open Virtualization Archive) format. Its operating system is Ubuntu 18. The virtual machine contains an installation of the CHORA static analysis tool, which is the implementation of the technique described by the associated paper. The virtual machine also contains the benchmark programs that were used in the experiments of the associated paper, along with a script that is designed to replicate the paper's experimental results. The virtual machine has a user account with name "chorauser" and password "chorapassword", and allows login via graphical user interface, or via SSH on port 22.</p>

},
keywords = {Invariant generation, Recurrence relation}
}

@software{10.1145/3395657,
author = {Nigam, Rachit and Atapattu, Sachille and Thomas, Samuel and Li, Zhijing and Bauer, Theodore and Ye, Yuwei and Koti, Apurva and Sampson, Adrian and Zhang, Zhiru},
title = {Replication Package for Article: Predictable Accelerator Design with Time-Sensitive Affine types},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395657},
abstract = {
    <p>Contains the following repositories: - Dahlia (v0.0.1): The reference compiler built for the paper. - Dahlia-evaluation: The data and the evaluation scripts. - Dahlia-spatial-comparison: Repository to reproduce Dahlia's Spatial evaluation. - Polyphemus: Server framework used to run FPGA experiments on AWS.</p>

},
keywords = {affine types, high-level synthesis}
}

@software{10.1145/3395658,
author = {Boehm, Hans-J.},
title = {Real arithmetic package and code to check floating point precision},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395658},
abstract = {
    <p>Source code and instructions to run the floating point accuracy test described in the paper. This includes the real arithmetic package, with the described comparison support, and an updated version of the previously described underlying recursive reals package (which diverges on exact comparison of equal real numbers). The real arithmetic package is very similar to that currently used by Google's Android calculator.</p>

},
keywords = {accuracy checking, comparison, decidability, floating point, real numbers}
}

@software{10.1145/3395659,
author = {Yang, Albert Mingkun and \"{O}sterlund, Erik and Wrigstad, Tobias},
title = {Replication Package for Article: Improving Program Locality in the GC using Hotness},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3395659},
abstract = {
    <p>It includes our implementation, benchmarks used, and scripts for running benchmarks and collecting/visualizing results.</p>

},
keywords = {garbage collection, load barrier, openjdk, program locality}
}

@software{10.5281/zenodo.3597725,
author = {Kr\"{u}ger, Stefan and Ali, Karim and Bodden, Eric},
title = {CogniCrypt_GEN - Generating Code for the Secure Use of Crypto APIs (Artefact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3597725},
abstract = {
    <p>In this artefact, we present Cognicrypt_GEN, a code generation approach that allows for the generation of functionally correct, type-safe, and secure Java code that implements common use cases of cryptographic APIs. To implement a given use case, Cognicrypt_GEN requires two artefacts: a) a set of API-usage rules in the specification language CrySL and b) a Java code template specifying which CRYSL rules are to be used and how. The artefact comes with an Eclipse environment, in which Cognicrypt_GEN may be executed with all eleven use cases from the original paper. It further contains the artefacts to all use cases to allow for modification and extension. We finally include a tutorial on how Cognicrypt_GEN is used.</p>
},
keywords = {Code Generation, Cryptography, Eclipse, Java}
}

@software{10.1145/3373125,
author = {Pizzuti, Federico and Steuwer, Michel and Dubach, Christophe},
title = {Replication Packager for 'Generating Fast Sparse Matrix Vector Multiplicationfrom a High Level Generic Functional IR'},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373125},
abstract = {
    <p>The artefact contains the version of the Lift compiler used within the paper, together with the reference cuSparse benchmark and detailed instructions on how to reproduce the experiment</p>
},
keywords = {Code Generation, Dependent Types, GPU programming, Sparse Matrix}
}

@software{10.1145/3373126,
author = {Thakur, Manas and Nandivada, V. Krishna},
title = {Artifact for Paper: Mix Your Contexts Well},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373126},
abstract = {
    <p>Our artifact includes Java code for our techniques proposed in this paper: lsrvH and lsrvkobjH. We have also provided the code for our implementation of the object-sensitive analysis (kobjH). Instructions to use can be found in the included appendix.pdf and README.txt.</p>
},
keywords = {Context-sensitivity, Java, Static analysis}
}

@software{10.5281/zenodo.3605359,
author = {Kang, Seokwon and Choi, Kyunghwan and Park, Yongjun},
title = {[Evaluation Package] PreScaler: An Efficient System-aware Precision Scaling Framework on Heterogeneous Systems},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3605359},
abstract = {
    <p>This package provides all the binaries, libraries, benchmarks, and scripts, for evaluating the PreScaler implementations. These require target heterogeneous systems that contain Intel CPUs and NVIDIA GPUs. This package provides PreScaler artifact in two forms: ocker images and native binaries for several different system environments. These include installation scripts for software dependencies except NVIDIA Graphic Driver and CUDA toolkit. When you use a Docker image, all the software dependencies are preinstalled.</p>
},
keywords = {Compiler, HSA, OpenCL, Precision Scaling, Profile-guided, Runtime}
}

@software{10.5281/zenodo.3558339,
author = {Dakkak, Abdul and Wickham-Jones, Tom and Hwu, Wen-mei},
title = {Artifact for The Design and Implementation of the Wolfram Language Compiler},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3558339},
abstract = {
    <p>Benchmark source code for the CGO'20 paper</p>
},
keywords = {compiler, mathematica, wolfram}
}

@software{10.5281/zenodo.3581199,
author = {Zhang, Yunming and Brahmakshatriya, Ajay and Chen, Xinyi and Dhulipala, Laxman and Kamil, Shoaib and Amarasinghe, Saman and Shun, Julian},
title = {Optimizing Ordered Graph Algorithms with GraphIt},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3581199},
abstract = {
    <p>Instructions to test the compiler extension and replicate the performance numbers.</p>
},
keywords = {Compiler Optimizations, Graph Processing}
}

@software{10.5281/zenodo.3597890,
author = {Cowan, Meghan and Moreau, Thierry and Chen, Tianqi and Bornholt, James and Ceze, Luis},
title = {Replication Package for Automatic Generation of High-Performance Quantized Machine Learning Kernels},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3597890},
abstract = {
    <p>This artifact contains the source code for generating quantized operators for ARM devices as well as scripts to reproduce the experimental results. Quantized microkernels are synthesized for ARM NEON, which are used by TVM, a machine learning compiler.</p>
},
keywords = {code generation, program synthesis, Quantization}
}

@software{10.1145/3373116,
author = {Arntzenius, Michael and Krishnaswami, Neel},
title = {Artifact for Article: Semina\"{\i}ve Evaluation for a Higher-Order Functional Language},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373116},
abstract = {
    <p>A virtual machine containing the source code for an implementation of Datafun along with the tools necessary to build it and run a simple benchmark suite demonstrating an asymptotic speedup resulting from the seminaive optimization (along with auxilliary optimizations) described in the paper.</p>
},
keywords = {Datafun, Datalog, functional languages, incremental computation, relational languages, semina\"{\i}ve evaluation}
}

@software{10.5281/zenodo.3546500,
author = {Darais, David and Sweet, Ian and Liu, Chang and Hicks, Michael},
title = {OblivML},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3546500},
abstract = {
    <p>OblivML is an extension of the  obliv language with additional programming constructs. The repository also contains examples of ORAM and an Oblivious Stack (OStack). It is the artifact for the associated POPL 2020 paper, A Language for Probabilistically Oblivious Computation.</p>
},
keywords = {Noninterference., Oblivious Computation, Probability, Type Systems}
}

@software{10.1145/3373111,
author = {Jaber, Guilhem},
title = {Prototype of SyTeCi},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373111},
abstract = {
    <p>This prototype generates, from two programs M_1,M_2 written in a fragment of ML, the Structured-Memory Transition Machine A_S as described in this paper. It is represented using the dot format of graphviz. One can then check that no failed states are reachable in A_S to prove that M_1,M_2 are contextually equivalent. In the restricted fragment described in the paper cited above, the prototype can also generates the set of constrained Horn clauses corresponding to the non-reachability of failed states of A_S. These constrained Horn clauses are written in an extension of the SMT-LIB2 formate described here, than can be checked by the SMT-sover z3.</p>
},
keywords = {Contextual Equivalence, Operational Game Semantics}
}

@software{10.1145/3373106,
author = {Saad, Feras A. and Freer, Cameron E. and Rinard, Martin C. and Mansinghka, Vikash K.},
title = {Sampling Algorithms and Experiments for: Optimal Approximate Sampling from Discrete Probability Distributions},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373106},
abstract = {
    <p>This artifact contains implementations of the main algorithms in the paper, implementations of baseline sampling algorithms and experimental pipelines. Please refer to the README for additional details.</p>
},
keywords = {experimental pipelines, performance measurements, sampling algorithms}
}

@software{10.1145/3373113,
author = {Lazarek, Lukas and King, Alexis and Sundar, Samanvitha and Findler, Robert Bruce and Dimoulas, Christos},
title = {Artifact for: Does Blame Shifting Work?},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373113},
abstract = {
    <p>The artifact is a VirtualBox virtual machine appliance that contains all of the source code, benchmarks, and experiment harnesses used in the development of the paper (pre-built and set up). It comes with a README and interactive demo illustrating how the experiment works, as well as pointers for how to extend or modify the experiment.</p>
},
keywords = {blame, Higher-order contracts, programming languages design evaluation, Racket}
}

@software{10.1145/3373109,
author = {Wang, Chenglong and Feng, Yu and Bodik, Rastislav and Cheung, Alvin and Dillig, Isil},
title = {Falx: Visualization by Example Tool},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373109},
abstract = {
    <p>Our artifact contains the following materials: * Benchmarks of visualization by example tasks. See Benchmarks section. * Implementation of the synthesis algorithm (named Falx, stored under the artifact directory) in Python3. This is our implementation used in the paper evaluation. * Evaluation log and analysis scripts used in our paper evaluation. * A new implementation of the synthesis algorithm for playing purpose (named Falx-new, stored under the falx-new directory). See Extra: Play with the Tool to learn about this new implementation.</p>
},
keywords = {Program Synthesis, Programming-by-Example, Visualization}
}

@software{10.5281/zenodo.3533633,
author = {Wang, Peixin and Fu, Hongfei and Chatterjee, Krishnendu and Deng, Yuxin and Xu, Ming},
title = {Software Artifact Accompanying the Article: Proving Expected Sensitivity of Probabilistic Programs with Randomized Variable-Dependent Termination Time},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3533633},
abstract = {
    <p>This artifact contains an implementation of the RSM synthesis algorithm as described in the paper. For details, please see the "README.md" file.</p>
},
keywords = {Expected Sensitivity, Martingales, Probabilistic Programs}
}

@software{10.1145/3365460,
author = {Jeanjean, Pierre and Combemale, Benoit and Barais, Olivier},
title = {Artifact for the Paper: From DSL specification to interactive computer programming environment},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3365460},
abstract = {
    <p>This artifact contains the necessary Eclipse plugins to generate and execute REPLs from more traditional DSL specifications. It was made to be run on top of the GEMOC Studio, a customized Eclipse platform that includes technologies to develop, maintain and use executable modeling languages. The GEMOC Studio includes, among others, support and integration for DSL specifications, and an execution engine to execute languages with semantics written in ALE (Action Language for EMF). The current artifact also includes the specifications of two languages that were introduced in the evaluation of the submitted paper: Logo and MiniJava.</p>
},
keywords = {domain specific languages, language engineering, repl}
}

@software{10.1145/3365461,
author = {Castegren, Elias and Fernandez-Reyes, Kiko},
title = {Source Code for "Developing a Monadic Type Checker for an Object-Oriented Language"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3365461},
abstract = {
    <p>This artifact contains the complete source code for the type checker design presented in "Developing a Monadic Type Checker for an Object-Oriented Language". It is available both as plain Haskell source code and as a VM image with the prerequisites installed. If you don't want to download the VM image, you can also find the code online: https://github.com/parapluu/monadic-typechecker.</p>
},
keywords = {compilers, functional programming, object-oriented languages, type systems}
}

@software{10.1145/3365463,
author = {Diekmann, Lukas and Tratt, Laurence},
title = {Experiment for Article: Default Disambiguation for Online Parsers},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3365463},
abstract = {
    <p>This artefact provides scripts, programs, and other materials needed to reproduce the results from the evaluation section of the paper. The archive also contains a Debian VM which has been pre-configured with all necessary dependencies to run the experiment. For more information, please refer to the README.txt and guide.pdf in the archive.</p>
},
keywords = {language composition, parsing}
}

@software{10.5281/zenodo.3369436,
author = {K?ikava, Filip and Miller, Heather and Vitek, Jan},
title = {Artifact for Scala Implicits are Everywhere},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3369436},
abstract = {
    <p>Code and data for the OOPLSA 2019 paper.</p>
},
keywords = {analysis, Scala}
}

@software{10.5281/zenodo.3378067,
author = {Mariano, Benjamin and Reese, Josh and Xu, Siyuan and Nguyen, ThanhVu and Qiu, Xiaokang and Foster, Jeffrey S. and Solar-Lezama, Armando},
title = {Replication Package for "Program Synthesis with Algebraic Library Specifications"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3378067},
abstract = {
    <p>This artifact can be used to recreate the experiments from the paper "Program Synthesis with Algebraic Library Specifications". In particular, the artifact contains the benchmarks we used and scripts for running the experiments, as well as instructions for building the tool from source.</p>
},
keywords = {Algebraic Specification, Java, Sketch-based Program Synthesis, Term Rewriting}
}

@software{10.5281/zenodo.3362696,
author = {Song, Dowon and Lee, Myungho and Oh, Hakjoo},
title = {Automatic and Scalable Detection of Logical Errors in Functional Programming Assignments},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3362696},
abstract = {
    <p>This is an artifact for the paper "Automatic and Scalable Detection of Logical Errors in Functional Programming Assignments" submitted to OOPSLA 2019. It provides VM and documentation for reproducing the evaluation results in the paper. The VM contains source codes for implementing the algorithm, benchmarks used in evaluation, and a python script for reproducing the Table 1 and Table 2 in the paper. Specially, you can see that the main parts of our algorithm are implemented in the following files: 1. engine/TestML/testGenerator.ml: Our overall algorithm and symbolic test case generation 2. engine/TestML/sym_exec.ml: Symbolic verification</p>
},
keywords = {Automated Test Case Generation, Program Synthesis, Symbolic Execution}
}

@software{10.5281/zenodo.3369573,
author = {Goel, Aviral and Vitek, Jan},
title = {Replication Package for Article: On the Design, Implementation and Use of Laziness in R},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3369573},
abstract = {
    <p>The artifact is a Docker image. It performs a dynamic analysis on packages written in the R language, and analyzes the generated data. The artifact uses this data to generate an HTML report containing the graphs and data appearing in our paper. The report is served by the Docker container on localhost:8000.</p>
},
keywords = {Corpus Analysis, Delayed or Lazy Evaluation, Empirical Study, Large-scale, R Language}
}

@software{10.5281/zenodo.3370437,
author = {Biswas, Ranadeep and Enea, Constantin},
title = {Database Testing Tool for Article: On the Complexity of Checking Transactional Consistency},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3370437},
abstract = {
    <p>The artifact contains a database testing tool named `dbcop` which provides three functionalities: 1. A random generator for client programs to run on a database. 2. A `trait`(equivalent to java interface) to run client programs on a database and log its executions. A user can use this trait to write an implementation specific to a database. 3. A verifier that checks conformance of a given execution to a consistency model. `dbcop` offers two subcommands: `generate` and `verify`. 1. `generate` generates client programs to run on a database. 2. `verify` verifies consistency of the executions of these client programs. The artifact is packaged as a Docker image. The image includes our tool and the database-generated executions (histories) used in the experimental evaluation reported in the paper.</p>
},
keywords = {axiomatic specifications, consistency, testing, transactional databases}
}

@software{10.5281/zenodo.3374034,
author = {Wei, Guannan and Chen, Yuxuan and Rompf, Tiark},
title = {Replication Package for Article: Staged Abstract Interpreter},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3374034},
abstract = {
    <p>The artifact contains programs that show how to stage an abstract interpreter step-by-step, as well as programs to reproduce the performance evaluation in the paper.</p>
},
keywords = {abstract interpreters, multi-stage programming, Scala}
}

@software{10.5281/zenodo.3374835,
author = {Yamazaki, Tetsuro and Nakamaru, Tomoki and Ichikawa, Kazuhiro and Chiba, Shigeru},
title = {Generating a fluent API with syntax checking from an LR grammar (Artifact)},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3374835},
abstract = {
    <p>The artifact for "Generating a fluent API with syntax checking from an LR grammar", which will be published in OOPSLA 2019. "artifact.pdf" mentions the usage of typelevelLR, a fluent-API-style library-skeleton generator, which we implemented for the experiments presented in the paper. This artefact contains all the programs that can be used to reproduce the evaluation of our paper. You can find the instructions in the README.pdf file.</p>
},
keywords = {artifact, fluent API, library skeleton generator, OOPSLA 2019}
}

@software{10.5281/zenodo.3384856,
author = {Abdulla, Parosh Aziz and Atig, Mohamed Faouzi and Jonsson, Bengt and L\r{a}ng, Magnus and Ngo, Tuan Phong and Sagonas, Konstantinos},
title = {Optimal Stateless Model Checking for Reads-From Equivalence under Sequential Consistency},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3384856},
abstract = {
    <p>The artifact reproduces the performance numbers in the paper. It consists of an overview document, which describes its use, and a virtual machine image.</p>
},
keywords = {concurrency, model checking, sequential consistency, testing}
}

@software{10.5281/zenodo.3363977,
author = {Huang, Mingzhang and Fu, Hongfei and Chatterjee, Krishnendu and Goharshady, Amir Kafshdar},
title = {Software Artifact Accompanying the Article "Modular Verification for Almost-Sure Termination of Probabilistic Programs"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3363977},
abstract = {
    <p>Please see the readme file.</p>
},
keywords = {modular analysis, probabilistic programs, Termination analysis}
}

@software{10.5281/zenodo.3364114,
author = {Mastrangelo, Luis and Hauswirth, Matthias and Nystrom, Nathaniel},
title = {Casting about in the Dark - Artifact Evaluation},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3364114},
abstract = {
    <p>Companion dataset artifact used in the paper "Casting about in the Dark".</p>
},
keywords = {cast, Java, type safety}
}

@software{10.5281/zenodo.3366212,
author = {Adams, Ulf},
title = {Implementations of Ryu \&amp; Ryu Printf},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3366212},
abstract = {
    <p>A set of C and Java libraries implementing Ryu and Ryu Printf.</p>
},
keywords = {c, conversion, float, java, printf, string}
}

@software{10.5281/zenodo.3368188,
author = {Vukotic, Ivana and Rahli, Vincent and Esteves-Ver\'{\i}ssimo, Paulo},
title = {Asphalion: Trustworthy Shielding Against Byzantine Faults},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3368188},
abstract = {
    <p>Asphalion is a Coq-based framework for verifying the correctness of implementations of fault-tolerant systems. It especially provides features to verify the correctness of hybrid fault-tolerant systems (such as the MinBFT protocol http://www.di.fc.ul.pt/~bessani/publications/tc11-minimal.pdf), where normal components (that can for example fail arbitrarily) trust some special components (that can for example only crash on failure) to provide properties in a trustworthy manner. Asphalion allows running such trusted-trustworthy components inside Intel SGX enclaves. More details are provided here: https://vrahli.github.io/articles/asphalion.pdf and here: https://vrahli.github.io/articles/asphalion-long.pdf</p>
},
keywords = {Byzantine fault-tolerance, Compositional reasoning, Coq, Crash fault-tolerance, Distributed systems, Fault-tolerance, Formal verification, Hybrid fault-tolerance, Intel SGX, Knowledge calculus, MinBFT, State machine replication, Trusted components}
}

@software{10.5281/zenodo.3368779,
author = {Wang, Shengyi and Cao, Qinxiang and Mohan, Anshuman and Hobor, Aquinas},
title = {Coq library supporting the paper "Certifying Graph-Manipulating C Programs via Localizations within Data Structures"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3368779},
abstract = {
    <p>This Docker machine contains a compiled and ready-to-use version of our Coq code library. Our work aims to provide a comprehensive solution to the problem of formally verifying programs that manipulate mathematical graphs. The codebase contains a number of worked examples showing how our library can be used to verify real C programs. The overview file provides a helpful starter guide to understanding and replicating our verifications.</p>
},
keywords = {CompCert, Coq, Graph-manipulating programs, Separation logic, VST}
}

@software{10.5281/zenodo.3369915,
author = {Bastian, Th\'{e}ophile and Kell, Stephen and Zappa Nardelli, Francesco},
title = {Reliable and Fast DWARF-Based Stack Unwinding (Artifact)},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3369915},
abstract = {
    <p>This VM contains the tools to reproduce the experiments of the submission: Reliable and Fast DWARF-based Stack Unwinding</p>
},
keywords = {debugging, DWARF, stack unwinding}
}

@software{10.5281/zenodo.3370063,
author = {Konnov, Igor and Kukovec, Jure and Tran, Thanh-Hai},
title = {Artifact - TLA+ Model Checking Made Symbolic},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3370063},
abstract = {
    <p>This artifact version, named "25_ae", contains the same materials which we submitted in the artifact evaluation, and two new files README, and LICENSE. Our artifact comes in the form of a virtual machine (user: oopsla19, pass: ae). Our model checker v0.5.0 is already installed on the VM. After the rebuttal, we agreed with the reviewers to add new optimizations in our model checker, and new benchmarks in the second submission. However, these changes are included only in the later version of our artifact, named "25_v2". Please follow the link 10.5281/zenodo.3370071 for the new version called "25_v2", which contains updates in our second submission.</p>
},
keywords = {artifact, model checking, SMT, TLA+}
}

@software{10.5281/zenodo.3370297,
author = {Kokologiannakis, Michalis and Raad, Azalea and Vafeiadis, Viktor},
title = {Replication package for 'Effective Lock Handling in Stateless Model Checking'},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3370297},
abstract = {
    <p>This is the artifact accompanying the paper "Effective Lock Handling in Stateless Model Checking". Our paper's artifact is the set of benchmarks we used in the paper, as well as the results we got by running particular versions of model checking tools (i.e., GenMC and LAPOR) on the benchmarks' set.</p>
},
keywords = {Model checking, mutual exclusion locks, weak memory models}
}

@software{10.5281/zenodo.3377079,
author = {Lu, Jingbo and Xue, Jingling},
title = {Replication package for article: Precision-Preserving Yet Fast Object-Sensitive Pointer Analysis with Partial Context Sensitivity},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3377079},
abstract = {
    <p>This artifact is provided to enable the reproducing of results in Section 4 of the companion paper "Precision-Preserving Yet Fast Object-Sensitive Pointer Analysis with Partial Context Sensitivity". To use this artifact, please start by reading Getting-Started-Guide.pdf and Step-by-Step-Instructions.pdf in the artifact package.</p>
},
keywords = {Dacapo, Soot}
}

@software{10.5281/zenodo.3363988,
author = {Marcozzi, Micha\"{e}l and Tang, Qiyi and Donaldson, Alastair F. and Cadar, Cristian},
title = {Replication Package for "Compiler Fuzzing: How Much Does It Matter?"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3363988},
abstract = {
    <p>This artifact provides the bug impact measurement infrastructure and the experimental data presented in the following paper: Micha l Marcozzi, Qiyi Tang, Alastair F. Donaldson, and Cristian Cadar. 2019. Compiler Fuzzing: How Much Does It Matter . Proc. ACM Program. Lang. 3, OOPSLA, Article 155 (October 2019), 29 pages. https://doi.org/10.1145/3360581 The paper introduces the first quantitative and qualitative study of the tangible impact of fuzzer-found compiler bugs. It follows a novel methodology where the impact of a miscompilation bug is evaluated based on (1) whether the bug appears to trigger during compilation; (2) the extent to which generated assembly code changes syntactically due to triggering of the bug; and (3) how likely such changes are to cause runtime divergences during execution. The study is conducted with respect to the compilation of more than 10 million lines of C/C++ code from 309 Debian packages, using 12\% (27) of the historical and now fixed miscompilation bugs found by four state-of-the-art fuzzers in the Clang/LLVM compiler, as well as 18 other bugs found by the Alive formal verification tool or human users. This artifact provides the necessary software and data to replicate this study for the 45 Clang/LLVM miscompilation bugs over the 309 Debian packages. In addition to enabling the easy replication of the paper results, the provided bug impact measurement infrastructure can also be used to measure the impact of miscompilation bugs over Debian packages that have not been considered in the paper. It can also be extended to perform differential testing for multiple compilers or optimisation options of a compiler.</p>
},
keywords = {bug impact, Clang, compilers, fuzzing, LLVM, software testing}
}

@software{10.5281/zenodo.3364086,
author = {Padhye, Rohan and Lemieux, Caroline and Sen, Koushik and Simon, Laurent and Vijayakumar, Hayawardh},
title = {Replication Package for "FuzzFactory: Domain-Specific Fuzzing with Waypoints"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3364086},
abstract = {
    <p>The artifact contains a Docker image for supporting various claims made in the paper. In particular, the Docker image contains a snapshot of the AFL fuzzing tool, a snapshot of FuzzFactory (which itself is a fork of AFL), a snapshot of Google's fuzzer-test-suite, scripts to replicate the experiments described in the paper, and a "pre-baked" data dump of the results of experiments that were conducted on the author's machine (this data can be used to reproduce the plots that are included in the paper).</p>
},
keywords = {domain-specific fuzzing, fuzz testing, waypoints}
}

@software{10.5281/zenodo.3366234,
author = {Rapoport, Marianna and Lhot\'{a}k, Ond?ej},
title = {Coq type soundness proof for 'A Path to DOT: Formalizint Fully Path-Dependent Types'},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3366234},
abstract = {
    <p>Our paper presents pDOT, a generalization of the Dependent Object Types (DOT) calculus that formalizes Scala. The pDOT calculus extends DOT with support for path-dependent types on paths of arbitrary length. This artifact presents the Coq formalization of the pDOT type-safety proof as presented in Section 5 of the paper.</p>
},
keywords = {Coq, DOT, paths, Scala, type safety}
}

@software{10.5281/zenodo.3366904,
author = {Siraichi, Marcos Yukio and Santos, Vin\'{\i}cius Fernandes dos and Collange, Caroline and Pereira, Fernando Magno Quint\~{a}o},
title = {Experiment and Software to Reproduce: Qubit Allocation as a Combination of Subgraph Isomorphism and Token Swapping},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3366904},
abstract = {
    <p>This artifact is composed of mainly scripts, benchmarks, and configuration data used to generate the data of this paper. The scripts set up the environment, downloading the necessary software and dependencies using Git and APT (since package managers are specific for different distros, it may not work on all of them), and compiling them all. In the end, you will have in hands: (i) "enfield", an OpenQASM source-to-source compiler; (ii) all the benchmarks used; (iii) helper scripts. Ideally, you would run the script for reproducing the experiments as is, but you may also change the configuration data for custom experiments.</p>
},
keywords = {Compilers, Quantum Computing, Qubit Allocation}
}

@software{10.5281/zenodo.3368504,
author = {Sergey, Ilya and Nagaraj, Vaivaswatha and Johannsen, Jacob and Kumar, Amrit and Trunov, Anton and Hao, Ken Chan Guan},
title = {Benchmarks accompanying the OOPSLA 2019 paper Safer Smart Contract Programming with Scilla},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3368504},
abstract = {
    <p>This is the artefact accompanying the OOPSLA 2019 paper entitled "Safer Smart Contract Programming with Scilla". The artefact contains scripts for reproducing the quantitative comparison with Ethereum Virtual Machine, reported in the paper.</p>
},
keywords = {Benchmarks, EVM, Scilla, Smart Contracts, Zilliqa}
}

@software{10.5281/zenodo.3374030,
author = {Pan, Rong and Hu, Qinheping and Xu, Gaowei and D'Antoni, Loris},
title = {RFixer: a tool for repairing complex regular expressions using examples},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3374030},
abstract = {
    <p>This artifact contains the virtual machine image that has RFixer installed. RFixer is a tool for repairing complex regular expressions using examples. Given an incorrect regular expression and sets of positive and negative examples, RFixer synthesizes the closest regular expression to the original one that is consistent with the examples. The paper "Automatic Repair of Regular Expressions" that describes RFixer is conditionally accepted at OOPSLA 2019. The Step-by-Step Instructions in the README file explains how to reproduce the paper's results.</p>
},
keywords = {Program Repair, Program Synthesis, Regular Expressions}
}

@software{10.5281/zenodo.3374036,
author = {Shajii, Ariya and Numanagi?, Ibrahim and Baghdadi, Riyadh and Berger, Bonnie and Amarasinghe, Saman},
title = {Seq (OOPSLA 2019 Artifact)},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3374036},
abstract = {
    <p>This is the artifact submitted alongside the Seq paper to OOPSLA 2019, which consists of a VM containing an alpha build of Seq, as well as a usage guide. Seq is a programming language for computational genomics and bioinformatics. With a Python-compatible syntax and a host of domain-specific features and optimizations, Seq makes writing high-performance genomics software as easy as writing Python code, and achieves performance comparable to (and in many cases better than) C/C++.</p>
},
keywords = {artifact, bioinformatics, compiler, domain-specific language, genomics, programming language}
}

@software{10.5281/zenodo.3362424,
author = {Caires, Lu\'{\i}s and Toninho, Bernardo},
title = {Refinement Kinds: Type-safe Programming with Practical Type-level Computation (Artifact)},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3362424},
abstract = {
    <p>This is the artifact for the paper Refinement Kinds: Type-safe Programming with Practical Type-level Computation. The artifact consists of a prototype kind and type-checker (which also includes an evaluator) for the language described in the paper. The artifact is distributed as a Docker image that bundles the source code, all its dependencies, the code examples from the paper and various additional examples. See the README for a getting started and syntax guides.</p>
},
keywords = {Refinement Kinds, Type Theory, Type-level Computation, Typed Meta-Programming}
}

@software{10.5281/zenodo.3365412,
author = {Bender, John and Palsberg, Jens},
title = {JAM Model: Herd and Coq Instantiations},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3365412},
abstract = {
    <p>The artifact is a virtual machine image with all necessary dependencies to use the Herd and Coq models and reproduce the results of our paper.</p>
},
keywords = {coq, herd, mechanized, memory models}
}

@software{10.5281/zenodo.3366380,
author = {Barik, Rajkishore and Sridharan, Manu and Ramanathan, Murali Krishna and Chabbi, Milind},
title = {Optimization of Swift Protocols},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3366380},
abstract = {
    <p>Swift, an increasingly-popular programming language, advocates the use of protocols, which define a set of required methods and properties for conforming types. Protocols are commonly used in Swift programs for abstracting away implementation details; e.g., in an industrial app, they are heavily used to enable mock objects for unit testing. Unfortunately, heavy use of protocols can result in significant performance overhead. Beyond the dynamic dispatch often associated with such a feature, Swift allows for both value and reference types to conform to a protocol, leading to significant boxing and unboxing overheads. In this paper, we describe three new optimizations and transformations we have developed to reduce the overhead of Swift protocols. Within a procedure, we define LocalVar, a data-flow analysis and transformation to remove both dynamic dispatch and boxing overheads. We also describe Param, which optimizes the case of protocol-typed method parameters using specialization. Finally, we describe SoleType, a transformation that injects casts when a global analysis (like type-hierarchy analysis) discovers some protocol variable must have some concrete type. We also describe how these optimizations work fruitfully together and with existing Swift optimizations to deliver further speedups. We perform elaborate experimentation and demonstrate that our optimizations deliver an average 1.56x speedup on a suite of Swift benchmarks that use protocols. Further, we applied the optimizations to a production iOS Swift application used by millions of customers daily. For a set of performance spans defined by the developers of the application, the optimized version showed speedups ranging from 6.9\% to 55.49\%. A version of our optimizations has been accepted as part of the official Swift compiler distribution.</p>
},
keywords = {boxing/unboxing, protocols, SIL, Swift, virtual method disptach}
}

@software{10.5281/zenodo.3368627,
author = {Antonopoulos, Timos and Koskinen, Eric and Le, Ton Chanh},
title = {Knotical: An Inference System of Trace Refinement Relations},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3368627},
abstract = {
    <p>This is an artifact for the paper "Specification and Inference of Trace Refinement Relations", which is accepted to OOPSLA 2019. The artifact is licensed under the MIT license. The development repository is located at https://github.com/knotical/knotical.</p>
},
keywords = {Kleene Algebra with Tests, program refinement, relational reasoning, trace refinement}
}

@software{10.5281/zenodo.3363914,
author = {Astrauskas, Vytautas and M\"{u}ller, Peter and Poli, Federico and Summers, Alexander J.},
title = {Software Artefact for the OOPSLA'19 Paper Titled "Leveraging Rust Types for Modular Specification and Verification"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3363914},
abstract = {
    <p>This artefact contains a virtual machine that can be used to reproduce the evaluation of our paper. You can find the instructions in the README.pdf file. If you are interested in building on top of our research results, you can find the latest version of Prusti in our GitHub repository: https://github.com/viperproject/prusti-dev.</p>
},
keywords = {Rust, verification, Viper}
}

@software{10.5281/zenodo.3365991,
author = {Nanevski, Aleksandar and Banerjee, Anindya and Delbianco, Germ\'{a}n Andr\'{e}s and F\'{a}bregas, Ignacio},
title = {Specifying Concurrent Programs in Separation Logic: Morphisms and Simulations (Artefact).},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3365991},
abstract = {
    <p>This artefact is a companion to: Aleksandar Nanevski, Anindya Banerjee, Germ n Andr s Delbianco, and Ignacio F bregas. 2019. Specifying Concurrent Programs in Separation Logic: Morphisms and Simulations. Proc. ACM Program. Lang. 3, OOPSLA, Article 161 (October 2019), 30 pages. https://doi.org/10.1145/3360587 The artefact contains all the Coq sources of the developments presented in the submission, including the meta-theory of FCSL, and the example case studies. It also contains additional examples that the main body submission does not discuss. Some, such as readers/writers locks, are presented in the Extended Technical Report [arXiv:1904.07136], which has also been included in the artefact.</p>
},
keywords = {Coq, FCSL, Hoare/Separation Logics, Program Logics for Concurrency}
}

@software{10.5281/zenodo.3369233,
author = {Keidel, Sven and Erdweg, Sebastian},
title = {Artifact: Sound and Reusable Components for Abstract Interpretation},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3369233},
abstract = {
    <p>The artifact contains the library of analysis components (Section 6) and the code of the case studies (Section 7).</p>
},
keywords = {Abstract Interpretation, Soundness, Static Analysis}
}

@software{10.5281/zenodo.3364750,
author = {Near, Joseph P. and Darais, David and Abuah, Chike and Stevens, Tim and Gaddamadugu, Pranav and Wang, Lun and Somani, Neel and Zhang, Mu and Sharma, Nikhil and Shan, Alex and Song, Dawn},
title = {Replication Package for Article: Duet: An Expressive Higher-Order Language and Linear Type System for Statically Enforcing Differential Privacy},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3364750},
abstract = {
    <p>Duet is an expressive higher-order language, linear type system and tool for automatically verifying differential privacy of arbitrary higher-order programs. In addition to general purpose programming, it supports encoding machine learning algorithms such as stochastic gradient descent, as well as common auxiliary data analysis tasks such as clipping, normalization and hyperparameter tuning. Current version is available at the GitHub repository: https://github.com/uvm-plaid/duet</p>
},
keywords = {Differential privacy, machine learning, typechecking}
}

@software{10.1145/3342531,
author = {Miltner, Anders and Maina, Solomon and Fisher, Kathleen and Pierce, Benjamin C. and Walker, David and Zdancewic, Steve},
title = {Replication Package for Artifact: Synthesizing Symmetric Lenses},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342531},
abstract = {
    <p>The Artifact contains Boomerang extended with Symmetric combinators, and Symmetric Optician. This tool allows people to write and synthesize symmetric lenses on string data.</p>
},
keywords = {Bidirectional Programming, Information Theory, Program Synthesis, Type Systems, Type-Directed Synthesis}
}

@software{10.1145/3342521,
author = {Mokhov, Andrey and Lukyanov, Georgy and Marlow, Simon and Dimino, Jeremie},
title = {Software packages and proofs for the paper "Selective Applicative Functors"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342521},
abstract = {
    <p>This artefact comprises a Docker image containing a snapshot of the software packages related to the paper "Selective Applicative Functors" and all their dependencies.</p>
},
keywords = {applicative functors, effects, monads, selective functors}
}

@software{10.1145/3342524,
author = {Vezzosi, Andrea and M\"{o}rtberg, Anders and Abel, Andreas},
title = {Source code for examples from article Cubical Agda: A Dependently Typed Programming Language with Univalence and Higher Inductive Types},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342524},
abstract = {
    <p>The artifact contains complete source files implementing the examples from the article. It also contains a Dockerfile to setup a working environment where they can be tested.</p>
},
keywords = {Cubical Agda, Dependent Type Theory, Homotopy Type Theory, Univalence}
}

@software{10.1145/3342525,
author = {Kiss, Csongor and Field, Tony and Eisenbach, Susan and Peyton Jones, Simon},
title = {Fork of GHC implementing -XUnsaturatedTypeFamilies for the paper 'Higher-Order Type-Level Programming in Haskell'},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342525},
abstract = {
    <p>The artefact contains two files 1. The source code (ghc-icfp-src.tar.gz) for the fork of GHC which implements UnsaturatedTypeFamilies 2. A prebuilt docker image (ghc-icfp-docker.tar.gz) which can be loaded to run the examples from the paper. The nix expression which was used to build the docker image can be found in the `build-docker` subdirectory.</p>
},
keywords = {GHC, Haskell, type-level programming}
}

@software{10.1145/3342527,
author = {Delaware, Benjamin and Suriyakarn, Sorawit and Pit-Claudel, Cl\'{e}ment and Ye, Qianchuan and Chlipala, Adam},
title = {Virtual machine and source code for Narcissus: Correct-by-Construction Derivation of Decoders and Encoders from Binary Formats},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342527},
abstract = {
    <p>This artifact contains our source code, as well as a virtual machine with our code and benchmarks. The README provides the following: * Instructions on running the virtual machine and stepping through the tutorial in our paper (Section 1.1   A tour of Narcissus), * Guidance on how to reproduce the benchmarks in our paper (Section 6), * Directions to build and use our library in general, outside of the virtual machine, * Links from the definitions, lemmas, and rules in the paper to the actual implementation in our code, and * Instructions on how to set up our virtual machine and its environment from scratch.</p>
},
keywords = {Deductive Synthesis, Parser Combinators, Program Synthesis, Serialization and Deserialization}
}

@software{10.1145/3342528,
author = {Qu, Weihao and Gaboardi, Marco and Garg, Deepak},
title = {A Type Checker BiARel for 'Relational Cost Analysis for Functional-Imperative Programs'},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342528},
abstract = {
    <p>This software is an implementation of the type-and-effect system ARel proposed in 'Relational Cost Analysis for Functional-Imperative Programs', written in OCaml. It uses SMT solver alt-ergo and uses the front end Why3 to solve the constraint generated from the bidirectional type checker.</p>
},
keywords = {refinement types, relational type systems, type-and-effect systems}
}

@software{10.1145/3342532,
author = {Timany, Amin and Birkedal, Lars},
title = {Coq formalization for the paper: Mechanized Relational Verification of Concurrent Programs with Continuations},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342532},
abstract = {
    <p>This artifact includes the Coq formalization of the theory presented in the paper.</p>
},
keywords = {Concurrency, Continuations, Logical relations}
}

@software{10.1145/3342534,
author = {Sherman, Benjamin and Michel, Jesse and Carbin, Michael},
title = {Artifact for Article: Sound and Robust Solid Modeling via Exact Real Arithmetic and Continuity},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342534},
abstract = {
    <p>The artifact consists of the following: - The MarshallB programming system, a programming language interpreter written in OCaml. Our artifact permits running a REPL for the language. - The StoneWorks library for MarshallB, which is several files of MarshallB code. Our artifact permits processing these files, ensuring they typecheck, and allowing them to be used at the REPL. - Standalone MarshallB files and commands to execute the case studies from the paper, for which the paper describes computational results that we produced using MarshallB.</p>
},
keywords = {constructive analysis, continuity, exact real arithmetic, solid modeling, synthetic topology}
}

@software{10.1145/3342535,
author = {Weirich, Stephanie and Choudhury, Pritam and Voizard, Antoine and Eisenberg, Richard A.},
title = {Replication Package for Article: A Role for Dependent Types in Haskell},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342535},
abstract = {
    <p>This archive contains the artifact submitted with the paper "A Role for Dependent Types in Haskell" (DOI: 10.1145/3341705). The artifact consists of the entire mechanization, using the Coq proof assistant, of the results presented in the paper. It contains both a Docker image and a copy of the source code.</p>
},
keywords = {Coq, Dependent Types, Functional Languages, Haskell, Mechanized Metatheory, Type Theory}
}

@software{10.1145/3342536,
author = {Gratzer, Daniel and Sterling, Jonathan and Birkedal, Lars},
title = {blott: An Implementation of a Modal Dependent Type Theory},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342536},
abstract = {
    <p>An experimental OCaml implementation of the modal dependent type theory described in "Implementing a Modal Dependent Type Theory".</p>
},
keywords = {implementation, modalities, normalization-by-evaluation, OCaml, type theory, type-checker}
}

@software{10.1145/3342537,
author = {Orchard, Dominic and Liepelt, Vilem-Benjamin and Eades III, Harley},
title = {Language implementation for Quantitative Program Reasoning with Graded Modal Types},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342537},
abstract = {
    <p>This artefact provides a snapshot of the Granule language implementation, which provides a type-checker and interpreter (gr), as well as an interactive shell (grin). This is the core implementation of the theory described in the paper. Included are many example programs, including literate Granule files which replay the examples from Section 2 and Section 8 of the paper ("examples/intro.gr.md" and "examples/further-examples.gr.md"). The artefact includes the source (written in Haskell) and a Docker image, along with instructions on how to setup the Docker or install from source yourself.</p>
},
keywords = {coeffects, graded modal types, Granule, implementation, linear types}
}

@software{10.1145/3342520,
author = {P\'{e}drot, Pierre-Marie and Tabareau, Nicolas and Fehrmann, Hans Jacob and Tanter, \'{E}ric},
title = {Coq plugin for the Reasonably Exceptional Type Theory},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342520},
abstract = {
    <p>This plugin allows to automatically translate Coq terms in such a way that they can now use exceptions in a controlled way. This can be useful for programming, e.g. to allow failure locally and prove after the fact that assuming a few properties the translated term does not fail, without endangering reduction nor polluting the type signature as a monadic translation would do.</p>
},
keywords = {Coq, effects, exceptions, plugin, type theory}
}

@software{10.1145/3342522,
author = {Zhang, Hengchu and Roth, Edo and Haeberlen, Andreas and Pierce, Benjamin C. and Roth, Aaron},
title = {Prototype Implementation of Fuzzi: A Three-Level Logic for Differential Privacy},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342522},
abstract = {
    <p>The prototype implementation contains a typechecker, and a transpiler for typechecking and translating Fuzzi code into Python code for execution.</p>
},
keywords = {apRHL, Differential privacy, Fuzz, Fuzzi, static analysis, typechecking}
}

@software{10.1145/3342523,
author = {Bahr, Patrick and Graulund, Christian Uldal and M\o{}gelberg, Rasmus Ejlers},
title = {Coq formalisation for Simply RaTT},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342523},
abstract = {
    <p>This artefact is a Coq formalisation of the results in the paper "Simply RaTT: A Fitch-style Modal Calculus for Reactive Programming Without Space Leaks".</p>
},
keywords = {Coq, functional reactive programming, logical relation, operational semantics, type system}
}

@software{10.5281/zenodo.3257707,
author = {Swierstra, Wouter and Baanen, Tim},
title = {Source code},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3257707},
abstract = {
    <p>This artefact contains the proofs and programs associated with the ICFP '19 paper 'A Predicate Transformer Semantics for Effects'</p>
},
keywords = {Agda, effects, free monads, predicate transformers, program calculation, programming with dependent types, refinement, weakest precondition semantics}
}

@software{10.1145/3342526,
author = {Sozeau, Matthieu and Mangin, Cyprien},
title = {Equations Reloaded Accompanying Material},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342526},
abstract = {
    <p>This artifact contains the code of version 1.2 of Equations along with extended versions of all the examples presented in the article. It also includes a version of the Normalization of Predicative System F development.</p>
},
keywords = {Coq, Dependent Pattern-Matching, Well-Founded Recursion}
}

@software{10.1145/3342529,
author = {Hameer, Aliya and Pientka, Brigitte},
title = {Learn-OCaml Extensions and Repository for Article Teaching the Art of Functional Programming using Automated Grading (Experience Report)},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342529},
abstract = {
    <p>Software sources and Docker image for the extensions to Learn-OCaml described in the paper Teaching the Art of Functional Programming using Automated Grading (Experience Report).</p>
},
keywords = {automated grading, functional programming, OCaml, online programming platforms, programming education, programming style, test-driven development}
}

@software{10.1145/3342533,
author = {Flatt, Matthew and Derici, Caner and Dybvig, R. Kent and Keep, Andrew W. and Massaccesi, Gustavo E. and Spall, Sarah and Tobin-Hochstadt, Sam and Zeppieri, Jon},
title = {Artifact: Rebuilding Racket on Chez Scheme (Experience Report)},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3342533},
abstract = {
    <p>Source code and Docker image for Racket, Chez Scheme, and Racket on Chez Scheme, including benchmark sources and scripts.</p>
},
keywords = {Racket, Scheme}
}

@software{10.5281/zenodo.3257080,
author = {Eremondi, Joseph and Tanter, \'{E}ric and Garcia, Ronald},
title = {Redex Model: Approximate Normalization for Gradual Dependent Types},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3257080},
abstract = {
    <p>This artifact contains an implementation of the core calculus from the paper, built using the Racket Redex library.</p>
},
keywords = {dependent types, gradual types, racket, redex, type systems}
}

@software{10.1145/3339072,
author = {Sharma, Aman and Nasre, Rupesh},
title = {QADroid: Regression Event Selection for Android Applications},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3339072},
abstract = {
    <p>We present here the artifacts that supports our ISSTA 19 paper. We proposed QADroid. We implemented QaDroid using Soot and FlowDroid, and tested it over multiple versions of Android apps. We compared the regression selection of events in QADroid against the total number of events. The artifacts provides the experimental setup used and the steps to run QADroid on Android apps.</p>
},
keywords = {Android apps, Regression Analysis, Software Engineering}
}

@software{10.1145/3339066,
author = {Fazzini, Mattia and Xin, Qi and Orso, Alessandro},
title = {Replication Package for Article: Automated API-Usage Update for Android Apps},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3339066},
abstract = {
    <p>This artifact contains instructions on how to replicate the empirical evaluation of our work titled "Automated API-Usage Update for Android Apps".</p>
},
keywords = {API analysis, automated update, Mobile apps}
}

@software{10.1145/3339069,
author = {Padhye, Rohan and Lemieux, Caroline and Sen, Koushik and Papadakis, Mike and Le Traon, Yves},
title = {Replication Package for "Semantic Fuzzing with Zest"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3339069},
abstract = {
    <p>The artifact is a Docker image that contains the Zest fuzzing engine, benchmark programs evaluated in the paper, scripts to run all the experiments described in the paper, and a data-set containing the results of the experiments when they were run on the authors' machine.</p>
},
keywords = {property-based testing, random testing, Structure-aware fuzzing}
}

@software{10.1145/3339070,
author = {Kechagia, Maria and Devroey, Xavier and Panichella, Annibale and Gousios, Georgios and van Deursen, Arie},
title = {Replication Package for Article: Effective and Efficient API Misuse Detection via Exception Propagation and Search-Based Testing},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3339070},
abstract = {
    <p>Effective and efficient detection of API misuses in Java client programs by combining static exception propagation and search-based testing. The artifact includes the main components for the exception propagation and the search-based testing. A tutorial is also provided for running the experiments.</p>
},
keywords = {API misuse, search-based software testing, software crash, static exception propagation}
}

@software{10.1145/3339067,
author = {Schwahn, Oliver and Coppik, Nicolas and Winter, Stefan and Suri, Neeraj},
title = {Artifact for Article: Assessing the State and Improving the Art of Parallel Testing for C},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3339067},
abstract = {
    <p>This is the artifact for the paper "Assessing the State and Improving the Art of Parallel Testing for C" by Oliver Schwahn, Nicolas Coppik, Stefan Winter, and Neeraj Suri. The provided artifact contains the prototype implementations and raw data used for the paper packaged as a Docker image. The ZIP file includes our Docker image along with a more detailed README.txt and some utility shell scripts to simplify Docker handling and package installation. The Docker image contains a complete setup for building and executing our tools as well as the repository study and library raw data and scripts. Please refer to the aforementioned README.txt for the full documentation and detailed instructions. The Docker image and its contents are provided as is without any warranty for academic purposes. The user-space included in the Docker image was installed from the Ubuntu software repository. The source code for the Debian repository study and the libraries was downloaded from the Debian software repository. The source code for additional third-party tools, libraries, and programs was downloaded from their respective distribution archives or GitHub, e.g., llvm.org, https://github.com/coccinelle/coccinelle, https://github.com/AlDanial/cloc, https://cran.r-project.org, https://pypi.org/, https://www.rust-lang.org, https://crates.io Note that all included third-party software is subject to their respecive licenses.</p>
},
keywords = {Parallel Test Execution, Parallel Testing, Software Repository Analysis, Static Analysis, Static Dependency Detection}
}

@software{10.1145/3339068,
author = {Li, Xia and Li, Wei and Zhang, Yuqun and Zhang, Lingming},
title = {Replication Package for Article: "DeepFL: Integrating Multiple Fault Diagnosis Dimensions for Deep Fault Localization"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3339068},
abstract = {
    <p>This artifact is used to implement our fault localization technique "DeepFL". It includes two main components: (1) DeepFL execution and (2) Result analysis.</p>
},
keywords = {Deep learning, Fault localization, Mutation testing}
}

@software{10.1145/3339073,
author = {Ghanbari, Ali and Benton, Samuel and Zhang, Lingming},
title = {PraPR},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3339073},
abstract = {
    <p>PraPR (Practical Program Repair) is a JVM bytecode-level, mutation-based automated program repair tool. PraPR exhaustively mutates suspicious statements and uses test cases to validate the patches. PraPR mutators are either traditional mutation operators from mutation testing or simple program transformations that frequently occur in real-world bug fix commits.</p>
},
keywords = {Automated Program Repair, JVM Bytecode, Mutation Testing}
}

@software{10.5281/zenodo.3237378,
author = {Liu, Kui and Koyuncu, Anil and Kim, Dongsun and Bissyand\'{e}, Tegawend\'{e} F.},
title = {Replication package of TBar},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3237378},
abstract = {
    <p>Template-based Automated Program Repair Tool</p>
},
keywords = {fix pattern, program repair}
}

@software{10.5281/zenodo.3239998,
author = {Lee, Sungho and Ryu, Sukyoung},
title = {Adlib: Static Analyzer to Detect Vunlerable Patterns in AdSDKs},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3239998},
abstract = {
    <p>Adlib is a static analyzer for AdSDKs. AdSDKs have powerful APIs, but the APIs may open to the malicious advertisements. Using predefined vulnerable patterns, Adlib constructs callgraphs and performs data flow analysis to find the vulnerable APIs that open to and can be abused by advertisements.</p>
},
keywords = {AdSDKs, Advertising Platform Vulnerabilities, Hybrid Applications, Malicious Advertisements}
}

@software{10.1145/3339065,
author = {Cai, Haipeng and Zhang, Ziyi and Li, Li and Fu, Xiaoqin},
title = {Artifact for Study of Application Incompatibilities in Android},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3339065},
abstract = {
    <p>This package includes the artifact associated with the article title "A Large-Scale Study of Application Incompatibilities in Android". The content of the package includes the source code and experimental datasets used in the study. A README document enclosed gives details on how to use the package for replicating the study results and reusing the code and data for future studies.</p>
},
keywords = {Android, compatibility, evolution, execution, installation}
}

@software{10.1145/3339071,
author = {Piskachev, Goran and Do, Lisa Nguyen Quang and Bodden, Eric},
title = {Replication Package for Artifact: Codebase-Adaptive Detection of Security-Relevant Methods},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3339071},
abstract = {
    <p>The artifact has a Virtual Machine containing (1) prepared Java program to execute the fully automatic SWAN approach on given test set, (2) 12 Java frameworks used in the paper for the evaluation, (3) generated methods from those frameworks, (4) manually annotated lists of methods used in the evaluation of the paper, (5) IntelliJ IDEA IDE with pre-installed SWAN-Assist plugin and example project, and (6) Java program for running the Suggester Algorithm proposed in the paper. All these component can be used to repeat the experiments from the paper. (1), (5) and (6) can be reused with other Java datasets. (3) and (4) can be used as datasets in other applications. Additionally, there is a manual for running the components of the artifact.</p>
},
keywords = {Java, machine learning, security, static code analysis}
}

@software{10.5281/zenodo.2678129,
author = {Yadavalli, S. Bharadwaj and Smith, Aaron},
title = {LLVM-MCTOLL},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2678129},
abstract = {
    <p>MCTOLL is an LLVM-based static analysis tools that raises x64 and Arm32 binaries to LLVM bitcode.</p>
},
keywords = {Binary Translation, LLVM, Static Analysis}
}

@software{10.5281/zenodo.2678161,
author = {Das, Sourav and Unnithan, R. Harikrishnan and Menon, Arjun and Rebeiro, Chester and Veezhinathan, Kamakoti},
title = {SHAKTI-MS Artifacts},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2678161},
abstract = {
    <p>Artifacts for SHAKTI-MS: A RISC-V Processor for Memory Safety in C</p>
},
keywords = {c, compiler, LLVM, memory corruption, security}
}

@software{10.5281/zenodo.2648959,
author = {Daruwalla, Kyle and Zhuo, Heng and Schulz, Carly and Lipasti, Mikko},
title = {BitBench Artifact Evaluation},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2648959},
abstract = {
    <p>A ZIP file containing the source files and scripts to verify the results of BitBench.</p>
},
keywords = {bitstream computing, high level synthesis, pulse density modulation, stochastic computing, verilog}
}

@software{10.5281/zenodo.2649613,
author = {Smolka, Steffen and Kumar, Praveen and Kahn, David M. and Foster, Nate and Hsu, Justin and Kozen, Dexter and Silva, Alexandra},
title = {McNetKAT: Scalable Verification of Probabilistic Networks},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2649613},
abstract = {
    <p>This is the artifact associated with the following paper: Steffen Smolka, Praveen Kumar, David M. Kahn, Nate Foster, Justin Hsu, Dexter Kozen, and Alexandra Silva. 2019. Scalable Verification of Probabilistic Networks. In PLDI  19. https://doi.org/10.1145/3314221.3314639. Please refer to artifact-page/index.html for instruction on how to install McNetKAT and reproduce the experiments from the paper.</p>
},
keywords = {McNetKAT, Network verification, Probabilistic Programming}
}

@software{10.1145/3325990,
author = {Gysi, Tobias and Grosser, Tobias and Brandner, Laurin and Hoefler, Torsten},
title = {Replication Package for Article: A Fast Analytical Model of Fully Associative Caches},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325990},
abstract = {
    <p>The artifact contains the sources, benchmarks, and scripts necessary to reproduce the results of the paper "A Fast Analytical Model of Fully Associative Caches".</p>
},
keywords = {cache model, performance tool, static analysis}
}

@software{10.1145/3325976,
author = {Dhulipala, Laxman and Blelloch, Guy E. and Shun, Julian},
title = {Artifact for "Low-Latency Graph Streaming using Compressed Purely-Functional Trees"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325976},
abstract = {
    <p>This repository provides experiments, scripts, and instructions for reproducing the experiments in our paper, *Low-Latency Graph Streaming Using Compressed Purely-Functional Trees*. Our paper introduces Aspen, a graph-streaming system based on compressed purely-functional trees. Aspen is designed for maintaining a dynamic graph subject to updates by a single writer, while supporting multiple concurrent readers. Due to the fact that the graph is purely-functional, all operations in Aspen are strictly serializable. In the Getting Started Guide, we include functionality to reproduce the main results presented in our paper. In the Step-By-Step Instructions, we also include the codes and instructions used for running experiments on very large graphs (hundreds of billions of edges). Due to the size of these graphs, and the memory footprint requirement on the machine, and the time to download, convert, and process these graphs, we expect that most users will not perform these steps, but we include them for completeness, and to ensure that our results for very large graphs are reproducible. We have made all graphs used in our paper publicly-available to ensure that our results are reproducible and can be built upon.</p>
},
keywords = {dynamic graph processing, graph streaming, parallel graph algorithms}
}

@software{10.1145/3325988,
author = {Abdulla, Parosh Aziz and Arora, Jatin and Atig, Mohamed Faouzi and Krishna, Shankaranarayanan},
title = {Replication Package for Article: Verification of Programs under Release Acquire Semantics},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325988},
abstract = {
    <p>The artifact consists of a virtual machine (VM) containing binaries of four model checking tools (VBMC, Cdschecker, Rcmc, and Tracer) along with several scripts in order to reproduce the experimental results in the paper titled  Verification of Concurrent Programs under the Release-Acquire Semantics .</p>
},
keywords = {Bounded Model Checking, Concurrent Program, Release Acquire Semantics, Undecidability, View Bounding}
}

@software{10.1145/3325989,
author = {Kuhlenschmidt, Andre and Almahallawi, Deyaaeldeen and Siek, Jeremy G.},
title = {Benchmarks Replication for Toward Efficient Gradual Typing for Structural Types via Coercions},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325989},
abstract = {
    <p>We setup the benchmarks that we performed for our paper in a virtual machine. This virtual machine provides documentation of our benchmarking setup and allows reviewers to spot check the results (expect some variation due to the overheads of virtualization). If more accurate results are required in the future, the benchmark suite is setup as a docker image to ease reproduction.</p>
},
keywords = {compilation, efficiency, gradual typing}
}

@software{10.5281/zenodo.2644665,
author = {Mohammadi, Mahdi Soltan and Yuki, Tomofumi and Cheshmi, Kazem and Davis, Eddie C. and Hall, Mary and Dehnavi, Maryam Mehri and Nandy, Payal and Olschanowsky, Catherine and Venkat, Anand and Strout, Michelle Mills},
title = {Replication Package for Article: "Sparse Computation Data Dependence Simplification for Efficient Compiler-Generated Inspectors"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2644665},
abstract = {
    <p>We use four packages to implement our approach: IEGenLib library, ISL library, CHiLL compiler framework, and Omega+ codegen included in the CHiLL. CHiLL is a source-to-source compiler framework for composing and applying high-level loop transformations to improve the performance of nested loops written in C. We use CHiLL to extract the dependence relations from the benchmarks. The CHiLL compiler also includes the Omega+ library, a modified version of Omega, which is an integer set manipulation library with limited support for constraints that involve uninterpreted function calls. We have used Omega+'s codegen capability to generate the DAG construction portion of the wavefront inspector code. ISL is a library for manipulating integer sets and relations that only contain affine constraints. It can act as a constraint solver by testing the emptiness of integer sets. It is also equipped with other operations on integer sets for detecting equalities and testing subset relationships. ISL does not support uninterpreted functions, and thus cannot directly represent the dependence constraints in sparse matrix code. IEGenLib is a set manipulation library that can manipulate integer sets/relations that contain uninterpreted function symbols. It uses ISL for some of its functionalities. We implemented the detection of unsatisfiable dependences and finding the equalities utilizing the IEGenLib and ISL libraries. The following briefly describes how our driver, illustrated in Figure 3 of the paper, generates wavefront parallelization inspectors. First, the driver extracts the dependences using CHiLL, and stores them in IEGenLib data structures. The driver also reads the JSON file with user-defined, domain-specific knowledge about index arrays, and stores them in IEGenLib environment variables. Then, it makes a call to an IEGenLib function to simplify the dependences. IEGenLib instantiates universally quantified assertions using the procedure described in Section 5 to prove unsatisfiability and to detect equalities. The uninterpreted functions are removed by replacing each call with a fresh variable, and functional consistency is encoded with additional constraints, before calling ISL to test for satisfiability and to expose equalities. Once the satisfiable, simplified, dependences are obtained, the driver tests each pair of the remaining dependences using IEGenLib for subsets and discards any dependence subsumed by another. Finally, the inspectors for the remaining dependences are generated by Omega+. Since, the outermost loop in the inspectors that we generate are embarrassingly parallel, the driver turns Omega+ generated code into a parallel inspector by simply adding an "omp parallel for" pragma before the outermost loop. The reason why the inspectors are obviously parallel is that each iteration of their outermost loop just connects dependence edges for the row (column) of the same iteration in the dependence graph structure. There are number of different source codes and data sources in this artifact: (1) IEGenLib library: used as a platform for some parts of the implementations. IEGenLib has its own licensing that can be referred to. (2) CHiLL compiler framework: used as a platform for some parts of the implementations. CHiLL has its own licensing that can be referred to. (3) ISL library that is included as part of IEGenLib. ISL has its own licensing that can be referred to. (4) Sparse computations benchmark suit (inside data directory) that have several different sources, and their sources are referenced in the paper. (5) Other codes and scripts, the drivers, built scripts, etc, are implemented by authors.</p>
},
keywords = {CHiLL, Codegen+, data dependence simplification, dependence analysis, IEGenLib, inspector-executor strategies, ISL, Omega+, Presburger arithmetic with uninterpreted functions, SMT solvers, sparse matrices}
}

@software{10.1145/3325980,
author = {Hallahan, William T. and Xue, Anton and Bland, Maxwell Troy and Jhala, Ranjit and Piskac, Ruzica},
title = {G2: Lazy Counterfactual Symbolic Execution},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325980},
abstract = {
    <p>An artifact, consisting of code and benchmarks, for Lazy Counterfactual Symbolic Execution, by William T. Hallahan, Anton Xue, Maxwell Troy Bland, Ranjit Jhala, and Ruzica Piskac.</p>
},
keywords = {counterexamples, counterfactual, Haskell, lazy, symbolic execution}
}

@software{10.1145/3325986,
author = {Prokopec, Aleksandar and Ros\`{a}, Andrea and Leopoldseder, David and Duboscq, Gilles and T?ma, Petr and Studener, Martin and Bulej, Lubom\'{\i}r and Zheng, Yudi and Villaz\'{o}n, Alex and Simon, Doug and W\"{u}rthinger, Thomas and Binder, Walter},
title = {Renaissance: Benchmarking Suite for Parallel Applications on the JVM},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325986},
abstract = {
    <p>Renaissance is a new benchmark suite composed of modern, real-world, concurrent, and object-oriented workloads that exercise various concurrency primitives of the JVM, with the goal of revealing optimization opportunities that were not visible with prior benchmark workloads. The artifact contains the Renaissance suite together with tools used to analyze the workloads and compare performance of two production level JIT compilers. The artifact also contains complete data sets of experiments described in the associated paper and scripts used to process those data sets for the figures and tables presented in the paper.</p>
},
keywords = {benchmarks, JIT compilation, parallelism}
}

@software{10.1145/3325987,
author = {Powers, Bobby and Tench, David and Berger, Emery D. and McGregor, Andrew},
title = {Replication Package For Article: Mesh: Compacting Memory Management for C/C++ Applications},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325987},
abstract = {
    <p>The provided Linux virtual machine (in VirtualBox OVA format) can be used to verify the claims made in the Mesh paper. The VM boots up into an Ubuntu desktop with an open terminal and instructions on running the artifact.</p>
},
keywords = {Memory management, runtime systems, unmanaged languages}
}

@software{10.1145/3325973,
author = {Sakka, Laith and Sundararajah, Kirshanthan and Newton, Ryan R. and Kulkarni, Milind},
title = {Grafter: Clang tool that perform sound, fine-grained traversal fusion for heterogeneous trees},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325973},
abstract = {
    <p>Grafter is clang tool that performs source to source transformation, namely traversals fusion. Grafter parse programs written in subset of C++, and write back the transformed code into the same files. The artifact includes the source code of Grafter in addition to the instructions on how to build it and use it. It also includes a pre-build version on a VM, with instructions on how to regenerate the experiments in the initial version of the paper.</p>
},
keywords = {Clang tool., Traversal Fusion}
}

@software{10.1145/3325974,
author = {Vollmer, Michael and Koparkar, Chaitanya and Rainey, Mike and Sakka, Laith and Kulkarni, Milind and Newton, Ryan R.},
title = {Artifact for "LoCal: A Language for Programs Operating on Serialized Data"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325974},
abstract = {
    <p>The artifact for our paper is the Gibbon compiler. It also includes the benchmarks presented in the paper, and some scripts to run them and plot appropriate graphs.</p>
},
keywords = {Compilers, Program Optimization, Tree Traversals}
}

@software{10.1145/3325985,
author = {Loring, Blake and Mitchell, Duncan and Kinder, Johannes},
title = {Artifact for PLDI 2019 paper: Sound Regular Expression Semantics for Dynamic Symbolic Execution of JavaScript},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325985},
abstract = {
    <p>The central contribution of this paper is a modification to the ExpoSE symbolic execution engine adding support for complex JavaScript regular expressions. The support for these regular expressions will often improve dynamic symbolic execution of JavaScript applications as they are widely used. A core part of this support is the introduction of a CEGAR loop on top of the SMT solver that automatically refines SMT problems to account for incorrect matching precedence. This artifact submission accompanies our PLDI 2019 paper. Our artifact is a virtual machine image with the paper software and experiments pre-installed.</p>
},
keywords = {Dynamic symbolic execution, JavaScript, regular expressions, SMT}
}

@software{10.5281/zenodo.2642857,
author = {van Tonder, Rijnard and Le Goues, Claire},
title = {Lightweight Multi-Language Syntax Transformation with Parser Parser Combinators: PLDI 2019 Artifact},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2642857},
abstract = {
    <p>The PLDI 2019 VM artifact is archived for the associated paper and it's emphasis is to produce results consistent with those in the paper. It includes a research-grade implementation, associated transformations, and repository data to reproduce the tables in the paper. For those interested in actively trying or using the out the tool, consider the newer, actively maintained variety of this software at https://github.com/comby-tools/comby.</p>
},
keywords = {parsers, refactoring, rewriting, syntax, transformation}
}

@software{10.1145/3325984,
author = {Nguy?n, Ph\'{u}c C. and Gilray, Thomas and Tobin-Hochstadt, Sam and Van Horn, David},
title = {Checkers used in: Size-Change Termination as a Contract},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325984},
abstract = {
    <p>The dynamic and static checkers for size-change termination, and the tests used in the paper.</p>
},
keywords = {dynamic analysis, static analysis, termination checker}
}

@software{10.1145/3325964,
author = {Kazerounian, Milod and Guria, Sankha Narayan and Vazou, Niki and Foster, Jeffrey S. and Van Horn, David},
title = {Replication package for paper: Type-Level Computations for Ruby Libraries},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325964},
abstract = {
    <p>We provide a virtual machine containing the necessary materials to recreate the data presented in the paper, including: CompRDL, library type annotations, and annotated benchmark apps.</p>
},
keywords = {database queries, dynamic languages, libraries, Ruby, type-level computations, types}
}

@software{10.1145/3325972,
author = {Krishnaswami, Neelakantan R. and Yallop, Jeremy},
title = {Replication package for paper: A typed, algebraic approach to parsing},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325972},
abstract = {
    <p>The artifact is a Docker image that makes it possible to explore the library described in the paper and re-run the performance experiments to reproduce the results.</p>
},
keywords = {context-free languages, functional programming, multi-stage programming, parser combinators, parsing, type theory}
}

@software{10.1145/3325979,
author = {Kokologiannakis, Michalis and Raad, Azalea and Vafeiadis, Viktor},
title = {Replication package for Article: "Model Checking for Weakly Consistent Libraries"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325979},
abstract = {
    <p>We consider our paper's artifact to be the set of benchmarks we used in the paper, as well as the results we got by running particular versions of model checking tools (Nidhugg, Tracer, RCMC, and GenMC) on the benchmarks set. We do not consider the artifact of the paper to be GenMC, as it will evolve over time. We have made GenMC publicly available on GitHub (https://github.com/MPI-SWS/genmc), to further facilitate access to the tool. The artifact consists of a Virtual Machine (VM) containing binaries for Nidhugg, Tracer, RCMC, and GenMC, along with all the benchmarks used in the submitted version of our paper.</p>
},
keywords = {Model checking, weak memory models}
}

@software{10.1145/3325982,
author = {Mercadier, Darius and Dagand, Pierre-\'{E}variste},
title = {Replication Package for Article: Usuba: high-throughput \&amp; constant-time ciphers, by construction},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325982},
abstract = {
    <p>This artifact builds a docker image, which, once built, will contain the necessary software to reproduce the results of the paper "Usuba: high-throughput &amp; constant-time ciphers, by construction". The docker image contains Usubac, the compiler for Usuba, and its sources, the Usuba sources of the ciphers presented if our paper, as well as the benchmarks evaluating our work.</p>
},
keywords = {Bitslicing, Block and stream ciphers, Dataflow languages, Domain specific languages, Optimizing Compiler, Vectorization}
}

@software{10.1145/3325983,
author = {Zhu, He and Xiong, Zikang and Magill, Stephen and Jagannathan, Suresh},
title = {Replication Package for Article: An Inductive Synthesis Framework for Verifiable Reinforcement Learning},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325983},
abstract = {
    <p>A toolset for verify safety properties of reinforcement learning system.</p>
},
keywords = {Invariant Inference, Program Synthesis, Program Verification, Reinforcement Learning, Runtime Shielding}
}

@software{10.5281/zenodo.2646525,
author = {Rowe, Reuben N. S. and F\'{e}r\'{e}e, Hugo and Thompson, Simon J. and Owens, Scott},
title = {ROTOR: A Reliable OCaml Tool for OCaml Refactoring - Trustworthy Refactoring for OCaml},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2646525},
abstract = {
    <p>ROTOR is a refactoring tool for the OCaml language that is written in OCaml.</p>
},
keywords = {OCaml, Refactoring}
}

@software{10.5281/zenodo.2646617,
author = {Dasgupta, Sandeep and Park, Daejun and Kasampalis, Theodoros and Adve, Vikram S. and Ro\c{s}u, Grigore},
title = {Replication package for the article "A Complete Formal Semantics of x86-64 User-Level Instruction Set Architecture"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2646617},
abstract = {
    <p>We present the most complete and thoroughly tested formal semantics of x86-64 to date. Our semantics faithfully formalizes all the non-deprecated, sequential user-level instructions of the x86-64 Haswell instruction set architecture. This totals 3155 instruction variants, corresponding to 774 mnemonics. The semantics is fully executable and has been tested against more than 7,000 instruction-level test cases and the GCC torture test suite. This extensive testing paid off, revealing bugs in both the x86-64 reference manual and other existing semantics. We also illustrate potential applications of our semantics in different formal analyses, and discuss how it can be useful for processor verification</p>
},
keywords = {Formal Semantics, ISA specification, x86-64}
}

@software{10.5281/zenodo.2646720,
author = {Churchill, Berkeley and Padon, Oded and Sharma, Rahul and Aiken, Alex},
title = {Semantic Alignment Equivalence Checker},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2646720},
abstract = {
    <p>An equivalence checker for x86-64 using semantic program alignment, as presented in the 2019 PLDI paper "Semantic Program Alignment for Equivalence Checking".</p>
},
keywords = {equivalence checking, formal verification, x86-64}
}

@software{10.1145/3325968,
author = {Scalas, Alceste and Yoshida, Nobuko and Benussi, Elias},
title = {Effpi: a toolkit for verified message-passing programs in Dotty},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325968},
abstract = {
    <p>This artifact contains the source code of Effpi: a toolkit for strongly-typed concurrent programming in Dotty (a.k.a. the future Scala 3 programming language), with model-checking-based verification capabilities. The toolkit is described in sections 1 and 5 of the companion paper: Alceste Scalas, Nobuko Yoshida, and Elias Benussi. Verified Message-Passing Programs with Dependent Behavioural Types. PLDI 2019. https://doi.org/10.1145/3314221.3322484 This artifact contains instruction for reproducing the benchmarks in the companion paper: see README.txt It also contains a ready-to-use virtual machine (based on a minimal Ubuntu installation) with Effpi's software dependencies. For the latest version of Effpi, visit: https://alcestes.github.io/effpi</p>
},
keywords = {actors, behavioural types, dependent types, Dotty, model checking, processes, Scala, temporal logic}
}

@software{10.1145/3325971,
author = {Heo, Kihong and Raghothaman, Mukund and Si, Xujie and Naik, Mayur},
title = {Replication Package for Article: Continuously Reasoning about Programs using Differential Bayesian Inference},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325971},
abstract = {
    <p>This directory contains the artifact of the paper "Continuously Reasoning about Programs using Differential Bayesian Inference" published in PLDI 2019.</p>
},
keywords = {alarm prioritization, alarm relevance, continuous integration, software evolution, Static analysis}
}

@software{10.1145/3325977,
author = {Knoth, Tristan and Wang, Di and Polikarpova, Nadia and Hoffmann, Jan},
title = {Replication package for: Resource-Guided Program Synthesis},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325977},
abstract = {
    <p>Included is the source for resyn, a program synthesizer that generates functional programs from refinement-type signatures. Resyn also takes an upper bound on the codes' resource usage; using a novel resource type system to guide the search process.</p>
},
keywords = {Automatic amortized resource analysis, Program synthesis, refinement types.}
}

@software{10.1145/3325978,
author = {Lahav, Ori and Margalit, Roy},
title = {Rocker: Robustness Checker},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325978},
abstract = {
    <p>A program to transform TPL programs with C/C++11 release/acquire semantics to promela. The promela program can then be verified using Spin model checker.</p>
},
keywords = {C/C++11, D, release/acquire, robustness, weak memory models}
}

@software{10.1145/3325981,
author = {Le, Ton Chanh and Zheng, Guolong and Nguyen, ThanhVu},
title = {Replication Package for Article: SLING: Using Dynamic Analysis to Infer Program Invariants in Separation Logic},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325981},
abstract = {
    <p>SLING is a tool for dynamically inferring separation logic specifications. Current version of SLING works with C or C++. It uses LLDB to obtain traces and Python to infer separation logic invariants based on the traces.</p>
},
keywords = {dynamic invariant generation, program analysis, separation logic}
}

@software{10.5281/zenodo.2645128,
author = {Liu, Lun and Millstein, Todd and Musuvathi, Madanlal},
title = {schotspot-aarch64: First Release for Artifact Registration for PLDI 2019},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2645128},
abstract = {
    <p>This is the first release of the artifact of the PLDI 2019 paper "Accelerating Sequential Consistency for Java with Speculative Compilation". For the latest updates please check out the GitHub repo: https://github.com/Lun-Liu/schotspot-aarch64</p>
},
keywords = {Java virtual machine, memory consistency, sequential consistency, speculative compilation, volatile by default}
}

@software{10.1145/3325966,
author = {Khan, Tanvir Ahmed and Zhao, Yifan and Pokam, Gilles and Mozafari, Barzan and Kasikci, Baris},
title = {Software Artifact for Huron: Hybrid False Sharing Detection and Repair},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325966},
abstract = {
    <p>The artifact consists of a VirtualBox virtual machine disk (VMDK file) containing the Huron software and source code, evaluation data, instructions, and all open source evaluation applications and input files.</p>
},
keywords = {False sharing, Performance optimization}
}

@software{10.1145/3325967,
author = {Kapus, Timotej and Ish-Shalom, Oren and Itzhaky, Shachar and Rinetzky, Noam and Cadar, Cristian},
title = {Replication Package for Cumputing Summaries of String Loops},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325967},
abstract = {
    <p>The artefact contains a docker image that has the implementation of loop summarisation described in the paper set up. See the README file for more details.</p>
},
keywords = {Loop Summarisation, Optimisation, Refactoring, Strings, Symbolic Execution, Synthesis}
}

@software{10.1145/3325970,
author = {Cauligi, Sunjay and Soeller, Gary and Johannesmeyer, Brian and Brown, Fraser and Wahby, Riad S. and Renner, John and Gr\'{e}goire, Benjamin and Barthe, Gilles and Jhala, Ranjit and Stefan, Deian},
title = {Evaluation Artifact for FaCT: A DSL for Timing-Sensitive Computation},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325970},
abstract = {
    <p>We provide a virtual machine image that contains our compiler and our case studies. The image comes with instructions for building the compiler, building the case studies, and running the evaluation.</p>
},
keywords = {cryptography, domain-specific language, program transformation}
}

@software{10.1145/3325965,
author = {Yoga, Adarsh and Nagarakatte, Santosh},
title = {TaskProf2: A Parallelism Profiler and an Adviser for Task Parallel Programs.},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3325965},
abstract = {
    <p>TaskProf2 is a parallelism profiler and an adviser for task parallel programs that use the Intel Threading Building Blocks (TBB). As a parallelism profiler, it identifies regions with serialization bottlenecks, tasking overheads, and the secondary effects of execution. As an adviser, it automatically identifies a set of code regions that matter in improving parallelism with its what-if analyses.</p>
},
keywords = {differential analysis, parallelism, profiler, what-if analyses}
}

@software{10.5281/zenodo.2640455,
author = {Wang, Peixin and Fu, Hongfei and Goharshady, Amir Kafshdar and Chatterjee, Krishnendu and Qin, Xudong and Shi, Wenjun},
title = {Replication Package for Article: Cost Analysis of Nondeterministic Probabilistic Programs},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2640455},
abstract = {
    <p>The artifact contains an implementation of our approach in Matlab. Please see the readme file.</p>
},
keywords = {Probabilistic Programs, Program Cost Analysis}
}

@software{10.5281/zenodo.2640864,
author = {Gershuni, Elazar and Amit, Nadav and Gurfinkel, Arie and Narodytska, Nina and Navas, Jorge A. and Rinetzky, Noam and Ryzhyk, Leonid and Sagiv, Mooly},
title = {Tool implementation for paper: "Simple and Precise Static Analysis of Untrusted Linux Kernel Extensions"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2640864},
abstract = {
    <p>C++ implementation of the analyzer described in the paper.</p>
},
keywords = {ebpf, kernel extensions, linux, static analysis}
}

@software{10.5281/zenodo.2641028,
author = {Chajed, Tej and Tassarotti, Joseph and Kaashoek, M. Frans and Zeldovich, Nickolai},
title = {Argosy: Verifying Layered Storage Systems with Recovery Refinement (Artifact)},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2641028},
abstract = {
    <p>Artifact for the PLDI 2019 paper "Argosy: Verifying layered storage systems with recovery refinement". Includes the Coq sources for the Argosy framework and the examples we verified using Argosy.</p>
},
keywords = {Coq, Kleene Algebra, Refinement}
}

@software{10.5281/zenodo.2229779,
author = {Lim, Jay P. and Nagarakatte, Santosh},
title = {CASM_Verify},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2229779},
abstract = {
    <p>This is the artifact of the tool, CASM_Verify, for the paper, “Automatic Equivalence Checking for Assembly Implementations of Cryptography Libraries,” which will appear in CGO 2019.</p>
<p>CASM_Verify is a tool that automatically checks whether the equivalence of highly optimized assembly implementation of cryptographic implementations are equivalent to the reference implementation.</p>
<p>The artifact contains the source code of CASM_Verify, the benchmarks used for the evaluation, and the Dockerfile that can automatically create a Docker image containing all the required software and CASM_Verify.</p>
<p>To use CASM_Verify without Docker, install Python3 and z3.</p>

},
keywords = {CGO 2019}
}

@software{10.5281/zenodo.1494266,
author = {v. Gleissenthall, Klaus and K\i{}c\i{}, Rami G\"{o}khan and Bakst, Alexander and Stefan, Deian and Jhala, Ranjit},
title = {Replication Package for Article: "Pretend Synchrony: Synchronous Verification of Asynchronous Distributed Programs"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1494266},
abstract = {
    <p>The artifact contains a VirtualBox VM that can be used to replicate the results mentioned in "Pretend Synchrony: Synchronous Verification of Asynchronous Distributed Programs". It includes the source code that implements our verification framework called Goolong, and the benchmarks we have used to evaluate our approach. For instructions, please visit https://goto.ucsd.edu/~rkici/popl19_artifact_evaluation/</p>
},
keywords = {Distributed Systems, Pretend Synchrony, Reduction, Symmetry, Verification}
}

@software{10.1145/3291645,
author = {Singh, Gagandeep and Gehr, Timon and P\"{u}schel, Markus and Vechev, Martin},
title = {Replication Package for the article: An Abstract Domain for Certifying Neural Networks},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3291645},
abstract = {
    <p>The artifact is in the form of a virtual machine running Ubuntu 18.04. We provide the source code for DeepPoly transformers (as part of the ETH LIbrary for Numerical Analysis (ELINA)), the ETH Robustness Analyzer for Neural Networks (ERAN) which uses the DeepPoly transformers described in our POPL paper for verifying the robustness of neural networks against L -norm based adversarial attacks, and our abstract interpreter for certifying robustness against rotation perturbations.</p>
},
keywords = {Abstract Interpretation, Adversarial attacks, Deep Learning}
}

@software{10.1145/3291640,
author = {Toman, John and Grossman, Dan},
title = {Artifact for Concerto: A Framework for Combined Concrete and Abstract Interpretation},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3291640},
abstract = {
    <p>This archive contains a self-contained virtual machine image with the necessary scripts and binaries to reproduce the experiments in our POPL 19 paper.</p>
},
keywords = {abstract interpretation, framework-based applications, metaprogramming, reflection, state separation}
}

@software{10.1145/3291650,
author = {Crary, Karl},
title = {Fully Abstract Module Compilation, formal proofs},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3291650},
abstract = {
    <p>Machine-checkable Coq proofs of the theorems in Fully Abstract Module Compilation, by Karl Crary.</p>

},
keywords = {full abstraction, Modules, phase separation}
}

@software{10.1145/3291634,
author = {Bae, Kyungmin and Lee, Jia},
title = {stlMC: Bounded Model Checking of Signal Temporal Logic},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3291634},
abstract = {
    <p>The stlMC is a prototype Python implementation of our bounded model checking algorithm for signal temporal logic (STL) that is refutationally complete for STL properties of bounded signals. You can see the instructions of installation and usage through readme.pdf in the artifact.</p>
},
keywords = {Bounded model checking, Satisfiability modulo theories (SMT), Signal temporal logic, Syntactic separation}
}

@software{10.1145/3291627,
author = {Wang, Di and Hoffmann, Jan},
title = {Resource Aware ML},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3291627},
abstract = {
    <p>This artifact provides an implementation of a novel resource-parametric type-guided worst-case input generation algorithm for a purely functional fragment of Resource Aware ML (RaML), a tool that automatically and statically computes resource-use bounds for OCaml programs.</p>
},
keywords = {amortized analysis, Resource bound analysis, symbolic execution, type systems, worst-case analysis}
}

@software{10.1145/3291623,
author = {Saad, Feras A. and Cusumano-Towner, Marco F. and Schaechtle, Ulrich and Rinard, Martin C. and Mansinghka, Vikash K.},
title = {Synthesis Systems and Experiments for: Bayesian Synthesis of Probabilistic Programs for Automatic Data Modeling},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3291623},
abstract = {
    <p>This artifact contains a Dockerfile that installs the two synthesis systems described in the text inside a virtual environment. The virtual environment contains the pipeline scripts used to run the experiments in the paper, as well as instructions for how to automatically build two of the many experiments.</p>
},
keywords = {probabilistic program synthesis}
}

@software{10.1145/3291631,
author = {Gorogiannis, Nikos and O'Hearn, Peter W. and Sergey, Ilya},
title = {Software and evaluation targets for paper "A True Positives Theorem for a Static Race Detector" (table (b), p24)},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3291631},
abstract = {
    <p>This archive contains: - a checkout of the Infer github repository at https://github.com/facebook/infer; - the RacerDX implementation (in the form of a patch to the main version); - the sources for the evaluation targets; - the scripts used to run the tests, runtests.sh and dostats.sh; - the analysis results appearing in the paper.</p>
},
keywords = {compositional analysis, data races, static analysis}
}

@software{10.1145/3291621,
author = {Kaposi, Ambrus and Kov\'{a}cs, Andr\'{a}s and Altenkirch, Thorsten},
title = {Agda formalizations for article "Constructing Quotient Inductive-Inductive Types"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3291621},
abstract = {
    <p>Agda sources for the article "Constructing Quotient Inductive-Inductive Types"</p>
},
keywords = {quotient inductive-inductive type, type theory}
}

@software{10.5281/zenodo.1412854,
author = {Mayer, Mika\"{e}l and Kuncak, Viktor and Chugh, Ravi},
title = {Implentation for: Bidirectional Evaluation with Direct Manipulation},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1412854},
abstract = {
    <p>This release matches the code submitted for the OOPSLA 2018 artifact evaluation of the paper "Bidirectional Evaluation with Direct Manipulation" by Ravi Chugh and Mika l Mayer. The license has been updated with respect to the University of Chicago filing a patent on this technology.</p>
},
keywords = {Bidirectional Programming, Direct Manipulation, Sketch-n-Sketch}
}

@software{10.5281/zenodo.1458158,
author = {Ries, Beno\^{\i}t and Capozucca, Alfredo and Guelfi, Nicolas},
title = {Excalibur},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1458158},
abstract = {
    <p>Excalibur is an open-source UML Requirements Engineering tool, developed as a plugin to Eclipse. Excalibur provides an Excalibur Outline, developed as an Eclipse view, which allows to explore the 3 Excalibur project types (specification, report, and simulation). Excalibur, which defines the Messir requirements specification DSL, is able to generate UML-like diagram view (use-case diagrams, class diagrams, sequence diagrams); The third-party technologies used and required for the end-users to be known are : Eclipse, UML, OCL, LaTeX and prolog (for the simulation only).</p>
},
keywords = {Eclipse, Latex, Model-Driven Engineering, Prolog Simulation, Report Generation, Requirements Engineering, UML}
}

@software{10.1145/3284653,
author = {Tikhonova, Ulyana and Stoel, Jouke and van der Storm, Tijs and Degueule, Thomas},
title = {Software and examples supporting the paper: "Constraint-based Run-time State Migration for Live Modeling"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3284653},
abstract = {
    <p>The artifact contains the implementation of Nextep, our prototype tool for constraint-based run-time state migration, along with the examples and benchmarks discussed in the paper.</p>
},
keywords = {live modeling, nextep, relational model finding, run-time state migration}
}

@software{10.5281/zenodo.1460552,
author = {R\'{e}gis-Gianas, Yann and Jeannerod, Nicolas and Treinen, Ralf},
title = {Morbig: a Static Parser for POSIX Shell},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1460552},
abstract = {
    <p>Morbig is a parser for shell scripts written in the POSIX shell script language. It parses the scripts statically, that is without executing them, and constructs a concrete syntax tree for each of them. The concrete syntax trees are built using constructors according to the shell grammar of the POSIX standard.</p>
},
keywords = {functional programming, menhir, ocaml, parser, posix shell, scripts}
}

@software{10.1145/3284654,
author = {Racordon, Dimitri and Buchs, Didier},
title = {SafeScript Compiler},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3284654},
abstract = {
    <p>SafeScript is a dialect of JavaScript, whose specificity is to add a type system on the top of JavaScript to make aliasing safer.</p>
},
keywords = {aliasing, compiler, immutability, memory safety, type capabilities, type checker}
}

@software{10.1145/3284655,
author = {Str\"{o}mb\"{a}ck, Filip},
title = {Storm},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3284655},
abstract = {
    <p>Release 0.2.26 of Storm with source code and examples from the paper Storm: A Language Platform for Interacting and Extensible Languages (Tool Demo).</p>
},
keywords = {domain specific language, DSL, extensible language}
}

@software{10.1145/3284656,
author = {Mey, Johannes and Sch\"{o}ne, Ren\'{e} and Hedin, G\"{o}rel and S\"{o}derberg, Emma and K\"{u}hn, Thomas and Fors, Niklas and \"{O}qvist, Jesper and Aβmann, Uwe},
title = {Replication Package for Article: Continuous Model Validation using Reference Attribute Grammars},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3284656},
abstract = {
    <p>The paper discusses the utilization of reference attribute grammars (RAGs) for model validation and presents two specific contributions. First, the differences between models and trees specified by reference attribute grammars, specifically non-containment references, are discussed and a manual, yet optimised method to efficiently overcome these differences is presented. Secondly, an extension of RAG grammar specifications is proposed to model non-containment references automatically. The proposed modelling techniques are compared to state-of-the-art modelling tools utilizing a benchmarking framework for continuous model validation, the *Train Benchmark*. Structure of the Supplementary Artifacts ======================================== The artifacts are structured in three parts: - A standalone example of the non-containment references preprocessor - Benchmark code to reproduce the measurements, including all relevant source codes - Full collection of all measurement data and diagrams mentioned in the paper</p>
},
keywords = {bidirectional relations, incremental model evaluation, References Attribute Grammars}
}

@software{10.1145/3284657,
author = {van Binsbergen, L. Thomas and Scott, Elizabeth and Johnstone, Adrian},
title = {Replication package of Article: GLL Parsing with Flexible Combinators},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3284657},
abstract = {
    <p>This artifact contains the Haskell package `gll` of which aspects have been described and evaluated in the paper "GLL Parsing with Flexible Combinators". The artifact also contains the paper's literal Haskell code which can be tested by running a number of unit-tests. The purpose of the artifact is to enable reproducing the evaluation data of the paper and to confirm the correctness of the implemented algorithms.</p>
},
keywords = {generalised parsing, GLL parsing, grammar combinators, Haskell, interpretation, parser combinators, semantic functions}
}

@software{10.1145/3284658,
author = {Leduc, Manuel and Degueule, Thomas and Combemale, Benoit},
title = {Artifact for the paper: Modular Language Composition for the Masses},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3284658},
abstract = {
    <p>The Revisitor pattern is a language implementation pattern that enables independent extensibility of the syntax and semantics of metamodel-based DSLs, with incremental compilation and without anticipation. It is inspired by the Object Algebra design pattern and adapted to the specificities of metamodeling. On top of the Revisitor pattern, we introduce Alex, a high-level language for semantics specification of metamodels that compiles to Revisitors to support separate compilation of language modules. Alex is tightly integrated with the Eclipse Modeling Framework (EMF) and relies on the Ecore meta-language for the definition of the abstract syntax of DSLs. Operational semantics is defined with Alex using an open-class-like mechanism. Alex is bundled a set of Eclipse plug-ins. In the current artifact, we evaluate Alex in the development of a new DSL for IoT systems modeling resulting from the composition of three independently defined languages (UML activity diagrams, Lua, and the CORBA Interface Description Language).</p>
},
keywords = {language composition, language concern, language interface, modular language development}
}

@software{10.1145/3284659,
author = {Amorim, Lu\'{\i}s Eduardo de Souza and Steindorfer, Michael J. and Erdweg, Sebastian and Visser, Eelco},
title = {Experiment for Declarative Specification of Indentation Rules: A Tooling Perspective on Parsing and Pretty-Printing Layout-Sensitive Languages},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3284659},
abstract = {
    <p>The artifact consists of an experiment to evaluate the performance of a layout-sensitive parser and the correctness of a layout-sensitive pretty-printer generated from a language specification containing layout declarations.</p>
},
keywords = {layout-sensitivity, parsing, pretty-printing}
}

@software{10.1145/3276938,
author = {Cohen, Nachshon and Aksun, David T. and Larus, James R.},
title = {Replication Package For Object-Oriented Recovery for Non-volatile Memory},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276938},
abstract = {
    <p>The attached artifact provides an image of the virtual machine of the NvmReconstruction system as proposed in the OOPSLA submission for the purpose of reproducibility and examination. The artifact contains all sources and shell scripts in the VM to reproduce all results presented in the paper. For convenience all the scripts are provided for reproducibility in the VM at /home/nvm/NvmReconstruction folder.</p>
},
keywords = {C++, non-volatile memory, NVM, object-oriented programming, programming model}
}

@software{10.1145/3276924,
author = {Ezudheen, P. and Neider, Daniel and D'Souza, Deepak and Garg, Pranav and Madhusudan, P.},
title = {Horn-ICE Verification Toolkit},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276924},
abstract = {
    <p>This artifact contains the Horn-ICE verification toolkit for automatically synthesizing loop invariants and function contracts using data driven machine learning techniques, including the benchmarks described in the paper and instructions how to reproduce the experimental results. To allow for an easy access to the toolkit, the artifact features a bootable virtual machine image horn_ice.ova (Ubuntu 16.04) with all dependencies already installed.</p>
},
keywords = {Constrained Horn Clauses, Decision Trees, ICE Learning, Software Verification}
}

@software{10.1145/3276915,
author = {van Antwerpen, Hendrik and Bach Poulsen, Casper and Rouvoet, Arjen and Visser, Eelco},
title = {Case Studies for Article: Scopes as Types},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276915},
abstract = {
    <p>This artifact contains the following: 1) An implementation of the Statix language as part of the Spoofax language workbench. 2) A test suite of unit tests for the Statix language. 3) Spoofax language definitions for the Simply Typed Lambda Calculus with Records, System F, and Featherweight Generic Java. Each implementation includes a static semantics definition in Statix, some example programs, and a test suite to test the static semantics. The implementations provide source code editors with syntax highlighting and type checking.</p>
},
keywords = {case studies, domain-specific language, language definitions, name resolution, scope graphs, static semantics, type checker, type systems}
}

@software{10.1145/3276927,
author = {Williams, Jack and Morris, J. Garrett and Wadler, Philip},
title = {TypeScript implementation for paper: The Root Cause of Blame: Contracts for Intersection and Union Types},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276927},
abstract = {
    <p>This artifact consists of a TypeScript contract library that faithfully implements the blame semantics set out in the paper. The library uses JavaScript proxies to implement contracts and is intended for practical use.</p>
},
keywords = {blame, contracts, intersection, javascript, proxies, typescript, union}
}

@software{10.1145/3276933,
author = {Kalhauge, Christian Gram and Palsberg, Jens},
title = {Evaluation Artifact: Sound Deadlock Prediction},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276933},
abstract = {
    <p>This artifact contains the code used in the article. It also contains instructions to replicate some of the tables in the evaluation and the raw data to create those tables. The purpose of this artifact is to help future researchers recreate and build upon the results of the paper.</p>
},
keywords = {Deadlocks, Prediction}
}

@software{10.1145/3276936,
author = {Padhi, Saswat and Jain, Prateek and Perelman, Daniel and Polozov, Oleksandr and Gulwani, Sumit and Millstein, Todd},
title = {Replication Package for Article: "FlashProfile: A Framework for Synthesizing Data Profiles"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276936},
abstract = {
    <p>FlashProfileDemo: A C# application that demonstrates the capabilities of FlashProfile, which has been released as Matching.Text within the PROSE library from Microsoft.</p>
},
keywords = {data profiling, hierarchical clustering, outlier detection, pattern learning, pattern profiles, program synthesis}
}

@software{10.1145/3276943,
author = {Boston, Brett and Gong, Zoe and Carbin, Michael},
title = {Software Implementation for Leto: Verifying Application-Specific Hardware Fault Tolerance with Programmable Execution Models},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276943},
abstract = {
    <p>This artifact contains the C++ implementation of the Leto algorithm as we have described it in the Leto paper. It also contains the benchmarks required to reproduce our results, as well as instructions for running these benchmarks.</p>
},
keywords = {automatic verification, fault tolerance, leto, verification}
}

@software{10.5281/zenodo.1294300,
author = {Davis, James C. and Coghlan, Christy A. and Servant, Francisco and Lee, Dongyoon},
title = {Artifact (software + dataset) for "The Impact of Regular Expression Denial of Service (ReDoS) in Practice: an Empirical Study at the Ecosystem Scale"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1294300},
abstract = {
    <p># Ecosystem-scale regexp study Welcome to the FSE'18 artifact for the ESEC/FSE paper *"The Impact of Regular Expression Denial of Service (ReDoS) in Practice: an Empirical Study at the Ecosystem Scale"*, by J.C. Davis, C.A Coghlan, F. Servant, and D. Lee, all of Virginia Tech. This paper describes a study in which we: - extracted regular expressions (regexes, regexps) from npm and pypi modules - analyzed the regexes along several dimensions Our artifact consists of: - Code to analyze a regex for super-linear performance (Table 1), degree of vulnerability (Table 2), semantic meaning (Table 3), and use of anti-patterns (Table 4). - Unique regexes collected from npm and pypi modules. We are releasing these regexes raw (without analysis or source module(s)) due to security concerns. In addition, we wrote code to statically extract regexes from npm and pypi modules. We released this code as part of our `vuln-regex-detector` software, available [here](https://github.com/davisjam/vuln-regex-detector). Regex extraction was uninteresting from a scientific perspective so we do not elaborate on it in this artifact. In addition to this directory's `README.md`, each sub-tree comes with one or more READMEs describing the software and tests. ## Installation ### By hand To install, execute the script `./configure` on an Ubuntu 16.04 machine with root privileges. This will obtain and install the various dependencies (OS packages, REDOS detectors, npm modules, and pypi modules). It will also initialize submodules. The final line of this script is `echo "Configuration complete. I hope everything works!"`. If you see this printed to the console, great! Otherwise...alas. ### Container To facilitate replication, we have published a [containerized version](https://hub.docker.com/r/jamiedavis/daviscoghlanservantlee-fse18-regexartifact/) of this project on hub.docker.com. The container is based on an Ubuntu 16.04 image so it is fairly large. For example, you might run: ``` docker pull jamiedavis/daviscoghlanservantlee-fse18-regexartifact docker run -ti jamiedavis/daviscoghlanservantlee-fse18-regexartifact &gt; vim .env # Set ECOSYSTEM_REGEXP_PROJECT_ROOT=/davis-fse18-artifact/EcosystemREDOS-FSE18 &gt; . .env &gt; ./full-analysis/analyze-regexp.pl ./full-analysis/test/vuln-email.json ```</p>
},
keywords = {ReDoS, regexes, Regular expressions}
}

@software{10.5281/zenodo.1434471,
author = {Zhang, Yunming and Yang, Mengjiao and Baghdadi, Riyadh and Kamil, Shoaib and Shun, Julian and Amarasinghe, Saman},
title = {GraphIt-DSL/graphit: Initial release to make the artifact available for OOPSLA18},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1434471},
abstract = {
    <p>Initial release to make the artifact available for OOPSLA18.</p>
},
keywords = {Compiler Optimization, Domain Specific Language, Graph Algorithms}
}

@software{10.1145/3276916,
author = {Li, Peixuan and Zhang, Danfeng},
title = {Replication Package: A Derivation Framework for Dependent Security Label Inference},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276916},
abstract = {
    <p>This package provides implementation of derivation solvers for dependent type inference. It consists of four constraint solvers, i.e., one-shot, early-accept, early-reject and hybrid solver along with two partition algorithms: sequential and combinational partitioning. A parser for the core constraint language and plotting scripts are also available in the package.</p>
},
keywords = {Dependent Types, Information Flow Analysis, Security Label Inference}
}

@software{10.1145/3276930,
author = {Szab\'{o}, Tam\'{a}s and Bergmann, G\'{a}bor and Erdweg, Sebastian and Voelter, Markus},
title = {IncA environment set up on an Ubuntu virtual machine},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276930},
abstract = {
    <p>The downloaded artifact is a VirtualBox image. It is based on an Ubuntu 18.04 OS. We already pre-installed Oracle JDK 1.8 and the Meta Programming System (MPS) version 2017.3.5 on it. Additionally, we cloned the source code of IncA, and performed the automated gradle build. We also cloned the repository containing the benchmark code bases. You only need to install VirtualBox on your machine, which is free software, and then you can immediately try out IncA or execute the benchmarks.</p>
},
keywords = {Datalog, Domain-Specific Language, Incremental Computing, Language Workbench, Lattice, Static Analysis}
}

@software{10.1145/3276932,
author = {Li, Yue and Tan, Tian and M\o{}ller, Anders and Smaragdakis, Yannis},
title = {Artifact of Article: Precision-Guided Context Sensitivity for Pointer Analysis},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276932},
abstract = {
    <p>This artifact is provided to enable the results of all three research questions (RQ1   RQ3) in Section 4 of our companion paper (including the results in Appendix) to be reproduced. To ease the users to examine all the experimental results or any results they are particularly interested in, we specially design and provide different commands to make such examinations convenient. The artifact also contains comprehensive guidance. To use the artifact, please refer to  readme.pdf  and  getting-started.pdf  in the artifact package. The artifact contains our implementation of Zipper (our tool), Doop framework (a state-of-the-art pointer analysis framework for Java), as well as the Java programs and the library to be analyzed in the evaluation. It also provides some expected output samples of this artifact for the user to examine without running the artifact.</p>
},
keywords = {Java, points-to analysis, static analysis}
}

@software{10.1145/3276941,
author = {Selakovic, Marija and Pradel, Michael and Karim, Rezwana and Tip, Frank},
title = {Replication Package for Article: Test Generation for Higher-Order Functions in Dynamic Languages},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276941},
abstract = {
    <p>LambdaTester is a test generator for higher-order functions written in JavaScript. The artifact contains test generator, the differential testing tool to find differences between polyfill and native implementations and the tool to compute code coverage.</p>
},
keywords = {Higher-order functions, JavaScript, polyfill, promise}
}

@software{10.1145/3276988,
author = {Li, Yue and Tan, Tian and M\o{}ller, Anders and Smaragdakis, Yannis},
title = {Artifact of Article: Scalability-First Pointer Analysis with Self-Tuning Context-Sensitivity},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276988},
abstract = {
    <p>This artifact is provided to enable the results of all four research questions (RQ1 -- RQ4) in our companion paper, i.e., the results in Table 1, Table 2, Figure 7 and Figure 8, to be reproduced. The artifact contains Scaler (our tool), Doop (a state-of-the-art pointer analysis framework for Java), as well as the Java programs and the library to be analyzed in the evaluation, to reproduce the results. To ease the users to examine all the experimental results or any results they are particularly interested in, we specially design and provide different commands to make such examinations convenient. The artifact also contains comprehensive guidance. To use the artifact, please refer to  README.pdf  and  INSTALL.pdf  in the artifact package.</p>
},
keywords = {Java, points-to analysis, static analysis}
}

@software{10.5281/zenodo.1420217,
author = {Aydin, Abdulbaki and Eiers, William and Bang, Lucas and Brennan, Tegan and Gavrilov, Miroslav and Bultan, Tevfik and Yu, Fang},
title = {Tool for article: Parameterized Model Counting for String and Numeric Constraints},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1420217},
abstract = {
    <p>The Multi-Track Automata Based Counter (MT-ABC) is a string and numeric constriant solver and model counter. ABC provides solutions to systems of string and numeric constraints in the form of a multi-tracked deterministic finite automaton. In addition ABC produces symbolic representation of the number of strings and integers within a length bound, k, that satisfy a set of constraints. ABC can also output the number of satisfying solutions given a bound.</p>
},
keywords = {constraint solving, model counting, quantitative program analysis}
}

@software{10.1145/3276922,
author = {Weisenburger, Pascal and K\"{o}hler, Mirko and Salvaneschi, Guido},
title = {Distributed System Development with ScalaLoci},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276922},
abstract = {
    <p>The artifact contains the source code associated with the OOPSLA'18 paper "Distributed System Development with ScalaLoci". All source code is also publicly available on GitHub (http://scala-loci.github.io). The artifact contains the following subdirectories: * **case-study-flink**   Apache Flink case study (cf. Section 8 of the paper) http://github.com/scala-loci/case-study-flink * **case-study-gearpump**   Apache Gearpump case study (cf. Section 8 of the paper) http://github.com/scala-loci/case-study-gearpump * **case-study-play-scalajs**   Play Scala.js Application case study (cf. Section 8 of the paper) http://github.com/scala-loci/case-study-play-scalajs * **dslparadise**   Compiler Plugin for Context Propagation (cf. Section 7 of the paper) http://github.com/pweisenburger/dslparadise [published to Bintray: http://bintray.com/stg-tud] * **examples-simple**   Simple showcases of ScalaLoci using small examples (cf. Section 3 of the paper) http://github.com/scala-loci/examples-simple * **examples-variants**   Comparison of different variants of the same software (cf. Section 8 of the paper) http://github.com/scala-loci/examples-variants * **scala-loci**   ScalaLoci implementation http://github.com/scala-loci/scala-loci [published to Bintray: http://bintray.com/stg-tud] * **system-benchmark**   System Benchmark Setup (cf. Section 8 of the paper)</p>
},
keywords = {Distributed Programming, Multitier Programming, Placement Types, Reactive Programming, Scala}
}

@software{10.1145/3276987,
author = {Adamsen, Christoffer Quist and M\o{}ller, Anders and Alimadadi, Saba and Tip, Frank},
title = {Prototype Implementation for Article: Practical AJAX Race Detection for JavaScript Web Applications},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276987},
abstract = {
    <p>This artifact contains the prototype implementation of AjaxRacer, which is presented in the article 'Practical AJAX Race Detection for JavaScript Web Applications'. The tool is implemented using JavaScript, and has been designed to detect post-initialization event races in client-side JavaScript web applications. The artifact's INSTALL.md and README.md files contains more information on how to install and use the tool.</p>
},
keywords = {dynamic analysis, event race detection, JavaScript}
}

@software{10.1145/3276926,
author = {Feltey, Daniel and Greenman, Ben and Scholliers, Christophe and Findler, Robert Bruce and St-Amour, Vincent},
title = {Artifact Virtual Machine Image for Collapsible Contracts: Fixing a Pathology of Gradual Typing},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276926},
abstract = {
    <p>A virtual machine with the necessary software to reproduce the plots and experiments described in the paper "Collapsible Contracts: Fixing a Pathology of Gradual Typing"</p>
},
keywords = {contracts, gradual typing, migratory typing, performance evaluation}
}

@software{10.1145/3276914,
author = {Zappa Nardelli, Francesco and Belyakova, Julia and Pelenitsyn, Artem and Chung, Benjamin and Bezanson, Jeff and Vitek, Jan},
title = {Artifact for "Julia Subtyping: A Rational Reconstruction" paper},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276914},
abstract = {
    <p>Software and data to reproduce the results of paper.</p>
},
keywords = {Julia programming language, multiple dispatch, subtyping}
}

@software{10.1145/3276940,
author = {Lee, Junho and Song, Dowon and So, Sunbeom and Oh, Hakjoo},
title = {Artifact of Evaluation for Aritcle: Automatic Diagnosis and Correction of Logical Errors for Functional Programming Assignments},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276940},
abstract = {
    <p>This artifact aims to reproduce the main results in the paper "Automatic Diagnosis and Correction of Logical Errors for Functional Programming Assignments" submitted to OOPSLA 2018. Specifically, Table 1 will be reproduced.</p>
},
keywords = {Automated Program Repair, Program Synthesis}
}

@software{10.1145/3276993,
author = {Pauck, Felix and Bodden, Eric and Wehrheim, Heike},
title = {Replication Package for Article: Do Android Taint Analysis Tools Keep Their Promises?},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276993},
abstract = {
    <p>The artifact includes all the software and data used and generated during the evaluation of the associated paper. Thus, the tools used and results achieved are contained. Along with that detailed instructions are provided which describe how to use the tools and how to review or reproduce the results.</p>
},
keywords = {Analysis Query Language, Android Taint Analysis, AQL, Benchmarks, Empirical Studies, Reproducibility, Tools}
}

@software{10.1145/3277000,
author = {Lehmann, Daniel and Pradel, Michael},
title = {Feedback-Directed Differential Testing of Interactive Debuggers (Artifact)},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3277000},
abstract = {
    <p>This artifact includes (1) the source code of a differential testing tool for interactive debuggers, matching the approach presented in the paper "Feedback-Directed Differential Testing of Interactive Debuggers", (2) the set of test programs and the specific browser versions of Firefox and Chromium used during evaluation of said paper, and (3) the list of found bugs with links to the official issue tracker entries and videos of the bugs appearing in the debuggers' user interfaces.</p>
},
keywords = {bugs, Chromium, debugger, differential testing, Firefox, JavaScript, TypeScript}
}

@software{10.5281/zenodo.1412749,
author = {Alimadadi, Saba and Zhong, Di and Madsen, Magnus and Tip, Frank},
title = {Replication Package for Article: Finding Broken Promises in Asynchronous JavaScript Programs},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1412749},
abstract = {
    <p>Recently, promises were added to ECMAScript 6, the JavaScript standard, in order to provide better support for the asynchrony that arises in user interfaces, network communication, and non-blocking I/O. Using promises, programmers can avoid common pitfalls of event-driven programming such as event races and the deeply nested counterintuitive control flow referred to as  callback hell . Unfortunately, promises have complex semantics and the intricate control  and data-flow present in promise-based code hinders program comprehension and can easily lead to bugs. The promise graph was proposed as a graphical aid for understanding and debugging promise-based code. PromiseKeeper is an open-source tool which performs a dynamic analysis to create promise graphs and infer common promise anti-patterns. The results of applying PromiseKeeper to 12 open source promise-based Node.js applications suggest that the constructed promise graphs can provide developers with valuable information about occurrences of common anti-patterns in their promise-based code, and that promise graphs can be constructed with acceptable run-time overhead.</p>
},
keywords = {Dynamic Analysis, JavaScript, Promise Graph, PromiseKeeper, Promises}
}

@software{10.1145/3276913,
author = {Muehlboeck, Fabian and Tate, Ross},
title = {Mechanically Verified Proofs from "Empowering Union and Intersection Types with Integrated Subtyping"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276913},
abstract = {
    <p>Mechanical verification of the claims in the paper that declarative and empowered subtyping are decidable due to equivalence to reductive and integrated subtyping, respectively, and that intersectors are composable.</p>
},
keywords = {decidability, distributivity, extensibility, intersections, subtyping, unions}
}

@software{10.1145/3276931,
author = {Jeon, Minseok and Jeong, Sehun and Oh, Hakjoo},
title = {Precise and Scalable Points-to Analysis via Data-Driven Context Tunneling},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276931},
abstract = {
    <p>This artifact aims to reproduce the main results we reported in the paper  Precise and Scalable Points-to Analysis via Data-Driven Context Tunneling  submitted to OOPSLA 2018. Specifically, Table 2~3 and learned formulas in Appendix A will be reproduced.</p>
},
keywords = {Context-sensitive analysis, Data-driven program analysis, Points-to analysis}
}

@software{10.5281/zenodo.1317760,
author = {Saini, Vaibhav and Farmahinifarahani, Farima and Lu, Yadong and Baldi, Pierre and Lopes, Cristina V.},
title = {Reusable Package for Article: Oreo: Detection of Clones in the Twilight Zone},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1317760},
abstract = {
    <p>This artifact contains Oreo, a clone detector designed to find code clones in the Twilight zone, along with the input data needed for running this tool, and the materials used in evaluating it.</p>
},
keywords = {Clone detection, Information Retrieval, Machine Learning, Software Metrics}
}

@software{10.1145/3276910,
author = {Drechsler, Joscha and Mogk, Ragnar and Salvaneschi, Guido and Mezini, Mira},
title = {Example Project, Library Source and Benchmark Suite and Tools for Article "Thread-Safe Reactive Programming"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276910},
abstract = {
    <p>This Artifact contains four key components: (1) An example project using the thread-safe Reactive Programming library described in the article as an out-of-the-box maven dependency. (2) A copy of the library's source code. (3) The source code of all benchmarks used in the article's empirical evaluation. (4) The toolchain to process the benchmark results into the charts shown in the article.</p>
},
keywords = {Benchmarks, Concurrency Control, Reactive Programming, Scala}
}

@software{10.1145/3276911,
author = {Meier, Remigius and Rigo, Armin and Gross, Thomas R.},
title = {Replication Package for Article: Virtual Machine Design for Parallel Dynamic Programming Languages},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276911},
abstract = {
    <p>VM image with pre-compiled binaries, evaluation data, source code, and documentation for reproducing the results as reported in the article.</p>
},
keywords = {dynamic language, parallel execution, virtual machine}
}

@software{10.1145/3276928,
author = {Abdulla, Parosh Aziz and Atig, Mohamed Faouzi and Jonsson, Bengt and Ngo, Tuan Phong},
title = {Replication Package for the paper: Optimal Stateless Model Checking under the Release-Acquire Semantics},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276928},
abstract = {
    <p>The artifact contains two components. - The first one is a Virtual machine. This machine can be used with VirtualBox. - The first one is an instruction file. This file explains how to reproduce the experimental results in the paper.</p>
},
keywords = {C/C++11, Release-Acquire, software model checking, Software verification, stateless model checking}
}

@software{10.1145/3276929,
author = {Vedurada, Jyothi and Nandivada, V. Krishna},
title = {Replication Package for Article: Identifying Refactoring Opportunities for Replacing Type Code with Subclass and State},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276929},
abstract = {
    <p>Artifact material contains three files: (1)rcp_plug_1.0.0.201809121031.jar, (2)README.pdf and (3)LICENSE.txt. rcp_plug_1.0.0.201809121031.jar is the Eclipse plugin. README.pdf provides instructions for basic testing of the artifact. LICENSE.txt contains the license used.</p>
},
keywords = {Points-to Analysis, Refactoring, Replace Conditionals with Polymorphism, Replace Type Code with State, Replace Type Code with Subclass, Static Program Analysis}
}

@software{10.1145/3276935,
author = {Bornholt, James and Torlak, Emina},
title = {Artifact: Finding Code That Explodes Under Symbolic Evaluation},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276935},
abstract = {
    <p>This artifact contains the code for all experiments in the "Finding Code That Explodes Under Symbolic Evaluation".</p>
},
keywords = {profiling, solver-aided programming, symbolic execution}
}

@software{10.1145/3276937,
author = {Degenbaev, Ulan and Eisinger, Jochen and Hara, Kentaro and Hlopko, Marcel and Lippautz, Michael and Payer, Hannes},
title = {Software Artifact for Article: Cross-Component Garbage Collection},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276937},
abstract = {
    <p>Artifact for the paper "Cross-Component Garbage Collection". See the README.txt file in the artifact for detailed instructions on how to set up and run the experiments illustrated in the paper.</p>
},
keywords = {Garbage Collection, Language Implementation, Memory Management, Runtime Environments}
}

@software{10.1145/3277001,
author = {Rahman, Mohammad Masudur and Roy, Chanchal K.},
title = {Replication Package for Paper: Improving IR-Based Bug Localization with Context-Aware Query Reformulation},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3277001},
abstract = {
    <p>This artifact contains (1) a working prototype of the bug localization tool, BLIZZARD, (2) all the software and data dependencies for running the tool, (3) necessary commands to replicate part of the published results, (4) detailed published results with auxiliary materials, and (5) sufficient instructions for reproducing results with other subject systems.</p>
},
keywords = {bug localization, bug report quality, Debugging automation, graph-based term weighting, information retrieval, query reformulation, replication package, working prototype}
}

@software{10.1145/3277004,
author = {Si, Xujie and Lee, Woosuk and Zhang, Richard and Albarghouthi, Aws and Koutris, Paraschos and Naik, Mayur},
title = {ALPS: Syntax-Guided Synthesis of Datalog Programs},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3277004},
abstract = {
    <p>This artifact consists of the source code, data and scripts of ALPS, which is a proof-of-concept implementation of our ideas presented in the FSE18 paper.</p>
},
keywords = {Active learning, Augmentation, Datalog, SQL, Syntax guided, Synthesis, Template}
}

@software{10.5281/zenodo.1310129,
author = {Kate, Sayali and Ore, John-Paul and Zhang, Xiangyu and Elbaum, Sebastian and Xu, Zhaogui},
title = {Artifact (software + dataset) for "Phys: Probabilistic Physical Unit Assignment and Inconsistency Detection"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1310129},
abstract = {
    <p>This artifact contains a docker version of the tool Phys, along with source code and a dataset of C++ files that build against the Robot Operating System (ROS).</p>
},
keywords = {abstract type inference, factor graphs, robot software, software defect analysis}
}

@software{10.5281/zenodo.1315183,
author = {Wang, Ying and Wen, Ming and Liu, Zhenwei and Wu, Rongxin and Wang, Rui and Yang, Bo and Yu, Hai and Zhu, Zhiliang and Cheung, Shing-Chi},
title = {Available badge for Article: 'Do the Dependency Conflicts in My Project Matter?'},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1315183},
abstract = {
    <p>Decca is a Maven plugin which detects dependency conflict issues between Java projects and third party libraries and assesses the issues' severity levels to warn developers whether the issues are benign or harmful (e.g., causing runtime exceptions). HomePage: https://deccadc.github.io/fse18/</p>
},
keywords = {Dependency conflict, third party library}
}

@software{10.5281/zenodo.1413855,
author = {Koppel, James and Premtoon, Varot and Solar-Lezama, Armando},
title = {Cubix: Source, Docker Image, and experiments},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1413855},
abstract = {
    <p>Contains: * Source code of Cubix * A Dockerfile and the resulting image with a working build of Cubix, * See "Data Documentation" below</p>
},
keywords = {cubix, program transformation, turing test}
}

@software{10.5281/zenodo.1419090,
author = {Zhang, Hailong and Wu, Haowei and Rountev, Atanas},
title = {APTWear},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1419090},
abstract = {
    <p>This artifact contains the static analysis, testing framework, experimental subjects, materials for app market study, logs generated by the static analysis, and the result of testing.</p>
},
keywords = {Android Wear, energy, sensor, smartwatch, static analysis, testing}
}

@software{10.5281/zenodo.1419882,
author = {Guo, Shengjian and Wu, Meng and Wang, Chao},
title = {Implementation and benchmarks for article: Adversarial Symbolic Execution for Detecting Concurrency-Related Cache Timing Leaks},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1419882},
abstract = {
    <p>The source code, the document, and the benchmarks of the Adversarial Symbolic Execution tool.</p>
},
keywords = {Cache timing leak, Concurrency, Symbolic execution}
}

@software{10.5281/zenodo.1420135,
author = {Kini, Dileep and Mathur, Umang and Viswanathan, Mahesh},
title = {Data Race Detection on Compressed Traces},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1420135},
abstract = {
    <p>ZipTrack analyses traces of concurrent programs, compressed as SLPs (straight line programs) and checks if there is a race. ZipTrack performs two analyses : 1. HB race detection 2. LockSet violation detection ZipTrack is written in Java. The following classes let you perform different analyses: 1. `ZipHB.java` - for HB race detection on compressed traces 2. `ZipLockSet.java` - for detecting violations of lockset discipline on compressed traces 3. `ZipMetaInfo.java` - for printing trace characteristics. 4. `TransformGrammar.java` - for transforming an SLP S into another SLP S' with more production rules that have terminal symbols only.</p>
},
keywords = {compression, concurrency, dynamic program analysis, Eraser lockset, happens-before, race detection}
}

@software{10.1145/3276939,
author = {Wang, Chenglong and Cheung, Alvin and Bodik, Rastislav},
title = {Speeding up Symbolic Reasoning for Relational Queries},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276939},
abstract = {
    <p>The artifact for reproducing paper evluation result</p>
},
keywords = {Database, Symbolic Reasoning, Verification}
}

@software{10.1145/3276934,
author = {Barowy, Daniel W. and Berger, Emery D. and Zorn, Benjamin},
title = {ExceLint software artifact},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276934},
abstract = {
    <p>ExceLint is a static analysis that finds formula errors in spreadsheets. This guide provides an installation walkthrough as well as instructions for running the tool. You can run the tool as a plugin using Excel, or using the benchmark runner which will reproduce the results from the paper. Finally, a post-processing script is supplied that will produce charts similar to those found in the paper.</p>
},
keywords = {debugging, error detection, spreadsheet}
}

@software{10.1145/3235040,
author = {Diehl, Larry and Firsov, Denis and Stump, Aaron},
title = {Replication Package for Article: Generic Zero-Cost Reuse for Dependent Types},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235040},
abstract = {
    <p>The Cedille formalization accompanying the article "Generic Zero-Cost Reuse for Dependent Types", packaged as a VirtualBox image.</p>
},
keywords = {dependent types, generic programming, reuse}
}

@software{10.5281/zenodo.1307486,
author = {Kaiser, Jan-Oliver and Ziliani, Beta and Krebbers, Robbert and R\'{e}gis-Gianas, Yann and Dreyer, Derek},
title = {Mtac2 and Iris packages corresponding to the article: "Mtac2: Typed Tactics for Backward Reasoning in Coq"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1307486},
abstract = {
    <p>The artifact includes the code for Mtac2, and a modified branch of Iris 3.1.0 using and showcasing typed tactics.</p>
},
keywords = {Coq, Dependent types, Tactics}
}

@software{10.5281/zenodo.1311928,
author = {Nandi, Chandrakana and Wilcox, James R. and Panchekha, Pavel and Blau, Taylor and Grossman, Dan and Tatlock, Zachary},
title = {Artifact for paper: Functional Programming for Compiling and Decompiling Computer-Aided Design},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1311928},
abstract = {
    <p>In our paper, we made the following contributions (Section 1, last paragraph): 1. A purely functional programming language model for 3D CAD along with denotational semantics for both CAD and triangular mesh. 2. A meaning preserving compilation algorithm from 3D CAD to mesh along with a proof sketch for compiler correctness. 3. A synthesis algorithm that can reverse engineer 3D CAD programs from meshes. This artifact demonstrates the following in support of the above contributions: 1. An early prototype of the compiler from the core 3D CAD language to mesh. The goal is to show that our compiler is capable of generating valid triangular meshes as we described in the paper. To that end we provide 5 CAD programs which cover all the core CAD language features we described in Figure 4 of the paper: 3D primitives, affine transformations, binary operations, and their combinations. 2. An early prototype of the synthesis tool or reverse compiler (Section 5) from 3D mesh to CAD. The goal is to show that the synthesis tool is capable of synthesizing CAD programs from meshes for the case studies we described in Section 6 of the paper. For further details, please refer to our AEC guide document.</p>
},
keywords = {compilers, computational geometry., denotational semantics, language design, program synthesis}
}

@software{10.1145/3235031,
author = {Keidel, Sven and Poulsen, Casper Bach and Erdweg, Sebastian},
title = {Source code for case studies},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235031},
abstract = {
    <p>This document is also available at [Github](https://github.com/svenkeidel/sturdy/blob/icfp-artifact/ARTIFACT.md) with links to highlighted source code. ## Getting Started The artifact is provided as a docker container. To obtain the artifact run the following docker command: ''' docker pull svenkeidel/sturdy-icfp-18-artifact ''' If the artifact has been provided as an archive, unzip it and load it as follows: ''' gunzip -c sturdy-icfp-18-artifact.tar.gz | docker load ''' Afterwards, run the following command to start a shell to get access to the container: ''' docker run --interactive --tty --workdir="/opt/build/" svenkeidel/sturdy-icfp-18-artifact /bin/bash ''' To build the code base, use the Haskell build tool [Stack](https://www.haskellstack.org/) and run 'stack build' from the top-level directory '/opt/build/'. To run the tests, run 'stack test' from the top-level directory. After running the tests, the test reports can be found in '/opt/build/.stack-work/logs/sturdy-stratego-*-test.log' and '/opt/build/.stack-work/logs/sturdy-pcf-*-test.log'. ## Step-by-Step Instructions This artifact consists of the code shown in figures throughout the paper. - Figure 1: * [Concrete Interpreter](figure1/Concrete.hs) * [Abstract Interpreter](figure1/Abstract.hs) - Figure 2: * [Concrete Interpreter](figure2/Concrete.hs) * [Abstract Interpreter](figure2/Abstract.hs) - Figure 3: * [Shared Interpreter](figure3/Shared.hs) - Figure 4: * [Concrete Interpreter](figure3/Concrete.hs) * [Abstract Interpreter](figure3/Abstract.hs) - Section 6: Evaluation The evaluation in the paper consists two case studies, a tree-shape analysis for Stratego and a _k_-CFA analysis for PCF. Each case study consists of the Haskell code of the concrete and abstract interpreter, as well as the corresponding soundness proof. The code of each case study consists of a shared interpreter that is parameterized by an arrow-based interface and the concrete and abstract instantiation of the shared interpreter. To implement the concrete and abstract interpreter arrows, we used _arrow transformers_ (analogous to _monad transformers_). These arrow transformers define, for example, how fixpoints are computed, exceptions are propagated, or how a store is threaded. Each pair of corresponding concrete and abstract arrow transformer implements an arrow-based interface that is used by the shared interpreter. + Section 6.1 - Stratego: * [Syntax definition](stratego/src/Syntax.hs) * [Shared interpreter](stratego/src/SharedSemantics.hs) (includes code of figure 6) * [Concrete interpreter](stratego/src/ConcreteSemantics.hs) * [Abstract interpreter](stratego/src/WildcardSemantics.hs) * Fixpoint computations: [interface](lib/src/Control/Arrow/Fix.hs), [concrete](lib/src/Control/Arrow/Transformer/Concrete/FixPoint.hs), [abstract](lib/src/Control/Arrow/Transformer/Abstract/GreatestFixPoint.hs) * Exceptional computations: [interface](lib/src/Control/Arrow/Except.hs), [concrete](lib/src/Control/Arrow/Transformer/Concrete/Except.hs), [abstract](lib/src/Control/Arrow/Transformer/Abstract/HandleExcept.hs) * Powerset computations: [abstract](lib/src/Control/Arrow/Transformer/Abstract/Powerset.hs) * Tests: [concrete](stratego/test/ConcreteSemanticsSpec.hs), [abstract](stratego/test/WildcardSemanticsSpec.hs) + Section 6.2 - PCF: * [Syntax definition](pcf/src/Syntax.hs) * [Shared interpreter](pcf/src/SharedSemantics.hs) (includes code of figure 8) * [Concrete interpreter](pcf/src/ConcreteSemantics.hs) (includes code of figure 7) * [Abstract interpreter](pcf/src/IntervalAnalysis.hs) (includes code of figure 7) * [Intervals](lib/src/Data/Abstract/Interval.hs) * Fixpoint computations: [interface](lib/src/Control/Arrow/Fix.hs), [concrete](lib/src/Control/Arrow/Transformer/Concrete/FixPoint.hs), [abstract](lib/src/Control/Arrow/Transformer/Abstract/LeastFixPoint.hs) * Environments for _k_-CFA: [interface](lib/src/Control/Arrow/Environment.hs), [concrete](lib/src/Control/Arrow/Transformer/Concrete/Environment.hs), [abstract](lib/src/Control/Arrow/Transformer/Abstract/BoundedEnvironment.hs) * Recording of call-string for _k_-CFA: [abstract](lib/src/Control/Arrow/Transformer/Abstract/Contour.hs) * Exceptional computations: [interface](lib/src/Control/Arrow/Except.hs), [concrete](lib/src/Control/Arrow/Transformer/Concrete/Except.hs), [abstract](lib/src/Control/Arrow/Transformer/Abstract/PropagateExcept.hs) * Tests: [concrete](pcf/test/ConcreteSpec.hs), [abstract](pcf/test/IntervalAnalysisSpec.hs) [shared](pcf/test/SharedSpecs.hs) + The soundness proofs of the analyses: [Proofs](proofs.pdf)</p>
},
keywords = {Abstract Interpretation, Sound Static Analysis}
}

@software{10.1145/3235033,
author = {?cibior, Adam and Kammar, Ohad and Ghahramani, Zoubin},
title = {Software library described in the article: Functional programming for modular Bayesian inference},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235033},
abstract = {
    <p>The artifact provides a full implementation of the library described in the paper. It also contains the code to replicate the experiments shown in the paper.</p>
},
keywords = {Bayesian inference, Haskell, machine learning, MonadBayes, monads, Monte Carlo, probabilistic programming}
}

@software{10.1145/3235034,
author = {Kiss, Csongor and Pickering, Matthew and Wu, Nicolas},
title = {Replication Package for Article: Generic Deriving of Generic Traversals},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235034},
abstract = {
    <p>The artefact contains the source code described in the paper 'Generic Deriving of Generic Traversals' and an accompanying set of performance benchmarks.</p>
},
keywords = {generic programming, Haskell, lenses, traversals}
}

@software{10.1145/3235042,
author = {Wand, Mitchell and Culpepper, Ryan and Giannakopoulos, Theophilos and Cobb, Andrew},
title = {Coq proofs for: Contextual Equivalence for a Language with Continuous Random Variables and Recursion},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235042},
abstract = {
    <p>Coq development of theorems and proofs for the paper: "Contextual Equivalence for a Language with Continuous Random Variables and Recursion" by Mitchell Wand, Ryan Culpepper, Theophilos Giannakopoulos, and Andrew Cobb (ICFP 2018, https://doi.org/10.1145/3236782).</p>
},
keywords = {contextual equivalence, logical relations, probabilistic programming}
}

@software{10.1145/3235048,
author = {Allais, Guillaume and Atkey, Robert and Chapman, James and McBride, Conor and McKinna, James},
title = {Replication Package for Article: A Type and Scope Safe Universe of Syntaxes with Binding: Their Semantics and Proofs},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235048},
abstract = {
    <p>This artifact contains: * Two README files describing respectively the libraries' dependencies and its architecture * a docker image of the library packaged with its dependencies * the source files of the library itself * the html rendering of the source files * a copy of the paper's pdf</p>
},
keywords = {Agda, Fusion, Generic Programming, Logical Relations, Semantics, Simulation, Syntax with Binding}
}

@software{10.1145/3235039,
author = {Foner, Kenneth and Zhang, Hengchu and Lampropoulos, Leonidas},
title = {StrictCheck},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235039},
abstract = {
    <p>StrictCheck is a property-based random testing framework for observing, specifying, and testing the strictness behaviors of Haskell functions. Strictness behavior is traditionally considered a non-functional property; StrictCheck allows it to be tested as if it were one, by reifying demands on data structures so they can be manipulated and examined within Haskell.</p>
},
keywords = {Generic Programming, Haskell, Laziness, Random Testing}
}

@software{10.1145/3235041,
author = {Maina, Solomon and Miltner, Anders and Fisher, Kathleen and Pierce, Benjamin C. and Walker, David and Zdancewic, Steve},
title = {Synthesizing Quotient Lenses},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235041},
abstract = {
    <p>The artifact is a virtual machine containing the code and data used to evaluate the effectiveness of the quotient lens synthesis tool described in the paper "Synthesizing Quotient Lenses"</p>
},
keywords = {Bidirectional Programming, Program Synthesis, Type Systems, Type-Directed Synthesis}
}

@software{10.1145/3235032,
author = {Ohori, Atsushi and Ueno, Katsuhiro and Mima, Hisayuki},
title = {Prototype Implementation of the algorithm presented in Article: Finitary Polymorphism for Optimizing Type-Directed Compilation},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235032},
abstract = {
    <p>The artifact is a ZIP archive consisting of the following: a Docker image containing the SML# compiler with the optimization proposed in the article, the benchmark programs used in the experiments, and all the sources to rebuild all binaries in the artifact. The artifact can be used mainly in three ways: trying the SML# compiler, running the benchmark programs used in the article, and reproducing all the graphs presented in the article. See artifact_overview.pdf in the archive for the details.</p>
},
keywords = {Compiler Optimization, Finitary polymorphism, Second-Order Lambda Calculus, Type-Directed Compilation}
}

@software{10.1145/3235035,
author = {Gibbons, Jeremy and Henglein, Fritz and Hinze, Ralf and Wu, Nicolas},
title = {Code from paper "Relational Algebra by Way of Adjunctions"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235035},
abstract = {
    <p>This artifact is the Haskell code from Appendix B of the paper "Relational Algebra by Way of Adjunctions", appearing at ICFP 2018.</p>
},
keywords = {comprehensions, database queries, finite maps, Haskell, monads}
}

@software{10.1145/3235038,
author = {Campora, John Peter and Chen, Sheng and Walkingshaw, Eric},
title = {Herder Implementation and Data for: "Casts and Costs: Harmonizing Safety and Performance in Gradual Typing"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235038},
abstract = {
    <p>This artifact contains the implementation of Herder, along with the datasets and scripts to recreate the results in the Evaluation section of the paper, "Casts and Costs: Harmonizing Safety and Performance in Gradual Typing".</p>
},
keywords = {Cast Insertion, Cost Analysis, Gradual Typing, Performance}
}

@software{10.1145/3235043,
author = {Horn, Rudi and Perera, Roly and Cheney, James},
title = {Replication Package for Article: Incremental Relational Lenses},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235043},
abstract = {
    <p>A modified version of the Links programming language, extended with incremental relational lenses. It also contains all sample data and programs required to simulate the experimental results shown in the paper.</p>
},
keywords = {bidirectional transformations, incremental computation, lenses, relational algebra}
}

@software{10.1145/3235050,
author = {Omar, Cyrus and Aldrich, Jonathan},
title = {VirtualBox image for Article: Reasonably Programmable Literal Notation},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235050},
abstract = {
    <p>A VirtualBox image that contains a pre-installed version of the Relit software that implements expression TLMs as described in the accompanying article.</p>
},
keywords = {extensible syntax, macros, parsing, type systems}
}

@software{10.1145/3235037,
author = {Stampoulis, Antonis and Chlipala, Adam},
title = {Replication Package for "Prototyping a Functional Language using Higher-Order Logic Programming: A Functional Pearl on Learning the Ways of ?Prolog/Makam"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235037},
abstract = {
    <p>This artifact can be used to run the Makam code that is contained in the paper "Prototyping a Functional Language using Higher-Order Logic Programming: A Functional Pearl on Learning the Ways of __?__Prolog/Makam" by Antonis Stampoulis and Adam Chlipala and to experiment with changes and additional queries. We include a Makam installation as a Docker image, along with the Makam code fragments from the paper. As the paper is a literate development, we include the literate code of the paper itself as well. Detailed installation and usage instructions are available within the artifact, in the README.md file.</p>
},
keywords = {higher-order logic programming, metaprogramming, programming language prototyping}
}

@software{10.1145/3235036,
author = {Breitner, Joachim and Spector-Zabusky, Antal and Li, Yao and Rizkallah, Christine and Wiegley, John and Weirich, Stephanie},
title = {The hs-to-coq tool with examples},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235036},
abstract = {
    <p>The artifact contains a docker image with a snapshot of the hs-to-coq tool and example verification projects, including the verification of the Haskell containers library discussed in the paper.</p>
},
keywords = {Coq, Haskell, verification}
}

@software{10.1145/3235045,
author = {Greenman, Ben and Felleisen, Matthias},
title = {Software for Article: A Spectrum of Type Soundness and Performance},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235045},
abstract = {
    <p>Contents: - git submodules for Racket, Typed Racket, and our experimental fork of Typed Racket - benchmark programs, software to collect and plot their results - source code for the paper - redex models The README text is written for the ICFP artifact evaluation committee. Reviewers downloaded a virtual machine that contained the software in this artifact, but with all git submodules updated and compiled. Run `make install` to update and compile the git submodules (expected time: 2 hours). Link to ICFP artifact virtual machine: https://drive.google.com/open__?__id=1j4RWjpiL9MOL6HAjYlA1G-V31q_VHeuq</p>
},
keywords = {D-deliverable, migratory typing, performance evaluation, type soundness}
}

@software{10.1145/3235047,
author = {Mokhov, Andrey and Mitchell, Neil and Peyton Jones, Simon},
title = {Executable models for the paper "Build Systems \`{a} la Carte"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235047},
abstract = {
    <p>This image contains a snapshot of the "Build Systems a la Carte" project repository https://github.com/snowleopard/build and all its dependencies. # Running the image Unzip the archive, obtaining file snowleopard-build.tar To load the image into Docker use the command: docker load --input snowleopard-build.tar To run it interactively use the command: docker run -it snowleopard/build . # What to check You may be interested to: * Run stack test to execute all the provided build systems on a very simple example. * Run stack haddock to generate HTML documentation of all the interfaces. * Read the code, particularly src/Build/System.hs which is the concrete implementation of all build systems. Following the imports (or the Haddock documentation) will lead you to all the constituent parts. # Further activities There aren't really any. The code served as a proving ground for ideas, and its existence both allows confirmation that our conclusions are valid, and opportunity to cheaply conduct further experiments. Although the code is a useful adjoint to the paper, it is not essential to it (other than we wouldn't have been able to discover what we did without an executable specification). # Dockerfile Created using the following Dockerfile: ``` FROM fpco/stack-build:lts-11.8 MAINTAINER Andrey Mokhov RUN wget -O build-systems.zip https://github.com/snowleopard/build/archive/dbbe1322962cab3f523f61b7a6b3be57533cec44.zip RUN unzip build-systems.zip WORKDIR /build-dbbe1322962cab3f523f61b7a6b3be57533cec44 RUN stack build &amp;\&amp; stack test RUN exit ```</p>
},
keywords = {Build systems, functional programming}
}

@software{10.1145/3235049,
author = {Elsman, Martin and Henriksen, Troels and Annenkov, Danil and Oancea, Cosmin E.},
title = {Coq development for Article: Static Interpretation of Higher-Order Modules in Futhark},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235049},
abstract = {
    <p>This artifact contains the Coq development sources for the article Static Interpretation of Higher-Order Modules in Futhark. Please consult the contained README.md file for details.</p>
},
keywords = {Coq, higher-order modules, module semantics, modules}
}

@software{10.1145/3235051,
author = {Yallop, Jeremy and von Glehn, Tamara and Kammar, Ohad},
title = {Replication package for article: Partially-Static Data as Free Extension of Algebras},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3235051},
abstract = {
    <p>The artifact is a Docker image containing pre-built versions of the Haskell and OCaml libraries described in the paper, along with the benchmarks.</p>
},
keywords = {haskell, meta-programming, metaocaml, multi-stage programming, partial evaluation, partially-static data, universal algebra}
}

@software{10.5281/zenodo.1306029,
author = {Krebbers, Robbert and Jourdan, Jacques-Henri and Jung, Ralf and Tassarotti, Joseph and Kaiser, Jan-Oliver and Timany, Amin and Chargu\'{e}raud, Arthur and Dreyer, Derek},
title = {Coq development for MoSeL: A General, Extensible Modal Framework for Interactive Proofs in Separation Logic},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1306029},
abstract = {
    <p>This is the artifact for the paper "MoSeL: A General, Extensible Modal Framework for Interactive Proofs in Separation Logic". The artifact comes in two forms: As a "mosel-final.zip" file to build yourself, and as a preconfigured VM "MoSeL Artifact.ova" with the artifact already set up and built. You can find the paper and the latest version of this artifact at http://iris-project.org/mosel/</p>
},
keywords = {Coq, Interactive Theorem Proving, Separation Logic}
}

@software{10.1145/3234989,
author = {Kellogg, Martin and Dort, Vlastimil and Millstein, Suzanne and Ernst, Michael D.},
title = {Replication package for Lightweight Verification of Array Indexing},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3234989},
abstract = {
    <p>Contains scripts that reproduce numbers appearing in the paper, especially tables 3 and 4. For a more thorough description, see the README.</p>
},
keywords = {checker framework, index out of bounds, pluggable type checking, type systems}
}

@software{10.5281/zenodo.1297764,
author = {Lyu, Yingjun and Li, Ding and Halfond, William G. J.},
title = {Replication Package for Article: Remove RATs from Your Code: Automated Optimization of Resource Inefficient Database Writes for Mobile Applications},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1297764},
abstract = {
    <p>To facilitate research into local database optimization in mobile applications, we have made available the raw data, analysis code and analysis results that were used in our paper. The artifact includes the source code of the detection and optimization analyses, energy and runtime measurement data, and detailed analysis results for each research question in the paper.</p>
},
keywords = {database, mobile applications, Performance optimization}
}

@software{10.5281/zenodo.1299357,
author = {Wu, Meng and Guo, Shengjian and Schaumont, Patrick and Wang, Chao},
title = {[ISSTA '18 Artifact Evaluation] Eliminating Timing Side-Channel Leaks using Program Repair},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1299357},
abstract = {
    <p>This is an artifact evaluation release for ISSTA 18' paper "Eliminating Timing Side-Channel Leaks using Program Repair" The artifact is in an open virtual machine format which can be open with VirtualBox or VMware. To log into the virtual machine, use username: ae, pwd: 123</p>
},
keywords = {program repair, timing side channel}
}

@software{10.5281/zenodo.1306224,
author = {Tabareau, Nicolas and Tanter, \'{E}ric and Sozeau, Matthieu},
title = {Coq Development: Equivalences for Free: Univalent Parametricity for Effective Transport},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1306224},
abstract = {
    <p>Coq source files accompanying the ICFP 2018 paper "Equivalences for Free: Univalent Parametricity for Effective Transport", by Tabareau, Tanter, Sozeau.</p>
},
keywords = {Coq, parametricity, Univalence}
}

@software{10.1145/3234985,
author = {Jiang, Jiajun and Xiong, Yingfei and Zhang, Hongyu and Gao, Qing and Chen, Xiangqun},
title = {SimFix},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3234985},
abstract = {
    <p>Replication package for paper "Shaping Program Repair Space with Existing Patches and Similar Code"</p>
},
keywords = {Automated program repair, code adaptation, code differencing}
}

@software{10.1145/3234988,
author = {Fourtounis, George and Kastrinis, George and Smaragdakis, Yannis},
title = {Artifact for Article: "Static Analysis of Java Dynamic Proxies"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3234988},
abstract = {
    <p>This artifact contains the software and benchmarks needed to evaluate the article "Static Analysis of Java Dynamic Proxies". The artifact contains the Doop analysis framework, a suite of XCorpus programs containing proxies, and two case studies (okhttp, guice), all packaged as a Docker archive.</p>
},
keywords = {Doop, dynamic proxies, reflection, static analysis}
}

@software{10.1145/3234991,
author = {Grech, Neville and Fourtounis, George and Francalanza, Adrian and Smaragdakis, Yannis},
title = {A docker container with all necessary software},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3234991},
abstract = {
    <p>A docker container with all necessary software: - Doop - HeapDL - Benchmarks (dacapo-bach) - Memory dumps - Scripts for running benchmarks and collecting results</p>
},
keywords = {Program analysis}
}

@software{10.5281/zenodo.1296310,
author = {Bl\"{a}ser, Luc},
title = {HSR Parallel Checker},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1296310},
abstract = {
    <p>Checker tool described in the paper. Please follow Installation.pdf for the tool setup and further instruction steps.</p>
},
keywords = {.NET, C#, data race, deadlock, static checker}
}

@software{10.5281/zenodo.1301239,
author = {DeFreez, Daniel and Thakur, Aditya V. and Rubio-Gonz\'{a}lez, Cindy},
title = {func2vec-fse2018-artifact},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1301239},
abstract = {
    <p>Artifact with source for running Func2vec and link to data for reproducing experiments.</p>
},
keywords = {error handling, program analysis, program comprehension, program embeddings, specification mining}
}

@software{10.5281/zenodo.1218718,
author = {Liu, Peizun and Wahl, Thomas},
title = {CUBA: Interprocedural Context-Unbounded Analysis of Concurrent Programs (Artifact)},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1218718},
abstract = {
    <p>This is the artifact package for the article: CUBA: Interprocedural Context-Unbounded Analysis of Concurrent Programs. It includes: 1. The tool implemented in the article. In particular, -- the source code, -- executable binaries, -- an installation guide, -- documentation. 2. A brief introduction to the syntax used in our input programs. 3. A brief tutorial. 4. A set of benchmarks used and a guide to run the experiments.</p>
},
keywords = {Concurrent Program, Context Bound, Interprocedural Analysis, Recursion, Stack}
}

@software{10.5281/zenodo.1218771,
author = {Chen, Dong and Liu, Fangzhou and Ding, Chen and Pai, Sreepathi},
title = {Software Artifact for Locality Analysis through Static Parallel Sampling},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1218771},
abstract = {
    <p>We provide the Static Parallel Sampling (SPS) artifact that contains code, testing shell scripts and Python scripts for plotting result. We extracted the minimal code needed from the newest version of the Static Parallel Sampling tools and provide a Dockerfile to generate one working testing environment. This given artifact can reproduce all our results in Figures 5-7 (Miss ratio curve, overhead and parallel execution) in the evaluation section of the paper.</p>
},
keywords = {locality, program specialization, Static analysis}
}

@software{10.1145/3211990,
author = {Steindorfer, Michael J. and Vinju, Jurgen J.},
title = {Replication Package for Article "To-Many or To-One? All-in-One! Efficient Purely Functional Multi-maps with Type-Heterogeneous Hash-Tries"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3211990},
abstract = {
    <p># Getting Started Guide The evaluation of our PLDI'18 paper entitled _To-many or To-one__?__ All-in-one! --- Efficient Purely Functional Multi-Maps with Type-Heterogeneous Hash-Tries_ consists of microbenchmarks and a case study in program analysis, both benchmarks execute fully automated. ## Requirements We assume basic familiarity with UNIX terminals and command line tools. The artifact was tested under UNIX operating systems (i.e., Ubuntu Linux 16.04.3.LTS and Apple macOS). The artifact requires the following resources to run: * Command line tools: * java (version 8), * maven, * make, * ant, * R and RScript * Internet connection (for automatically downloading dependencies). The execution time benchmarks are configured to use heap sizes of 8GB, whereas the memory measurments use 16GB. Thus computers or virtual machiens with at least 8GB RAM are recommended. For ease of use, we created a virtual machine with tools, benchmarks, and data setup. As basis we used the **Ubuntu Linux 16.04.3.LTS** distribution, installed in a [**VirtualBox**](https://www.virtualbox.org) virtual machine (version 5.2.6) with the **Oracle VM VirtualBox Extension Pack** installed. Go to [www.virtualbox.org](www.virtualbox.org) for downloading the software and installation instructions. The virtual machine has the following packages installed in order to satisfy our requirements: * `sudo apt install git` * `sudo apt install default-jdk` * `sudo apt install maven` * `sudo apt install openssh-server` * `sudo apt install r-base r-base-dev` ## SSH access to Virtual Machine For more convenient usage of the artifact, the authors are asked to setup remote access via terminal according to the stackoverflow answer [How to SSH to a VirtualBox guest externally through a host__?__](https://stackoverflow.com/questions/5906441/how-to-ssh-to-a-virtualbox-guest-externally-through-a-host). Afterwards, users of the artifact can log into the virtual machine with the following command line: &gt; ssh -p 3022 axiom@localhost When prompted for a password, use the password "axiom" (i.e., the same as the username that is already provided in the commannd line). ## Executing the Benchmarks and Data Post-Processing Pipeline Thh execution of benchmark referred to in the evaluation Sections 4, 5, and 6 of the paper, are entriely automated. The data post-processing of the data used in Sections 4 and 5 (cf. Figures 4, 5 and 6) are automated as well. Getting started with reproducing our resutls requires the execution of following commands in a console/terminal after being logged into our virtual machine: Moving into the artifacts directory: &gt; cd pldi18-artifact Setting up and compiling the artifacts: &gt; make prepare (To manually inspect what the **make** commands do, have a look at *pldi18-artifact/Makefile*.) ### (Quickly) Evaluating Archived Data concerning Sections 4 and 5 Next, one can re-generate the boxplots of the Figures 4, 5 and 6 (page 8 of the paper) based the logs that we obtained when executing the benchmarks ourselves. Our cached results are contained in the folder *data/20170417_1554*. The folder contains the following files: * **results.all-20170417_1554.log**: comma-separated values (CSV) file containing microbenchmark results of runtimes of individual operations * **map_sizes_heterogeneous_exponential_32bit_20170417_1554**: CSV file containing memory footprints in a 32-bit JVM setting. * **map_sizes_heterogeneous_exponential_64bit_20170417_1554**: CSV file containing memory footprints in a 64-bit JVM setting. * **hamt-benchmark-results-20170417_1554.tgz**: an archieve containing the files mentioned above verbose console output from running the benchmarks. The folder addionally contains three PDFs that were generated from the data files referenced above. The files correspond directly to the boxplots of Figures 4, 5, and 6 of page 8 of the paper. The boxplots are named **all-benchmarks-vf_champ_multimap_hhamt_by_vf_(scala|clojure|champ_map_as_multimap-map)-boxplot-speedup.pdf** and were generated with the following command, which should finish in a few seconds: &gt; make postprocessing_cached The reviewer may delete the three PDFs and re-generate them by with the command. An R script that is located under *benchmark/resources/r/benchmarks.r* performs the data post-processing and generation of the plots. ### (Relatively Quickly) Re-executing the whole Pipeline with a Reduced Dataset concerning Sections 4 and 5 The following commands re-execute the benchmarks for a reduced data set (with not statistically significant results) for the data structure sizes 16, 2048 and 1048576: Running reduced set of microbenchmarks: &gt; make run_microbenchmarks_short Benchmarking should approximately be finished in 15 to 30 minutes. After the benchmarks finished, the *data* directory should contain a new timestamped sub-folder with the benchmark results. After executing the following post-processing command, the folder should once again contain three PDFs / figures with boxplots: Running result analysis and post-processing: &gt; make postprocessing Note, that the results are neither statistically significant, nor do the cover a representative set of data structures size or data points in general. Nevertheless, the shape the boxplots may be similar to the figures in the paper. ### (Extremely Long) Re-executing the whole Pipeline with the Full Dataset concerning Sections 4 and 5 Running reduced set of microbenchmarks: &gt; make run_microbenchmarks Running result analysis and post-processing: &gt; make postprocessing Benchmarking the full data set can take up to two days of processing and should be performed on a dedicated machine without load or extraneous processes running in order to yield reliable results (see paper section about experimental setup and related work). ### (Relatively Quickly) Re-executing the Static Analysis Case Study concerning Section 6 Running case study benchmarks: &gt; make run_static_analysis_case_study Executing the case study benchmark I guess takes approximatley 1 to 2 hours. The benchmark results should be shown in tabular form in the terminal at the end of the benchmark run, and also serialized to disk (to a CSV file named *results.all-real-world-$TIMESTAMP.log*). Post-processing the data of this benchmark was not automated, and instead done by hand. However, it should be observable that the benchmark results for CHAMP and AXIOM are roughly the same. Note that abbreviations used in the benchmark setup do not match the names in the paper, i.e., CHART is used for CHAMP, and VF_CHAMP_MULTIMAP_HHAMT is used for AXIOM. The results cover the first three columns of Table 1. Colums 3-6 of Table 1 were also extracted manually with an instrumented version of the benchmark (cf. file *benchmark/src/main/java/dom/multimap/DominatorsSetMultimap_Default_Instrumented.java*). ## Other Relevant Items of our Artifact Our AXIOM hash trie implementations can be found under *code/capsule-experimental/src/main/java/io/usethesource/capsule/experimental/multimap/TrieSetMultimap_HHAMT.java*, for people interested in manually inspecting the implementation. The packages *benchmark/src/main/scala/io/usethesource/criterion/impl/persistent/scala* and *benchmark/src/main/java/io/usethesource/criterion/impl/persistent/clojure* contain simple interface facades that enables cross-library benchmarks under a common API. The benchmark implementations can be found in the *benchmark* project. File *benchmark/src/main/java/dom/multimap/DominatorsSetMultimap_Default.java* implements the real-word experiment (Section 6 of the paper), and file *benchmark/src/main/java/dom/multimap/DominatorsSetMultimap_Default_Instrumented.java* was used to extracting further statistics (colums 4-6 of Table 1). File *JmhSetMultimapBenchmarks.java* measures the runtimes of individual operations, whereas *CalculateHeterogeneousFootprints.java* performs footprint measurements (cf. page 8, Figures 4, 5, and 6). Note that the Java benchmark classes contain default parameters for their invocation, however the actual parameters are set in *runMicrobenchmarks.sh* and *runStaticProgramAnalysisCaseStudy.sh*.</p>
},
keywords = {Data structures, functional programming, graph, hashtable, JVM., many-to-many relation, multi-map, optimization, performance, persistent data structures}
}

@software{10.1145/3212005,
author = {Pombrio, Justin and Krishnamurthi, Shriram},
title = {PLDI 2018 Artifact for Inferring Type Rules for Syntactic Sugar},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3212005},
abstract = {
    <p>This is the artifact for the paper "Inferring Type Rules for Syntactic Sugar" by Justin Pombrio and Shriram Krishnamurthi. Type systems and syntactic sugar are both valuable to programmers, but sometimes at odds. While sugar is a valuable mechanism for implementing realistic languages, the expansion process obscures program source structure. As a result, type errors can reference terms the programmers did not write (and even constructs they do not know), baffling them. The language developer must also manually construct type rules for the sugars, to give a typed account of the surface language. We address these problems by presenting a process for automatically reconstructing type rules for the surface language using rules for the core. We have implemented this theory, and show several interesting case studies.</p>
},
keywords = {Macros, Programming Languages, Resugaring, Syntactic Sugar, Type Systems}
}

@software{10.1145/3211981,
author = {Panchekha, Pavel and Geller, Adam T. and Ernst, Michael D. and Tatlock, Zachary and Kamil, Shoaib},
title = {Replication of Evaluation for VizAssert},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3211981},
abstract = {
    <p>Fully reproduces the experiments that are introduced in the paper, including: automatically verifying (or producing counterexamples for) 14 industry-standard assertions on 51 professionally-designed web pages; and testing VizAssert's formalization of line height, margin collapsing, and floating layout against Mozilla Firefox.</p>
},
keywords = {accessibility, CSS, layout, semantics, SMT, usability, verification}
}

@software{10.1145/3211984,
author = {Brutschy, Lucas and Dimitrov, Dimitar and M\"{u}ller, Peter and Vechev, Martin},
title = {C4 Tool Source Code},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3211984},
abstract = {
    <p>This is the source code for the C4 tool that we developed and reported in our "Static Serializability Analysis for Causal Consistency" PLDI '18 paper. For more information, check out the project home page at http://ecracer.inf.ethz.ch/.</p>
},
keywords = {Atomic Visibility, Causal Consistency, Serializability, Static Analysis}
}

@software{10.1145/3211988,
author = {Sanchez-Stern, Alex and Panchekha, Pavel and Lerner, Sorin and Tatlock, Zachary},
title = {Herbgrind Sources &nbsp;at Time Of Submission},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3211988},
abstract = {
    <p>A source archive of Herbgrind, and the version of Herbie used in the paper eval. A more up-to-date version of Herbgrind can be found at github.com/uwplse/herbgrind.git</p>
},
keywords = {debugging, dynamic analysis, floating point}
}

@software{10.1145/3211997,
author = {Gehr, Timon and Misailovic, Sasa and Tsankov, Petar and Vanbever, Laurent and Wiesmann, Pascal and Vechev, Martin},
title = {Artifact for the PLDI'18 paper "Bayonet: Probabilistic Inference for Networks"},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3211997},
abstract = {
    <p>This is the version of Bayonet that was used to generate the results in the paper "Bayonet: Probabilistic Inference for Networks" Find the current version of Bayonet at: http://bayonet.ethz.ch</p>
},
keywords = {Computer Networks, Probabilistic Programming}
}

@software{10.1145/3211982,
author = {Vilk, John and Berger, Emery D.},
title = {Software Artifact for BLeak: Automatically Debugging Memory Leaks in Web Applications},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3211982},
abstract = {
    <p>The artifact consists of a VirtualBox VM image (OVA file) containing the BLeak software and source code, evaluation data, instructions, and all open source evaluation applications and input files.</p>
},
keywords = {BLeak, debugging, JavaScript, leak debugging, leak detection, memory leaks, web applications, web browsers}
}

@software{10.1145/3211994,
author = {Wang, Di and Hoffmann, Jan and Reps, Thomas},
title = {PMAF: An Algebraic Framework for Static Analysis of Probabilistic Programs},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3211994},
abstract = {
    <p>PMAF is an algebraic framework for static analysis of probabilistic programs. PMAF takes an interpretation of a pre-Markov algebra (PMA) and a program as its input, and then performs the analysis specified by the algebra on the program automatically via a fixpoint computation. We have instantiated PMAF on three PMAs, obtaining tolls for: Bayesian inference, the Markov decision problem, and linear expectation-invariant analysis.</p>
},
keywords = {Expectation invariant, Pre-Markov algebra, Probabilistic program, Program analysis}
}

@software{10.1145/3212003,
author = {Zhu, He and Magill, Stephen and Jagannathan, Suresh},
title = {Artifact for paper: A Data-Driven CHC Solver (PLDI 2018)},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3212003},
abstract = {
    <p>LinearArbitrary-SeaHorn: A CHC solver for LLVM-based languages</p>
},
keywords = {Constrained Horn Clauses (CHCs), Data-Driven Analysis, Invariant Inference, Program Verification}
}

@software{10.1145/3211992,
author = {Lee, Woosuk and Heo, Kihong and Alur, Rajeev and Naik, Mayur},
title = {Replication Package for PLDI'18 of Euphony},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3211992},
abstract = {
    <p>This is the replication package for our paper titled "Accelerating Search-Based Program Synthesis using Learned Probabilistic Models". The package includes a virtual machine image along with instructions how to use our tool and reproduce the claims in our paper. Using this package, one can reproduce Table 4, 5, 6, 7 and Figure 8 in the paper.</p>
},
keywords = {Domain-specific languages, Statistical methods, Synthesis, Transfer learning}
}

@software{10.1145/3190500,
author = {Zhou, Qing and Li, Lian and Wang, Lei and Xue, Jingling and Feng, Xiaobing},
title = {Replication Package for Article: May-Hppen-in-Parallel Analysis with Static Vector Clocks},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3190500},
abstract = {
    <p>This is a virtual box image. You can use it to run the default data race detector LDruid with Static Vector Clocks. Static vector clocks are used to do MHP analysis. The image does not consist of source code, and we plan to open source in future. The relevant algorithm and experimental results can be found in paper CGO2018: MHP analysis with Static Vector Clocks.</p>
},
keywords = {Data race detector, MHP, Static vector clocks}
}

@software{10.1145/3190495,
author = {Xie, Biwei and Zhan, Jianfeng and Liu, Xu and Gao, Wanling and Jia, Zhen and He, Xiwen and Zhang, Lixin},
title = {Replication Package for Article, CVR: Efficient Vectorization of SpMV on X86 Processors},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3190495},
abstract = {
    <p>The artifact contains the source code of SpMV using CVR after converting a sparse matrix from CSR to CVR. It can support the experiment results in section 8 of our CGO'2018 paper, CVR: Efficient SpMV Vectorization on X86 Processors. To validate the results, build CVR and run the benchmarks with provided scripts. This artifact provides general instructions to evaluate CVR, while more details are provided on Github (
 <ext-link xlink:href="https://github.com/puckbee/CVR">
  https://github.com/puckbee/CVR)
 </ext-link>.</p>
},
keywords = {Knights Landing, Many core, SIMD, SpMV}
}

@software{10.1145/3190496,
author = {Kruse, Michael and Grosser, Tobias},
title = {CGO '18 Artifact for DeLICM},
year = {2017},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3190496},
abstract = {
    <p>The artifact contains the scripts used to obtain the data from the article, including the results we obtained ourselves.</p>
},
keywords = {experiment, LLVM, Polly, result}
}

