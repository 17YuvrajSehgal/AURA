@software{10.5281/zenodo.12453932,
author = {Cassano, Federico and Gouwar, John and Lucchetti, Francesca and Schlesinger, Claire and Freeman, Anders and Anderson, Carolyn Jane and Feldman, Molly Q and Greenberg, Michael and Jangda, Abhinav and Guha, Arjun},
title = {Artifact: Knowledge Transfer from High-Resource to Low-Resource Programming Languages for Code LLMs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12453932},
abstract = {
    <p>The artifact contains the code to fully reproduce the results in the
paper.</p>

},
keywords = {large language models trained on code}
}

@software{10.5281/zenodo.12552491,
author = {Lin, Zhengyao and Gancher, Joshua and Parno, Bryan},
title = {FlowCert: Translation Validation for Asynchronous Dataflow Programs via Dynamic Fractional Permissions},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12552491},
abstract = {
    <p>Implementation of FlowCert and evaluation data packaged in a Docker
image.</p>

},
keywords = {Asynchronous Dataflow, Coarse-Grained Reconfigurable Arrays, Translation Validation}
}

@software{10.5281/zenodo.12604575,
author = {Le, Callista and Gopinathan, Kiran and Lee, Koon Wen and Gilbert, Seth and Sergey, Ilya},
title = {OBatcher: Implementation, Data Structures, and Experiments (OOPSLA'24 Artefact) Creators},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12604575},
abstract = {
    <p>This release snapshots the functionality of the submitted artefact
for the OBatcher framework and data structures described in the OOPSLA
24 paper “Concurrent Data Structures Made Easy”:</p>
<ul>
<li><p>Docker file with reproducible build environment</p></li>
<li><p>Readme with getting started and step-by-step
instructions</p></li>
<li><p>Source code and build files for OBatcher</p></li>
<li><p>Instantiation of the OBatcher framework in Rust</p></li>
<li><p>Benchmark code and scripts to reproduce the 33 graphs presented
in the paper</p></li>
</ul>

},
keywords = {batched data structures, batching, concurrency, OCaml, programming languages, Rust}
}

@software{10.5281/zenodo.12627576,
author = {Nagy, Shaan and Kim, Jinwoo and Reps, Thomas and D’Antoni, Loris},
title = {Wuldo Unrealizability Logic Proof Synthesizer},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12627576},
abstract = {
    <p>Automated verification of all members of a (potentially infinite) set
of programs has the potential to be useful in program synthesis, as well
as in verification of dynamically loaded code, concurrent code, and
language properties. Existing techniques for verification of sets of
programs are limited in scope and unable to create or use interpretable
or reusable information about sets of programs. The consequence is that
one cannot learn anything from one verification problem that can be used
in another. Unrealizability logic (UL), proposed by Kim et al.&nbsp;as the
first Hoare-style proof system to prove properties over sets of programs
(defined by a regular tree grammar), presents a theoretical framework
that can express and use reusable insight. In particular, UL features
nonterminal summaries—inductive facts that characterize recursive
nonterminals (analogous to procedure summaries in Hoare logic). In this
work, we design the first UL proof synthesis algorithm, implemented as
Wuldo. Specifically, we decouple the problem of deciding how to apply UL
rules from the problem of synthesizing/checking nonterminal summaries by
computing proof structure in a fully syntax-directed fashion. We show
that Wuldo, when provided nonterminal summaries, can express and prove
verification problems beyond the reach of existing tools, including
establishing how infinitely many programs behave on infinitely many
inputs. In some cases, Wuldo can even synthesize the necessary
nonterminal summaries. Moreover, Wuldo can reuse previously proven
nonterminal summaries across verification queries, making verification
1.96 times as fast as when summaries are instead proven from
scratch.</p>

},
keywords = {automated reasoning, infinite sets of programs, Unrealizability logic}
}

@software{10.5281/zenodo.12654518,
author = {Torczon, Cassia and Su\'{a}rez Acevedo, Emmanuel and Agrawal, Shubh and Velez-Ginorio, Joey and Weirich, Stephanie},
title = {Artifact Associated with "Effects and Coeffects in Call-by-Push-Value"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12654518},
abstract = {
    <p>Coq mechanization of definitions and theorems</p>

},
keywords = {CBPV, Coeffects, Coq, Effects}
}

@software{10.5281/zenodo.12659527,
author = {Haselwarter, Philipp G. and Li, Kwing Hei and de Medeiros, Markus and Gregersen, Simon Oddershede and Aguirre, Alejandro and Tassarotti, Joseph and Birkedal, Lars},
title = {Tachis: Higher-Order Separation Logic with Credits for Expected Costs - Coq Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12659527},
abstract = {
    <p>Formalization of the results of the paper “Tachis: Higher-Order
Separation Logic with Credits for Expected Costs” in the Coq proof
assistant.</p>

},
keywords = {expected time complexity, probabilistic programs, resource analysis}
}

@software{10.5281/zenodo.12666682,
author = {Liew, Dennis and Cogumbreiro, Tiago and Lange, Julien},
title = {Sound and partially-complete static analysis of data-races in GPU programs (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12666682},
abstract = {
    <p>An artifact with all the tools and datasets presented in Section 6,
and mechanized proofs of the theoretical results mentioned in Section
4.4.</p>

},
keywords = {data-race detection, GPU programming, static analysis, true positives}
}

@software{10.5281/zenodo.12668895,
author = {Drosos, Georgios-Petros and Sotiropoulos, Thodoris and Alexopoulos, Georgios and Mitropoulos, Dimitris and Su, Zhendong},
title = {Reproduction Package for Article: "When Your Infrastructure Is a Buggy Program: Understanding Faults in Infrastructure as Code Ecosystems},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12668895},
abstract = {
    <p>The purpose of this artifact is (1) to reproduce the results
presented in the OOPSLA 2024 paper titled “When Your Infrastructure Is a
Buggy Program: Understanding Faults in Infrastructure as Code
Ecosystems”, and (2) to document the dataset and the proposed
categorization in order to facilitate further research. Specifically,
the artifact has the following structure:</p>
<ul>
<li><code>scripts/</code>: This directory contains the scripts necessary
to replicate the findings, figures, and tables introduced in our
study.</li>
<li><code>scripts/fetch/</code>: This directory contains the scripts
required to assemble the dataset of IaC bugs as outlined in Section 3.1
of our study (i.e., this directory includes the code for our repository
collection gathering and bug collection stages).</li>
<li><code>data/</code>: This directory contains the initial bug dataset
of the data collection phase as well as the “pre-baked” dataset of the
360 IaC bugs under study.</li>
<li><code>figures/</code>: A directory which is going to store the
produced paper figures.</li>
<li><code>requirements.txt</code>: A textual file declaring the required
PyPI libraries to run our analysis.</li>
</ul>

},
keywords = {Ansible, bug, Chef, deployment, IaC, infrastructure as code, Puppet}
}

@software{10.5281/zenodo.12669479,
author = {Blinn, Andrew and Li, Xiang and Kim, June Hyung and Omar, Cyrus},
title = {Artifact for Statically Contextualizing Large Language Models with Typed Holes},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669479},
abstract = {
    <p>Artifact for the paper ‘Artifact for Statically Contextualizing Large
Language Models with Typed Holes’, to be published at OOPSLA2024. The
artifact consists of raw data from the experiments, the testing harness
used, the source for the Hazel Editor and Langauge Server, and a copy of
the StarCoder2 LLM weights. The archive is password protected to prevent
the benchmark data set from being automatically scrapped; see the Zenodo
description for the password.</p>

},
keywords = {Large Language Models, Program Synthesis, Programming Languages, Types}
}

@software{10.5281/zenodo.12669572,
author = {Pham, Long and Wang, Di and Saad, Feras A. and Hoffmann, Jan},
title = {Artifact for Programmable MCMC with Soundly Composed Guide Programs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669572},
abstract = {
    <p>In probabilistic programming with a newly proposed coroutine-based
programmable inference framework, the user provides (i) a model
coroutine and (ii) a sequential composition of guide coroutines. The
model coroutine specifies a probabilistic model for Bayesian inference.
Meanwhile, the sequential composition of guide coroutines customizes the
Block Metropolis-Hastings (BMH) algorithm, where we successively run the
guide coroutines, each of which is followed by an MH acceptance routine.
Each guide coroutine only updates a subset (i.e., block) of random
variables. The model and guide coroutines communicate with one another
by message passing, and their communication protocols are described by
guide types.</p>
<p>This artifact is a program analysis tool for statically checking the
soundness of a probabilistic program in this coroutine-based framework.
The artifact offers three functionalities: - Type-equality checking:
check structural type equality of guide types. - Type inference: infer
guide types of model and guide coroutines (using the first functionality
for structural-type-equality checking) - Coverage checking: check
whether the support of sequentially composed guide coroutines coincides
with the support of a model coroutine.</p>

},
keywords = {Bayesian inference, context-free types, coroutines, probabilistic programming, type systems}
}

@software{10.5281/zenodo.12669638,
author = {Zhang, Chengyu and Su, Zhendong},
title = {SMT2Test: From SMT Formulas to Effective Test Cases},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669638},
abstract = {
    <p>The main focus of this artifact is to help people 1) validate the
functionality of the bugfinding tool SMT2Test, 2) check the bug
triggering test cases reported in the paper, 3) reproduce the
performance evaluation. This artifact includes the implementation of
SMT2Test, bug-triggering test cases, seed formulas, and scripts for
reproducing the experiments.</p>

},
keywords = {program verification, SMT solving, software testing}
}

@software{10.5281/zenodo.12669773,
author = {Johnson, Keith J.C. and Krishnan, Rahul and Reps, Thomas and D’Antoni, Loris},
title = {Automating Pruning in Top-Down Enumeration for Program Synthesis Problems with Monotonic Semantics},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669773},
abstract = {
    <p>This is the artifact submission for OOPSLA’24 (R2) submission #377:
Automating Pruning in Top-Down Enumeration for Program Synthesis
Problems with Monotonic Semantics</p>

},
keywords = {abstract interpretation, grammar flow analysis, program synthesis}
}

@software{10.5281/zenodo.12669929,
author = {Zhou, Litao and Wan, Qianyong and Oliveira, Bruno C. d. S.},
title = {Artifact for "Full Iso-Recursive Types"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669929},
abstract = {
    <p>This artifact accompanies the OOPSLA’24 paper titled Full
Iso-recursive Types. It provides the Coq formalization of the proofs
discussed in the paper, including a pre-configured Docker image for easy
verification and the original source code for those who wish to build
the proofs manually. The artifact includes all necessary scripts, proof
files, and dependencies to reproduce the results presented in the paper,
with a focus on the formalization of iso-recursive types and their
extensions.</p>

},
keywords = {Coq, Mechanized Proof, Recursive types, Subtyping, Type system}
}

@software{10.5281/zenodo.12670155,
author = {Sistla, Meghana and Chaudhuri, Swarat and Reps, Thomas},
title = {Weighted CFLOBDDs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670155},
abstract = {
    <p>The artifact contains source code and experiments to run Weighted
CFLOBDDs (WCFLOBDDs)</p>

},
keywords = {quantum simulation, Weighted decision diagrams}
}

@software{10.5281/zenodo.12670660,
author = {Wang, Qian and Jung, Ralf},
title = {Reproduction Image for Article 'Rustlantis: Randomized Differential Testing of the Rust Compiler'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670660},
abstract = {
    <p>Docker image to reproduce evaluations in OOPSLA 2024 paper
Rustlantis: Randomized Differential Testing of the Rust Compiler.</p>

},
keywords = {Compiler testing, Differential fuzzing, Rust}
}

@software{10.5281/zenodo.12671562,
author = {Dardinier, Thibault and Li, Anqi and M\"{u}ller, Peter},
title = {Hypra: A Deductive Program Verifier for Hyperproperties (artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12671562},
abstract = {
    <p>This artifact consists of: - Our tool Hypra. - Our evaluation, with
instructions to replicate it. - An Isabelle/HOL proof of the soundness
of the novel loop rule described in section 4.2 (Theorem 1), as well as
Lemma 1.</p>
<p>The artifact is a VirtualBox VM image with Ubuntu 24.04 LTS that
contains our tool Hypra, all benchmarks used in our evaluation, Isabelle
2024, and our Isabelle/HOL formalization. It uses 8GB of RAM and two
cores by default.</p>

},
keywords = {automated reasoning, deductive verification, hyperproperties, incorrectness logic}
}

@software{10.5281/zenodo.12671619,
author = {Zhou, Chijin and Qian, Bingzhou and Go, Gwihwan and Zhang, Quan and Li, Shanshan and Jiang, Yu},
title = {PolyJuice: Detecting Mis-Compilation Bugs in Tensor Compilers with Equality Saturation Based Rewriting},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12671619},
abstract = {
    <p>This is the artifact for “PolyJuice: Detecting Mis-Compilation Bugs
in Tensor Compilers with Equality Saturation Based Rewriting”, published
in SPLASH/OOPSLA 2024. Reproducibility instructions can be found in the
“oopsla24-polyjuice-artifact.pdf” file.</p>

},
keywords = {Equality Saturation, Fuzzing, ML System, Tensor Compiler Testing}
}

@software{10.5281/zenodo.12775308,
author = {Schenck, Robert and Hinnerskov, Nikolaj Hey and Henriksen, Troels and Madsen, Magnus and Elsman, Martin},
title = {futhark-oopsla24},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12775308},
abstract = {
    <p>Artifact for the paper AUTOMAP: Inferring Rank-Polymorphic Function
Applications with Integer Linear Programming submitted to OOPSLA 24.</p>

},
keywords = {array programming, constraint-based type systems, data parallelism}
}

@software{10.5281/zenodo.13166254,
author = {Borgarelli, Andrea and Enea, Constantin and Majumdar, Rupak and Nagendra, Srinidhi},
title = {Artifact for Reward Augmentation in Reinforcement Learning for Testing Distributed Systems &nbsp;Creators},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13166254},
abstract = {
    <p>The artifact provides a framework - WaypointRL - for testing
distributed protocol implementations using Reinforcement learning
methods and strategies. The framework expects an instrumented
implementation as input. The instrumentation will allow the framework to
simulate the network and pick the order of messages delivered.
Additionally, the framework will control the nodes of the distributed
system to introduce failures (stops and restarts). Apart from RL based
strategies when testing, the framework provides a generic interface to
implement any strategy as an Agent that interacts with the distributed
system Environment.</p>

},
keywords = {distributed systems, reactive systems testing, reinforcement learning}
}

@software{10.5281/zenodo.13323059,
author = {Jungmair, Michael and Engelke, Alexis and Giceva, Jana},
title = {Artifact for "HiPy: Extracting High-Level Semantics From Python Code For Data Processing"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13323059},
abstract = {
    <p>This is the artifact to the paper “HiPy: Extracting High-Level
Semantics From Python Code For Data Processing” which provides the
source code of HiPy as well as tooling, benchmarks, and Docker images to
reproduce the experiments shown in the paper.</p>

},
keywords = {Data Processing, High-Level Optimizations, Program Generation, Python}
}

@software{10.5281/zenodo.13367665,
author = {Wu, Jifeng and Lemieux, Caroline},
title = {Reproduction Package for Article `QuAC: Quick Attribute-Centric Type Inference for Python`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13367665},
abstract = {
    <p>This artifact supports the paper “QuAC: Quick Attribute-Centric Type
Inference for Python.” The artifact includes the code and data used to
generate the results presented in the paper. It aims to reproduce the
main scientific claims and facilitate future research by making the
software publicly available.</p>

},
keywords = {Gradual Typing, Python, Static Analysis, Type Inference}
}

@software{10.5281/zenodo.13368062,
author = {Liu, Jiangyi and Murphy, Charlie and Grover, Anvay and Johnson, Keith J.C. and Reps, Thomas and D’Antoni, Loris},
title = {Artifact of paper "Synthesizing Formal Semantics from Executable Interpreters"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13368062},
abstract = {
    <p>This is the artifact of paper “Synthesizing Formal Semantics from
Executable Interpreters”. It contains code for the tool Synantic as well
as benchmarks used to support our claims in the paper.</p>

},
keywords = {program synthesis, semantics, SemGuS, SMT solvers, SyGuS}
}

@software{10.5281/zenodo.13370788,
author = {Kang, Chan Gu and Lee, Joonghoon and Oh, Hakjoo},
title = {Artifact for Paper "Statistical Testing of Quantum Programs via Fixed-Point Amplitude Amplification" in OOPSLA 2024},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13370788},
abstract = {
    <p>This is Zenodo repoistory for Software Artifact of Paper “Statistical
Testing of Quantum Programs via Fixed-Point Amplitude Amplification”
appeared in in OOPSLA 2024.</p>
<p>This repository contains a PDF file of artifact manual and runnable
software artifact. Running the artifact will give:</p>
<ul>
<li>Numerical calculation shown in the Examples in the paper</li>
<li>Validation of depth cost expression (appeared in Section 6 and 7 of
the paper)</li>
<li>Producing Speed-up plots in Case Study (appeared in Section 7 of the
paper)</li>
<li>Implementation of Testing Algorithms</li>
</ul>
<p>For the further details, see the attached artifact manual. For any
questions, contact changukang@korea.ac.kr. The artifact may be continued
through following github repo: https://github.com/kupl/FpaaTestArtifact
.</p>

},
keywords = {Quantum Computing, Quantum Programming, Testing, Verification}
}

@software{10.5281/zenodo.13370814,
author = {Tan, Jinhao and Oliveira, Bruno C. d. S.},
title = {A Case for First-Class Environments (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13370814},
abstract = {
    <p>The artifact includes the Coq formalization of the paper “A Case for
First-Class Environments”.</p>

},
keywords = {First-class Environments, Mechanical Formalization, Semantics}
}

@software{10.5281/zenodo.13372573,
author = {Bembenek, Aaron and Greenberg, Michael and Chong, Stephen},
title = {Making Formulog Fast: An Argument for Unconventional Datalog Evaluation (OOPSLA'24 Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13372573},
abstract = {
    <p>Welcome to the artifact for the paper “Making Formulog Fast: An
Argument for Unconventional Datalog Evaluation” (OOPSLA’24) by Aaron
Bembenek, Michael Greenberg, and Stephen Chong. This artifact was
reviewed by the OOPSLA’24 Artifact Evaluation Committee. The artifact
includes: our extensions to Formulog and Souffl\'{e}; benchmarks and
experimental infrastructure; the data from our experiments and our data
analysis scripts; and documentation on how to build on top of our
software. To use the artifact, download the archive, extract it, and
follow the instructions in the README. If you just want to run Formulog,
you can get Formulog directly from the GitHub repo
(https://github.com/HarvardPL/formulog).</p>

},
keywords = {compilation, Datalog, Formulog, parallel evaluation, SMT solving}
}

@software{10.5281/zenodo.13373228,
author = {Ye, Wenjia and Sun, Yaozhu and Oliveira, Bruno C. d. S.},
title = {Imperative Compositional Programming (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13373228},
abstract = {
    <p>This is the artifact of the OOPSLA2024 research paper: Imperative
Compositional Programming.</p>

},
keywords = {Bidirectional Typing, Compositional Programming, Distributive Subtyping, Intersection Types, Mutable References, Type Soundness}
}

@software{10.5281/zenodo.13376916,
author = {Bowman, William J.},
title = {A Low-Level Look at A-Normal Form (artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13376916},
abstract = {
    <p>This artifact accompanies the paper A low-level look at A-normal form
(https://doi.org/10.1145/3689717). The <code>materials.tar.gz</code>
contain source files, documentation, Docker files, and assorted build
scripts. The file <code>oopsla2024-159-artifact-amd64.qcow2</code>
contains the same files, bundled as a QEMU VM image; instructions for
running it are in the gzip file.</p>

},
keywords = {A-normal form, Compilers, CPS, Intermediate Representation, Monadic Form, Normal Form, Normalization, Optimization}
}

@software{10.5281/zenodo.13377564,
author = {Jeon, Seungmin and Cho, Kyeongmin and Kang, Chan Gu and Lee, Janggun and Oh, Hakjoo and Kang, Jeehoon},
title = {Artifact for "Quantum Probabilistic Model Checking for Time-Bounded Properties"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13377564},
abstract = {
    <p>This is the artifact for OOPSLA 2024 paper: “Quantum Probabilistic
Model Checking for Time-Bounded Properties”.</p>
<p>This artifact includes the following files: - qpmc.zip: Contains the
implementation and evaluation program used to generate the results
presented in the paper. - qpmc-evaluation-results.zip: Includes the
output files generated by the evaluation program.</p>
<p>For detailed information about this artifact, please refer to the
README.md file within the qpmc.zip archive. The artifact also includes
the full paper with appendices (paper-full.pdf).</p>

},
keywords = {bounded reachability, probabilistic model checking, quantum computing}
}

@software{10.5281/zenodo.13380062,
author = {Craaijo, Jos and Verbeek, Freek and Ravindran, Binoy},
title = {Reproduction package (Docker container) for the OOPSLA 2024 article "libLISA: Instruction Discovery and Analysis on x86-64"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13380062},
abstract = {
    <p>These files accompany the OOPSLA 2024 paper ‘libLISA - Instruction
Discovery and Analysis on x86-64’.</p>
<p>This artifact consists of the following:</p>
<ul>
<li>The source code for libLISA, the tool presented in the paper.</li>
<li>The generated semantics for the five CPU architectures we
analyzed.</li>
<li>The source code for all additional tools that we used to generate
the data in Table 5, 6, 7, 8 and 9.</li>
</ul>
<p>This is all relevant source code and data necessary to reproduce all
results in the paper.</p>
<p>Please see the full guide in artifact-evaluation-guide.7z.</p>

},
keywords = {instruction enumeration, instruction semantics, synthesis}
}

@software{10.5281/zenodo.13380561,
author = {Hinrichsen, Jonas Kastberg and Jacobs, Jules and Krebbers, Robbert},
title = {Multris: Functional Verification of Multiparty Message Passing in Separation Logic - Coq Mechanization},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13380561},
abstract = {
    <p>Coq mechanization artifact for the OOPSLA’24 paper: “Multris:
Functional Verification of Multiparty Message Passing in Separation
Logic”.</p>
<p>See included README for more details.</p>

},
keywords = {Coq, Mechanization, Separation Logic}
}

@software{10.5281/zenodo.13381305,
author = {Root, Alexander J and Yan, Bobby and Liu, Peiming and Gyurgyik, Christophe and Bik, Aart J.C. and Kjolstad, Fredrik},
title = {Artifact for OOPSLA 2024 Paper: Compilation of Shape Operators on Sparse Arrays},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13381305},
abstract = {
    <p>This artifact contains the prototype Burrito compiler, all benchmarks
from the paper, and graphing scripts used to produce the figures in the
paper.</p>

},
keywords = {sparse array programming, sparse data structures, sparse iteration theory}
}

@software{10.5281/zenodo.13381352,
author = {Palmer, Zachary and Filardo, Nathaniel Wesley and Wu, Ke},
title = {Intensional Functions Virtual Machine Image},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13381352},
abstract = {
    <p>This archive contains a virtual machine image with a precompiled
version of the artifact from the paper Intensional Functions, which
appears in OOPSLA 2024 / PACMPL.</p>

},
keywords = {function, image, intensional, machine, virtual}
}

@software{10.5281/zenodo.13383121,
author = {Legoupil, Maxime and Rousseau, June and Georges, A\"{\i}na Linn and Pichon-Pharabod, Jean and Birkedal, Lars},
title = {Artifact and Appendix of 'Iris-MSWasm: elucidating and mechanising the security invariants of Memory-Safe WebAssembly'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13383121},
abstract = {
    <p>This is the artifact and appendix of the OOPSLA ‘24 paper
’Iris-MSWasm: elucidating and mechanising the security invariants of
Memory-Safe WebAssembly’. The artifact contains the coq source code as
well as a readme.md file that explains how to build the project and
where to find the different parts of the paper. The appendix is a pdf
that contains figures that were elided in the paper for space
constraints.</p>

},
keywords = {Capabilities, Coq, Encapsulation, Logical Relation, Mechanised Proofs, Memory Safety, MSWasm, Wasm, WebAssembly}
}

@software{10.5281/zenodo.13388204,
author = {Kim, Caleb and Li, Pai and Mohan, Anshuman and Butt, Andrew and Sampson, Adrian and Nigam, Rachit},
title = {Reproduction Package for "Unifying Static and Dynamic Intermediate Languages for Accelerator Generators"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13388204},
abstract = {
    <p>The artifact is a VirtualBox Image to reproduce the results for
“Unifying Static and Dynamic Intermediate Languages for Accelerator
Generators”. In particular, the artifact can be used to reproduce the
graphs and quantitative claims made in section 6 and 7 of the paper.
More detailed instructions can be found in the REAMDE.md of the
following repository: https://github.com/cucapra/calyx-resource-eval,
and more general documentation of Piezo can be found here:
https://docs.calyxir.org/.</p>
<p>The VirtualBox image consists of: - The Calyx/Piezo compiler - fud,
the compiler driver - The Dahlia compiler - The evaluation code. In
particular, it contains the scripts necessary to generate the data and
graphs used in the paper. It also contains the source code for the
benchmarks used in the paper: in particular Polybench benchmarks written
in Dahlia and PIFO tree benchmarks written in Piezo. For the systolic
arrays, fud uses a Python script to generate systolic arrays written in
Piezo. More details about fud’s systolic array generation can be found
here: https://docs.calyxir.org/frontends/systolic-array.html.</p>

},
keywords = {Accelerator Design Language, Intermediate Language}
}

@software{10.5281/zenodo.13446443,
author = {Wong, Augustine and Bucci, Paul and Beschastnikh, Ivan and Fedorova, Alexandra},
title = {NonSequitur Source Code and User Study Result Data for the paper "Making Sense of Multi-Threaded Application Performance at Scale with NonSequitur."},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13446443},
abstract = {
    <p>The artifact accompanying the paper “Making Sense of Multi-Threaded
Application Performance at Scale with NonSequitur,” which contains: The
source code for the NonSequitur visualization tool. Some additional
Python scripts and data collected/used during the user study described
in the paper.</p>
<p>This paper was accepted in the OOPSLA 2024 conference held in
Pasadena, California. The artifact is contained in the zip file
“oopsla24-ns-artifact.zip.” A detailed description of the artifact is in
the file “OOPSLA 2024 NonSequitur Artifact Doc.pdf.”</p>

},
keywords = {Multi-threaded Applications, Outlier events, Performance debugging, Runtime trace visualization}
}

@software{10.5281/zenodo.13485897,
author = {Alvarez-Picallo, Mario and Freund, Teodoro and Ghica, Dan R. and Lindley, Sam},
title = {Effect Handlers for C via Coroutines - Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13485897},
abstract = {
    <p>Artifact for the library and benchmarks described in the Effect
Handlers for C via Coroutines paper published at OOPSLA 2024.</p>

},
keywords = {C, Coroutines, Effect Handlers}
}

@software{10.5281/zenodo.13487216,
author = {Venev, Hristo and Gehr, Timon and Dimitrov, Dimitar and Vechev, Martin},
title = {Artifact for "Modular Synthesis of Efficient Quantum Uncomputation"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13487216},
abstract = {
    <p>This archive contains the artifact for the paper “Modular Synthesis
of Efficient Quantum Uncomputation”. &nbsp;It can be used to reproduce the
results in Tables 1-3.</p>

},
keywords = {intermediate representations, quantum programming languages}
}

@software{10.5281/zenodo.13502454,
author = {Bittner, Paul Maximilian and Schulthei\ss{}, Alexander and Moosherr, Benjamin and Young, Jeffrey M. and Teixeira, Leopoldo and Walkingshaw, Eric and Ataei, Parisa and Th\"{u}m, Thomas},
title = {Vatras - Artifact for the Paper "On the Expressive Power of Languages for Static Variability"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13502454},
abstract = {
    <p>Vatras is an Agda library and formalizes all results in our
paper:</p>
<ul>
<li>All formal languages for static software variability presented in
our survey (<strong>Section 3 + Table 1</strong>) are formalized as
algebraic datatypes.</li>
<li>The library implements our formal framework for language
comparisons, including necessary data structures, theorems, and proofs
(<strong>Section 4</strong>).</li>
<li>This library contains all theorems and proofs to establish the map
of variability languages we find by comparing the languages from our
survey with our framework (<strong>Section 5</strong>).</li>
</ul>
<p>Additionally, our library comes with a small demo. When run in a
terminal, our demo will show a translation roundtrip, showcasing the
circle of compilers developed for identifying the map of variability
languages (Section 5).</p>

},
keywords = {expressive power, formalization, proofs, software product lines, software variability}
}

@software{10.5281/zenodo.13599952,
author = {Somers, Thomas and Krebbers, Robbert},
title = {Artifact of 'Verified Lock-Free Session Channels with Linking'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13599952},
abstract = {
    <p>This artifact contains the Coq mechanization of the OOPSLA 2024
paper: ‘Verified Lock-Free Session Channels with Linking’. It contains
the source code, instructions for evaluating the artifact, and the
correspondence between the artifact and paper.</p>

},
keywords = {Coq, Iris, Message passing, separation logic, session types}
}

@software{10.5281/zenodo.13618225,
author = {Liu, Si and Gu, Long and Wei, Hengfeng and Basin, David},
title = {Artifact for "Plume: Efficient and Complete Black-Box Checking of Weak Isolation Levels"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13618225},
abstract = {
    <p>This artifact provides a Docker image that includes all the necessary
tools and experimental data used in the paper titled “Plume: Efficient
and Complete Black-Box Checking of Weak Isolation Levels.” The Docker
image ensures a fully configured environment to facilitate the
reproducibility of the results presented in the paper.</p>
<p>The Docker image includes:</p>
<ul>
<li>Comparison Tools: A suite of tools required for the
experiments.</li>
<li>Experimental Data: Complete datasets used in the experiments.</li>
<li>Reproduction Scripts: Scripts for reproducing the experimental
results.</li>
</ul>

},
keywords = {black-box testing, formal specification, weak isolation levels}
}

@software{10.5281/zenodo.13618683,
author = {Yi, Xin and Yu, Hengbiao and Chen, Liqian and Mao, Xiaoguang and Wang, Ji},
title = {FPCC: Detecting Floating-Point Errors via Chain Conditions (Paper Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13618683},
abstract = {
    <p>This is the artifact for “FPCC: Detecting Floating-Point Errors via
Chain Conditions”, published in SPLASH/OOPSLA 2024. All instructions can
be found in the zip file.</p>

},
keywords = {accuracy, chain condition, error-triggering input, floating-point error}
}

@software{10.5281/zenodo.13621222,
author = {Cheng, Luyu and Parreaux, Lionel},
title = {The Ultimate Conditional Syntax (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13621222},
abstract = {
    <p>This is the artifact of OOPSLA paper titled <em>The Ultimate
Conditional Syntax</em>. The latest version of the artifact can be found
at <a href="https://github.com/hkust-taco/ucs" class="uri">https://github.com/hkust-taco/ucs</a>. A online web demo can
be found at <a href="https://ucs.mlscript.dev" class="uri">https://ucs.mlscript.dev</a>. A comprehensive manual of the
artifact is located at <code>manual/manual.pdf</code> in the
archive.</p>

},
keywords = {compiler, MLscript, pattern matching, semantics, syntax, transformation, web demo}
}

@software{10.5281/zenodo.13622515,
author = {Lobo-Vesga, Elisabet and Russo, Alejandro and Gaboardi, Marco and Corti\~{n}as, Carlos Tom\'{e}},
title = {Paper Artifact: Sensitivity by Parametricity},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13622515},
abstract = {
    <p>The official artifact accompanying the OOPSLA 2024 paper “Sensitivity
by Parametricity” for the Spar library. The paper explores the use of
parametricity to perform sensitivity analysis on user-defined functions,
additionally, it introduces a Haskell library called Spar that
implements this technique. Spar encodes value distances as type-level
naturals, proving the sensitivity of a function is reduced to
type-checking! This artifact is distributed as a Docker image where the
Spar library is built and ready to use. Instructions for building the
image are provided in README.</p>

},
keywords = {differential privacy, functional programming languages, Haskell, sensitivity}
}

@software{10.5281/zenodo.13624896,
author = {Goharshady, Amir Kafshdar and Lam, Chun Kit and Parreaux, Lionel},
title = {Fast and Optimal Extraction for Sparse Equality Graphs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13624896},
abstract = {
    <p>This artifact contains the implementation of our optimal extraction
algorithm, as well as experiment with the cranelift (wasmtime)
compiler.</p>

},
keywords = {e-graphs, optimal extraction, treewidth}
}

@software{10.5281/zenodo.13625830,
author = {Yang, Ziteng and Shirako, Jun and Sarkar, Vivek},
title = {Artifact for "Fully Verified Instruction Scheduling"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13625830},
abstract = {
    <p>This is the artifact of our project in our paper Fully Verified
Instruction Scheduling: a lightweight and flexible approach.</p>
<p>The artifacts consists of two parts: mechanized proofs and
performance experiments. Evaluating the mechanized proofs only requires
software dependencies on Linux machine and the use of proof assistant
Coq. Evaluating the experiments requires an in-order Risc-V
hardware.</p>
<p>The documentations contains step-by-step building guides and a
detailed paper-to-artifact correspondence guide that matches every
lemma/theorems in our submitted paper with the mechanized proofs.</p>

},
keywords = {CompCert, Compiler Verification, Coq Proof Assistant, Instruction-level
Parallelism}
}

@software{10.5281/zenodo.13625874,
author = {Carnier, Denis and Pottier, Fran\c{c}ois and Keuchel, Steven},
title = {Type Inference Logics - Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13625874},
abstract = {
    <p>This artifact contains both sources and a prebuilt Docker image. The
sources file contains a <code>README.md</code> for navigating the source
code with instructions on how to get started. The image file contains a
Docker image compiled for AMD64 with all the necessary dependencies to
check the code with the Coq proof assistant and GHC.</p>

},
keywords = {elaboration, program verification, type inference}
}

@software{10.5281/zenodo.13626195,
author = {Nagar, Kartik and Sahoo, Anmol and Chowdhury, Romit Roy and Jagannathan, Suresh},
title = {Artifact - Automated Robustness Verification of Concurrent Data Structure Libraries Against Relaxed Memory Models},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13626195},
abstract = {
    <p>The artifact for our submission contains the implementation of the
tool (Robocop) and various library implementations tested for
robustness. Robocop is an executable program, written in Python, that
takes as input a library implementation in C and library specifications
in a text format. Internally, it parses the C code, performs the
necessary analysis to generate constraints and generates SMT calls to
Z3, to discharge whether the library is robust or not.</p>

},
keywords = {verification, weak-memory}
}

@software{10.5281/zenodo.13626469,
author = {Guan, Zhichao and Cao, Yiyuan and Yu, Tailai and Wang, Ziheng and Wang, Di and Hu, Zhenjiang},
title = {Artifact for OOPSLA'24: Semantics Lifting for Syntactic Sugar},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13626469},
abstract = {
    <p>Artifact for OOPSLA’24: Semantics Lifting for Syntactic Sugar. This
project will be maintained at
https://github.com/vbcpascal/Osazone-oopsla24.</p>

},
keywords = {Domain-specific Languages, Programming Language, Syntactic Sugar}
}

@software{10.5281/zenodo.13770453,
author = {Ma, Cong and Ge, Zhaoyi and Lee, Edward and Zhang, Yizhou},
title = {Lexical Effect Handlers, Directly (artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13770453},
abstract = {
    <p>This is the artifact accompanying the paper
<code>Lexical Effect Handlers, Directly</code>.</p>

},
keywords = {Algebraic effects, compiler correctness, continuations, effect handlers, Lexa, Salt, stack switching}
}

@software{10.6084/m9.figshare.26105056.v1,
author = {Li, Haofeng and Shi, Chenghang and Lu, Jie and Li, Lian and Xue, Jingling},
title = {Boosting the Performance of Alias-Aware IFDS Analysis with CFL-Based Environment Transformers (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.26105056.v1},
abstract = {
    <p>The IFDS algorithm is pivotal in solving field-sensitive data-flow
problems. However, its conventional use of access paths for field
sensitivity leads to the generation of a large number of data-flow
facts. This causes scalability challenges in larger programs, limiting
its practical application in extensive codebases. In response, we
propose a new field-sensitive technique that reinterprets the generation
of access paths as a CFL for field-sensitivity and formulates it as an
IDE problem. This approach significantly reduces the number of data-flow
facts generated and handled during the analysis, which is a major factor
in performance degradation.</p>
<p>To demonstrate the effectiveness of this approach, we developed a
taint analysis tool, IDEDroid, in the IFDS/IDE framework. IDEDroid
outperforms FlowDroid, an established IFDS-based taint analysis tool, in
the analysis of 24 major Android apps while improving its precision
(guaranteed theoretically). The speed improvement ranges from 2.1\texttimes{} to
2,368.4\texttimes{}, averaging at 222.0\texttimes{}, with precision gains reaching up to 20.0\%
(in terms of false positives reduced). This performance indicates that
IDEDroid is substantially more effective in detecting information-flow
leaks, making it a potentially superior tool for mobile app vetting in
the market.</p>

},
keywords = {Alias Analysis, CFL-Reachability, IDE, IFDS, Taint Analysis}
}

@software{10.1145/3672536,
author = {Kelly, Terence},
title = {Source code for "Zero Tolerance for Bias"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3672536},
abstract = {
    <p>The tarball containing this README file contains example code related to the problem of shuffling, i.e., randomly permuting a given set of items.  Compile and run the C programs in the obvious way after reading the source, noting any warnings in the comments.</p>
}
}

@software{10.1145/3580431,
author = {Lee, Edward and Zhao, Yaoyu and Lhot\'{a}k, Ond\v{r}ej and You, James and Satheeskumar, Kavin and Brachth\"{a}user, Jonathan Immanuel},
title = {Artifact for the OOPSLA 2024 paper ’Qualifying System F-sub’},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580431},
abstract = {
    <p>Mechanized proofs for the calculi described in the paper ’Qualifying System F-sub’.</p>

},
keywords = {Coq, Mechanized proofs, System F-sub-Q}
}

@software{10.1145/3580432,
author = {Lu, Kuang-Chen and Krishnamurthi, Shriram},
title = {Reproduction Package for Article `Identifying and Correcting Programming Language Behavior Misconceptions'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580432},
abstract = {
    <p>We claim in the paper (Section 7) that “we provide all the misinterpreters in the artifact.” To support this claim, this artifact provides the source code of all misinterpreters in ./Misinterpreters. In addition, we provide the source code of the reference interpreter ./Misinterpreters/smol-referential.rkt, which represents the correct conception. ./Misinterpreters contains a few other files:</p>
<ul>
<li>Metadata that makes the folder a Racket package: ./Misinterpreters/info.rkt</li>
<li>The definitions of AST and a parser (from S-expressions to AST): ./Misinterpreters/smol-syntax.rkt and ./Misinterpreters/parse.rkt</li>
<li>Shared helper functions for all (mis)interpreters: ./Misinterpreters/utilities.rkt</li>
</ul>
<p>We present statistical results in the paper. Though not promised in the paper, to support all those claims, this artifact also provides an R Markdown ./Paper.Rmd that computes (most of) the numbers, generates the figures, and performs the hypothesis tests. For numbers that cannot be computed, the R Markdown gives justification.</p>
<p>./Paper.Rmd depends on the ./SMoL Tutor folder, which includes</p>
<ul>
<li>Metadata about SMoL Tutor: ./SMoL Tutor/Tasks.csv and ./SMoL Tutor/Choices.csv</li>
<li>Data collected by SMoL Tutor: ./SMoL Tutor/Datasets/</li>
<li>A script that tags wrong answers with misinterpreters: ./SMoL Tutor/Tag_Answers.rkt</li>
</ul>

},
keywords = {automated interactive tutors, misconceptions, program behavior/semantics}
}

@software{10.5281/zenodo.10452601,
author = {Yuan, Charles and Villanyi, Agnes and Carbin, Michael},
title = {Artifact for Quantum Control Machine: The Limits of Control Flow in Quantum Programming},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10452601},
abstract = {
    <p>This artifact contains an implementation of a simulator for the quantum control machine and the programs from the case study as presented in the paper.</p>

},
keywords = {quantum instruction set architectures, quantum programming languages}
}

@software{10.5281/zenodo.10457566,
author = {Chatterjee, Krishnendu and Goharshady, Amir Kafshdar and Meggendorfer, Tobias and \v{Z}ikeli\'{c}, undefinedor\dj{}e},
title = {Artefact for: Quantitative Bounds on Resource Usage of Probabilistic Programs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10457566},
abstract = {
    <p>The artefact for the OOPSLA 2024 paper “Quantitative Bounds on Resource Usage of Probabilistic Programs”.</p>

},
keywords = {Cost Analysis, Martingales, Probabilistic Programming, Quantitative Bounds, Static Analysis}
}

@software{10.5281/zenodo.10463878,
author = {Yadavally, Aashish and Li, Yi and Wang, Shaohua and Nguyen, Tien N.},
title = {Artifact for "A Learning-Based Approach to Static Program Slicing"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10463878},
abstract = {
    <p>NS-Slicer is a learning-based static program slicing tool, which extends such an analysis to partial Java programs. The source code, data, and model artifacts are publicly available on GitHub (https://github.com/aashishyadavally/ns-slicer), and Zenodo (https://zenodo.org/records/10463878).</p>

},
keywords = {AI4SE, Debugging, Neural Networks, Pre-Trained Language Models, Static Slicing, Vulnerability Detection}
}

@software{10.5281/zenodo.10517828,
author = {Avanzini, Martin and Barthe, Gilles and Gr\'{e}goire, Benjamin and Moser, Georg and Vanoni, Gabriele},
title = {ehoare},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10517828},
abstract = {
    <p>This artifact provides a docker image that contains a working installation of Easycrypt together with three proof scripts related to the examples given in the paper.</p>
<ul>
<li><code>qselect.ec</code> contains the formalisation of quickselect from Section 3. It relies on an auxiliary library <code>partition.eca</code> concerned with properties of the partitioning scheme.</li>
<li><code>skip_list.ec</code> contains the formalisation of skip-lists outlined in Section 6</li>
<li><code>adversary.ec</code> contains the prototypical cryptography proof example outlined in Section 7</li>
</ul>

},
keywords = {expectation logic, skip list}
}

@software{10.5281/zenodo.10609061,
author = {Zhang, Chi and Wang, Linzhang and Rigger, Manuel},
title = {Artifact for "Finding Cross-rule Optimization Bugs in Datalog Engines"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10609061},
abstract = {
    <p>The artifact consists of two main components:</p>
<p>1、The source code of the tool Datalog Engine Optimization Tester (Deopt), which we used to find all of the bugs presented in our paper. 2、The data and reproduce documents for the results of the evaluation in the paper.</p>

},
keywords = {cross-rule optimization bugs, Datalog engine testing, test oracle}
}

@software{10.5281/zenodo.10701642,
author = {Ye, Qianchuan and Delaware, Benjamin},
title = {Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation: OOPSLA24 Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10701642},
abstract = {
    <p>This is the artifact for the OOPSLA24 paper “Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation”. It contains:</p>
<ul>
<li>README.md: artifact instructions in markdown format</li>
<li>README.pdf: artifact instructions in pdf format</li>
<li>taypsi-image-amd64.tar.xz: docker image for amd64 (x86_64) architecture</li>
<li>taypsi-image-arm64.tar.xz: docker image for arm64 architecture</li>
<li>Dockerfile: docker file used to generate the docker images</li>
<li>taypsi.tar.xz: source code of the Taypsi type checker, compiler, examples and benchmarks</li>
<li>taype-pldi.tar.xz: source code of the Taype type checker and compiler (PLDI23), extended with additional benchmarks for comparison with Taypsi</li>
<li>taype-sa.tar.xz: source code of a version of Taype with an additional optimization (smart array) for a fairer comparison with Taypsi</li>
<li>taype-drivers.tar.xz: source code of drivers that implement the cryptographic primitives and oblivious array, used by taypsi and taype-sa</li>
<li>taype-drivers-legacy.tar.xz: source code of the drivers used by taype-pldi</li>
<li>taypsi-theories.tar.xz: Coq formalization of the Taypsi core calculus</li>
<li>taype-vscode.tar.xz: source code of a VS Code extension that provides basic syntax highlighting for Taypsi programs</li>
</ul>
<p>To evaluate this artifact, you only need to download the docker image for your architecture. Other tarballs provide clean versions of the source code, but you do not need them for evaluation. See README.md / README.pdf for details about this artifact and evaluation instructions. The same README.md is also available in the docker images.</p>

},
keywords = {Algebraic Data types, Coq Proof Assistant, Dependent Types, Oblivious Computation, Secure Multiparty Computation}
}

@software{10.5281/zenodo.10774458,
author = {Sundram, Shiv and Tariq, Muhammad Usman and Kjolstad, Fredrik},
title = {Artifact for OOPSLA 2024 Paper: Compiling Recurrences over Dense and Sparse Arrays (version 1)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10774458},
abstract = {
    <p>This is a docker container containing the artifact for the OOPSLA 2024 accepted paper “Compiling Recurrences over Dense and Sparse Arrays” by Shiv Sundram, Muhammad Usman Tariq, Fredrik Kjolstad</p>
<p>Directions for running artifact and reproducing the paper’s figures can be found in the Getting Started Guide:</p>
<p>https://docs.google.com/document/d/1YCC8AskQYFQfUQ1_jtW2OOqWrT9-qpizTR4BUmbYBXQ/edit?usp=sharing</p>

},
keywords = {Domain specific languages, Recurrences, Software and its engineering, Source code generation}
}

@software{10.5281/zenodo.10775922,
author = {Chen, Zhe and Zhu, Yunlong and Wang, Zhemin},
title = {Reproduction Package for Article `Design and Implementation of an Aspect-Oriented C Programming Language'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10775922},
abstract = {
    <p>The artifact contains the Movec compiler for Aclang and all the benchmarks used in our experiments. The purpose of the artifact is to reproduce the experiments in Section 7 and support the main claims in the paper.</p>

},
keywords = {aspect-oriented programming, C language, compiler, instrumentation, semantics, transformation}
}

@software{10.5281/zenodo.10777503,
author = {Paradis, Anouk and Dekoninck, Jasper and Bichsel, Benjamin and Vechev, Martin},
title = {Reproduction Package for the Article "Synthetiq: Fast and Versatile Quantum Circuit Synthesis"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10777503},
abstract = {
    <p>This artifact contains the code for the paper ‘Synthetiq: Fast and Versatile Quantum Circuit Synthesis’. Synthetiq is a tool to synthesize quantum circuits implementing a given (partial) specification over arbitrary finite gate sets and is faster and more versatile than existing works.</p>
<p>This artifact contains: - the code of our tool Synthetiq and installation instructions; - precise instructions to reproduce our evaluation; - usage guide to use Synthetiq on new operators; - all quantum circuits found by Synthetiq and mentioned in the paper.</p>

},
keywords = {Clifford+T, Quantum Circuits, Synthesis}
}

@software{10.5281/zenodo.10779424,
author = {Binder, David and Skupin, Ingo and S\"{u}berkr\"{u}b, Tim and Ostermann, Klaus},
title = {Artifact for the article "Deriving Dependently-Typed OOP from First Principles"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10779424},
abstract = {
    <p>Contained in the artifact is a Rust implementation of a dependently-typed programming language. This implementation contains a typechecker as well as an LSP server, VScode plugin and the infrastructure necessary to produce a static website in which snippets from the programming language can be typechecked in the browser. The language server provides a code action which can transform any codata type into a data type using defunctionalization, and any data type into a codata type using refunctionalization.</p>

},
keywords = {algebraic data types, codata, defunctionalization, dependent types, refunctionalization}
}

@software{10.5281/zenodo.10782412,
author = {Klinkenberg, Lutz and Blumenthal, Christian and Chen, Mingshuai and Haase, Darion and Katoen, Joost-Pieter},
title = {Exact Bayesian Inference for Loopy Probabilistic Programs using Generating Functions - Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10782412},
abstract = {
    <p>The artifact includes a Docker image with the Prodigy tool and program examples that were used for the benchmarks in the paper. It includes scripts and documentation to allow for easy replication of the presented benchmark results.</p>

},
keywords = {Bayesian inference, conditioning, denotational semantics, generating functions, non-termination, probabilistic programs, quantitative verification}
}

@software{10.5281/zenodo.10791709,
author = {Wang, Di and Reps, Thomas},
title = {Newtonian Program Analysis of Probabilistic Programs (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10791709},
abstract = {
    <p>This artifact provides a prototype implementation of the framework of Newtonian Program Analysis with Pre-Markov Algebras (NPA-PMA). NPA-PMA is an interprocedural dataflow-analysis framework for designing and implementing (partially) non-iterative program analyses of probabilistic programs with unstructured control-flow, nondeterminism, and general recursion. To demonstrate the usage of NPA-PMA, this artifact also includes five instantiations for four analyses: Bayesian-inference analysis, higher-moment analysis of accumulated rewards, expectation-invariant analysis, and expectation-recurrence analysis.</p>

},
keywords = {Algebraic Program Analysis, Interprocedural Program Analysis, Newton's Method, Probabilistic Programs}
}

@software{10.5281/zenodo.10794350,
author = {Smith, Scott and Zhang, Robert},
title = {Software Artifact for A Pure Demand Operational Semantics with Applications to Program Analysis},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10794350},
abstract = {
    <p>This artifact facilitates building, testing, benchmarking, and evolving the interpreter and program analyses presented in the paper.</p>

},
keywords = {Higher-Order Functional Programming, Operational Semantics, Program Analysis}
}

@software{10.5281/zenodo.10796440,
author = {Alshnakat, Anoud and Lundberg, Didrik and Guanciale, Roberto and Dam, Mads},
title = {OOPSLA 2024 Artifact: HOL4P4: Mechanized Small-Step Semantics for P4},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10796440},
abstract = {
    <p>For a detailed description of this artifact, see OVERVIEW.md or OVERVIEW.pdf among the files.</p>
<p>HOL4P4-OOPSLA2024-source.tar.gz is a compressed directory with the source code, and hol4p4-amd64.tar.gz and hol4p4-aarch64.tar.gz are compressed Docker images for x86_64-based and ARM64-based CPUs, respectively.</p>

},
keywords = {formal verification, interactive theorem proving, P4, programming language semantics}
}

@software{10.5281/zenodo.10796555,
author = {Stjerna, Amanda and R\"{u}mmer, Philipp},
title = {Reproduction Package for `A Constraint Solving Approach to Parikh Images of Regular Languages'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10796555},
abstract = {
    <p>This is a reproduction and software package for A Constraint Solving Approach to Parikh Images of Regular Languages, published in OOPSLA 2024. For more information, see Artifact Overview.md.</p>
<p>It contains all software developed for the paper, as well as Jupyter notebooks for analysing experiments and relevant scripts for building them.</p>

},
keywords = {automata, automated theorem proving, parikh automata, parikh images, regular languages, SMT, string solving}
}

@software{10.5281/zenodo.10797791,
author = {Marshall, Daniel and Orchard, Dominic},
title = {Functional Ownership through Fractional Uniqueness (Artefact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10797791},
abstract = {
    <p>Artifact for the paper of the same title that appears at OOPSLA 2024. Includes code examples in both Granule and Rust. See overview.pdf for more information.</p>

},
keywords = {borrowing, fractional permissions, graded modal types, ownership}
}

@software{10.5281/zenodo.10798266,
author = {Kravchuk-Kirilyuk, Anastasiya and Feng, Gary and Iskander, Jonas and Zhang, Yizhou and Amin, Nada},
title = {Persimmon: Nested Family Polymorphism with Extensible Variant Types (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10798266},
abstract = {
    <p>Our implementation consists of the Persimmon type checker and our prototype compiler to Scala.</p>

},
keywords = {composable extensions, extensibility, family polymorphism, nested inheritance, Persimmon}
}

@software{10.5281/zenodo.10798571,
author = {Crichton, Will and Krishnamurthi, Shriram},
title = {Artifact for "Profiling Programming Language Learning"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10798571},
abstract = {
    <p>These are Docker images that contain the codebase, data, and analysis scripts for our OOPSLA 2024 paper “Profiling Programming Language Learning”.</p>

},
keywords = {digital textbooks, item response theory, rust education}
}

@software{10.5281/zenodo.10798978,
author = {Lamba, Ada and Taylor, Max and Beardsley, Vincent and Bambeck, Jacob and Bond, Michael D. and Lin, Zhiqiang},
title = {Implementation for "Cocoon: Static Information Flow Control in Rust"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10798978},
abstract = {
    <p>Cocoon is a Rust library that provides types and mechanisms for statically enforcing information flow control in Rust programs. Cocoon is currently intended to prevent programmer errors such as accidentally leaking a “private” value to an untrusted function or other value. Cocoon does not currently address dynamic labels, integrity labels, OS integration, or leaks caused by other means such as side-channel attacks.</p>
<p>This artifact contains the Cocoon library itself, all examples presented in the paper, and evaluation scripts.</p>

},
keywords = {information flow control, Rust, type and effect systems}
}

@software{10.5281/zenodo.10814650,
author = {Enea, Constantin and Koskinen, Eric},
title = {CION: Concurrent Trace Reductions},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10814650},
abstract = {
    <p>A proof-of-concept implementation to automatically generate candidate layer quotient automata directly form the source code of concurrent object implementations. See f OOPSLA 2024 paper, “Scenario-Based Proofs for Concurrent Objects”.</p>

},
keywords = {concurrent objects, layer quotients, linearizability, proofs of concurrent objects, Quotients}
}

@software{10.5281/zenodo.10897277,
author = {Zhang, Yifan and Shi, Yuanfeng and Zhang, Xin},
title = {Learning Abstraction Selection for Bayesian Program Analysis (Paper Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10897277},
abstract = {
    <p>Our artifact includes all code, scripts, data, and statistics in our experiments. It supports the following things: 1. Reproduction of all results in our experiments automatically. 2. Transformation from the results to Tables 7-11 and Figures 8-10 in our paper automatically. 3. Reusability guide for applying BinGraph framework to other settings and extensions.</p>

},
keywords = {abstract interpretation, alarm ranking, Bayesian network, machine learning for program analysis, Static analysis}
}

@software{10.6084/m9.figshare.25365340.v1,
author = {Ryan, Gabriel and Cetin, Burcu and Lim, Yongwhan and Jana, Suman},
title = {HBFourier Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.25365340.v1},
abstract = {
    <p>Replication artifact for paper “Accurate Data Race Prediction in the Linux Kernel through Sparse Fourier Learning” to appear in OOPSLA 2024. The artifact contains HBFourier’s core implementation as a well as scripts for reproducing all results presented in the paper.</p>

},
keywords = {Data Race Prediction, Linux Kernel, Machine Learning, Spectral Method}
}

@software{10.5281/zenodo.10440364,
author = {Michelland, S\'{e}bastien and Deleuze, Christophe and Gonnord, Laure},
title = {Replication package for article: From low-level fault modeling (of a pipeline attack) to a proven hardening scheme},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10440364},
abstract = {
    <p>This software package is the Docker image of a project about protecting RISC-V processors against certain low-level fault attacks. It mainly contains a modified LLVM, GNU binutils, QEMU, and test scripts.</p>
<p>Project repository from which this image is built: https://gricad-gitlab.univ-grenoble-alpes.fr/michelse/fetch-skips-hardening</p>
<p>Instructions for using this software and reproducing results: https://gricad-gitlab.univ-grenoble-alpes.fr/michelse/fetch-skips-hardening/-/blob/main/README.md?ref_type=heads</p>

},
keywords = {Compilation, LLVM, Software fault resistance}
}

@software{10.5281/zenodo.10457086,
author = {Salvador Rohwedder, Caio and L. De Carvalho, Jo\~{a}o P. and Amaral, Jos\'{e} Nelson},
title = {Artifact of "Region-Based Data Layout via Data Reuse Analysis"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10457086},
abstract = {
    <ul>
<li>docker-artifact.tar.gz: docker image for the execution of experiments.</li>
<li>results.zip: log files, graphs, and tables that were used in the paper, as well as additional figures/tables not shown in the paper due to space constraints.</li>
<li>region-packing-pass.zip: source code for the out-of-tree LLVM implementation of the analysis that finds region-based data layout transformation candidates (.so file in docker image).</li>
<li>region-packing-scripts.zip: scripts used to run experiments and Dockerfile source (also provided in docker image).</li>
<li>artifact-appendix.pdf: Instructions on how to use this artifact.</li>
</ul>

},
keywords = {Data-Layout Transformation, LLVM, Structure Splitting}
}

@software{10.5281/zenodo.10525151,
author = {Dura, Alexandru and Reichenbach, Christoph},
title = {Reproduction Package for 'Clog: A Declarative Language for C Static Code Checkers'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10525151},
abstract = {
    <p>Clog is a declarative language for describing static code checkers for C. Clog is a dialect of Datalog and adds syntactic pattern matching over the C language. We have built Clog using the MetaDL framework and the Clang C compiler frontend. The MetaDL framework supports Datalog evaluation and syntactic patterns, while the Clang frontend provides AST facts and an AST matching mechanism.</p>
<p>We provide the Clog artifact as a Docker image. The artifact contains the Clog implementation, the evaluation framework and the test suites we have used in our evaluation.</p>

},
keywords = {C, Datalog, Static Analysis Frameworks, Syntactic Patterns}
}

@software{10.5281/zenodo.10566216,
author = {Li, Wei and He, Dongjie and Gui, Yujiang and Chen, Wenguang and Xue, Jingling},
title = {Artifact for "A Context-Sensitive Pointer Analysis Framework for Rust and Its Application to Call Graph Construction"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10566216},
abstract = {
    <p>This is the artifact for the CC’24 paper titled “A Context-Sensitive Pointer Analysis Framework for Rust and Its Application to Call Graph Construction”. It includes a docker image and a READEME file.</p>

},
keywords = {Call Graph Construction, Pointer Analysis, Rust}
}

@software{10.5281/zenodo.10567311,
author = {Mavrogeorgis, Nikolaos and Vasiladiotis, Christos and Mu, Pei and Khordadi, Amir and Franke, Bj\"{o}rn and Barbalace, Antonio},
title = {Reproduction Package for Article 'UNIFICO: Thread Migration in Heterogeneous-ISA CPUs without State Transformation'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10567311},
abstract = {
    <p>Artifact of the paper “UNIFICO: Thread Migration in Heterogeneous-ISA CPUs without State Transformation”. - unificocc24-unifico.tar.gz: docker image for the execution of experiments - llvm-unifico.tar.gz: LLVM source code with Unifico implementation (binaries in docker image) - unifico.tar.gz: scripts used to run experiments, the NPB benchmark suite, logs, plots, and Dockerfile source (also provided in docker image)</p>
<ul>
<li>figures.tar.gz: generated result plots from the paper</li>
</ul>

},
keywords = {Compilers, Computer Systems, LLVM}
}

@software{10.5281/zenodo.10570638,
author = {Zhu, Yifan and Cat, Quartic and Ge, Boluo and Sun, Shaotong},
title = {Paguroidea: Fused Parser Generator with Transparent Semantic Actions},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10570638},
abstract = {
    <p>This artifact provides source code and detailed guidance on building and benchmarking the Paguroidea parser generator. Paguroidea integrates lexer-parser fusion alongside a unique transparent encoding of semantic actions, delivering flexibility and performance. Developed using the Rust programming language, the Paguroidea enjoys good portability. Therefore, the setup process and the acquisition of results would not require too much effort.</p>

},
keywords = {compiler, context-free grammar, parser, parser generator, substructural logic}
}

@software{10.5281/zenodo.10571103,
author = {Drescher, Florian and Engelke, Alexis},
title = {Artifact for CC'24 paper on "Fast Template-Based Code Generation for MLIR"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10571103},
abstract = {
    <p>The artifact contains the sources for building the template-based MLIR compiler and the dependent LLVM sources (commit 5d4927 with some modifications). It compiles and executes MLIR programs consisting of supported operations (multiple sample programs are included; similar to mlir-cpu-runner); on first execution, it generates required templates and persists them. Furthermore, the artifact contains the modified sources for LingoDB with integrated template-based code-generation backend and Polygeist (commit fd4194b) for conversion of C files to MLIR upstream dialect operations. Sample MLIR programs and scripts for preparing/running the benchmarks from Figures 2-5 are attached.</p>

},
keywords = {Binary Code Patching, Fast Compilation, JIT Compilation, MLIR, Template-based Compilation}
}

@software{10.5281/zenodo.10574579,
author = {VenkataKeerthy, S. and Jain, Siddharth and Kalvakuntla, Umesh and Gorantla, Pranav Sai and Chitale, Rajiv Shailesh and Brevdo, Eugene and Cohen, Albert and Trofin, Mircea and Upadrasta, Ramakrishna},
title = {ML-Compiler-Bridge: The Next 700 ML-Enabled Compiler Optimizations},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10574579},
abstract = {
    <p>This artifact corresponds to the tool described in the paper, “The Next 700 ML-Enabled Compiler Optimizations”, published in CC 2024.</p>
<p>Please visit our project page - https://compilers.cse.iith.ac.in/publications/mlcompilerbridge for the latest version of ML-Compiler-Bridge.</p>

},
keywords = {Compilers, ML-based Compiler Optimizations}
}

@software{10.5281/zenodo.10577943,
author = {Mu, Pei and Mavrogeorgis, Nikolaos and Vasiladiotis, Christos and Tsoutsouras, Vasileios and Kaparounakis, Orestis and Stanley-Marbell, Phillip and Barbalace, Antonio},
title = {CoSense Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10577943},
abstract = {
    <p>The artifact of CoSense, which is a CC’2024 paper.</p>

},
keywords = {compiler optimizations, embedded systems, interval arithmetic, sensors, value interval propagation}
}

@software{10.1145/3643873,
author = {Kelly, Terence},
title = {Source code for "Programmer Job Interviews"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3643873},
abstract = {
    <p>The tarball containing this README file provides several programs that illustrate different ways of solving the FIFO State Penitentiary problem discussed in my Drill Bits column on programmer job interview questions.  Read that column first.  This README file explains how the example programs work, how to compile and run them, and the insights we gain from implementing solutions --- insights that we might overlook if we merely design a solution without writing code.</p>
}
}

@software{10.5281/zenodo.10160153,
author = {Park, Sungwoo and Oh, Seyeon and Kim, Min-Soo},
title = {INFINEL: An efficient GPU-based processing method for unpredictable large output graph queries},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10160153},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10213773,
author = {Hu, Siyu and Zhao, Tong and Sha, Qiuchen and Li, Enji and Meng, Xiangyu and Liu, Liping and Wang, Lin-Wang and Tan, Guangming and Jia, Weile},
title = {Training one DeePMD Model in Minutes: a Step towards Online Learning},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10213773},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10222938,
author = {Wheatman, Brian and Burns, Randal and Buluc, Aydin and Xu, Helen},
title = {CPMA: An Efficient Batch-Parallel Compressed Set Without Pointers},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10222938},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10223442,
author = {Muller, Stefan K},
title = {Language-Agnostic Static Deadlock Detection for Futures},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10223442},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10224742,
author = {Li, Yifei and Zhou, Bole and Zhang, Jiejing and Wei, Xuechao and Li, Yinghan and Chen, Yingda},
title = {POSTER: RadiK: Scalable Radix Top-K Selection on GPUs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10224742},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10225523,
author = {Chen, Yuetao and Li, Kun and Wang, Yuhao and Bai, Donglin and Wang, Lei and Ma, Lingxiao and Yuan, Liang and Zhang, Yunquan and Cao, Ting and Yang, Mao},
title = {ConvStencil: Transform Stencil Computation to Matrix Multiplication on Tensor Cores},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10225523},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10225634,
author = {Park, Seongyeon and Hong, Junguk and Song, Jaeyong and Kim, Hajin and Kim, Youngsok and Lee, Jinho},
title = {AGAThA: Fast and Efficient GPU Acceleration of Guided Sequence Alignment for Long Read Mapping},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10225634},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10226261,
author = {Kim, Daewoo and Brown, Trevor and Singh, Ajay},
title = {Are Your Epochs Too Epic? Batch Free Can Be Harmful},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10226261},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10252149,
author = {Dong, Xiaojun and Dhulipala, Laxman and Gu, Yan and Sun, Yihan},
title = {Parallel Integer Sort: Theory and Practice},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10252149},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10253798,
author = {Liu, Quanquan C. and Shun, Julian and Zablotchi, Igor},
title = {Parallel k-Core Decomposition with Batched Updates and Asynchronous Reads},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10253798},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10257908,
author = {Khalaji, Mohammad and Brown, Trevor and Daudjee, Khuzaima and Aksenov, Vitaly},
title = {Practical Hardware Transactional vEB Trees},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10257908},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10430776,
author = {Bhosale, Akshay and Eigenmann, Rudolf},
title = {Recurrence Analysis for Automatic Parallelization of Subscripted Subscripts},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10430776},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10433852,
author = {Ma, Lixian and Chen, Haoruo and Shao, En and Wang, Leping and Chen, Quan and Tan, Guangming},
title = {POSTER: FineCo: Fine-grained Heterogeneous Resource Management for Concurrent DNN Inferences},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10433852},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10437290,
author = {Lin, Zhiheng and Meng, Ke and Shui, Chaoyang and Zhang, Kewei and Xiao, Junmin and Tan, Guangming},
title = {Exploiting Fine-Grained Redundancy in Set-Centric Graph Pattern Mining},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10437290},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10447532,
author = {Blelloch, Guy E. and Wei, Yuanhao},
title = {VERLIB: Concurrent Versioned Pointers},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10447532},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10449841,
author = {Liu, Xiaoyan and Zheng, Xuegui and Yang, Hailong and Luan, Zhongzhi and Qian, Depei},
title = {Tetris: Accelerating Sparse Convolution by Exploiting Memory Reuse on GPU},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10449841},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10475796,
author = {McCoy, Hunter and Pandey, Prashant},
title = {Gallatin: A General-Purpose GPU Memory Manager},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10475796},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10531146,
author = {Ahmad, Zafar and Browne, Reilly and Chowdhury, Rezaul and Das, Rathish and Huang, Yushen and Zhu, Yimin},
title = {Fast American Option Pricing using Nonlinear Stencils},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10531146},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.6084/m9.figshare.24803229,
author = {Jangda, Abhinav and Yadav, Mohit},
title = {Fast Kronecker Matrix-Matrix Multiplication on GPUs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24803229},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.1145/3626492,
author = {Kelly, Terence},
title = {Source code for "Protecting Secrets from Computers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3626492},
abstract = {
    <p>The column argues that secrets should be protected from contact with computers and software. In that spirit, I recommend that you prevent the software associated herewith from seeing secrets of any kind. Use this example code only to check your practice work with paper-and-pencil methods, and for amusement.</p>
}
}

@software{10.5281/zenodo.7921796,
author = {Shen, Mingjie and Davis, James C. and Machiry, Aravind},
title = {Reproduction Package for Article `Towards Automated Identification of Layering Violations in Embedded Applications (WIP)'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7921796},
abstract = {
    <p>This is a tool to detect layering violations in embedded applications. The tool uses LLVM and requires a bitcode file of the target application.</p>
<p>Specifically, given a bitcode file, our tool will generate the list of all NCMAs (a type of layering violations).</p>

},
keywords = {Embedded Systems, Firmware, Hardware Abstraction Layer, Portability, Static Analysis}
}

@software{10.5281/zenodo.7939291,
author = {Rommel, Florian and Dietrich, Christian and Ziegler, Andreas and Ostapyshyn, Illia and Lohmann, Daniel},
title = {Thread-Level Attack-Surface Reduction - Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7939291},
abstract = {
    <p>This artifact contains the raw data of the evaluation results and the necessary programs and scripts to repeat the experiments and analyses of the paper “Thread-Level Attack-Surface Reduction”, presented at the 24th ACM SIGPLAN/SIGBED International Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES 2023). See https://doi.org/10.1145/3589610.3596281</p>

},
keywords = {binary tailoring, debloating, return-oriented programming}
}

@software{10.5281/zenodo.7703209,
author = {Alzayat, Mohamed and Mace, Jonathan and Druschel, Peter and Garg, Deepak},
title = {Accompanying artifact for the paper "Groundhog: Efficient Request Isolation in FaaS"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7703209},
abstract = {
    <p>Groundhog is a lightweight in-memory snapshot and restore tool that enforces sequential request isolation in Function-as-a-Service (FaaS).
In FaaS each function executes in its own container&nbsp;to isolate concurrent executions of different functions from one another. However, successive invocations of the same function commonly reuse the runtime state of a previous invocation in order to avoid container cold-start delays when invoking a function. Although efficient, this container reuse has security implications for functions that are invoked on behalf of differently privileged users or administrative domains: bugs in a function's implementation --- or a third-party library/runtime it depends on --- may leak private data from one invocation of the function to subsequent invocations of the same function.
Groundhog isolates sequential invocations of a function by efficiently reverting to a clean state, free from any private data, after each invocation. The system exploits two properties of typical FaaS platforms: each container executes at most one function at a time and legitimate functions do not retain state across invocations. This enables Groundhog to efficiently snapshot and restore function state between invocations in a manner that is independent of the programming language/runtime and does not require any changes to existing functions, libraries, language runtimes, or OS kernels.
Please visit&nbsp;https://groundhog.mpi-sws.org/ for the latest version and documentation of Groundhog.</p>
}
}

@software{10.5281/zenodo.7703530,
author = {Jeong, Jinwoo and Baek, Seungsu and Ahn, Jeongseob},
title = {Accompanying artifact for the paper "Fast and Efficient Model Serving Using Multi-GPUs with Direct-Host-Access"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7703530},
abstract = {
    <p>This is the artifact of the paper: "Fast and Efficient Model Serving Using Multi-GPUs with Direct-Host-Access" to appear in 'EuroSys 2023'. This artifact includes the DeepPlan tool generating the inference execution plans for given DNN models, the libTorch execution engine guided by the generated plans, and the DL inference server prototype powered by our libTorch engine. It also includes the DNN workloads used in our paper and script files to set up and test our artifact.</p>
}
}

@software{10.5281/zenodo.7704577,
author = {Yoon, Wonsup and Ok, Jisu and Oh, Jinyoung and Moon, Sue and Kwon, Youngjin},
title = {Accompanying artifact for the paper "DiLOS: Do Not Trade Compatibility for Performance in Memory Disaggregation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7704577},
abstract = {
    <p>DiLOS: Do Not Trade Compatibility for Performance in Memory Disaggregation (Artifact)
&nbsp;
See README.md.</p>
}
}

@software{10.5281/zenodo.7719328,
author = {Narayanan, Vikram and Detweiler, David and Huang, Tianjiao and Burtsev, Anton},
title = {Accompanying artifact for the paper "DRAMHiT: A Hash Table Architected for the Speed of DRAM"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7719328},
abstract = {
    <p>Artifact evaluation for the paper "DRAMHiT: A Hash Table Architected for the Speed of DRAM" (Eurosys 2023)</p>
}
}

@software{10.5281/zenodo.7726172,
author = {Tang, Lilia and Bhandari, Chaitanya and Zhang, Yongle and Karanika, Anna and Ji, Shuyang and Gupta, Indranil and Xu, Tianyin},
title = {Accompanying artifact for the paper "Fail through the Cracks: Cross-System Interaction Failures in Modern Cloud Systems"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7726172},
abstract = {
    <p>EuroSys '23 artifact for&nbsp;Fail through the Cracks: Cross-System Interaction Failures in Modern Cloud Systems</p>
}
}

@software{10.5281/zenodo.7734495,
author = {Gupta, Suyash and Rahnama, Sajjad and Pandey, Shubham and Crooks, Natacha and Sadoghi, Mohammad},
title = {Accompanying artifact for the paper "Dissecting BFT Consensus: In Trusted Components we Trust!"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7734495},
abstract = {
    <p>Creating a persistent release using Zenodo.</p>
}
}

@software{10.5281/zenodo.7737994,
author = {Lim, Hwijoon and Kim, Jaehong and Cho, Inho and Jang, Keon and Bai, Wei and Han, Dongsu},
title = {Accompanying artifact for the paper "FlexPass: A Case for Flexible Credit-based Transport for Datacenter Networks"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7737994},
abstract = {
    <p>Official Github repository for the EuroSys '23 paper "FlexPass: A Case for Flexible Credit-based Transport for Datacenter Networks"</p>
}
}

@software{10.6084/m9.figshare.22223914.v1,
author = {Zhang, Jian and Ji, Ye and Mu, Shuai and Tan, Cheng},
title = {Accompanying artifact for the paper "Viper: A Fast Snapshot Isolation Checker"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.22223914.v1},
abstract = {
    <p>Viper is an SI checker that is sound, complete, and fast. Viper checks black-box databases and hence is transparent to both users and databases.</p>
}
}

@software{10.1145/3594731,
author = {Kelly, Terence},
title = {Source code for Drill Bits 9 article "Catch-23: The New C Standard Sets the World on Fire"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3594731},
abstract = {
    <p>File stack.c contains the code shown in Figure 1 of my column, which illustrates idiomatic use of standard C realloc(). The stack assumes a sane "zero-null" memory allocator, i.e., a memory allocator that works the way C89 and C99 strongly recommended: Zero-length allocation requests return NULL, which means that realloc(p,0) unconditionally frees p and returns NULL and cannot fail.  Standards from C89 through C17 have *permitted* zero-null implementations of the standard library but have not *required* zero-null behavior.  Historically, many wise and good implementations have followed the zero-null rule.  Unfortunately, some implementations have done otherwise.</p>
}
}

@software{10.1145/3594732,
author = {Kelly, Terence},
title = {Source code for "Persistent Memory Programming on Conventional Hardware"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3594732},
abstract = {
    <p>"famus" is "failure-atomic msync() in user space", a library for C/C++ applications on Linux that provides an interface similar to conventional POSIX mmap()/msync() but with stronger semantics.  Like its conventional counterpart, famus enables applications to manipulate a backing file via LOADs and STOREs to the file's in-memory image.  However, unlike conventional mmap()/msync(), famus provides a strong fault tolerance guarantee: Following recovery, the state of the backing file will always reflect the most recent successful sync operation, even in the presence of failures such as power outages, OS kernel panics, and application process crashes.</p>
}
}

@software{10.1145/3594733,
author = {Kelly, Terence},
title = {Source code for "Is Persistent Memory Persistent?"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3594733},
abstract = {
    <p>This file contains instructions for running sudden whole-system power interruption tests on a Raspberry Pi 3 Model B+, as described in the accompanying article.</p>
}
}

@software{10.1145/3554353,
author = {Landgraf, Joshua and Giordano, Matthew and Yoon, Esther and Rossbach, Christopher J.},
title = {File System for Reconfigurable Fabrics Codebase},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554353},
abstract = {
    <p>This artifact contains the software and hardware code for FSRF, File System for Reconfigurable Fabrics, along with corresponding scripts and documentation for preparing test data, setting up the system, and running workloads and experiments.</p>

},
keywords = {FPGAs, Operating Systems, Virtual Memory, Virtualization}
}

@software{10.5281/zenodo.7564087,
author = {Feng, Yuan and Xu, Yingte},
title = {NQPV},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7564087},
abstract = {
    <p>NQPV is a verification assistant prototype of nondeterministic quantum programs. It implements the verification logic of partial correctness in the numerical form, with soundness guaranteed by the theory and experiments.</p>

},
keywords = {nondeterminism, program verification, quantum programming}
}

@software{10.5281/zenodo.7583154,
author = {Chen, Zizhan and Shao, Zili},
title = {Reproduction Package for Article ‘Transparent Runtime Change Handling for Android Apps’},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7583154},
abstract = {
    <p>The artifact provides the source code of RCHDroid, along with the instructions to generate the results. The artifact allows users to reproduce key results from the paper, including Figure 7, Figure 8, Figure 9, Figure 10, and Figure 14. The hardware must contain the ROC-RK3399-PC-PLUS development board connected to a screen. We provide compiled images to simplify the experiment workflow. Users can also build images from the source code.</p>

},
keywords = {embedded systems, mobile systems, operating systems}
}

@software{10.5281/zenodo.7588406,
author = {Lin, Mao and Zhou, Keren and Su, Pengfei},
title = {Reproduction Package for Article 'DrGPUM: Guiding Memory Optimization for GPU-Accelerated Applications'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7588406},
abstract = {
    <p>The artifact includes DrGPUM and benchmarks, along with instructions to reproduce the results shown in the paper.</p>

},
keywords = {CUDA, GPU profilers, GPUs, Memory management}
}

@software{10.5281/zenodo.7591603,
author = {Malik, Raghav and Sheth, Kabir and Kulkarni, Milind},
title = {Coyote: A Compiler for Vectorizing Encrypted Arithmetic Circuits (artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7591603},
abstract = {
    <p>This artifact contains everything necessary to replicate the results of the paper, including: * An implementation of the compiler described in the paper * A backend test harness for profiling vectorized code * Implementations of all benchmarks used in the evaluation * Scripts necessary to automate the process of compiling, running, and collecting data from the benchmarks.</p>

},
keywords = {arithmetic circuits, Homomorphic encryption, vectorization}
}

@software{10.5281/zenodo.7591742,
author = {Hsu, Olivia and Strange, Maxwell and Sharma, Ritvik and Won, Jaeyeon and Olukotun, Kunle and Emer, Joel S. and Horowitz, Mark A. and Kj\o{}lstad, Fredrik},
title = {Reproduction Package for 'The Sparse Abstract Machine'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7591742},
abstract = {
    <p>This artifact describes how to set up and run our Sparse Abstract Machine (SAM) Python simulator and the C++ CUSTARD compiler, which compiles from concrete index notation (CIN) to SAM graphs (represented and stored in the DOT file format). The artifact also describes how to reproduce the quantitative experimental results in this paper. The artifact can be executed with any X86-64 or M-series Apple machine with Docker support and Python 3, at least 32 GB of RAM, and more than 20 GB of disk space.</p>
<p>Additionally, all instructions and dependencies for using the artifact are contained in the artifact appendix of the paper.</p>

},
keywords = {abstract machine, compilers, cycle-approximate modeling, sparse tensor algebra, streaming dataflow}
}

@software{10.5281/zenodo.7592823,
author = {Tan, Zujun and Chon, Yebin and Kruse, Michael and Doerfert, Johannes and Xu, Ziyang and Homerding, Brian and Campanoni, Simone and August, David I.},
title = {SPLENDID: Supporting Parallel LLVM-IR Enhanced Natural Decompilation for Interactive Development},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7592823},
abstract = {
    <p>The artifact for this paper contains tools and data to reproduce, with minimal effort, the entire testing flow and corroborate its claims. All results can be generated from scratch (source codes) and run across different platforms with the provided docker image. The pre-built docker image supports runs across different platforms with software dependencies taken care of, including a pre-compiled copy of the proposed decompiler, its variants, state-of-the-art decompilers used for comparison, and miscellaneous software such as vim and python. We provide an easy top level interface,  to simplify the testing process.</p>

},
keywords = {ASPLOS'23, Automatic Parallelization, Decompiler}
}

@software{10.5281/zenodo.7592848,
author = {Norman, Chase and Godbole, Adwait and Manerkar, Yatin A.},
title = {Code for Article 'PipeSynth: Automated Synthesis of Microarchitectural Axioms for Memory Consistency'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7592848},
abstract = {
    <p>This is the code for the ASPLOS 2023 paper ‘PipeSynth: Automated Synthesis of Microarchitectural Axioms for Memory Consistency’.</p>

},
keywords = {formal methods, memory consistency, microarchitecture, synthesis}
}

@software{10.5281/zenodo.7592970,
author = {Gao, Xiangyu and Raghunathan, Divya and Fang, Ruijie and Wang, Tao and Zhu, Xiaotong and Sivaraman, Anirudh and Narayana, Srinivas and Gupta, Aarti},
title = {Reproduction Package for Article CaT: A Solver-Aided Compiler for Packet-Processing Pipelines},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7592970},
abstract = {
    <p>This is the artifact evaluation part for the CaT compiler, proposed in our paper. The instruction helps reproduce the results from all tables and figures in IMPLEMENTATION AND EVALUATION section.</p>

},
keywords = {code generation, integer linear programming, packet processing pipelines, program synthesis, Programmable switches}
}

@software{10.5281/zenodo.7598726,
author = {Shu, Junyi and Zhu, Ruidong and Ma, Yun and Huang, Gang and Mei, Hong and Liu, Xuanzhe and Jin, Xin},
title = {Reproduction Package for Article 'Disaggregated RAID Storage in Modern Datacenters'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7598726},
abstract = {
    <p>We provide the artifact for the ASPLOS 2023 paper “Disaggregated RAID Storage in Modern Datacenters”, including:</p>
<ul>
<li>The main implementation of dRAID.</li>
<li>CloudLab testbed setup scripts.</li>
<li>FIO experiment scripts (Sec 9.2-9.5), which get the main results of the paper.</li>
<li>YCSB experiment scripts (Sec 9.6).</li>
</ul>

},
keywords = {Disaggregated Storage, NVMe-oF, RAID, RDMA}
}

@software{10.5281/zenodo.7612226,
author = {Li, Shaohua and Su, Zhendong},
title = {Artifact for "Finding Unstable Code via Compiler-Driven Differential Testing"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7612226},
abstract = {
    <p>The artifact contains the code and datasets we used for our experiments, as well as scripts to generate the numbers, tables, and figures of our evaluation. Specifically, it includes (a) the Juliet testsuite used for evaluation; (b) scripts for running CompDiff, sanitizers, Coverity, CppCheck, and Infer on the Juliet testsuite; (c) scripts for reporting detection results of these tools; (d) scripts for generating bug statistics on 23 real-world programs; and (e) scripts for fuzzing a target with CompDiff-AFL++. Everything is packaged and pre-built as a docker image. A standard X86 Linux machine running docker is necessary to evaluate this artifact.</p>

},
keywords = {compiler, fuzzing, undefined behavior, Unstable code}
}

@software{10.5281/zenodo.7621336,
author = {Wang, Haoyuan and Beamer, Scott},
title = {RepCut: Superlinear Parallel RTL Simulation with Replication-Aided Partitioning},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7621336},
abstract = {
    <p>This package contains the artifact for of RepCut: Superlinear Parallel RTL Simulation with Replication-Aided Partitioning, DOI 10.1145/3582016.3582034</p>
<p>This artifact contains the source code for RepCut, as well as other open source projects that are required to reproduce the results in the paper. We include Verilator 4.226 as a baseline. In addition, this artifact also contains scripts and a Makefile to compile and run the generated simulators, as well as to reproduce every figure and table from experiment data.</p>
<p>Please find more details in README.md</p>

},
keywords = {Parallel RTL Simulation, RepCut}
}

@software{10.5281/zenodo.7633678,
author = {Garimella, Karthik and Ghodsi, Zahra and Jha, Nandan Kumar and Garg, Siddharth and Reagen, Brandon},
title = {Source Code for "Characterizing and Optimizing End-to-End Systems for Private Inference"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7633678},
abstract = {
    <p>We open source our private inference simulator at the following GitHub repo: <a href="https://github.com/kvgarimella/characterizing-private-inference">https://github.com/kvgarimella/characterizing-private-inference</a>. We construct a model of a system for private inference and a simulator using Simpy to explore and evaluate tradeoffs under different system conditions. We model a single-client, single-server setting where inferences are queued in a FIFO manner and are generated by sampling from a Poisson distribution.</p>
<p>The repository itself contains four high-level directories. The directory <code>garbled_circuits</code> contains the raw data for benchmarking ReLU Garbling and Evaluation on an Intel Atom Z8350 embedded device (1.92GHz, 4 cores, 2GB RAM) and an AMD EPYC 7502 server (2.5GHz, 32 cores, 256GB RAM). These two devices represent our client and server, respectively. Next, the directory <code>layer_parallel_HE</code> contains our code and the raw data for applying layer-parallelism to linear layer homomorphic evaluations. The directory <code>simulator</code> contains our private inference simulator. Finally, <code>artifact</code> contains scripts to replicate key figures in our paper.</p>

},
keywords = {cryptography, machine learning, private inference protocols, systems for machine learning}
}

@software{10.5281/zenodo.7643745,
author = {Ye, Zihao and Lai, Ruihang and Shao, Junru and Chen, Tianqi and Ceze, Luis},
title = {SparseTIR Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7643745},
abstract = {
    <p>This repository contains scripts for setting up environments and reproducing results presented in the ASPLOS 2023 paper entitled SparseTIR: Composable Abstractions for Deep Learning.</p>
<p>Please read the README.md file or visit https://github.com/uwsampl/sparsetir-artifact for instructions on how to run and install this artifact.</p>

},
keywords = {Deep-Learning-Compilers, Sparse-Computation, Tensor-Compilers}
}

@software{10.5281/zenodo.7668541,
author = {Raina, Ashwini and Lu, Jianan and Cidon, Asaf and Freedman, Michael J.},
title = {ASPLOS 2023 Artifact for "Efficient Compactions Between Storage Tiers with PrismDB"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7668541},
abstract = {
    <p>This artifact consists of the source code of PrismDB and the necessary scripts to reproduce the evaluation of the paper “Efficient Compactions Between Storage Tiers with PrismDB”, ASPLOS 23.</p>
<p>NOTE: Source code for the baselines rocksdb and mutant is not provided here. For rocksdb baseline, please refer to its official documentation on GitHub. For mutant baseline please follow the mutant SoCC paper.</p>

},
keywords = {compaction, key-value store, PrismDB, storage, tiered}
}

@software{10.5281/zenodo.7680535,
author = {Zuo, Gefei and Ma, Jiacheng and Quinn, Andrew and Kasikci, Baris},
title = {Reproduction Package for Article "Vidi: Record Replay for Reconfigurable Hardware"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7680535},
abstract = {
    <p>Source code is available at https://github.com/efeslab/aws-fpga</p>
<p>This artifact is prepared for ASPLOS 2023 artifact evaluation. Please refer to the <code>artifact-eval/README.md</code> for usage instructions.</p>

},
keywords = {Debugging, FPGA, Record Replay}
}

@software{10.5281/zenodo.7685681,
author = {Laeufer, Kevin and Iyer, Vighnesh and Biancolin, David and Bachrach, Jonathan and Nikoli\'{c}, Borivoje and Sen, Koushik},
title = {Simulator Independent Coverage for RTL Hardware Languages - Software Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7685681},
abstract = {
    <p>The code to reproduce results from our ASPLOS’23 paper on “Simulator Independent Coverage for RTL Hardware Languages”. Most results can be reproduced on a standard x86 Linux computer, however, for the FireSim performance and area/frequency results a more complicated setup on AWS cloud FPGAs is necessary. Please consult the Readme.md in <code>simulator-independent-coverage.tar.gz</code> for more instructions.</p>

},
keywords = {Chisel, ChiselTest, FireSim, FIRRTL, FPGA, FSM Coverage, Hardware Compiler, Line Coverage, RTL, Toggle Coverage}
}

@software{10.5281/zenodo.7699872,
author = {Ye, Haojie and Vedula, Sanketh and Chen, Yuhan and Yang, Yichen and Bronstein, Alex and Dreslinski, Ronald and Mudge, Trevor and Talati, Nishil},
title = {Reproduction Package for Article "GRACE: A Scalable Graph-Based Approach To Accelerating Recommendation Model Inference"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7699872},
abstract = {
    <p>Our paper “GRACE: A Scalable Graph-Based Approach To Accelerating Recommendation Model Inference” presents an algorithm-system co-design for improving the performance of the embedding layer in Deep Learning Recommendation Models (DLRMs). This artifact reproduces some of the main results of our paper. The performance results shown in the paper are machine-dependent. For example, Fig. 8, Fig. 13, and Fig. 14 show results on a CPU-GPU system, HBM-only system, and DIMM-HBM system with Processing-In-Memory (PIM) capability, respectively. To enable reproducing results in a timely fashion on different machines, we reproduce the main result of our paper that is machine-independent (Fig. 10). Specifically, our instructions include 1) how to download the input datasets, 2) how to pre-process these datasets, 3) how to reproduce the memory traffic reduction results for each baseline, and 4) how to generate a plot similar to Fig. 10. Expected result: compared to a no-reduction baseline, GRACE reduces the memory traffic by 1.7x.</p>

},
keywords = {Algorithm-System Co-Design, DLRM, Embedding Reduction}
}

@software{10.5281/zenodo.7702231,
author = {Liu, Jiesong and Zhang, Feng and Guan, Jiawei and Sung, Hsin-Hsuan and Guo, Xiaoguang and Du, Xiaoyong and Shen, Xipeng},
title = {Artifact for Article "Space Efficient TREC for Enabling Deep Learning on Microcontrollers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7702231},
abstract = {
    <p>This directory contains the artifact for Space Efficient TREC for Enabling Deep Learning on Microcontrollers published in ASPLOS 2023. For detailed information, please see the readme.md in TREC-Artifact.zip.</p>

},
keywords = {Compiler Optimization, Real-time Machine Learning}
}

@software{10.5281/zenodo.7709303,
author = {Gosakan, Krishnan and Han, Jaehyun and Kuszmaul, William and Mubarek, Ibrahim N. and Mukherjee, Nirjhar and Sriram, Karthik and Tagliavini, Guido and West, Evan and Bender, Michael A. and Bhattacharjee, Abhishek and Conway, Alex and Farach-Colton, Martin and Gandhi, Jayneel and Johnson, Rob and Kannan, Sudarsun and Porter, Donald E.},
title = {Mosaic Pages: Big TLB Reach with Small Pages},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709303},
abstract = {
    <p>There are three artifacts for this paper: a Gem5 model to reproduce Figure 4, a modified Linux kernel to reproduce Tables 3 and 4, and Verilog code to reproduce Table 5. The Linux artifact includes scripts to setup a KVM environment with Mosaic and vanilla Linux kernels. The artifact also includes scripts to run the Linux workloads in a VM and a script to generate tables.</p>

},
keywords = {address translation, gem5, hashing, linux, paging, TLB, verilog, virtual memory}
}

@software{10.6084/m9.figshare.22081901.v1,
author = {Swamy, Tushar and Zulfiqar, Annus and Nardi, Luigi and Shahbaz, Muhammad and Olukotun, Kunle},
title = {Artifact for "Homunculus: Auto-Generating Efficient Data-Plane ML Pipelines for Datacenter Networks" - ASPLOS 2023},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.22081901.v1},
abstract = {
    <p>The artifact contains the source code for the titular Homunculus compiler, a backend for the Taurus ASIC switch architecture, as well as three representative applications. We used these applications to demonstrate the core results of our paper, i.e., how Homunculus-generated models outperform or match the hand-tuned baseline versions. We include applications for anomaly detection, traffic classification, and botnet detection. Homunculus also generates the appropriate hardware code for each of these applications to run on a Taurus switch architecture.</p>

},
keywords = {ML Compilers, Per-packet ML, Self-driving Networks}
}

@software{10.1145/3554347,
author = {Popoola, Tobi and Zhao, Tuowen and St. George, Aaron and Bhetwal, Kalyan and Strout, Michelle Mills and Hall, Mary and Olschanowsky, Catherine},
title = {Reproduction Package for Code Synthesis for Sparse Tensor Format Conversion and Optimization},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554347},
abstract = {
    <p>This artifact introduces a technique for data layout transformations based on constrained relationships between different forms of data. In this artifact, we apply this technique to generate code for transforming from one source format to another. We provide a docker container to replicate results. To ease testing we provide already generated transformation codes wrapped around necessary macros to evaluate our work. We also provide artifacts from the state-of-the-art discussed in our work.</p>

},
keywords = {Code synthesis, Index array properties, Polyhedral compilation, Sparse Format Conversion, Sparser Format Descriptors, Transformations, Uninterpreted functions}
}

@software{10.1145/3554349,
author = {Thangamani, Arun and Jost, Tiago Trevisan and Loechner, Vincent and Genaud, St\'{e}phane and Bramas, B\'{e}renger},
title = {Artifact for Lifting Code Generation of Cardiac Physiology Simulation to Novel Compiler Technology},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554349},
abstract = {
    <p>This artifact provides all required tools and dependencies needed to compile and execute applications, and generate figures 2, 3, 4 (optional), and 5 mentioned in the paper titled Lifting Code Generation of Cardiac Physiology Simulation to Novel Compiler Technology published in CGO’23.</p>

},
keywords = {Code Generation and Optimization, Code translation and transformation, Domain-specific languages, Parallel computing, Vectorization}
}

@software{10.1145/3554350,
author = {Mu, Wenlong and Zhang, Yilei and Huang, Bo and Guo, Jianmei and Cui, Shiqiang},
title = {Reproduction Package for Article “A Hotspot-Driven Semi-automated Competitive Analysis Framework for Identifying Compiler Key Optimizations”},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554350},
abstract = {
    <p>In order to identify the key optimizations adopted by some high-performance compilers, we propose a hotspot-driven semi-automatic framework for identifying key compiler optimizations through comparing the binaries generated by two different compilers. Firstly, the framework obtains the execution time and hotspot distribution information of binaries generated by two different compilers with the same source code through a performance analysis tool(Linux perf), and then the framework automatically selects the identified hotspots that cause the binaries‘ performance difference. We use DynamoRIO Client to analyze the instruction distribution characteristics of specific hotspots, which help us narrow down the scope of hotspots‘s binary analysis. All the above steps can be done automatically by the framework.</p>

},
keywords = {dynamic binary instrumentation, hotspots detection, semi-automated framework}
}

@software{10.1145/3554351,
author = {Rasch, Ari and Schulze, Richard and Shabalin, Denys and Elster, Anne and Gorlatch, Sergei and Hall, Mary},
title = {Reproduction Package for Article `(De/Re)-Compositions Expressed Systematically via MDH-Based Schedules'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554351},
abstract = {
    <p>This artifact contains the workflow to reproduce the experiments presented in the paper `(De/Re)-Compositions Expressed Systematically via MDH-Based Schedules’ accepted for publication at the ACM SIGPLAN 2023 International Conference on Compiler Construction. The user is invited to perform the steps described in file README.txt.</p>

},
keywords = {CPU, GPU, scheduling languages}
}

@software{10.1145/3554352,
author = {Patabandi, Tharindu R. and Hall, Mary},
title = {Reproduction package for "Efficiently Learning Locality Optimizations by Decomposing Transformation Domains"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554352},
abstract = {
    <p>The artifact contains executable binaries and trained predictive models to reproduce the results presented in the publication.</p>

},
keywords = {convolutional neural networks, data locality, loop permutation, Loop tiling, x86}
}

@software{10.5281/zenodo.7369395,
author = {Aanjaneya, Mridul and Nagarakatte, Santosh},
title = {Artifact for "Fast Polynomial Evaluation for Correctly Rounded Elementary Functions using the RLIBM Approach"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7369395},
abstract = {
    <p>Our library with the correctly rounded functions and the polynomial generator for them is available open source and publicly available at https://github.com/rutgers-apl/cgo23- artifact. It is available with the MIT license. The artifact includes: (1) 24 correctly rounded implementations for six elementary functions using the coefficient adaptation proce- dure by Knuth, Estrin’s method, and Estrin’s method with fused multiply-add operations for polynomial evaluation, (2) correctness testing framework for the 24 functions, (3) perfor- mance testing framework to demonstrate the performance improvements over RLibm and CRLIBM, and (4) polynomial generator for generating the polynomials using the Estrin’s method with fused multiply-add operations.</p>

},
keywords = {coefficient adaptation, correctly rounded, Estrin's procedure, fused-multiply-add, Horner's method, RLIBM}
}

@software{10.5281/zenodo.7374649,
author = {Dam\'{a}sio, Tha\'{\i}s and Canesche, Michael and Pacheco, Vin\'{\i}cius and Botacin, Marcus and Faustino da Silva, Anderson and Quint\~{a}o Pereira, Fernando M.},
title = {Reproduction Package for Article `A Game-Based Framework to Compare Program Classifiers and Evaders'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7374649},
abstract = {
    <p>This artifact compares different program classification techniques and pits them against different evasion techniques. In total, this artifact let us evaluate nine program encoding techniques; seven code obfuscation passes; and seven stochastic classification models. The artifact consists of a docker container with accompanying scripts to replicate Figures 5-15 automatically, plus the dataset and accompanying instructions to replicate Figure 16 manually. For a more up-to-date version of this source code, check: https://github.com/lac-dcc/yali</p>

},
keywords = {deep learning, obfuscation, ollvm, optimization}
}

@software{10.5281/zenodo.7374843,
author = {Deiana, Enrico Armenio and Suchy, Brian and Wilkins, Michael and Homerding, Brian and McMichen, Tommy and Dunajewski, Katarzyna and Dinda, Peter and Hardavellas, Nikos and Campanoni, Simone},
title = {Artifact for "Program State Element Characterization" CGO 2023.},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7374843},
abstract = {
    <p>This artifact is a podman image containing the CARMOT system and its dependencies, and it generates the main results of this paper in text format. All benchmark suites are included in the artifact, except for SPEC CPU 2017, which we cannot share directly (please refer to README.md in the artifact on how to include SPEC CPU 2017 results). This artifact requires podman (or docker) to load and run the image, and a network connection to download additional dependencies of the CARMOT system. The execution of this artifact requires an Intel multicore processor with shared memory.</p>

},
keywords = {code optimization, dynamic analysis, program characterization}
}

@software{10.5281/zenodo.7459640,
author = {Brahmakshatriya, Ajay and Amarasinghe, Saman},
title = {Artifacts for the CGO23 paper: D2X: An eXtensible conteXtual Debugger for modern DSLs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7459640},
abstract = {
    <p>Artifacts for the CGO23 paper: D2X: An eXtensible conteXtual Debugger for modern DSLs</p>

},
keywords = {compilers, debuggers, DSLs}
}

@software{10.5281/zenodo.7496594,
author = {Zhang, Peihua and Wu, Chenggang and Peng, Mingfan and Zeng, Kai and Yu, Ding and Lai, Yuanming and Kang, Yan and Wang, Wei and Wang, Zhe},
title = {Reproduction Package for Article 'Khaos: The Impact of Inter-procedural Code Obfuscation on Binary Diffing Techniques'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7496594},
abstract = {
    <p>Artifact for article ‘Khaos: The Impact of Inter-procedural Code Obfuscation on Binary Diffing Techniques’, including diffing files of 5 diffing works, scripts to parse the diffing result, and all the result of the paper.</p>

},
keywords = {binary diffing, code obfuscation}
}

@software{10.5281/zenodo.7499096,
author = {Basso, Matteo and Ros\`{a}, Andrea and Omini, Luca and Binder, Walter},
title = {Artifact associated to the paper "Java Vector API: Benchmarking and Performance Analysis" published in CC'23},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7499096},
abstract = {
    <p>JVBench is the first open-source benchmark suite for the Java Vector API. It includes several realistic and diversified benchmarks, specifically designed for evaluating vectorization. This artifact consists of a ready-to-use Docker image embedding JVBench together with a set of tools/scripts that can be used to execute the JVBench workloads as well as collect, process and plot performance measurements to replicate the evaluation of JVBench presented in the paper “Java Vector API: Benchmarking and Performance Analysis” (CC’23). The artifact also contains the complete pre-collected performance measurements used to generated the original figures of the paper.</p>

},
keywords = {Benchmarks, Code optimization, Java, Just-in-time compilation, Parallelism, SIMD, Vector API}
}

@software{10.5281/zenodo.7499790,
author = {Ahrens, Willow and Donenfeld, Daniel and Kjolstad, Fredrik and Amarasinghe, Saman},
title = {Looplets: A Language For Structured Coiteration (The Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7499790},
abstract = {
    <p>An artifact supporting the results in the submitted version of our paper. The submitted version is included as a PDF with the artifact instructions at the end, though they are also available as a readme in the artifact itself.</p>

},
keywords = {Array, Coiteration, Compiler, Compressed, Sparse, Tensor}
}

@software{10.5281/zenodo.7517506,
author = {Salvador Rohwedder, Caio and Henderson, Nathan and De Carvalho, Jo\~{a}o P. L. and Chen, Yufei and Amaral, Jos\'{e} Nelson},
title = {Artifact for "To Pack or Not to Pack: A Generalized Packing Analysis and Transformation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7517506},
abstract = {
    <ul>
<li>docker-packing-artifact.tar.gz: docker image for the execution of experiments</li>
<li>llvm-packing-v0.5.zip: LLVM source code with packing implementation (binary in docker image)</li>
<li>logs-and-graphs.zip: Log files and graphs that were used in the paper</li>
<li>packing-scripts.zip: scripts used to run experiments and Dockerfile source&nbsp;(also provided in docker image) -&nbsp;polybench-c-4.2.1-plus-contract-3d.zip: Polybench 4.2 and running example of paper (also provided in docker image)</li>
</ul>

},
keywords = {Packing Optimization LLVM Compiler}
}

@software{10.5281/zenodo.7519936,
author = {Ben-Nun, Tal and Ates, Berke and Calotoiu, Alexandru and Hoefler, Torsten},
title = {Reproduction package for the paper Bridging Control-Centric and Data-Centric Optimization},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7519936},
abstract = {
    <p>Contains the benchmarking suite for the benchmarks shown in the paper as well as scripts and instructions on how to reproduce them.</p>

},
keywords = {DaCe, data-centric programming, MLIR}
}

@software{10.5281/zenodo.7521260,
author = {Mitenkov, George and Magkanaris, Ioannis and Awile, Omar and Kumbhar, Pramod and Sch\"{u}rmann, Felix and Donaldson, Alastair F.},
title = {Reproduction package for "MOD2IR: High-Performance Code Generation for a Biophysically Detailed Neuronal Simulation DSL"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7521260},
abstract = {
    <p>The artifact was created to complement the submission of the “MOD2IR: High-Performance Code Generation for a Biophysically Detailed Neuronal Simulation DSL” paper to the ACM SIGPLAN 2023 International Conference on Compiler Construction. It contains all the necessary source code, data and scripts to reproduce the results published in the paper.</p>

},
keywords = {Code Generation, Compiler, DSL, LLVM, NEURON, NMODL, Vectorization}
}

@software{10.5281/zenodo.7524279,
author = {Kandiah, Vijay and Lustig, Daniel and Villa, Oreste and Nellans, David and Hardavellas, Nikos},
title = {Artifact for CGO'23 paper titled "Parsimony: Enabling SIMD/Vector Programming in Standard Compiler Flows"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7524279},
abstract = {
    <p>Parsimony is a SPMD programming approach built with semantics designed to be compatible with multiple languages and to cleanly integrate into the standard optimizing compiler toolchains for those languages. This artifact is for our CGO’23 paper titled “Parsimony: Enabling SIMD/Vector Programming in Standard Compiler Flows” and includes a LLVM prototype of the Parsimony model along with a build and test framework for the Simd Library benchmarks and ispc benchmarks. It also includes scripts to build our prototype compiler, build and run the SimdLibrary and ispc benchmarks, and reproduce the figures 4 and 5 presented in our CGO’23 paper.</p>

},
keywords = {Code Transformation, Compiler Design, Single-instruction Multiple-data, Single-program Multiple-data, Vectorization}
}

@software{10.5281/zenodo.7533561,
author = {Mart\'{\i}nez, Pablo Antonio and Woodruff, Jackson and Armengol-Estap\'{e}, Jordi and Bernab\'{e}, Gregorio and Garc\'{\i}a, Jos\'{e} Manuel and O’Boyle, Michael F. P.},
title = {Reproduction package for 'Matching Linear Algebra and Tensor Code to Specialized Hardware Accelerators'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7533561},
abstract = {
    <p>The artifact contains the ATC compiler implemented with OCaml, the JIT compiler implemented in LLVM, the SVM classifier implemented with scikit-learn and the list of GEMM and convolution programs used in the paper. The artifact also contains other compilers used in the evaluation such as KernelFaRer, IDL and LLVM-Polly.</p>

},
keywords = {GEMM, JIT, LLVM, Program synthesis}
}

@software{10.5281/zenodo.7573782,
author = {Fried, Andreas and Stemmer-Grabow, Maximilian and Wachter, Julian},
title = {Register Allocation for Compressed ISAs in LLVM},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7573782},
abstract = {
    <p>We provide a Docker image to reproduce the central result of our work. Our artifact builds two versions of LLVM+Clang, with and without the compression-aware register allocator. It then compiles the SPEC CPU2000 and CPU2006 benchmarks with both compilers. The result of the experiment is a reproduction of figure 1 of our paper, along with other graphs not present in the paper.</p>
<p>Reviewers can also experiment with the parameters of the register allocator and observe their effect on the compression achieved.</p>

},
keywords = {compressed instruction sets, LLVM, register allocation, RISC-V}
}

@software{10.5281/zenodo.7574403,
author = {Matsumura, Kazuaki and De Gonzalo, Simon Garcia and Pe\~{n}a, Antonio J.},
title = {PTXASW},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7574403},
abstract = {
    <p>A symbolic emulator works for shuffle synthesis on the NVIDIA PTX code. Also, this artifact contains the benchmarks.</p>

},
keywords = {CUDA, NVIDIA PTX, OpenACC}
}

@software{10.5281/zenodo.7575072,
author = {VenkataKeerthy, S. and Jain, Siddharth and Kundu, Anilava and Aggarwal, Rohit and Cohen, Albert and Upadrasta, Ramakrishna},
title = {Artifacts for the paper "RL4ReAl: Reinforcement Learning for Register Allocation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7575072},
abstract = {
    <p>This artifact corresponds to the publication “RL4ReAl: Reinforcement Learning for Register Allocation”, published in CC 2023. This artifact consists of a docker image submitted for the artifact evaluation.</p>

},
keywords = {Graph Coloring, Register Allocation, Reinforcement Learning}
}

@software{10.5281/zenodo.7639153,
author = {Shin, Yongwon and Park, Juseong and Cho, Sungjun and Sung, Hyojin},
title = {Reproduction Package for Article " PIMFlow: Compiler and Runtime Support for CNN Models on Processing-in-Memory DRAM"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7639153},
abstract = {
    <p>Our artifact consists of four parts: (1) PIM-aware ONNX transformation passes, (2) hardware measurement scripts for execution mode and granularity search, (3) an extended TVM compiler with DRAM-PIM back-end, and (4) GPU and DRAM-PIM simulators. For pre-generated input data, we provide GPU traces for the CNN models evaluated in the paper. You can also generate these traces by using NVBit2. For the compiler, we provide modified binaries and source codes for the TVM compiler extended with DRAM-PIM back- end. Artifact evaluation and testing are streamlined with a top-level script (pimflow) that controls different features of PIMFlow with lower-level scripts (Details in Section A.5). The evaluation and reproduction of the results in the paper can be done on any platform with the simulators, as long as the traces are generated on NVIDIA GeForce RTX 2080 Ti GPU.</p>

},
keywords = {CNN models, Processing-in-memory}
}

@software{10.6084/m9.figshare.21964787.v1,
author = {Peng, Mai Jacob and Dubach, Christophe},
title = {Reproduction Package for Artifact "LAGrad: Statically Optimized Differentiable Programming in MLIR"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21964787.v1},
abstract = {
    <p>This artifact contains the source code for LAGrad, pinned versions of LLVM and Enzyme, and the necessary scripts to reproduce the comparison against the state-of-the-art (Figures 7 and 8) in the CC ’23 paper “LAGrad: Statically Optimized Differentiable Programming in MLIR”.</p>

},
keywords = {automatic differentiation, differentiable programming, MLIR, sparsity, static analysis}
}

@software{10.6084/m9.figshare.21976358.v1,
author = {Rocha, Rodrigo C. O. and Saumya, Charitha and Sundararajah, Kirshanthan and Petoumenos, Pavlos and Kulkarni, Milind and O’Boyle, Michael F. P.},
title = {Artifact for "HyBF: A hybrid branch fusion strategy for code size reduction"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21976358.v1},
abstract = {
    <p>This is the artifact of the paper</p>
<p>“HyBF: A hybrid branch fusion strategy for code size reduction” Rodrigo Rocha, Charitha Saumya, Kirshanthan Sundararajah, Pavlos Petoumenos, Milind Kulkarni, Michael O’Boyle</p>
<p>published at the Conference on Compiler Construction, 2023.</p>
<p>We provide scripts that automate the installation and use of this artifact. Read README.md for detailed instructions.</p>

},
keywords = {branch fusion, code size, compiler optimizations, compilers, function merging, llvm}
}

@software{10.25442/hku.21342192.v1,
author = {Gao, Yizhao and Zhang, Baoheng and Qi, Xiaojuan and So, Hayden Kwok-Hay},
title = {DPACS: Hardware Accelerated Dynamic Neural Network Pruning through Algorithm-Architecture Co-design},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.25442/hku.21342192.v1},
abstract = {
    <p>DPCAS is an algorithm-architecture co-design framework for dynamic neural network pruning. It utilizes a hardware-aware dynamic spatial and channel pruning mechanism in conjunction with a dynamic dataflow engine in hardware to facilitate efficient processing of the pruned network.</p>

},
keywords = {Deep Learning Applications, hardware accelerators}
}

@software{10.5281/zenodo.7196061,
author = {Levine, Reese and Guo, Tianhao and Cho, Mingun and Baker, Alan and Levien, Raph and Neto, David and Quinn, Andrew and Sorensen, Tyler},
title = {MC Mutants Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7196061},
abstract = {
    <p>This artifact contains information for both collecting analyzing the results we present in the paper. On the collection side, we provide the means to run the exact experiments included in the paper. Using the exact devices from the paper will show very similar results to ours, but any GPU can be used to evaluate the way in which we collect and analyze data. On the analysis side, we include the results from running the experiments on the four devices in the paper, as well as the analysis tools we used to generate the main figures in the paper.</p>

},
keywords = {memory consistency, mutation testing, parallel programming models}
}

@software{10.5281/zenodo.7215748,
author = {Song, Yongju and Kim, Wook-Hee and Monga, Sumit Kumar and Min, Changwoo and Eom, Young Ik},
title = {Prism: Optimizing Key-Value Store for Modern Heterogeneous Storage Devices},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7215748},
abstract = {
    <p>We addressed the question: “How should we design a key-value store for the non-hierarchical storage landscape?”. We designed and implemented a novel key-value store named Prism that utilizes modern heterogeneous storage devices. This artifact contains three major components: 1) the source code of Prism, 2) a benchmark suite, and 3) a workload generator to evaluate the system. Additionally, the scripts enclosed allow readers to configure, build, and run Prism conveniently and precisely. For reference, since Prism is built on modern heterogeneous storage devices including non-volatile memory and NVMe SSDs, there are some hardware dependencies. For the software side, Prism needs PMDK and liburing libraries. Although it could be challenging to make up an identical testbed to ours, it is necessary to satisfy both the hardware and software requirements in order to get the expected key outcomes.</p>

},
keywords = {Key-value Stores, Non-volatile Memory}
}

@software{10.5281/zenodo.7217959,
author = {Xiao, Haocheng and Ainsworth, Sam},
title = {Reproduction package for article 'Hacky Racers: Exploiting Instruction-Level Parallelism to Generate Stealthy Fine-Grained Timers'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7217959},
abstract = {
    <p>Our artifact provides source code and scripts for four timing side-channel experiments mentioned in this paper, corresponding to sections 7.3 to 7.5, and each demonstrates the efficiency and portability of either/both Racing and Magnifier Gadgets. Our results should be evaluated on an Intel or AMD x86 machine (we used an i7-8750h, but systems of a similar architecture will work out-of-the-box). Migration to systems with other ISAs or significantly different micro-architectures require minor source-code modifications.</p>

},
keywords = {Caches, Instruction-level Parallelism, JavaScript, Microarchitectural Security, Spectre}
}

@software{10.5281/zenodo.7222132,
author = {Liu, Jiawei and Lin, Jinkun and Ruffy, Fabian and Tan, Cheng and Li, Jinyang and Panda, Aurojit and Zhang, Lingming},
title = {ASPLOS2023 Artifact for "NNSmith: Generating Diverse and Valid Test Cases for Deep Learning Compilers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222132},
abstract = {
    <p>The artifact contains evidence of bug finding, source code of NNSmith’s prototype, and user-friendly HTML documentation for re-generating the results. Specifically, it includes (1) links to bugs reported by the authors as real-world bug finding evidence, and (2) scripts and code to re-generate main results in § 5. To make artifact evaluation as simple as possible, our artifact is packaged into a pre-built docker image, along with a detailed and friendly HTML documentation. To fully evaluate the artifact, a X86-CPU platform with docker access is needed, with approximately 21 hours of machine time and 1 hour of manual inspection time.</p>

},
keywords = {Compiler, Fuzzing, Machine Learning Systems, Testing}
}

@software{10.5281/zenodo.7222728,
author = {Berlstein, Griffin and Nigam, Rachit and Gyurgyik, Christophe and Sampson, Adrian},
title = {Evaluation for "Stepwise Debugging for Hardware Accelerators"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222728},
abstract = {
    <p>This artifact consists of one piece of software, the Cider Interpreter and Debugger for Calyx, alongside data and helper scripts. Cider is a simulator and debugger for hardware accelerators written in the Calyx IR. Since Cider is also a simulator, it can be used to interpreter and debug hardware designs without lowering them from the IR to RTL.</p>
<p>This artifact seeks to reproduce the benchmark results discussed in our performance evaluation as well as the debugging process shown in section 3 of our paper. This supports our paper by showing the usability of Cider and how it compares to related tools, alongside demonstrating the debugging interface.</p>

},
keywords = {Accelerator Design, Accelerator Simulation, Debugging, Intermediate Language}
}

@software{10.5281/zenodo.7222794,
author = {Shen, Han and Pszeniczny, Krzysztof and Lavaee, Rahman and Kumar, Snehasish and Tallam, Sriraman and Li, Xinliang David},
title = {Artifacts for "Propeller: A Profile Guided, Relinking Optimizer for Warehouse Scale Applications"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222794},
abstract = {
    <p>The disassembly-driven, monolithic design of post link optimizers face scaling challenges with large binaries and is at odds with distributed build systems. To reconcile and enable post link optimizations within a distributed build environment, we propose Propeller, a relinking optimizer for warehouse scale workloads. Propeller uses basic block sections (a novel linker abstraction) to enable a new approach to post link optimization without disassembly. Propeller achieves scalability by relinking the binary using precise profiles instead of rewriting the binary. The overhead of relinking is lowered by caching and leveraging distributed compiler actions during code generation.</p>
<p>In this artifact, we present the means to replicate the results on a standalone machine. We provide a cloud-hosted bare metal machine which has been provisioned with the tooling and dependencies to run Propeller and Lightning BOLT. We use this environment to demonstrate Propeller’s approach to post link optimizations on a bootstraped build of clang. We show Propeller can achieve equitable performance to Lightning BOLT with lower peak memory consumption. A key aspect of Propeller enabled optimizations is the integration with a distributed build system which provides caching. To demonstrate the effect of caching we provide scripting which emulates the effect on a single machine. The scripts used to replicate the results are also publicly available at https://github.com/google/llvm-propeller.</p>

},
keywords = {Binary Optimization, Datacenters, Distributed Build System, Post-Link Optimization, Profile Guided Optimization, Warehouse-Scale Applications}
}

@software{10.5281/zenodo.7225459,
author = {Gao, Mingyu and Chakraborty, Soham and Ozkan, Burcu Kulahcioglu},
title = {Probabilistic Concurrency Testing for Weak Memory Programs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7225459},
abstract = {
    <p>The upload is a VagrantBox package, containing the artifact for the paper Probabilistic Testing for Weak Memory Programs. This vagrant package offers the experimental environment, which contains all code, benchmarks, and scripts to reproduce the experimental results in the paper.</p>

},
keywords = {Concurrency, Randomized algorithms, Testing, Weak memory}
}

@software{10.5281/zenodo.7240401,
author = {Liu, Congyu and Gong, Sishuai and Fonseca, Pedro},
title = {ASPLOS' 23 Artifact of "KIT: Testing OS-Level Virtualization for Functional Interference Bugs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7240401},
abstract = {
    <p>Container isolation is implemented through OS-level virtualization, such as Linux namespaces. Unfortunately, these mechanisms are extremely challenging to implement correctly and, in practice, suffer from functional interference bugs, which compromise container security. In particular, functional interference bugs allow an attacker to extract information from another container running on the same machine or impact its integrity by modifying kernel resources that are incorrectly isolated. Despite their impact, functional interference bugs in OS-level virtualization have received limited attention in part due to the challenges in detecting them. Instead of causing memory errors or crashes, many functional interference bugs involve hard-to-catch logic errors that silently produce semantically incorrect results. This paper proposes KIT, a dynamic testing framework that discovers functional interference bugs in OS-level virtualization mechanisms, such as Linux namespaces. The key idea of KIT is to detect inter-container functional interference by comparing the system call traces of a container across two executions, where it runs with and without the preceding execution of another container. To achieve high efficiency and accuracy, KIT includes two critical components: an efficient algorithm to generate test cases that exercise inter-container data flows and a system call trace analysis framework that detects functional interference bugs and clusters bug reports. KIT discovered 9 functional interference bugs in Linux kernel 5.13, of which 6 have been confirmed. All bugs are caused by logic errors, showing that this approach is able to detect hard-to-catch semantic bugs.</p>

},
keywords = {Bugs, OS-level Virtualization, Testing}
}

@software{10.5281/zenodo.7275326,
author = {Hu, Qinghao and Zhang, Meng and Sun, Peng and Wen, Yonggang and Zhang, Tianwei},
title = {Lucid Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7275326},
abstract = {
    <p>This artifact appendix describes how to reproduce main results in our paper. In our public repository, we provide the source code, related dataset and the instructions to perform artifact evaluation. Please refer to the README file for more details.</p>

},
keywords = {Cluster Management, Machine Learning, Workload Scheduling}
}

@software{10.5281/zenodo.7277139,
author = {Fingler, Henrique and Tarte, Isha and Yu, Hangchen and Szekely, Ariel and Hu, Bodun and Akella, Aditya and Rossbach, Christopher J.},
title = {Artifacts of LAKE},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7277139},
abstract = {
    <p>Kernel API remoting system, kernel drivers of workloads and benchmarks scripts.</p>

},
keywords = {api remoting, kernel, ml for systems, systems for ml}
}

@software{10.5281/zenodo.7306303,
author = {Pandey, Shweta and Kamath, Aditya K and Basu, Arkaprava},
title = {Scoped Buffered Release Persistency Model for GPUs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7306303},
abstract = {
    <p>We provide the source code and setup for our GPU persistency model, Scoped Buffered Release Persistency (SBRP). SBRP is a scope-aware, buffered persistency model that provides high performance to GPU applications that wish to persist data on Non-Volatile Memory (NVM). SBRP modifies the GPU hardware and has been implemented using GPGPU-Sim, a GPU simulator. For more details on the simulator requirements, check the README in the simulator folder.</p>
<p>This repository consists of the source code of the simulator, benchmarks used for evaluation and all scripts needed to replicate the figures in the paper.</p>

},
keywords = {Grpahics Processing Unit, Persistent Memory}
}

@software{10.5281/zenodo.7311322,
author = {You, Xin and Yang, Hailong and Lei, Kelun and Luan, Zhongzhi and Qian, Depei},
title = {Reproduction Package for Article "VClinic: A Portable and Efficient Framework for Fine-Grained Value Profilers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7311322},
abstract = {
    <p>The provided docker images contain pre-built VClinic and compared value profilers. For X86 platforms, docker image “vclinic_artifact_x86.tar” should be used; otherwise, for ARM platforms, docker image “vclinic_artifact_arm.tar” should be used. As pin-based value profilers only support X86 platforms, we only include the built pin-based value profilers in the “vclinic_artifact_x86.tar” docker image. The detailed instructions for evaluating the artifacts as well as the estimated evaluation time for each step on both platforms are listed in “/home/vclinic_artifact/README.md”. The summary of how to set up the experimental environment is listed in README. Note that both “vclinic_artifact_x86.tar” and <code>vclinic_artifact_arm.tar</code> are pre-built docker images and one can directly follow the instructions in the README file to reproduce the evaluation results.</p>

},
keywords = {Dynamic Binary Instrumentation, Performance Analysis, Value Profiler}
}

@software{10.5281/zenodo.7319957,
author = {Porter, Chris and Khan, Sharjeel and Pande, Santosh},
title = {Decker},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7319957},
abstract = {
    <p>The Decker framework consists of a compiler pass and runtime library. Its main objective is to debloat software at runtime. The artifact includes a Docker image that encapsulates basic dependencies, the<br>
Decker code itself, benchmarks, and the scripts to drive artifact evaluation.</p>

},
keywords = {program security, software debloating}
}

@software{10.5281/zenodo.7330354,
author = {Aguilera, Marcos K. and Ben-David, Naama and Guerraoui, Rachid and Murat, Antoine and Xygkis, Athanasios and Zablotchi, Igor},
title = {Artifacts to reproduce all experiments in `uBFT: Microsecond-Scale BFT using Disaggregated Memory`},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7330354},
abstract = {
    <p>This artifact contains all the necessary source code to compile, execute and generate the data of all the figures in <code>uBFT: Microsecond-Scale BFT using Disaggregated Memory</code>.</p>

},
keywords = {Byzantine fault tolerance, disaggregated memory, fast path, finite memory, microsecond scale, RDMA, replication, signatureless}
}

@software{10.5281/zenodo.7333207,
author = {Hildenbrand, David and Schulz, Martin and Amit, Nadav},
title = {Software artifacts for the paper "Copy-on-Pin: The Missing Piece for Correct Copy-on-Write"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7333207},
abstract = {
    <p>Software artifacts for the paper “Copy-on-Pin: The Missing Piece for Correct Copy-on-Write”.</p>

},
keywords = {copy-on-write, COW, fork, memory deduplication, page pinning, page sharing, virtual memory}
}

@software{10.5281/zenodo.7339970,
author = {Sun, Jinghan and Li, Shaobo and Sun, Yunxin and Sun, Chao and Vucinic, Dejan and Huang, Jian},
title = {Artifact of "LeaFTL: A Learning-Based Flash Translation Layer for Solid-State Drives"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7339970},
abstract = {
    <p>This artifact is for reproducing the experiment results in the paper. The artifact includes the simulator source code with LeaFTL implementation, datasets for evaluation, and also scripts and instructions for reproducing the results. More details on the artifact can be found in the GitHub README File.</p>

},
keywords = {Flash Translation Layer, Learning-Based Storage, Solid-State Drive}
}

@software{10.5281/zenodo.7423535,
author = {Duan, Zhuohui and Yao, Jiabo and Liu, Haikun and Liao, Xiaofei and Jin, Hai and Zhang, Yu},
title = {Reproduction Package for Article `Revisiting Log-structured Merging for KV Stores in Hybrid Memory Systems’},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7423535},
abstract = {
    <p>All experimental results in Figures 6, 7, 8, 9, 10, 11, and 12 can be reproduced. These results can reflect the performance of MioDB.</p>

},
keywords = {Key-Value Store, Log-Structured Merge, LSM-tree Compaction, Non-Volatile Memory, Skip List}
}

@software{10.5281/zenodo.7425382,
author = {Huang, Haochen and Shen, Bingyu and Zhong, Li and Zhou, Yuanyuan},
title = {Reproduction Package for Paper `Protecting Data Integrity of Web Applications with Database Constraints Inferred from Application Code`},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7425382},
abstract = {
    <p>This repo is for the code release of our paper <code>Protecting Data Integrity of Web Applications with Database Constraints Inferred from Application Code.</code> in ASPLOS 2023.</p>
<p>In the paper, we developed a static analysis tool to infer the missing database constraints from the application source code.</p>

},
keywords = {Data integrity, Database constraints, Static analysis, Web applications}
}

@software{10.5281/zenodo.7429879,
author = {Ding, Yaoyao and Yu, Cody Hao and Zheng, Bojian and Liu, Yizhi and Wang, Yida and Pekhimenko, Gennady},
title = {Artifact for paper "Hidet: Task Mapping Programming Paradigm for Deep Learning Tensor Programs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7429879},
abstract = {
    <p>This artifact helps readers to reproduce all experiments in the evaluation section of our paper. In Section 6, there are 6 experiments (one end to end experiment and 5 case studies). These experiments compare Hidet with other DNN frameworks and compilers on representative DNN models from the perspective of execution latency, optimization time, schedule space, input sensitivity, and different batch sizes. In the public artifact, we provide scripts to launch the 6 experiments automatically. With the hardware and software described in Section A.3.2 and A.3.3, the artifact should reproduce all experimental results in the evaluation section.</p>

},
keywords = {artifact, deep learning compiler, deep nerual networks, inference}
}

@software{10.5281/zenodo.7430228,
author = {Hackett, Finn and Hosseini, Shayan and Costa, Renato and Do, Matthew and Beschastnikh, Ivan},
title = {Compiling Distributed System Models with PGo [evaluation]},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7430228},
abstract = {
    <p>This repository aggregates all the tools and data necessary to reproduce the results in the evaluation section of our ASPLOS 2023 paper.</p>
<p>Our artifact has two components. We provide the PGo compiler itself, which can compile MPCal specifications, and we also provide a method for reproducing our performance results from our ASPLOS 2023 paper. These files describe how to reproduce our performance results.</p>
<p>Our own set of results is included in the <code>results_paper/</code> folder. For how to use the included tools and how to interpret the included results, see the README.</p>

},
keywords = {Compilers, Distributed systems, Formal methods, PlusCal, TLA+}
}

@software{10.5281/zenodo.7439846,
author = {Yang, Shuangyan and Zhang, Minjia and Dong, Wenqian and Li, Dong},
title = {Betty: Enabling Large-Scale GNN Training with Batch-Level Graph Partitioning},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7439846},
abstract = {
    <p>The directory of the Betty includes dataset/, Figures/, pytorch/, README.md, requiremnets.sh. We can execute ‘bash install_requirements.sh’ to install requirments. After downloading benchmarks and generating full batch data into folder /Betty/dataset/. The directory pytorch contains all necessary files for the micro-batch training and mini-batch training. In folder micro_batch_train, graph_partitioner.py contains our implementation of redundancy embedded graph partitioning. block_dataloader.py is implemented to construct the micro-batch based on the partitioning results of REG. The folder Figures contains these important figures for analysis and performance evaluation.</p>

},
keywords = {Graph neural network, Graph partition, Redundancy reduction}
}

@software{10.5281/zenodo.7481637,
author = {Gu, Diandian and Zhao, Yihao and Zhong, Yinmin and Xiong, Yifan and Han, Zhenhua and Cheng, Peng and Yang, Fan and Huang, Gang and Jin, Xin and Liu, Xuanzhe},
title = {ElasticFlow Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7481637},
abstract = {
    <p>The artifact provides source code for the prototype of the proposed system ElasticFlow, including the main implementation of ElasticFlow, testbed experiment scripts (Section 6.2 \&amp; Section 6.6), and cluster simulation scripts (Section 6.3 \&amp; Section 6.4 \&amp; Section 6.5). We provide a docker image with pre-installed prerequisites to simplify the testbed experiment workflow. Users can also use a script to install all software dependencies from scratch. Please refer to the documents in our repository for more details.</p>

},
keywords = {Cluster Scheduling, Distributed Deep Learning, GPU Cluster, Serverless Computing}
}

@software{10.5281/zenodo.7493145,
author = {Jayarajan, Anand and Zhao, Wei and Sun, Yudi and Pekhimenko, Gennady},
title = {Reproduction package for the article 'TiLT: A Time-Centric Approach for Stream Query Optimization and Parallelization'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7493145},
abstract = {
    <p>This artifact appendix includes the source code and scripts to reproduce the scalability results and the real-world applications performance in the article ‘TiLT: A Time-Centric Approach for Stream Query Optimization and Parallelization’. We include docker containers to setup the runtime environment for all the experiments in order to support portability. Therefore, the artifact can be executed on any multi-core machine with docker engine installed. We also use Linux gnuplot utility to generate figures from the collected performance numbers. We  using Ubuntu 20.04 operating system for running the scripts provided in the artifact.</p>

},
keywords = {compiler, intermediate representation, stream data analytics, temporal query processing}
}

@software{10.6084/m9.figshare.21354552.v2,
author = {Yuan, Ziqi and Hong, Siyu and Chang, Rui and Zhou, Yajin and Shen, Wenbo and Ren, Kui},
title = {Artifact of Article "VDom: Fast and Unlimited Virtual Domains on Multiple Architectures"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21354552.v2},
abstract = {
    <p>The artifact of paper “VDom: Fast and Unlimited Virtual Domains on Multiple Architectures”, consists of the source code of VDom modified Linux kernel, user-space libraries, all evaluation benchmarks, and scripts necessary to reproduce the paper’s evaluation results.</p>

},
keywords = {computer system security, operating system, operating systems, software security, virtualization}
}

@software{10.5281/zenodo.7173860,
author = {Yin, Xizhe and Zhao, Zhijia and Gupta, Rajiv},
title = {Reproduction Package for Article `Glign: Taming Misaligned Graph Traversals in Concurrent Graph Processing’},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7173860},
abstract = {
    <p>This artifact contains the source code of Glign, including the five concurrent query evaluation designs discussd in the paper and some graph benchmarks along with their inputs used in the experiments. In addition, this artifact provides bash scripts to compile Glign and reproduce the key experimental results reported in the paper.</p>

},
keywords = {concurrent graph processing, data locality, graph system}
}

@software{10.5281/zenodo.7182800,
author = {Sutherland, Mark and Falsafi, Babak and Daglis, Alexandros},
title = {Discrete-Event Simulation Software and Results Accompanying "Cooperative Concurrency Control for Write Intensive Key-Value Workloads"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7182800},
abstract = {
    <p>This archive contains the code, datasets, and instructions to generate the discrete-event simulation results appearing in the paper: “Cooperative Concurrency Control for Write-Intensive Key-Value Workloads”.</p>
<p>All instructions and tutorials for using the artifact are contained in the paper’s artifact appendix.</p>

},
keywords = {concurrency control, discrete-event simulation, key-value store, load balancing}
}

@software{10.5281/zenodo.7198195,
author = {Gouicem, Redha and Sprokholt, Dennis and Ruehl, Jasper and Rocha, Rodrigo C. O. and Spink, Tom and Chakraborty, Soham and Bhatotia, Pramod},
title = {Risotto: A Dynamic Binary Translator for Weak Memory Model Architectures},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7198195},
abstract = {
    <p>Artifact for the Risotto: A Dynamic Binary Translator for Weak Memory Model Architectures paper published at ASPLOS’23.</p>

},
keywords = {binary translation, formal verification, memory models}
}

@software{10.5281/zenodo.7220659,
author = {Luo, Shutian and Xu, Huanle and Ye, Kejiang and Xu, Guoyao and Zhang, Liping and He, Jian and Yang, Guodong and Xu, Chengzhong},
title = {Reproduction Package for Article &nbsp;Erms: Efficient Resource Management for Shared Microservices with SLA Guarantees},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7220659},
abstract = {
    <p>Erms is a cluster-level resource management system for shared microservices with SLA guarantees. This artifact includes a proto- type implementation of Erms and the experimental workflows for running DeathStarBench on Erms.</p>

},
keywords = {Resource Management, Shared Microservices, SLA Guarantees}
}

@software{10.1145/3576916,
author = {Kelly, Terence},
title = {Source code for Drill Bits 8 article "Literate Executables"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3576916},
abstract = {
    <p>Literate executables redefine the relationship between compiled binaries and source code to be that of chicken and egg, so it’s easy to derive either from the other. This episode of Drill Bits provides a general-purpose literacy tool and showcases the advantages of literacy by retrofitting it onto everyone's favorite command-line utility.</p>
}
}

@software{10.1145/3550218,
author = {Kelly, Terence},
title = {Source code for the article "Drill Bits 04: Schrodingers Code"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550218},
abstract = {
    <p>The example programs, Roman numerals I, II, III, and IV, each has a shell script that shows how I compiled and ran them; sample output is listed below.  The code has been compiled and tested with GCC 10.2.1 and Clang 11.0.0.  In my experience the .c source files compile as both C17 and C++17 and other relatively modern dialects.</p>
}
}

@software{10.1145/3550219,
author = {Kelly, Terence},
title = {Source code for Drill Bits 6 article "Steampunk Machine Learning"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550219},
abstract = {
    <p>Script "run.csh" generates the data sets discussed in my column and runs R to estimate regression parameters for a linear model using two techniques, least-squares and least absolute residuals.  Read this script to understand how the sample data were created and analyzed with R.  File "cmds.R" contains the actual R commands.</p>
}
}

@software{10.1145/3550220,
author = {Kelly, Terence},
title = {Source code for Drill Bits 7 article "Persistent Memory Allocation"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550220},
abstract = {
    <p>Most of the test programs bundled with pma are primarily intended to exercise pma functionality for my benefit; they're not optimized for tutorial value.  However they illustrate basic usage and you might learn a trick or two by studying them.  For example, test5 shows how to use the root pointer; test6 shows how to make pma fall back on the conventional ephemeral memory allocator (standard malloc); and test7 shows an easy way to create a persistent C++ STL container by sliding a pma persistent heap beneath an STL <map>.  The tests also show how to create an uninitialized backing file for a persistent heap using the "truncate" command-line utility.  Some tests run under Valgrind. Tests come in .c/.csh file pairs; the scripts run under the C Shell (csh).  My test scripts might not be perfectly compatible with every OS and compiler.  Edit as necessary.</map></p>
}
}

@software{10.1145/3550221,
author = {Kelly, Terence},
title = {Source code for pmgawk in Drill Bits 7 article "Persistent Memory Allocation"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550221},
abstract = {
    <p>To use persistent gawk, first create for the persistent heap a sparse file whose size is a multiple of the system page size. The media beneath the filesystem containing the backing file are unconstrained, i.e., pma supports persistent memory programming  on conventional hardware as well as NVM.</p>
}
}

@software{10.1145/3550217,
author = {Kelly, Terence},
title = {Source code for the article "Offline Algorithms in Low-Frequency Trading"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550217},
abstract = {
    <p>The source code has been compiled with GCC and tested on Linux.  It is intended to be portable to other compilers and OSes without excessive fuss.  Re-format to taste with the "indent" utility. I recommend compiling with GCC's "-fsanitize=undefined" flag if your version of GCC supports it.  That should catch out-of-bounds array subscripts and signed integer overflow errors at run time. Program "rb" generates random bids.  Program "auclear" clears two-resource auctions.  Script "run.csh" compiles and runs both programs.</p>
}
}

@software{10.1145/3550216,
author = {Kelly, Terence},
title = {Source code for the article "Decentralized Computing"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550216},
abstract = {
    <p>Two maximal independent set (MIS) solver implementations are provided: "mixer" and "mis".  Shell scripts run both implementations on the example graph.<br>The "mixer.py" Python program is a decentralized implementation.  For each vertex in the graph we create a process that decides for itself whether to be "in" or "out" of the MIS after communicating as necessary with other processes representing adjacent vertices in the graph.  Read "mixer.csh" to see how the set of processes run. Without options, "mixer.csh" runs a set of "mixer.py" processes on the example graph.  With the "renum" option, the script also runs the Python code again on a different graph created by re-numbering the vertices of the original example graph.<br>The "mis.c" C program is a centralized implementation.  It reads the graph in file "example_graph.txt" and uses the same basic algorithm as the decentralized implementation to compute the same MIS.  Shell script "mis.csh" compiles the C code, runs the executable under the control of Valgrind, and uses the "check.awk" script to verify that the output is indeed an MIS of the input graph.  Run "indent" to adjust the layout of the C program to taste.</p>
}
}

@software{10.1145/3550215,
author = {Kelly, Terence},
title = {Source code for the article "Efficient Graph Search"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550215},
abstract = {
    <p>The run.csh script compiles two random graph generators and two variants of the BFS implementation, then the script runs experiments. I recommend running the script twice: once to bring your computer up to normal operating temperature and a second time to gather performance results.  Some modern computers may throttle back CPU performance when intensive computations cause them to overheat, so we want to measure performance with the machine in a warm steady state rather than under cold-start conditions.</p>
}
}

@software{10.1145/3462319,
author = {Baudart, Guillaume and Mandel, Louis and Tekin, Reyyan},
title = {Reproduction package for article JAX Based Parallel Inference for Reactive Probabilistic Programming},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462319},
abstract = {
    <p>This artifact supports the LCTES 2022 article <strong>JAX Based Parallel Inference for Reactive Probabilistic Programming</strong>. It contains:</p>
<ul>
<li><code>zelus</code>: a modified version of the <a href="https://zelus.di.ens.fr">Zelus</a> compiler with a new JAX backend</li>
<li><code>probzelus</code>: the original <a href="https://github.com/IBM/probzelus">ProbZelus</a> runtime for OCaml</li>
<li><code>zlax</code>: the new ProbZelus runtime for JAX</li>
<li><code>examples</code>: several examples of ProbZelus programs</li>
<li><code>zlax-benchmarks</code>: the benchmarks to compare the OCaml and JAX runtimes based on the original <a href="https://github.com/IBM/probzelus">ProbZelus benchmark</a></li>
<li><code>lctes22-zlax.pdf</code>: the <a href="https://pldi22.sigplan.org/track/LCTES-2022">LCTES 2022</a> paper.</li>
<li><code>lctes22-zlax-image.tar.gz</code>: the saved <a href="https://www.docker.com">Docker</a> image with everything installed.</li>
</ul>

},
keywords = {Compilation, Parallel Computing, Probabilistic Programming, Reactive Programming, Streaming Inference}
}

@software{10.1145/3462320,
author = {Schlaak, Christof and Juang, Tzung-Han and Dubach, Christophe},
title = {Reproducton Package for Article "Optimizing Data Reshaping Operations in Functional IRs for High-Level Synthesis"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462320},
abstract = {
    <p>This artifact fully covers all the experiments in section 4 of the LCTES 2022 paper “Optimizing Data Reshaping Operations in Functional IRs for High-Level Synthesis”. Starting from high-level expressions as described in sections 4.1 and 4.2 for tiled matrix multiplication and 2D convolution, the compiler automatically generates an optimized hardware design based on VHDL files. On the FPGA server, a bitstream for an FPGA is synthesised from these generated design files. Then the design is run on a real FPGA to get all the performance numbers and resource usages of Table 2 and Table 3.</p>

},
keywords = {compilers, functional IR, High-level synthesis, rewrite rules}
}

@software{10.1145/3462321,
author = {Schneider, Klaus and Bhagyanath, Anoop and Roob, Julius},
title = {Reproduction Package for Paper "Code Generation Criteria for Buffered Exposed Datapath Architectures from Dataflow Graphs "},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462321},
abstract = {
    <p>The software can be used to reproduce the computations described in the corresponding paper and also to perform computations with modified or completely different examples. In general, one can derive via a SAT solver a move code program for a BED architecture either from a sequential program or a dataflow graph derived from it.</p>

},
keywords = {code generation, dataflow graphs, exposed data- path architectures, linear graph layouts, queue layouts}
}

@software{10.5281/zenodo.6598647,
author = {Liu, Fengyun and Prokopec, Aleksandar},
title = {Artifact for paper implicit state machines LCTES 2022},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6598647},
abstract = {
    <p>This is the artefact for the paper “implicit state machines” at LCTES 2022.</p>
<p>Note that DSL is an old version and thus deprecated. We are working on a newer version with a better design.</p>

},
keywords = {digital design, DSL, implicit state machine}
}

@software{10.5281/zenodo.6605099,
author = {Wang, Tianyu and Shen, Zhaoyan and Shao, Zili},
title = {Reproduction package of "Co-mining: A Processing-in-Memory Assisted Framework for Memory-Intensive PoW Acceleration"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6605099},
abstract = {
    <p>A simple simulator that can simulate hashrate for different NVIDIA graphic cards with GDDR6 or HBM-PIM. Content: /configs: All the configurations of different graphic cards. /build: The trace file and result analysis scripts. /src: Main logic of the simulator.</p>

},
keywords = {GPU-PIM simulator}
}

@software{10.48420/17041502.v1,
author = {Stirling, Sean and Rocha, Rodrigo C. O. and Hazelwood, Kim and Leather, Hugh and O'Boyle, Michael and Petoumenos, Pavlos},
title = {Artifact for F3M: Fast Focused Function Merging},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.48420/17041502.v1},
abstract = {
    <p>Evaluation Artifact for the CGO 2022 paper “F3M: Fast Focused Function Merging”.</p>
<p>This archive contains: 1) The scripts needed to setup the evaluation environment including pulling the Function Merging code and building it. 2) The scripts needed to reproduce the experiments in the paper. 3) Pre-compiled LLVM IR bitcode files on which we evaluate function merging.</p>

},
keywords = {code-size reduction, compiler optimization, function merging, LLVM}
}

@software{10.5281/zenodo.5703630,
author = {Vishwanathan, Harishankar and Shachnai, Matan and Narayana, Srinivas and Nagarakatte, Santosh},
title = {Artifact for submission "Sound, Precise, and Fast Abstract Interpretation with Tristate Numbers"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5703630},
abstract = {
    <p>In this artifact, we provide instructions to reproduce and validate the following claims in the paper.</p>
<ol type="1">
<li><p>Verification of tnum operations using the Z3 SMT solver</p></li>
<li><p>Precision improvements in our tnum multiplication algorithm compared to the Linux kernel’s tnum multiplication.</p></li>
<li><p>Performance improvements in our tnum multiplication algorithm compared to Linux kernel’s tnum multiplication.</p></li>
<li><p>Precision of tnum multiplication compared to the Linux kernel’s tnum multiplication as a function of increasing bitwidth of input tnums.</p></li>
</ol>

},
keywords = {Abstract domains, eBPF, Kernel extensions, Program verification, Static
analysis}
}

@software{10.5281/zenodo.5710526,
author = {Kallwies, Hannes and Leucker, Martin and Scheffel, Torben and Schmitz, Malte and Thoma, Daniel},
title = {Artifact (Docker Image) for paper "Aggregate Update Problem for Multi-Clocked Dataflow Languages"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5710526},
abstract = {
    <p>The artifact contains a TeSSLa to Scala compiler with the optimization described in the paper “Aggregate Update Problem for Multi-Clocked Dataflow Languages” and the benchmarks from the paper. The artifact is packaged as a Docker image for x86 64 Bit architectures. It provides shell scripts to compile and execute the synthetic as well as the real-world benchmarks described in the paper. The artifact further contains the source code of the implemented compiler phase and additional examples.</p>

},
keywords = {Aggregate Update Problem, Compiler Optimization, Dataflow Languages}
}

@software{10.5281/zenodo.5784251,
author = {Cummins, Chris and Wasti, Bram and Guo, Jiadong and Cui, Brandon and Ansel, Jason and Gomez, Sahir and Jain, Somya and Liu, Jia and Teytaud, Olivier and Steiner, Benoit and Tian, Yuandong and Leather, Hugh},
title = {CompilerGym Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5784251},
abstract = {
    <p>This is a supporting code artifact for the publication: “CompilerGym: Robust, Performant Compiler Optimization Environments for AI Research”. This is a snapshot of the CompilerGym repository, created at the time of publication.</p>
<p>For the most up-to-date release of CompilerGym, see GitHub: https://github.com/facebookresearch/CompilerGym.</p>
<p>For further information on CompilerGym, see our documentation site: https://compilergym.ai/.</p>

},
keywords = {compiler optimization, machine learning, reinforcement learning}
}

@software{10.5281/zenodo.5784768,
author = {Saumya, Charitha and Sundararajah, Kirshanthan and Kulkarni, Milind},
title = {Replication Package for Article: DARM: Control-Flow Melding for SIMT Thread Divergence Reduction},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5784768},
abstract = {
    <p>This artifact provides the source code that implements DARM, a compiler optimization technique for reducing SIMT thread divergence by control-flow melding. Our approach is implemented on top of the ROCm LLVM compiler. We also provide a benchmark suite to evaluate the effectiveness of our technique. This benchmark suite consists of well-known open-source GPGPU applications and optimized reference implementations of certain GPGPU applications. We provide a README file that describes how to build DARM and perform the experimental evaluation described in the initial version of our paper.</p>

},
keywords = {Compiler Optimizations, Control-Flow Divergence, GPGPUs}
}

@software{10.5281/zenodo.5785485,
author = {Tian, Linan and Shi, Yangyang and Chen, Liwei and Yang, Yanqi and Shi, Gang},
title = {Gadgets Splicing: Dynamic Binary Transformation for Precise Rewriting (CGO 2022 Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5785485},
abstract = {
    <p>This document describes the artifact for paper “Gadgets Splicing: Dynamic Binary Transformation for Precise Rewriting” at CGO 2022. The artifact is in the form of a virtual machine running Ubuntu 18.04. It contains all software dependencies and compiled GRIN rewriter, benchmark binaries and scripts. You can directly run the scripts for reproducing main experiments.</p>

},
keywords = {Binary analysis, Binary rewriting, Dynamic execution, Static analysis}
}

@software{10.5281/zenodo.5785832,
author = {Park, Sunghyun and Latifi, Salar and Park, Yongjun and Behroozi, Armand and Jeon, Byungsoo and Mahlke, Scott},
title = {SRTuner: Effective Compiler Optimization Customization by Exposing Synergistic Relations},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5785832},
abstract = {
    <p>SRTuner is a tuning strategy that searches for the best possible optimization setting for the given run-time environment. Within the tuning budget, SRTuner endeavors to expose important inter-relatonship between optimizations and leverage them to focus on the promising search subspace. To allow fast integration, SRTuner is built in the form of python library that provides tuning primitives. Users can build a standalone tuning framework with these primitives or adopt them into the existing tuning framework as a new tuning method. Latest version of SRTuner is available at: https://github.com/sunggg/SRTuner</p>

},
keywords = {autotuner, compiler, optimization}
}

@software{10.5281/zenodo.5786074,
author = {Bhat, Siddharth and Grosser, Tobias},
title = {Lambda the Ultimate SSA: Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5786074},
abstract = {
    <p>This is the artifact in the form of a docker image for our CGO’22 paper “Lambda the ultimate SSA”. It contains full source code of our compiler, benchmarks and scripts for reproducing main experiments of the paper. We supply instructions on how to run the artifact evaluation in the appendix of our paper.</p>

},
keywords = {compilers, functional programming}
}

@software{10.5281/zenodo.5787482,
author = {Wang, Xudong and Xu, Xuezheng and Li, Qingan and Yuan, Mengting and Xue, Jingling},
title = {Artifact for Article: Recovering Container Class Types in C++ Binaries},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5787482},
abstract = {
    <p>The artifact provides all non-proprietary components of TIARA.</p>

},
keywords = {Binary Code Analysis, Containers, Template Classes, Type Inference}
}

@software{10.5281/zenodo.5788581,
author = {Brahmakshatriya, Ajay and Amarasinghe, Saman},
title = {Replication Package for the paper 'GraphIt to CUDA Compiler in 2021 LOC: A Case for High-Performance DSL Implementation via Staging with BuilDSL'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5788581},
abstract = {
    <p>The artifact contains the source code and the evaluation scripts for the evaluations in the paper. The attached README has step-by-step instructions to clone, build and run BuilDSL. The README also has steps on how to obtain the dataset, build the comparison framework GraphIt and run the experiments that compare the performance of the generated code on 9 datasets and 5 applications.</p>
<p>The second part of the README provides step-by-step instructions to write a new DSL with BuilDSL for matrix multiplication and implement a simple analysis on top of it before generating CPU and GPU code.</p>

},
keywords = {code generation, data-flow analysis, domain-specific languages, meta-programming, multi-stage programming}
}

@software{10.5281/zenodo.5789242,
author = {Li, Ao and Zheng, Bojian and Pekhimenko, Gennady and Long, Fan},
title = {Replication Packet for Article: Automatic Horizontal Fusion for GPU Kernels},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5789242},
abstract = {
    <p>This replication package provides the source code for article: Automatic Horizontal Fusion for GPU Kernels.</p>

},
keywords = {CUDA, GPU, Kernel Fusion, LLVM}
}

@software{10.5281/zenodo.5789400,
author = {Matni, Angelo and Deiana, Enrico Armenio and Su, Yian and Gross, Lukas and Ghosh, Souradip and Apostolakis, Sotiris and Xu, Ziyang and Tan, Zujun and Chaturvedi, Ishita and Homerding, Brian and McMichen, Tommy and August, David I. and Campanoni, Simone},
title = {Replication Package For Article: NOELLE Offers Empowering LLVM Extensions},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5789400},
abstract = {
    <p>This artifact generates three sets of results.</p>
<p>MINIMAL: Data that supports the version of the paper that was submitted in September. This experiment does not include HELIX and DSWP, which both take a significant amount of time to transform each benchmark.</p>
<p>SUBMISSION: HELIX and DSWP are included.</p>
<p>FINAL: New results that were not included in the submitted version of the paper (extra 5 days). Also, HELIX and DSWP are included in this experiment.</p>

},
keywords = {automatic parallelization, dependence analysis, loop invariant analysis}
}

@software{10.5281/zenodo.5791919,
author = {Huber, Joseph and Cornelius, Melanie and Georgakoudis, Giorgis and Tian, Shilei and Monslave Diaz, Jose M and Dinel, Kuter and Chapman, Barbara and Doerfert, Johannes},
title = {Replication Package for Article: Efficient Execution of OpenMP on GPUs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5791919},
abstract = {
    <p>Our artifact provides the benchmarks used to evaluate the inter-procedural OpenMP optimizations implemented for this work. These benchmarks were evaluated using LLVM 12.0.1 as the baseline against a development branch of LLVM containing our changes with CUDA version 11.0. All but one of these patches have landed upstream, so any build of LLVM containing the commit hash 29a3e3dd7bed should be sufficient for general testing. Evaluation was done on a single Nvidia V100 GPU node, only kernel time was considered for benchmarking to measure the impact of our optimizations on the GPU.</p>

},
keywords = {GPU, LLVM, Offloading, OpenMP, Optimization}
}

@software{10.5281/zenodo.5792202,
author = {Rivera, Joao and Franchetti, Franz and P\"{u}schel, Markus},
title = {Artifact: A Compiler for Sound Floating-Point using Affine Arithmetic},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5792202},
abstract = {
    <p>The artifact is in the form of a virtual machine running Ubuntu 20.04. It contains source code of SafeGen, benchmarks and scripts for reproducing main experiments of the paper.</p>

},
keywords = {affine arithmetic, floating-point arithmetic, guaranteed computations, source-to-source compiler}
}

@software{10.5281/zenodo.5866935,
author = {Vesely, Jan and Pothukuchi, Raghavendra Pradyumna and Joshi, Ketaki and Gupta, Samyak and Cohen, Jonathan D. and Bhattacharjee, Abhishek},
title = {Distill: Domain-Specific Compilation for Cognitive Models Evaluation Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5866935},
abstract = {
    <p>This artifact contains an image with the environments and experiments presented in: “Distill: Domain-Specific Compilation for Cognitive Models” [CGO’22, Seoul, South Korea].</p>
<p>This artifact is based on an older version of PsyNeuLink (April 2021), and no longer represents the latest version. For up-to-date information on PsyNeuLink, as well as any support with developing cognitive models please visit https://github.com/PrincetonUniversity/PsyNeuLink.</p>

},
keywords = {cognitive models, Domain-specific compilation, human brain, JIT compilers, LLVM, PsyNeuLink, Python.}
}

@software{10.6084/m9.figshare.17048447.v1,
author = {Olabi, Mhd Ghaith and Luna, Juan G\'{o}mez and Mutlu, Onur and Hwu, Wen-mei and El Hajj, Izzat},
title = {A Compiler Framework for Optimizing Dynamic Parallelism on GPUs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.17048447.v1},
abstract = {
    <p>Our artifact is a compiler implemented within Clang for optimizing applications that use dynamic parallelism. Since building the compiler requires building Clang/LLVM which can be time and resource consuming, we provide pre-built binaries in a Docker image, along with the required dependences and the benchmarks/datasets on which the compiler has been evaluated. Reviewers can use these binaries to transform the CUDA code with our optimizations, then compile and run the code on a CUDA-capable GPU. Scripts are provided to automate this process.</p>

},
keywords = {compiler, CUDA kernel, GPU computing}
}

@software{10.6084/m9.figshare.17263274.v1,
author = {Rocha, Rodrigo C. O. and Petoumenos, Pavlos and Franke, Bj\"{o}rn and Bhatotia, Pramod and O'Boyle, Michael},
title = {Replication Package for Article, "Loop Rolling for Code Size Reduction"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.17263274.v1},
abstract = {
    <p>Artifact for the CGO 2022 paper titled: “Loop Rolling for Code Size Reduction”.</p>

},
keywords = {Code Size Reduction, Compiler, Compiler Optimization, LLVM, Loop Optimization}
}

@software{10.5281/zenodo.6335844,
author = {Shen, Weihai and khanna, Ansh and Angel, Sebastian and Sen, Siddhartha and Mu, Shuai},
title = {Implementation of the article "Rolis: a software approach to efficiently replicating multi-core transactions"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6335844},
abstract = {
    <p></p><p>Artifact appendix item for Eurosys22'</p><p></p>
}
}

@software{10.5281/zenodo.6336004,
author = {Li, Ning and Jiang, Hong and Che, Hao and Wang, Zhijun and NGUYEN, MINH},
title = {Implementation of the article "Improving Scalability of Database Systems by Reshaping User Parallel I/O"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6336004},
abstract = {
    <p></p><p>AppleS aims to improve database scalability by delivering the right amount and pattern of user parallel I/O requests to the database system under excessive user parallelism, aligning with the concurrency supported by the database and its underlying I/O stack. In doing so, AppleS improves user-level I/O performance in terms of user-level I/O fairness, throughput and latency stability. Implemented as a user-space module based on system call interception, AppleS is compatible with and portable to different types/versions of databases, different versions of OS kernels and their resource management tools, e.g., Cgroups.</p><p></p>
}
}

@software{10.5281/zenodo.6336200,
author = {Zhou, Xia and Li, Jiaqi and Zhang, Wenlong and Zhou, Yajin and Shen, Wenbo and Ren, Kui},
title = {Implementation of the article "OPEC: Operation-based Security Isolation for Bare-metal Embedded Systems"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6336200},
abstract = {
    <p></p><p>Keep consistent with zhouxzju/opec:v1.3</p><p></p>
}
}

@software{10.5281/zenodo.6336301,
author = {Kirth, Paul and Dickerson, Mitchel and Crane, Stephen and Larsen, Per and Dabrowski, Adrian and Gens, David and Na, Yeoul and Volckaert, Stijn and Franz, Michael},
title = {Implementation of the article "PKRU-Safe: Automatically Locking Down the Heap Between Safe and Unsafe Languages"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6336301},
abstract = {
    <p></p><p>Public release v1.0.0 of PKRU-Safe for EuroSys22.</p><p></p>
}
}

@software{10.5281/zenodo.6337102,
author = {Thalheim, Joerg and Okelmann, Peter and Unnibhavi, Harshavardhan and Gouicem, Redha and Bhatotia, Pramod},
title = {Implementation of the article "VMSH: Hypervisor-agnostic Guest Overlays for VMs"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6337102},
abstract = {
    <p></p><p>Source code of VMSH</p><p></p>
}
}

@software{10.5281/zenodo.6338745,
author = {Bozdoaan, Kartal Kaan and Stavrakakis, Dimitrios and Issa, Shady and Bhatotia, Pramod},
title = {Implementation of the article "SafePM: A Sanitizer for Persistent Memory"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6338745},
abstract = {
    <p></p><p>SafePM: Memory Safety for Persistent Memory --- Artifact Evaluation</p><p></p>
}
}

@software{10.5281/zenodo.6342303,
author = {Xiang, Lingfeng and Zhao, Xingsheng and Rao, Jia and Jiang, Song and Jiang, Hong},
title = {Implementation of the article "Characterizing the Performance of Intel Optane Persistent Memory -- A Close Look at its On-DIMM Buffering"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6342303},
abstract = {
    <p></p><p>Submitted version for EuroSys 2022 artifact evaluation</p><p></p>
}
}

@software{10.5281/zenodo.6344960,
author = {Lawall, Julia and Pandya, Himadri and Lozi, Jean-Pierre and Lepers, Baptiste and Zwaenepoel, Willy and Muller, Gilles},
title = {Implementation of the article "OS Scheduling with Nest: Keeping Tasks Close Together on Warm Cores"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6344960},
abstract = {
    <p></p><p>Nest is a scheduling policy built on the Linux kernel that is designed according to the principles of core reuse and keeping cores warm.&nbsp; This artifact contains instructions and tools necessary to replicate the experiments found in this paper.</p><p></p>
}
}

@software{10.5281/zenodo.6345303,
author = {Jiao, Yizheng and Porter, Don and Patel, Sagar and Zeller, Luke and Bennet, Rory and Bender, Michael and Condict, Michael and Conway, Alex and Farach-Colton, Martin and GE, XIONGZI and Jannen, William and Johnson, Rob and Yuan, Jun and Bertron, Simon and Mukherjee, Nirjhar},
title = {Implementation of the article "BetrFS: A Compleat File System for Commodity SSDs"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6345303},
abstract = {
    <p></p><p>Versions of scripts used to recreate the results from "BetrFS: A Compleat File System for Commodity SSDs".</p><p></p>
}
}

@software{10.5281/zenodo.6345350,
author = {Gog, Ionel and Kalra, Sukrit and Schafhalter, Peter and Gonzalez, Joseph and Stoica, Ion},
title = {Implementation of the article "D3: A Dynamic Deadline-Driven Approach for Building Autonomous Vehicles"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6345350},
abstract = {
    <p></p><p>Scripts to reproduce experiments and graphs from the <code>D3: A Dynamic Deadline-Driven Approach for Building Autonomous Vehicles</code> paper accepted at <code>EuroSys 2022</code>.</p><p></p>
}
}

@software{10.5281/zenodo.6345713,
author = {Chen, Chen and Zhong, Wenshao and Wu, Xingbo and Wu, Xingbo},
title = {Implementation of the article "Building an Efficient Key-Value Store in a Flexible Address Space"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6345713},
abstract = {
    <p></p><p>This is the Digital Object Identifier (DOI) page for persistently indexing the source code and artifact of FlexTree, FlexSpace and FlexDB. Their latest version could be found in the following GitHub repositories:</p>

<p>https://github.com/flexible-address-space/flexspace<br>
https://github.com/flexible-address-space/eurosys22-artifact</p><p></p>
}
}

@software{10.5281/zenodo.6345733,
author = {Xu, Ran and Lee, Jayoung and Wang, Pengcheng and Bagchi, Saurabh and Li, Yin and Chaterji, Somali},
title = {Implementation of the article "LiteReconfig: Cost and Content Aware Reconfiguration of Video Object Detection Systems for Mobile GPUs"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6345733},
abstract = {
    <p></p><p>The source code for the LiteReconfig paper at EuroSys 2022. Thanks to @StarsThu2016 @starpic414 @ChulanZhang for their contributions to this release.</p><p></p>
}
}

@software{10.5281/zenodo.6347456,
author = {Yang, Jianbang and Tang, Dahai and Song, Xiaoniu and Wang, Lei and Yin, Qiang and Chen, Rong and Yu, Wenyuan and Zhou, Jingren},
title = {Implementation of the article "GNNLab: A Factored System for Sample-based GNN Training over GPUs"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6347456},
abstract = {
    <p>FGNN's artifact evaluation (EuroSys 2022)</p>
}
}

@software{10.5281/zenodo.6347736,
author = {Asyabi, Esmail and Wang, Yuanli and Liagouris, John and Kalavri, Vasiliki and Bestavros, Azer},
title = {Implementation of the article "A New Benchmark Harness for Systematic and Robust Evaluation of Streaming State Stores"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6347736},
abstract = {
    <p></p><p>No description provided.</p><p></p>
}
}

@software{10.5281/zenodo.6348174,
author = {Mehrab, A K M Fazla and Nikolaev, Ruslan and Ravindran, Binoy},
title = {Implementation of the article "Kite: Lightweight Critical Service Domains full strip note"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6348174},
abstract = {
    <p></p><p>Artifact for EuroSys'22 paper "Kite: Lightweight Critical Service Domains". Please see kite/README.md in Kite.zip for more information.&nbsp;Please also see the licensing terms in LICENSE.</p><p></p>
}
}

@software{10.5281/zenodo.6349596,
author = {Khandelwal, Anurag and Tang, Yupeng and Agarwal, Rachit and Akella, Aditya and Stoica, Ion and Akella, Aditya},
title = {Implementation of the article "Jiffy: Statistical Multiplexing for Disaggregated Memory full strip note"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6349596},
abstract = {
    <p></p><p>Artifact appendix item for Eurosys 2022.</p><p></p>
}
}

@software{10.5281/zenodo.6350453,
author = {Wanninger, Nicholas and Hale, Kyle and Bowden, Joshua},
title = {Implementation of the article "Isolating at the Hardware Limit with Virtines"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6350453},
abstract = {
    <p></p><p>Wasp: micro-hypervisor that enables lightweight, isolated virtines</p><p></p>
}
}

@software{10.5281/zenodo.6360540,
author = {Iqbal, Md Shahriar and Krishna, Rahul and Javidian, Mohammad Ali and Ray, Baishakhi and Jamshidi, Pooyan},
title = {Implementation of the article "Unicorn: Reasoning about Configurable System Performance through the lens of Causality"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6360540},
abstract = {
    <p>Debugging Cross Stack Performance Faults using Causal Inference</p>
}
}

@software{10.5281/zenodo.5988606,
author = {Peduri, Anurudh and Bhat, Siddharth and Grosser, Tobias},
title = {QSSA: An SSA-based IR for Quantum Computing - Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5988606},
abstract = {
    <p>This is the artifact for our CC’22 paper “QSSA: An SSA-based IR for Quantum Computing”. It consists of a docker image containing full source code of our compiler, benchmarks and scripts for reproducing main experiments of the paper. We supply instructions on how to run the artifact evaluation in the appendix of our paper.</p>

},
keywords = {compilers, intermediate representations, optimization, quantum circuits, SSA}
}

@software{10.5281/zenodo.6313660,
author = {Wang, Huanting and Tang, Zhanyong and Zhang, Cheng and Zhao, Jiaqi and Cummins, Chris and Leather, Hugh and Wang, Zheng},
title = {Reproduction Package for Article 'Automating Reinforcement Learning Architecture Design for Code Optimization'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6313660},
abstract = {
    <p>The research artifact enables the reproduction of the main results of the paper. It provides instructions to download and run a preconfigured Docker image to reproduce the results and customize the experiments.</p>

},
keywords = {code optimization, Compiler optimization, reinforcement learning}
}

@software{10.5281/zenodo.6330043,
author = {Xu, Yufan and Raje, Saurabh and Rountev, Atanas and Sabin, Gerald and Sukumaran-Rajam, Aravind and Sadayappan, P.},
title = {Reproduction package for "Training of Deep Learning Pipelines on Memory-Constrained GPUs via Segmented Fused-Tiled Execution"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6330043},
abstract = {
    <p>The artifact contains all the scripts and data required to reproduce the experimental results in the CC 2022 paper titled “ Training of Deep Learning Pipelines on Memory-Constrained GPUs via Segmented Fused-Tiled Execution”. The git repository contains: 1)The SFT source code; 2)The scripts to measure execution time of default PyTorch, PyTorch checkpoint, and SFT; 3)Raw data that we used to plot Fig. 8 (for comparison).</p>

},
keywords = {Checkpointing, DNN, Fusion, GPU, Large image training, Memory-constrained execution, Tiling}
}

@software{10.5281/zenodo.6330172,
author = {Sahebolamri, Arash and Gilray, Thomas and Micinski, Kristopher},
title = {Ascent},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6330172},
abstract = {
    <p>Source code of Ascent, a logic programming language (similar to Datalog) embedded in Rust via macros.</p>

},
keywords = {Datalog, Logic Programming, Program Analysis, Rust}
}

@software{10.6084/m9.figshare.19249817.v1,
author = {Mogers, Naums and Li, Lu and Radu, Valentin and Dubach, Christophe},
title = {Artifact for the paper "Mapping Parallelism in a Functional IR through Constraint Satisfaction"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.19249817.v1},
abstract = {
    <p>This artifact contains the parallel code generator Lift which is described in the CC 2022 paper “Mapping Parallelism in a Functional IR through Constraint Satisfaction”. Furthermore, this artifact contains the Docker image, scripts and best-found convolution kernels required to reproduce the performance and search efficiency results presented in the paper. To validate the results, build Lift, run the best-found VGG-16 convolution kernels on a Mali GPU board, and, finally use the plotting script to reproduce the results from Figure 4 in the paper. We also provide scripts to perform time-intensive parallel mapping space exploration and discover the best parallelizations for each layer of VGG-16 for a given Mali GPU board, as well as measure exploration duration to reproduce Figure 5 in the paper.</p>

},
keywords = {code generation, convolution, mobile GPU, parallelism}
}

@software{10.1145/3462316,
author = {Gorjiara, Hamed and Xu, Guoqing Harry and Demsky, Brian},
title = {Replication Package for Article: Yashme: Detecting Persistency Races},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462316},
abstract = {
    <p>This artifact contains a vagrant repository that downloads and compiles the source code for Yashme, its companion compiler pass, and benchmarks. The artifact enables users to reproduce the bugs that are found by Yashme in PMDK, Memcached, and Redis, and RECIPE as well as the performance results to compare Yashme with Jaaru, the underlying model checker.</p>

},
keywords = {CCEH, Compiler, FastFair, Memcached, Persistency Race, PMDK, RECIPE, Redis, Software Verification, Yashme}
}

@software{10.1145/3462317,
author = {Du, Dong and Liu, Qingyuan and Jiang, Xueqiang and Xia, Yubin and Zang, Binyu and Chen, Haibo},
title = {Artifact for Paper: Serverless Computing on Heterogeneous Computers},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3462317},
abstract = {
    <p>The artifact is the main repo for paper, Serverless Computing on Heterogeneous Computers. It contains the instructions to build and run the experiments, and the top directory of the project.</p>

},
keywords = {heterogeneous architecture, operating system, Serverless computing, smart computers}
}

@software{10.5281/zenodo.5733989,
author = {Zheng, Zhen and Yang, Xuanda and Zhao, Pengzhan and Long, Guoping and Zhu, Kai and Zhu, Feiwen and Zhao, Wenyi and Liu, Xiaoyong and Yang, Jun and Zhai, Jidong and Song, Shuaiwen Leon and Lin, Wei},
title = {ASPLOS22 Artifact - AStitch Machine Learning Optimizing Compiler},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5733989},
abstract = {
    <p>The artifact contains the necessary software components to validate the main results in AStitch paper. We provide a docker image to ease the environment setup. The docker image contains the compiled binary of AStitch, scripts to evaluate the inference and training performance, and scripts to draw the figures. It requires a Linux system with NVIDIA driver (capable to run CUDA 10.0) running on a NVIDIA V100 GPU equipped x86_64 machine to create the docker container. After launching the docker container, people can run one script to collect all performance numbers. It requires some manual finishing to fill the performance numbers into several python scripts to draw the most important figures in the paper, showing the speedup of AStitch and breakdown information.</p>

},
keywords = {Compiler Optimization, Kernel Fusion, Machine Learning System, Memory-intensive Computation}
}

@software{10.5281/zenodo.5746505,
author = {Zhang, Haotian and Ren, Mengfei and Lei, Yu and Ming, Jiang},
title = {uTrimmer: Security Hardening of MIPS Embedded Systems via Static Binary Debloating for Shared Libraries},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5746505},
abstract = {
    <p>This abstract is used to evaluate performance of our debloating framework uTrimmer on SPEC CPU2017, MIPS firmware applications, and a real MIPS embedded application. uTrimmer is built on top of angr to identify and wipe out unused basic blocks from shared libraries’ binary code in MIPS firmware applications. For a given MIPS binary program and its dependent shared libraries, uTrimmer can export a debated shared libraries of the program. uTrimmer itself does not need additional software to work. However, to evaluate the debloating result, It requires IDA pro for function boundary detection and QEMU to emulate execution environment for programs under the test. The required execution scripts to reproduce the experiment results are provided in the VM image.</p>
<p>We performed several experiments to evaluate uTrimmer’s performance. The first experiment evaluates debloating capability of uTrimmer on SPEC CPU2017 and real firmware applications. The result is shown in Table 3 on page 10. The second experiment compares uTrimmer with the static linker about the debloating efficiency, which is shown in Table 4 on page 10. The third experiment demonstrates uTrimmer’s ability to reduce ROP gadgets on SPEC 2017 and firmware applications. We show the execution results in Table 5 on page 10. We also conducted an experiment on real firmware to evaluate uTrimmer’s performance, shown in Table 6 on page 12.</p>

},
keywords = {embeded system, shared library debloating, static binary analysis}
}

@software{10.5281/zenodo.5747666,
author = {Kannan, Tejas and Hoffmann, Henry},
title = {Replication Package for Article: Protecting Adaptive Sampling from Information Leakage on Low-Power Sensors},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5747666},
abstract = {
    <p>This artifact provides an implementation of Adaptive Group Encoding (AGE). AGE is a framework that protects adaptive sampling procedures on low-power sensors from leaking information through the size of batched messages. The system works by encoding all measurement batches as fixed-length messages, thereby breaking the relationship between the message size and the adaptive policy’s collection rate. This repository implements AGE both in a simulated environment and on a microcontroller (MCU). The simulator, written in Python, represents the sensor and server as individual processes. These components communicate using a local (encrypted) socket, and the simulator tracks the sensor’s energy consumption using traces from a TI MSP430 MCU. The hardware setting executes AGE on a TI MSP430 FR5994. The MCU transmits measurement batches to a separate server over a Bluetooth link. These experimental settings confirm AGE’s ability to maintain the low error of adaptive sampling while preventing information leakage and incurring negligible energy overhead. The repository https://github.com/tejaskannan/adaptive-group-encoding contains all the code for this work.</p>

},
keywords = {Adaptive Sampling, Data Privacy, Embedded Systems, Lossy Data Encoding}
}

@software{10.5281/zenodo.5748274,
author = {Pismenny, Boris and Liss, Liran and Morrison, Adam and Tsafrir, Dan},
title = {Artifact for 'The Benefits of General-Purpose On-NIC Memory'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5748274},
abstract = {
    <p>This repository contains scripts for ASPLOS’22 artifact evaluation of the The Benefits of General-Purpose on-NIC Memory paper by Boris Pismenny, Liran Liss, Adam Morrison, and Dan Tsafrir.</p>

},
keywords = {NFV acceleration, NIC memory, nicmem}
}

@software{10.5281/zenodo.5748410,
author = {Zhang, Qian and Wang, Jiyuan and Xu, Guoqing Harry and Kim, Miryung},
title = {Artifact for Article: HeteroGen: Transpiling C to Heterogeneous HLS Code with Automated Test Generation and Program Repair},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5748410},
abstract = {
    <p>This artifact includes an error study, a fuzzing-based test generation tool, and an automated code edit tool for error removal.</p>

},
keywords = {heterogeneous applications, program repair, test generation}
}

@software{10.5281/zenodo.5748606,
author = {Deutsch, Peter W. and Yang, Yuheng and Bourgeat, Thomas and Drean, Jules and Emer, Joel S. and Yan, Mengjia},
title = {Gem5/Rosette Simulation Packages for DAGguise},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5748606},
abstract = {
    <p>Our artifact comprises of two distinct parts: a unified gem5 / DRAMSim2 model (for performance evaluation), and a Rosette model (for security verification). The unified gem5/DRAMSim2 model is able to evaluate the performance of DAGguise and FS-BTA against an insecure baseline. We use gem5’s OoO core to perform baseline measurements, profile candidate rDAGs, and report final performance numbers. We also include the sample victim programs (DocDist and DNA) as described in the paper, in addition to an rDAG generation tool, and plotting scripts for Figures 7 and 9. The Rosette model symbolically executes the DAGguise system and verifies the Security Property with K-Induction as described in Section 5 of the paper.</p>

},
keywords = {dagguise, dramsim2, gem5, rosette}
}

@software{10.5281/zenodo.5748667,
author = {Roy, Rohan Basu and Patel, Tirthak and Tiwari, Devesh},
title = {IceBreaker: Warming Serverless Functions Better with Heterogeneity},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5748667},
abstract = {
    <p>IceBreaker is technique that reduces the service time and keep-alive cost of serverless functions, which are executed on a heterogeneous system consisting of costly and cheaper nodes. IceBreaker’s design consists of two major components: (1) Function Invocation Prediction Scheme (FIP), and (2) Placement Decision Maker (PDM). The FIP uses a Fourier transform based approach to determine the invocation concurrency of a function. The PDM decides where to warm up a serverless function: on a high-end server, or on a low- end server, or no warm up at all. This decision is made based upon an utility score which is calculated by considering several factors like probability of function invocation, speedup of a function on a high-end server, etc. Our artifact packages the scripts for setting up and invoking IceBreaker. It also contains the data obtained in our experimentation.</p>

},
keywords = {Cloud Computing, Cold Start, Heterogeneous Hardware, Keep-alive Cost, Serverless Computing}
}

@software{10.5281/zenodo.5780204,
author = {Li, Gushu and Wu, Anbang and Shi, Yunong and Javadi-Abhari, Ali and Ding, Yufei and Xie, Yuan},
title = {Artifact for Article: Paulihedral: A Generalized Block-Wise Compiler Optimization Framework for Quantum Simulation Kernels},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5780204},
abstract = {
    <p>See appendix for artifact description</p>

},
keywords = {compiler, quantum computing, quantum simulation}
}

@software{10.5281/zenodo.5785310,
author = {Wang, Bangyan and Deng, Lei and Sun, Fei and Dai, Guohao and Liu, Liu and Wang, Yu and Xie, Yuan},
title = {Replication package for paper "A One-for-All and $O(V\log(V))$-Cost Solution for Parallel Merge Style Operations on Sorted Key-Value Arrays"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5785310},
abstract = {
    <p>It contains the necessary source code to reproduce the result in paper “A One-for-All and <span class="math inline"><em>O</em>(<em>V</em>log (<em>V</em>))</span>-Cost Solution for Parallel Merge Style Operations on Sorted Key-Value Arrays”. It contains:</p>
<ol type="1">
<li>A modified GCC compiler that support the new SIMD primitives</li>
<li>A modified Gem5 simulator that support the new SIMD primitives</li>
<li>A collection of kernels written in C++ that use the new SIMD primitives. It should be compiled using the modified GCC.</li>
<li>A dockerfile to help you setup the environement.</li>
</ol>

},
keywords = {GCC, Gem5, Graph, Join, Key-value array, Merge sort, SIMD, Sparse linear algebra, SpGEMM}
}

@software{10.5281/zenodo.5790730,
author = {Chen, Zhangyu and Hua, Yu and Zhang, Yongle and Ding, Luochangqi},
title = {Replication Package for Article: Efficiently Detecting Concurrency Bugs in Persistent Memory Programs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5790730},
abstract = {
    <p>This is the finalized artifact of PMRace, a debugging tool for PM concurrency bugs. The artifact is maintained at <a href="https://github.com/yhuacode/pmrace-vagrant">GitHub</a> and developed by Zhangyu and Luochangqi.</p>

},
keywords = {Concurrency, Crash Consistency, Debugging, Persistent Memory, Testing}
}

@software{10.5281/zenodo.5792458,
author = {Zhao, Shixiong and Li, Fanxin and Chen, Xusheng and Shen, Tianxiang and Chen, Li and Wang, Sen and Zhang, Nicholas and Li, Cheng and Cui, Heming},
title = {Replication Package for Article: NASPipe: High Performance and Reproducible Pipeline Parallel Supernet Training via Causal Synchronous Parallelism},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5792458},
abstract = {
    <p>The artifact provides the availability, functionality, and key reproducible results of the paper (NASPipe: High Performance and Reproducible Pipeline Parallel Supernet Training via Causal Synchronous Parallelism): a causal parallel training execution framework. The artifact requires a host with at least 100GB CPU RAM and 4 Nvidia GPUs, and each GPU requires at least 11GB memory. The runtime environment is installed by docker with a few command lines. The experiments contain a throughput evaluation and reproducible training evaluation. The artifact provides one-click shell scripts to conduct the experiments.</p>

},
keywords = {Distributed Training, Neural Architecture Search, Pipeline training}
}

@software{10.5281/zenodo.5796083,
author = {Zhou, Keren and Hao, Yueming and Mellor-Crummey, John and Meng, Xiaozhu and Liu, Xu},
title = {Replication Package for Article: ValueExpert, Exploring Value Patterns in GPU-Accelerated Applications},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5796083},
abstract = {
    <p>Our artifact includes ValueExpert and benchmark code in this paper, along with instructions to use benchmarks to generate results for Figure 2, Figure 6, and Table 3 on NVIDIA A100 and RTX 2080 Ti GPUs. The speedup and overhead of each benchmark are averaged among 10 runs.</p>
<p>We provide a docker image with pre-installed prerequisites to simplify the experiment workflow. Users can also use a script to install all software from scratch.</p>

},
keywords = {GPU profilers, GPUs, Profiling Tools, Value Analysis, Value Patterns}
}

@software{10.5281/zenodo.5799180,
author = {Zhao, Zirui Neil and Ji, Houxiang and Morrison, Adam and Marinov, Darko and Torrellas, Josep},
title = {Pinned Loads: Taming Speculative Loads in Secure Processors},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5799180},
abstract = {
    <p>Our artifact provides a complete gem5 implementation of Pinned Loads, along with scripts to evaluate Pinned Loads’ performance on SPEC17, PARSEC, and SPLASH2X benchmark suites. We further provide access to a server with SPEC17 SimPoint checkpoints, PARSEC&amp;SPLASH2X checkpoints and disk images that allow a recreation of all the evaluation figures of the paper. Finally, we open sourced our implementation and scripts on GitHub.</p>

},
keywords = {Cache coherence protocol, Memory consistency, Processor design, Speculative execution defense}
}

@software{10.5281/zenodo.5802292,
author = {Cock, David and Ramdas, Abishek and Schwyn, Daniel and Giardino, Michael and Turowski, Adam and He, Zhenhao and Hossle, Nora and Korolija, Dario and Licciardello, Melissa and Martsenko, Kristina and Achermann, Reto and Alonso, Gustavo and Roscoe, Timothy},
title = {The Enzian Research Computer; Altium Design Sources},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5802292},
abstract = {
    <p>CAD design sources for the computer</p>

},
keywords = {cache coherence., FPGAs, heterogeneous systems}
}

@software{10.5281/zenodo.5830832,
author = {Miano, Sebastiano and Sanaee, Alireza and Risso, Fulvio and R\'{e}tv\'{a}ri, G\'{a}bor and Antichi, Gianni},
title = {Morpheus: Domain Specific Run Time Optimization for Software Data Planes - Artifact for ASPLOS'22},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5830832},
abstract = {
    <p>This is the artifact for the “Morpheus: Domain Specific Run Time Optimization for Software Data Planes” paper published at ASPLOS’22. This artifact contains the source code, the experimental workflow, and additional information to 1) compile and build Morpheus, 2) install the software dependencies and setup the testbed to run all the experiments, 3) the scripts that can be used to perform some of the experiments presented in the paper, and 4) the scripts to generate the plots based on the obtained results.</p>

},
keywords = {Data Plane Compilation, DPDK, eBPF, LLVM, XDP}
}

@software{10.5281/zenodo.5831327,
author = {Nikolaev, Ruslan and Nadeem, Hassan and Stone, Cathlyn and Ravindran, Binoy},
title = {Adelie: Continuous Address Space Layout Re-randomization for Linux Drivers - Artifact for ASPLOS'22},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5831327},
abstract = {
    <p>Artifact for ASPLOS’22 paper “Adelie: Continuous Address Space Layout Re-randomization for Linux Drivers”. The artifact contains source code, benchmark scripts, and preinstalled VM images that should be used with VirtualBox. The server VM image is in Adelie.zip, and the client (load generator) VM image is in Client.zip. Please see README.txt for more information. Please also see the licensing terms in LICENSE.</p>

},
keywords = {ASLR, PIC, ROP}
}

@software{10.5281/zenodo.5842408,
author = {Mathur, Umang and Pavlogiannis, Andreas and Tun\c{c}, H\"{u}nkar Can and Viswanathan, Mahesh},
title = {Replication Package for Article: A Tree Clock Data Structure for Causal Orderings in Concurrent Executions},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5842408},
abstract = {
    <p>This artifact contains all the source codes and experimental data for replicating our evaluation in the paper. We implemented the analyses programs as part of the tool Rapid. The provided experimental data contains all the 153 trace logs used in our evaluation. In our artifact we also provide Python scripts that fully automate the process of replicating our evaluation.</p>

},
keywords = {concurrency, dynamic analyses, happens-before, vector clocks}
}

@software{10.5281/zenodo.5846419,
author = {Ahmad, Hammad and Huang, Yu and Weimer, Westley},
title = {CirFix: Automatically Repairing Defects in Hardware Design Code (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5846419},
abstract = {
    <p>We provide the public repository for CirFix, both on Zenodo and GitHub. The artifact includes instructions for installing and running CirFix, as well as scripts and instructions used to reproduce core results from our paper.</p>
<p>Please contact Hammad Ahmad (hammada@umich.edu) if you have any questions.</p>

},
keywords = {automated program repair, hardware bugs, hardware designs, HDL benchmark}
}

@software{10.5281/zenodo.5847956,
author = {Pandey, Shweta and Kamath, Aditya K and Basu, Arkaprava},
title = {Replication Package for Article: GPM: Leveraging Persistent Memory from a GPU},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5847956},
abstract = {
    <p>GPM is a system which allows a GPU to leverage Persistent Memory and enables writing highly performant recoverable GPU applications. The repository contains the source of our benchmark suite: GPMBench and a CUDA library: LibGPM. GPMBench comprises of 9 benchmarks categorized as transactional, native and checkpointing. LibGPM contains the source of our CUDA library which provides a user-friendly interface for GPU-accelerated recoverable applications. More details about the work can be found in our paper ASPLOS’22 paper: Leveraging Persistent Memory from a GPU. The artifact also allows a user to reproduce some of the key results published in the paper.</p>

},
keywords = {GPU, Persistent Memory}
}

@software{10.5281/zenodo.5848404,
author = {Bandara, Thilini Kaushalya and Wijerathne, Dhananjaya and Mitra, Tulika and Peh, Li-Shiuan},
title = {REVAMP: A Systematic Framework for Heterogeneous CGRA Realization},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5848404},
abstract = {
    <p>REVAMP artifact includes the complete framework comprising the heterogeneous architecture generator, heterogeneous CGRA mapper, parameterized RTL and scripts for power, area calculation. We elaborate on the REVAMP tool flow with an example of generating a pareto-optimal heterogeneous CGRA from a 4x4 homogeneous CGRA targeting five application kernels.</p>

},
keywords = {CGRA design space exploration, Coarse Grained Reconfigurable Arrays (CGRAs), Heterogeneous CGRAs}
}

@software{10.5281/zenodo.5848986,
author = {Theodoridis, Theodoros and Grosser, Tobias and Su, Zhendong},
title = {ASPLOS 2022 Artifact for "Understanding and Exploiting Optimal Function Inlining"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5848986},
abstract = {
    <p>The artifact contains the code and dataset we used for our experiments, as well as scripts to generate the numbers, figures, and tables of our evaluation. Specifically, it includes (a) the LLVM-IR files we used both for exhaustive search and autotuning (b) a modified LLVM that we use for exhaustive search and autotuning; (c) scripts to run exhaustive search and autotuning; (d) the expected outputs; (e) scripts to generate the tables and figures of our paper; (f) scripts to perform exhaustive search and autotuning only on smaller callgraphs and to validate the results against the provided ones. Everything is packaged and pre-built as a docker image. A standard X86 Linux machine running docker is necessary to evaluate this artifact.</p>

},
keywords = {autotuning, compiler optimization, optimal inlining, program size}
}

@software{10.5281/zenodo.5855030,
author = {Ma, Jiacheng and Zuo, Gefei and Loughlin, Kevin and Zhang, Haoyang and Quinn, Andrew and Kasikci, Baris},
title = {Replication Package for Paper: Debugging in the Brave New World of Reconfigurable Hardware},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5855030},
abstract = {
    <p>20 hardware bugs and the debugging tools mentioned in the paper “Debugging in the Brave New World of Reconfigurable Hardware”.</p>

},
keywords = {Bug Study, Debugging, FPGA, Reconfigurable Hardware}
}

@software{10.5281/zenodo.5856289,
author = {Erd\H{o}s, M\'{a}rton and Ainsworth, Sam and Jones, Timothy M.},
title = {Research data supporting "MineSweeper: a "clean sweep" for drop-in use-after-free prevention"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5856289},
abstract = {
    <p>This artifact contains our MineSweeper implementation, an allocator extension implemented on top of JeMalloc to mitigate use-after-free attacks, together with scripts to evaluate its running time and memory overheads on the SPEC CPU2006 benchmarks. The base implementation itself and a minimally modified JeMalloc memory allocator are fetched from their own repositories, compiled, and dynamically loaded in the SPEC config scripts. The dynamically linked libraries can be used to evaluate SPEC CPU2006 overheads using our scripts (benchmarks not included), or they can be loaded to protect a pre-compiled program from use-after-reallocate and double-free exploits.</p>

},
keywords = {programming language security, temporal safety, use-after-free}
}

@software{10.5281/zenodo.5863686,
author = {Asmussen, Nils and Haas, Sebastian and Weinhold, Carsten and Miemietz, Till and Roitzsch, Michael},
title = {ASPLOS'22 artifact for Efficient and Scalable Core Multiplexing with M³v},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5863686},
abstract = {
    <p>This is the artifact for the ASPLOS’22 paper “Efficient and Scalable Core Multiplexing with M³v”. The archive contains the source code of the software part, including the modified Linux kernel we compared M³v against, and all scripts to run the benchmarks. The archive also contains the FPGA bitfiles for the hardware platform.</p>

},
keywords = {communications management, operating systems, operating-systems security, process management, tiled architecture}
}

@software{10.5281/zenodo.5865606,
author = {Oleksenko, Oleksii and Fetzer, Christof and K\"{o}pf, Boris and Silberstein, Mark},
title = {Replication Package for Article: Revizor - Testing Black-Box CPUs against Speculation Contracts},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5865606},
abstract = {
    <p>The artifact includes the source code of Revizor, a set of scripts for reproducing the results, and a description of how to use them. They help to reproduce the contract violations described in the paper and validate the claimed fuzzing speed.</p>

},
keywords = {contracts, spectre, Speculation, testing}
}

@software{10.5281/zenodo.5870184,
author = {Theodoridis, Theodoros and Rigger, Manuel and Su, Zhendong},
title = {ASPLOS 2022 Artifact for "Finding Missed Optimizations through the Lens of Dead Code Elimination"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5870184},
abstract = {
    <p>The artifact contains the code and dataset we used for our experiments, as well as scripts to generate the numbers and tables of our evaluation. Specifically, it includes (a) the corpus of randomly generated programs that we used in Section 4’s evaluation; (b)scripts for generating a new corpus and validating the existing one; (c) our LLVM-based optimization marker instrumenter; (d) scripts for generating the missed optimization statistics presented in Section 4; (e) the full list of submitted bug reports with links to the respective compiler bug trackers; (f) end-to-end examples that led to bug reports. Everything is packaged and pre-built as a docker image. A standard X86 Linux machine running docker is necessary to evaluate this artifact.</p>

},
keywords = {compilers, missed optimizations, testing}
}

@software{10.5281/zenodo.5874548,
author = {Cheng, Xiang and Devecsery, David},
title = {Artifact for: Creating Concise and Efficient Dynamic Analyses with ALDA},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5874548},
abstract = {
    <p>This artifact description contains information about the complete workflow required to set up and reproduce experiments in ALDA. We describe how the software can be obtained and the build process as well as necessary preprocessing steps to generate the test program and baseline. All the programs and benchmarks are publicly available except for the SPEC 2006 benchmark. In addition, we provide a VM with all the programs and input data pre-pared and as well as instructions on how to build such a VM.</p>

},
keywords = {compiler optimization, domain specific language, dynamic analysis}
}

@software{10.5281/zenodo.5900766,
author = {Li, Zijun and Liu, Yushi and Guo, Linsong and Chen, Quan and Cheng, Jiagan and Zheng, Wenli and Guo, Minyi},
title = {Artifact for Article: FaaSFlow: Enable Efficient Workflow Execution for Function-as-a-Service},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5900766},
abstract = {
    <p>FaaSFlow is a serverless workflow engine that enables efficient workflow execution in 2 ways: a worker-side workflow schedule pattern to reduce scheduling overhead, and an adaptive storage library to use local memory to transfer data between functions on the same node.</p>

},
keywords = {FaaS, graph partition, master-worker, serverless workflows}
}

@software{10.5281/zenodo.5902507,
author = {Lefeuvre, Hugo and B\u{a}doiu, Vlad-Andrei and Jung, Alexander and Teodorescu, Stefan Lucian and Rauch, Sebastian and Huici, Felipe and Raiciu, Costin and Olivier, Pierre},
title = {FlexOS: Towards Flexible OS Isolation},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5902507},
abstract = {
    <p>This artifact contains the source code of FlexOS, the proof of-concept of our flexible isolation approach presented at ASPLOS’22 (“FlexOS: Towards Flexible OS Isolation”), along with all scripts necessary to reproduce the paper’s measurements and plots. The goal of this artifact is to allow readers to reproduce the paper’s results, and build new research on top of FlexOS.</p>
<p>Abstract of the paper:</p>
<p>At design time, modern operating systems are locked in a specific safety and isolation strategy that mixes one or more hardware/software protection mechanisms (e.g.&nbsp;user/kernel separation); revisiting these choices after deployment requires a major refactoring effort. This rigid approach shows its limits given the wide variety of modern applications’ safety/performance requirements, when new hardware isolation mechanisms are rolled out, or when existing ones break.</p>
<p>We present FlexOS, a novel OS allowing users to easily specialize the safety and isolation strategy of an OS at compilation/deployment time instead of design time. This modular LibOS is composed of fine-grained components that can be isolated via a range of hardware protection mechanisms with various data sharing strategies and additional software hardening. The OS ships with an exploration technique helping the user navigate the vast safety/performance design space it unlocks. We implement a prototype of the system and demonstrate, for several applications (Redis/Nginx/SQLite), FlexOS’ vast configuration space as well as the efficiency of the exploration technique: we evaluate 80 FlexOS configurations for Redis and show how that space can be probabilistically subset to the 5 safest ones under a given performance budget. We also show that, under equivalent configurations, FlexOS performs similarly or better than several baselines/competitors.</p>

},
keywords = {compartmentalization, isolation, operating system, operating system security}
}

@software{10.5281/zenodo.5942213,
author = {Saileshwar, Gururaj and Wang, Bolin and Qureshi, Moinuddin and Nair, Prashant J.},
title = {Randomized Row-Swap: Mitigating Row Hammer by Breaking Spatial Correlation between Aggressor and Victim Rows},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5942213},
abstract = {
    <p>This artifact presents the code and methodology to simulate Randomized Row-Swap (RRS), our defense against Rowhammer attacks. We provide the C code for the implementation of RRS which is encapsulated within the USIMM, a memory system simulator. The RRS structures and operations are implemented within the memory controller module in our artifact. We provide scripts to compile our simulator, and run the baseline and RRS. We also provide scripts to parse the results and collate the performance results.</p>

},
keywords = {DRAM, Fault-Injection Attacks, Memory System, Row Hammer}
}

@software{10.5281/zenodo.5531242,
author = {Jouneaux, Gwendal and Barais, Olivier and Combemale, Benoit and Mussbacher, Gunter},
title = {SEALS: A Framework for Building Self-Adaptive Virtual Machines},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5531242},
abstract = {
    <p>In this artifact, we provide the implementation of the three SEALS-based Self-Adaptive Virtual Machines and the three handcrafted Self-Adaptive Virtual Machines (HTML, RobLANG and MiniJava).</p>
<p>This artifact provides a Maven-based build for the artifact as well as scripts to reproduce the benchmarking experiment and the lines of code count. Additionally, we provide a Jupyter notebook to analyze the results of the benchmarking experiments.</p>

},
keywords = {framework, self-adaptation, software language}
}

@software{10.5281/zenodo.5534113,
author = {Verano Merino, Mauricio and Beckmann, Tom and van der Storm, Tijs and Hirschfeld, Robert and Vinju, Jurgen J.},
title = {Skogi},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5534113},
abstract = {
    <p>S/Kogi is an extension of Kog that implements some simplification rules of context-free grammars as described in the SLE paper Getting Grammars into Shape for Block-based Editors. This tool allows users to derive block-based environments from a context-free grammar specification. S/Kogi uses on Google Blockly for rendering block-based environments, and Squeak/Smalltalk</p>

},
keywords = {app inventor, blockly, grammars, kogi, language workbench, rascal, scratch, smalltalk, snap}
}

@software{10.5281/zenodo.5572916,
author = {Leroy, Dorian and Lelandais, Beno\^{\i}t and Oudot, Marie-Pierre and Combemale, Benoit},
title = {Artifact for Article: Monilogging for Executabel DSLs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5572916},
abstract = {
    <p>The artifact is a Vagrant script building a VM that runs NabLab with MoniLog, allowing to instrument the execution of NabLab models with moniloggers. The resulting VM provides a NabLab workspace with 6 MoniLog specifications illustrating the different ways MoniLog can be used to perform logging and monitoring.</p>

},
keywords = {executable DSLs, logging, runtime monitoring}
}

@software{10.5281/zenodo.5573543,
author = {Yedidia, Zachary and Chong, Stephen},
title = {Artifact for Fast Incremental PEG Parsing},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5573543},
abstract = {
    <p>This artifact contains the source code for our GPeg incremental parser, the Flare syntax highlighting engine, an example text editor that uses both libraries, and our benchmarks and experiments from the paper, along with scripts to auto-generate the figures.</p>

},
keywords = {incremental parsing, packrat parsing, parsing expression grammars}
}

@software{10.6084/m9.figshare.16825933.v1,
author = {Farooq, Aamir and Zaytsev, Vadim},
title = {Supporting Code for Article "There Is More Than One Way to Zen Your Python"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.16825933.v1},
abstract = {
    <p>This archive contains the supporting code for the paper “There Is More Than One Way to Zen Your Python”. - catalogue_website_code/ contains the code for the website for our list of pythonic idioms. It can be viewed either by: - installing <code>docsify-cli</code> using: <code>npm i docsify-cli -g</code> and then running <code>docsify serve</code> in the <code>catalogue_website_code</code> folder. - using something like the Live Server extension for VSCode: https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer - deploying it to Github Pages - or visiting the live version of the website here: https://slimshadyiam.github.io/ZenYourPython/#/ - idiom_detection_code/ contains the code used to detect idioms in open source Python projects. A detailed setup guide and overview of the contents can be found in the README.md file in that directory, as well as the raw data collected from using the detection tool.</p>

},
keywords = {Python, pythonic idioms, pythonicity}
}

@software{10.5281/zenodo.4836022,
author = {Ashkboos, Saleh and De Sensi, Daniele and Di Girolamo, Salvatore and Hoefler, Torsten and Li, Shigang},
title = {Implementation of the article "Flare: Flexible In-Network Allreduce"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4836022},
abstract = {
    <p></p><p>SC21 Artifact</p><p></p>
}
}

@software{10.5281/zenodo.4899910,
author = {Ananthan, Shreyas and Li, Ruipeng and Mullowney, Paul and Mullowney, Paul and Rood, Jon and Sharma, Ashesh and Sprague, Michael and Thomas, Stephen and Willians, Alan},
title = {Implementation of the article "Preparing an Incompressible-Flow Fluid Dynamics Code for Exascale-Class Wind Energy Simulations"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4899910},
abstract = {
    <p></p><p>This release of Nalu-Wind can make use of an optimized Hypre GPU device assembly algorithm (<a href="https://doi.org/10.5281/zenodo.4899892">https://doi.org/10.5281/zenodo.4899892</a>).</p>
<p>Nalu-Wind can be built using the exawind-builder project (<a href="https://exawind.github.io/exawind-builder/">https://exawind.github.io/exawind-builder/</a>)</p>
<p>The following example, reg_tests/test_files/ablNeutralNGPHypreSegregated/ablNeutralNGPHypreSegregated.yaml, can be modified to use the optimized device assembly algorithm by setting:
  simple_hypre_matrix_assemble: yes
in the solver blocks</p><p></p>
}
}

@software{10.5281/zenodo.5116412,
author = {Hu, Qinghao and Sun, Peng and Wen, Yonggang and Yan, Shengen and Zhang, Tianwei},
title = {Implementation of the article "Characterization and Prediction of Deep Learning Workloads in Large-Scale GPU Datacenters"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5116412},
abstract = {
    <p></p><p>HeliosArtifact</p><p></p>
}
}

@software{10.5281/zenodo.5136675,
author = {Chen, Zhaodong and Ding, Yufei and Liu, Liu and Qu, Zheng and Xie, Yuan},
title = {Implementation of the article "Efficient Tensor Core-based GPU Kernels for Structured Sparsity under Reduced Precision"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5136675},
abstract = {
    <p></p><p>This is the artifact of our paper "Efficient Tensor Core-Based GPU Kernels for Structured Sparsity under Reduced Precision" accepted in SC21</p><p></p>
}
}

@software{10.5281/zenodo.5144378,
author = {Ding, Yufei and Feng, Boyuan and Feng, Boyuan and Geng, Tong and Li, Ang and WANG, YUKE},
title = {Implementation of the article "APNN-TC: Accelerating Arbitrary Precision Neural Networks on Ampere GPU Tensor Cores"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5144378},
abstract = {
    <p></p><p>This is the source code for the SC'21 paper:&nbsp;<strong>APNN-TC: Accelerating Arbitrary Precision Neural Networks on Ampere GPU Tensor Cores</strong></p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p><p></p>
}
}

@software{10.5281/zenodo.5144438,
author = {Aluru, Srinivas and Aluru, Maneesha R. and Chockalingam, Sriram P. and Srivastava, Ankit},
title = {Implementation of the article "Parallel Construction of Module Networks"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5144438},
abstract = {
    <p></p><p>This release adds more details on reproducing the results in the publication.</p><p></p>
}
}

@software{10.5281/zenodo.5144709,
author = {Li, Kenli and Lin, Shengle and Tsai, Qinyun and Wang, Haotian and Yang, Wangdong},
title = {Implementation of the article "STM-Multifrontal QR: Streaming Task Mapping Multifrontal QR Factorization Empowered by GCN"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5144709},
abstract = {
    <p></p><p>This is the first release version of Streaming Task Map Multifrontal QR Factorization Empowered by GCN.</p><p></p>
}
}

@software{10.5281/zenodo.5144874,
author = {Fahringer, Thomas and Knorr, Fabian and Thoman, Peter},
title = {Implementation of the article "ndzip-gpu: Efficient Lossless Compression of Scientific Floating-Point Data on GPUs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5144874},
abstract = {
    <p></p><p>As accepted by the SC'21 artifact evaluation committee.</p><p></p>
}
}

@software{10.5281/zenodo.5147573,
author = {Churavy, Valentin and Doerfert, Johannes and H\"{u}ckelheim, Jan and Moses, William S. and Narayanan, Sri Hari Krishna and Paehler, Ludger and Schanen, Michel},
title = {Implementation of the article "Reverse-Mode Automatic Differentiation and Optimization of GPU Kernels via Enzyme full strip note"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5147573},
abstract = {
    <p>This repo contains the benchmarks for Enzyme on GPU's</p>
}
}

@software{10.5281/zenodo.5148715,
author = {Kung, H. T. and Natesh, Vikas and Sabot, Andrew},
title = {Implementation of the article "CAKE: Matrix Multiplication Using Constant-Bandwidth Blocks"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5148715},
abstract = {
    <p></p><p>First release for Zenodo archiving</p><p></p>
}
}

@software{10.5281/zenodo.5148797,
author = {Alabandi, Ghadeer and Burtscher, Martin and Rusnak, Lucas and Te\v{s}i\'{c}, Jelena},
title = {Implementation of the article "Discovering and Balancing Fundamental Cycles in Large Signed Graphs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5148797},
abstract = {
    <p></p><p>First release for reviewers.</p><p></p>
}
}

@software{10.5281/zenodo.5148930,
author = {Allen, Tyler and Ge, Rong},
title = {Implementation of the article "In-Depth Analyses of Unified Virtual Memory System for GPU Accelerated Computing"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5148930},
abstract = {
    <p></p><p>Artifact appendix item for SC2021.</p><p></p>
}
}

@software{10.5281/zenodo.5154114,
author = {Halappanavar, Mahantesh and Khan, Arif and Serra, Edoardo and Rajam, Aravind Sukumaran and Xiang, Lizhi},
title = {Implementation of the article "cuTS: Scaling Subgraph Isomorphism on Distributed Multi-GPU Systems Using Trie Based Data Structure"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5154114},
abstract = {
    <p></p><p>This repository contains the code for the "cuTS: Scaling Subgraph Isomorphism on Distributed Multi-GPU Systems Using Trie Based Data Structure" framework. The cuTS framework is an efficient subgraph isomorphism solver for GPUs.</p><p></p>
}
}

@software{10.5281/zenodo.5155509,
author = {Ben-Nun, Tal and Calotoiu, Alexandru and De Matteis, Tiziano and Hoefler, Torsten and Lavarini, Luca and Schneider, Timo and Ziogas, Alexandos Nikolaos and de Fine Licht, Johannes},
title = {Implementation of the article "Productivity, Portability, Performance: Data-Centric Python"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5155509},
abstract = {
    <p></p><p>Artifact of SC'21 Paper "Productivity, Portability, Performance: Data-Centric Python".</p>

<p>The artifact can also be cloned from&nbsp;<a href="https://spclgitlab.ethz.ch/tim0s/ddace-lite-sc21">https://spclgitlab.ethz.ch/tim0s/ddace-lite-sc21</a></p><p></p>
}
}

@software{10.5281/zenodo.5155769,
author = {He, Ligang and He, Bingsheng and Jin, Hai and Liao, Xiaofei and Liu, Haikun and Zhang, Yu and Zhao, Jin},
title = {Implementation of the article "LCCG: A Locality-Centric Hardware Accelerator for High Throughput of Concurrent Graph Processing"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5155769},
abstract = {
    <p></p><p>This paper presents a locality-centric programmable accelerator LCCG, which can fundamentally address the challenge of the irregular accesses of the CGP jobs so as to achieve higher throughput for the execution of these jobs. By regularizing the graph traversals of the CGP jobs and fully consolidating the storage and accesses of the graph data, LCCG can minimize the data access cost for the execution of the CGP jobs and also achieve higher utilization of the cores. On a simulated 64-core processor, the experimental results show that LCCG improves the throughput of the state-of-the-<br>
art software system by up to 23.9 times with only 0.5\% extra area cost. In the future, we will research how to integrate some existing hardware techniques into LCCG to get better performance, and also research how to avoid the leaking of some private information of the jobs for the LCCG.</p><p></p>
}
}

@software{10.5281/zenodo.5156431,
author = {Hsu, Kuan-Chieh and Tseng, Hung-Wei},
title = {Implementation of the article "Accelerating Applications using Edge Tensor Processing Units"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5156431},
abstract = {
    <p></p><p>Alpha version of GPETPU Release</p><p></p>
}
}

@software{10.5281/zenodo.5159333,
title = {Implementation of the article "3D Acoustic-Elastic Coupling with Gravity: The Dynamics of the 2018 Palu, Sulawesi Earthquake and Tsunami"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5159333},
abstract = {
    <p></p><p>This repository contains the supplementary files for our SC21 submission: "3D Acoustic-Elastic Coupling with Gravity: The Dynamics of the 2018 Palu, Sulawesi Earthquake and Tsunami".</p>

<p>It contains the input data for all simulations. For more details, please refer to the included README.md files.</p>

<p>&nbsp;</p>

<p>The directory "seissol-sc21-revision-source-code" contains the version of SeisSol that we used.</p>

<p>&nbsp;</p><p></p>
}
}

@software{10.5281/zenodo.5162688,
title = {Implementation of the article "Hardware-supported Remote Persistence for Distributed Persistent Memory"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5162688},
abstract = {
    <p></p><p>No description provided.</p><p></p>
}
}

@software{10.5281/zenodo.5163624,
author = {Brinkmann, Andr\'{e} and Cortes, Toni and Klopp, David and Moti, Nafiseh and R\"{u}ckert, Ulrich and Salkhordeh, Reza and Schimmelpfennig, Frederic},
title = {Implementation of the article "Simurgh: A Fully Decentralized and Secure NVMM User Space File System"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5163624},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.5163851,
author = {Ali-Eldin, Ahmed and Shenoy, Prashant and Wang, Bin},
title = {Implementation of the article "The Hidden cost of the Edge: A Performance Comparison ofEdge and Cloud Latencies"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5163851},
abstract = {
    <p></p><p>This is the image dataset used in our paper The Hidden Cost of the Edge: A Performance Comparison of Edge and Cloud Latencies (to appear in SC21). In our experiments it's used as the workload of a deep neural network (DNN) image classification application.</p><p></p>
}
}

@software{10.5281/zenodo.5164404,
author = {Aiken, Alex and Bauer, Michael and Lee, Wonchan and McCormick, Patrick S. and Papadakis, Manolis and Slaughter, Elliott and Soi, Rupanshu and Treichler, Sean},
title = {Implementation of the article "Index Launches: Scalable, Flexible Representation of Parallel Task Groups"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5164404},
abstract = {
    <p></p><p>This is the software artifact for "Index Launches: Scalable, Flexible Representation of Parallel Task Groups", published in SC'21. A copy of this artifact is also archived under the tag <a href="https://github.com/StanfordLegion/legion/blob/papers/index-launch-sc21/language/sc21_scripts/README.md">papers/index-launch-sc21</a> in the original GitHub repository.</p>

<p>To use this software artifact, unpack it and refer to the instructions under language/sc21_scripts/README.md.</p><p></p>
}
}

@software{10.5281/zenodo.5165333,
author = {Awan, Muaaz Gul and Buluc, Aydin and Deslippe, Jack and Ding, Nan and Egan, Rob and Hofmeyr, Steven and Oliker, Leonid and Yelick, Katherine},
title = {Implementation of the article "Accelerating large scale de novo metagenome assembly using GPUs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5165333},
abstract = {
    <p></p><p>We used the version of MetaHipMer2 available at: <a href="https://bitbucket.org/berkeleylab/mhm2/src/master/">https://bitbucket.org/berkeleylab/mhm2/src/master/</a> and integrated our GPU local assembly module in it. This release contains the GPU accelerated version of MetaHipMer2 that has been discussed and presented in the SC21 submission. If you are looking to reproduce the results as shown in the SC21 submission please use this repo and if you are a user looking to use the most recent and stable release of MetaHipMer2 please go to the link mentioned above.</p><p></p>
}
}

@software{10.5281/zenodo.5165762,
author = {Chen, Hongzheng and Shen, Minghua},
title = {Implementation of the article "Krill: A Compiler and Runtime System for Concurrent Graph Processing"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5165762},
abstract = {
    <p></p><p>Krill is an efficient graph system for processing concurrent graph jobs, which consists of a high-level compiler and a runtime system. Property buffer and its compiler are provided to easily manage the property data. The runtime system is equipped with graph kernel fusion that greatly reduces the number of memory accesses.</p><p></p>
}
}

@software{10.5281/zenodo.5167006,
author = {Uezato, Yuya},
title = {Implementation of the article "Accelerating XOR-based Erasure Coding using Program Optimization Techniques"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5167006},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.5167629,
author = {Bhalachandra, Sridutt and Gupta, Akshat and Kumar, Vivek and Kumar, Sunil},
title = {Implementation of the article "Cuttlefish: Library for Achieving Energy Efficiency in Multicore Parallel Programs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5167629},
abstract = {
    <p></p><p>This artifact is the software implementation of the paper titled "Cuttlefish: Library for Achieving Energy Efficiency in Multicore Parallel Programs" published at the SC '21 conference. Cuttlefish is a programming model oblivious C/C++ library for achieving energy efficiency in multicore parallel programs running over Intel processors. An online profiler periodically profiles model-specific registers to discover a running application’s memory access pattern. Using a combination of DVFS and UFS, Cuttlefish then dynamically adapts the processor’s core and uncore frequencies, thereby improving its energy efficiency.</p><p></p>
}
}

@software{10.5281/zenodo.5167980,
author = {Diffenderfer, James D. and Georgakoudis, Giorgis and Laguna, Ignacio and Menon, Harshitha and Osei-Kuffuor, Daniel and Parasyris, Konstantinos and Schordan, Markus},
title = {Implementation of the article "HPAC: Evaluating Approximate Computing Techniques on HPC OpenMP Applications."},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5167980},
abstract = {
    <p></p><p>This is a baseline implementation of the approximate programming model called HPAC. HPAC extends Clang/LLVM. HPAC supports two approximation techniques perforation and memoization. Perforation supports subclasses of the technique that define the pattern of the perforated loops. Memoization supports two sub-classes of approximate memoization, namely input (iACT), and output (TAF) memorization. Each sub-class can be further parameterized to fine-tune the behavior of the technique. Finally, the release contains a set of scripts that facilitate exploration of the approximation design space and identify opportunities for approximations.</p><p></p>
}
}

@software{10.5281/zenodo.5168027,
author = {Ben-Nun, Tal and Besta, Maciej and Gaillard, Andr\'{e} and Hoefler, Torsten and Kabic, Marko and Kozhevnikov, Anton and Kwasniewski, Grzegorz and Saethre, Jens Eirik and Schneider, Timo and VandeVondele, Joost and Ziogas, Alexandos Nikolaos},
title = {Implementation of the article "On the Parallel I/O Optimality of Linear Algebra Kernels: Near-Optimal Matrix Factorizations"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5168027},
abstract = {
    <p></p><p>The first release of the library for distributed, communication-optimal LU and Cholesky factorization algorithms, with the appendix and the results from the paper.</p><p></p>
}
}

@software{10.5281/zenodo.5171429,
author = {Enright Jerger, Natalie and Gratz, Paul and Krishna, Tushar and Parasar, Mayank and San Miguel, Joshua},
title = {Implementation of the article "SEEC: Stochastic Escape Express Channel"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5171429},
abstract = {
    <p>artifacteval eval repo for sc2021</p>
}
}

@software{10.5281/zenodo.5176097,
author = {Chen, Quan and Cui, Weihao and Guo, Minyi and Leng, Jingwen and Li, Chao and Zhao, Han and Zhao, Jieru and Zheng, Ningxin},
title = {Implementation of the article "Enable Simultaneous DNN Services Based on Deterministic Operator Overlap and Precise Latency Prediction"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5176097},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.5204819,
author = {Arumugam, Kamesh and Paterno, Marc and Ranjan, Desh and Sakiotis, Ioannis and Sakiotis, Ioannis and Terzic, Balsa and Zubair, Mohammad},
title = {Implementation of the article "PAGANI: A Parallel Adaptive GPU Algorithm for Numerical Integration full strip note"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5204819},
abstract = {
    <p></p><p>This markdown file provides links to artifacts associated with the PAGANI integrator.</p><p></p>
}
}

@software{10.5281/zenodo.5236852,
author = {Brandt, Jim and Costa, Emily and Patel, Tirthak and Schwaller, Benjamin and Tiwari, Devesh},
title = {Implementation of the article "Systematically Inferring I/O Performance Variability by Examining Repetitive Job Behavior"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5236852},
abstract = {
    <p></p><p>Fixed an input parameter error</p><p></p>
}
}

@software{10.5281/zenodo.5262865,
author = {Roy, Rohan Basu and Gadepally, Vijay and Gettings, Karen and Li, Baolin and Patel, Tirthak and Tiwari, Devesh},
title = {Implementation of the article "Ribbon: Cost-Effective and QoS-Aware Deep Learning Model Inference using a Diverse Pool of Cloud Computing Instances"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5262865},
abstract = {
    <p></p><p>Renamed SIMBO to Ribbon</p><p></p>
}
}

@software{10.5281/zenodo.5513082,
author = {Bian, Zhengda and Bian, Zhengda and Li, Shenggui and Wang, Wei and You, Yang},
title = {Implementation of the article "Online Evolutionary Batch Size Orchestration for Scheduling Deep Learning Workloads in GPU Clusters"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.5513082},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.6084/m9.figshare.14396099,
author = {Canon, Richard Shane and Priedhorsky, Reid and Randles, Timothy and Younge, Andrew},
title = {Implementation of the article "Minimizing privilege for building HPC containers"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.14396099},
abstract = {
    <p></p>
}
}

@software{10.1145/3476481,
author = {Guo, Shengjian and Li, Guanpeng and Rahman, Md Hasanur and Shamji, Aabid},
title = {Implementation of the article "PEPPA-X: finding program test inputs to bound silent data corruption vulnerability in HPC applications"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3476481},
abstract = {
    <p>Peppa-X can efficiently finds a test input that can
              estimate the bound of program SDC(silent data corruption) resiliency. Generally with
              strawman method it takes days even month to find the input
              that provides the highest SDC probablilty with manually doing fault injection to every single input
              and check their SDC probabilty. But Peppa-X leverages genetic algorithm, along with our dynamic
              analysis technique described in the paper to guide the search towards the input which exercises the
              relatively much higher SDC probability among all other inputs. That means it can find the input that
              exercises the most vulnerable part of the program.</p>
}
}

@software{10.1145/3476482,
author = {Adelman, Menachem and Anderson, Cristina and Avancha, Sasikanth and Breuer, Alexander and Bruestle, Jeremy and Chaudhary, Narendra and Georganas, Evangelos and Heinecke, Alexander and Kalamkar, Dhiraj D. and Kundu, Abhisek and Kutnick, Denise and Laub, Frank and Md, Vasimuddin and Misra, Sanchit and Mohanty, Ramanarayan and Mohanty, Ramanarayan and Pabst, Hans and Ziv, Barukh},
title = {Implementation of the article "Tensor processing primitives: a programming abstraction for efficiency and portability in deep learning workloads"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3476482},
abstract = {
    <p>LIBXSMM is a library for specialized dense and sparse matrix operations as well as for deep learning primitives such as small convolutions. The library is targeting Intel Architecture with <span>Intel&nbsp;SSE</span>, <span>Intel&nbsp;AVX</span>, <span>Intel&nbsp;AVX2</span>, <span>Intel&nbsp;AVX‑512</span> (with VNNI and Bfloat16), and <span>Intel&nbsp;AMX</span> (Advanced Matrix Extensions) supported by future Intel processor code-named Sapphire Rapids. Code generation is mainly based on <span>Just‑In‑Time (JIT)</span> code specialization for compiler-independent performance (matrix multiplications, matrix transpose/copy, sparse functionality, and deep learning). LIBXSMM is suitable for "build once and deploy everywhere", i.e., no special target flags are needed to exploit the available performance. Supported GEMM datatypes are: `FP64`, `FP32`, `bfloat16`, `int16`, and `int8`.</p>
}
}

@software{10.1145/3476480,
author = {Frachtenberg, Eitan and Kaner, Rhody},
title = {Implementation of the article "Representation of Women in High-Performance Computing Conferences"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3476480},
abstract = {
    <p>These files represent all the raw and processed data, as well as the code to process it, to analyze some of the top systems conferences during 2017. Each subdirectory holds its own README.md file to describe the files in it.</p>
}
}

@software{10.1145/3476485,
author = {Arafa, Yehia and Arafa, Yehia and Badawy, Abdel-Hameed A. and Barai, Atanu and Chennupati, Gopinath and ELWazir, Ammar Mohamed Amin Ahmed and Eidenbenz, Stephan and Eker, Ali and Santhi, Nandakishore},
title = {Implementation of the article "Hybrid, scalable, trace-driven performance modeling of GPGPUs"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3476485},
abstract = {
    <p>PPT-GPU is a scalable and flexible framework to predict the performance of GPUs running general purpose workloads. PPT-GPU can use the virtual (PTX) or the native (SASS) ISAs without sacrificing accuracy, ease of use, or portability. The tool is currently focused on NVIDIA GPUs. We plan to extend our approach to model other vendors' GPUs such as AMD and Intel.</p>
}
}

@software{10.5281/zenodo.4697392,
author = {Schuster, Simon and W\"{a}gemann, Peter and Ulbrich, Peter and Schr\"{o}der-Preikschat, Wolfgang},
title = {PragMetis Source Code},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4697392},
abstract = {
    <p>This is the source code of the paper “Annotate Once - Analyze Anywhere: Context-Aware WCET Analysis by User-Defined Abstractions” [1]. Contains the modified T-Crest toolchain (llvm, clang, the platin WCET-analyzer and annotation language interpreter), distirbuted as a single derived work available under the GPLv3.</p>
<p>[1] Simon Schuster, Peter W\"{a}gemann, Peter Ulbrich, Wolfgang Schr\"{o}der-Preikschat. Annotate Once - Analyze Anywhere: Context-Aware WCET Analysis by User-Defined Abstractions. (to appear) In Proceedings of the 22nd International Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES 2021)</p>

},
keywords = {annotations, pragmetis, source code, toolchain, wcet analysis}
}

@software{10.5281/zenodo.4698901,
author = {Pusz, Oskar and Dietrich, Christian and Lohmann, Daniel},
title = {Source Code and Evaluation Data for the Paper: Data-Flow–Sensitive Fault-Space Pruning for the Injection of Transient Hardware Faults},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4698901},
abstract = {
    <p>We provide the data-flow pruner (DFP) presented in our paper. First, we would like to describe the concrete evaluation scenario shortly. We use the fault-injection tool FAIL* (https://github.com/danceos/fail) and have extended it with our pruner. To evaluate DFP we ran FAIL* with a generic experiment after pruning the fault space with the well-known def-use pruner which is already implemented in FAIL<em>. After the execution of the campaign, FAIL</em> created a database with all relevant information about the programs under investigation as well as the results of the fault-injection campaign. The databases are the baseline of our evaluation and can be found in the database-dump/ directory.</p>

},
keywords = {bit flip, fault injection, fault-space pruning, functional correctness, reliability, single event upset}
}

@software{10.5281/zenodo.4737731,
author = {Monniaux, David and Six, Cyril},
title = {Replication package for "Simple, Light, Yet Formally Verified, Global Common Subexpression Elimination and Loop-Invariant Code Motion"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4737731},
abstract = {
    <p>A virtual machine in OVA (Open Virtualization) format containing * The version of CompCert used to perform the experiments, for compiling to x86-64, AArch64, Risc-V and Kalray KV3. * The benchmarks. * Scripts to recreate the tables and figures of the paper.</p>

},
keywords = {AArch64, common subexpression elimination, KV3, Polybench, Risc-V, verified compilation, x86-64}
}

@software{10.5281/zenodo.4740299,
author = {Cai, Xuyi and Wang, Ying and Zhang, Lei},
title = {Replication Package for Article: Optimus: Towards Optimal Layer-Fusion on Deep Learning Processors},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4740299},
abstract = {
    <p>This is the implementation of the paper “Optimus: Towards Optimal Layer-Fusion on Deep Learning Processors”</p>

},
keywords = {embedded processor, layer fusion, memory, neural network}
}

@software{10.5281/zenodo.4744197,
author = {Oh, Deok-Jae and Moon, Yaebin and Lee, Eojin and Ham, Tae Jun and Park, Yongjun and Lee, Jae W. and Ahn, Jung Ho},
title = {Replication Package for Article: MaPHeA: A Lightweight Memory Hierarchy-Aware Profile-Guided Heap Allocation Framework},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4744197},
abstract = {
    <p>MaPHeA (pronounced like “mafia”) is a lightweight memory hierarchy-aware profile-guided heap allocation framework. It is lightweight as it profiles the memory access information of an application via hardware-event sampling instead of heavyweight instrumentation. MaPHeA is memory hierarchy-aware by utilizing a data access profile, which provides detailed information of a memory access, such as the address and the type of the access as well as where the data resides. Using this profiling information, it analyzes which heap objects are performance-critical. For example, MaPHeA can identify the objects that are frequently accessed (i.e., hot) from a certain memory hierarchy (e.g., LLC or main memory) or cause frequent TLB misses. Then, it can guide these hot data to be allocated to fast memory or allocate the TLB-miss-prone objects to a huge page. To realize this, we modify the intermediate representation of the gcc compiler and use a wrapper to replace the default malloc functions with the ones supporting tiered memory.</p>

},
keywords = {heap allocation, heterogeneous memory system, huge page, Profile-guided optimization}
}

@software{10.6084/m9.figshare.14544477,
author = {Rocha, Rodrigo C. O. and Petoumenos, Pavlos and Wang, Zheng and Cole, Murray and Hazelwood, Kim and Leather, Hugh},
title = {Replication Package for Article, "HyFM: Function Merging for Free"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.14544477},
abstract = {
    <p>This artifact contains a description of how to download and replicate the results achieved by the LCTES paper, titled “HyFM: Function Merging for Free”. It also includes the LLVM source code with the SalSSA and HyFM implementation.</p>

},
keywords = {Code-Size Reduction, Function Merging, Interprocedural Optimization, Link-Time Optimization, LLVM}
}

@software{10.1145/3410278,
author = {Luo, Weiyu and Demsky, Brian},
title = {C11Tester Artifact},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410278},
abstract = {
    <p>The artifact contains a c11tester-vagrant directory and a tsan11-tsan11rec-docker directory. The c11tester-vagrant directory is a vagrant repository that compiles source codes for C11Tester, LLVM, the companion compiler pass, and benchmarks for C11Tester. The tsan11-tsan11rec-docker directory contains benchmarks and a docker image with prebuilt LLVMs for tsan11 and tsan11rec.</p>

},
keywords = {C++11, concurrency, data races, memory models}
}

@software{10.1145/3410279,
author = {Ustiugov, Dmitrii and Petrov, Plamen and Kogias, Marios and Bugnion, Edouard and Grot, Boris},
title = {Benchmarking, Analysis, and Optimization of Serverless Function Snapshots},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410279},
abstract = {
    <p>This artifact contains the source code of the vHive-CRI host orchestrator and includes the necessary binary files of its dependencies, namely Firecracker-Containerd shim binaries, Firecracker hypervisor and jailer, default rootfs for Firecracker MicroVMs, MinIO object store server, and client binaries. The reviewers require Ubuntu 18.04 with root access and hardware virtualization support (e.g., VT-x), a platform with the root partition mounted on an SSD is preferred. The artifact lists the instructions to reproduce Fig. 8 for the configuration that uses vanilla Firecracker snapshots and the configuration that uses REAP-based snapshots. The reviewers can run functions from the representative FunctionBench suite, using pre-built Docker images.</p>

},
keywords = {cloud computing, datacenters, serverless, snapshots, virtualization}
}

@software{10.1145/3410280,
author = {Neal, Ian and Quinn, Andrew and Kasikci, Baris},
title = {Replication Package for Article: HIPPOCRATES: Healing Persistent Memory Bugs without Doing Any Harm},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410280},
abstract = {
    <p>This package contains the artifact for HIPPOCRATES. The artifact includes instructions for building and running HIPPOCRATES, as well as scripts and instructions used to reproduce the core results from the original article.</p>

},
keywords = {persistent memory, program repair}
}

@software{10.1145/3410281,
author = {Di, Bang and Liu, Jiawen and Chen, Hao and Li, Dong},
title = {Artifact for PMDebugger: Fast, Flexible, and Comprehensive Bug Detection for Persistent Memory Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410281},
abstract = {
    <p>This is the open-source site for PMDebugger&nbsp;(ASPLOS’21). For the latest version, please see our GitHub page: https://github.com/PASAUCMerced/PMDebugger.</p>

},
keywords = {Crash Consistency, Debugging, Persistent Memory, Testing}
}

@software{10.1145/3410283,
author = {Landgraf, Joshua and Yang, Tiffany and Lin, Will and Rossbach, Christopher J. and Schkufza, Eric},
title = {Artifact for Paper: Compiler-Driven FPGA Virtualization with SYNERGY},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410283},
abstract = {
    <p>This artifact contains the code for all the currently-available SYNERGY (Cascade) backends, including the experimental new backend for F1. The artifact also includes the benchmarks from the paper, data files to run them with, and experiment files to replicate the experiments shown in the paper on the SW and F1 backends. Instructions are documented in README.md, ARTIFACT.md, and experiments/README.md.</p>

},
keywords = {Compilers, FPGAs, Operating Systems, Virtualization}
}

@software{10.5281/zenodo.4321197,
author = {Margaritov, Artemiy and Ustiugov, Dmitrii and Shahab, Amna and Grot, Boris},
title = {Artifact evaluation pack for PTEMagnet (paper #111 in ASPLOS'21)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4321197},
abstract = {
    <p>The artifact contains a Linux kernel patch for enabling PTEMagnet, shell scripts for Linux kernel compilation, a virtual machine disk image with precompiled benchmarks, and Python/shell scripts that are expected to reproduce the results presented in Figure 6 of <a href="https://ease-lab.github.io/ease_website/pubs/PTEMagnet_ASPLOS21.pdf">the paper</a> for non-SPEC benchmarks.</p>

},
keywords = {operating system, virtual memory, virtualization}
}

@software{10.5281/zenodo.4321310,
author = {Panwar, Ashish and Achermann, Reto and Basu, Arkaprava and Bhattacharjee, Abhishek and Gopinath, K. and Gandhi, Jayneel},
title = {Fast Local Page-Tables for Virtualized NUMA Servers with vMitosis},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4321310},
abstract = {
    <p>This repository contains artifacts of the paper Fast Local Page-Tables for Virtualized NUMA Servers with vMitosis by Ashish Panwar, Reto Achermann, Arkaprava Basu, Abhishek Bhattacharjee, K. Gopinath, and Jayneel Gandhi to appear in the 26th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS’21).</p>

},
keywords = {ASPLOS'21, NUMA, Page-Tables, VMItosis-Linux}
}

@software{10.5281/zenodo.4321431,
author = {Sartakov, Vasily A. and Vilanova, Llu\'{\i}s and Pietzuch, Peter},
title = {Replication Package for Article: "CubicleOS: A Library OS with Software Componentisation for Practical Isolation"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4321431},
abstract = {
    <p>This artefact contains the library OS, two applications, the isolation monitor, and scripts to reproduce the experiments from the ASPLOS 2021 paper by V. A. Sartakov, L. Vilanova, R. Pietzuch — ``CubicleOS: A Library OS with Software Componentisation for Practical Isolation’’, which isolates components of a monolithic library OS without the use of message-based IPC primitives.</p>

},
keywords = {compartments, Intel MPK, inter-process communication, isolation}
}

@software{10.5281/zenodo.4321760,
author = {Jia, Zhipeng and Witchel, Emmett},
title = {Nightcore: Efficient and Scalable Serverless Computing for Latency-Sensitive, Interactive Microservices (Artifacts)},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4321760},
abstract = {
    <p>Our artifact includes the prototype implementation of Nightcore, the DeathStarBench and HipsterShop microservices ported to Nightcore, and the experiment workflow to run these workloads on AWS EC2 instances.</p>

},
keywords = {Cloud computing, function-as-a-service, microservices, serverless computing}
}

@software{10.5281/zenodo.4321945,
author = {Huang, Yipeng and Holtzen, Steven and Millstein, Todd and Van den Broeck, Guy and Martonosi, Margaret},
title = {Noisy Variational Quantum Algorithm Simulation via Knowledge Compilation for Repeated Inference},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4321945},
abstract = {
    <p>This artifact demonstrates a new way to perform quantum circuit simulation. We convert quantum circuits into probabilistic graphical models, which are then compiled into a format that enables efficient repeated queries.</p>
<p>The artifact consists of a Docker image which includes Google Cirq, a quantum programming framework, which we have extended to use our proposed approach as a quantum circuit simulation backend. Also in the Docker image are two quantum circuit simulators based on existing approaches which we compare against as evaluation baselines.</p>
<p>We offer the Docker image via three routes: a hosted version on Docker Hub provides the latest version of our software and requires minimal setup; a Dockerfile is provided to show how to replicate our environment from scratch; and finally a stable archival version is available on Zenodo.</p>
<p>With minimal setup, you can run test cases in our Docker container showing the validity of our approach. We test our quantum circuit simulation approach using the randomized test harness that Google Cirq uses to test its quantum circuit simulation back ends. We also demonstrate correct simulation results for a benchmark suite of quantum algorithms.</p>
<p>The Docker image contains performance benchmarking experiments that replicate results of our paper at reduced input problem sizes. The experiment scripts generate PDFs showing graphs that plot simulation wall clock time against input quantum circuit sizes. The input problem sizes are large enough to show that our proposed approach achieves a speedup versus existing simulation tools.</p>

},
keywords = {Bayesian networks, knowledge compilation, quantum circuit simulation, quantum computing}
}

@software{10.5281/zenodo.4322031,
author = {Li, Rui and Xu, Yufan and Sukumaran-Rajam, Aravind and Rountev, Atanas and Sadayappan, P.},
title = {Replication Package for Article: Analytical Characterization and Design Space Exploration for Optimization of CNNs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4322031},
abstract = {
    <p>This artifact includes a software implementation and benchmark specification for reproducing experiment results for paper “Analytical Characterization and Design Space Exploration for Optimization of CNNs”</p>

},
keywords = {Design space exploration, Neural networks, Performance modeling, Tile size optimization}
}

@software{10.5281/zenodo.4322033,
author = {Saileshwar, Gururaj and Fletcher, Christopher W. and Qureshi, Moinuddin},
title = {Code for Streamline Attack: A Fast, Flushless Cache Covert-Channel Attack byEnabling Asynchronous Collusion},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4322033},
abstract = {
    <p>This artifact presents the code and methodology to run the Streamline cache covert-channel attack. We provide the C++ code for the sender and receiver processes engaged in covert communication. Although the attack itself is not specific to an OS, ISA, or micro- architecture, the code is written with the assumption of an x86 Linux system and an Intel CPU that is a Skylake or a newer generation model. The code may be compiled with a standard compiler and run natively to execute the covert-communication. We also provide scripts to run the attack in several configurations demon- strated in Section-IV of our paper (with and without ECC, varying the shared array size and the synchronization period) and provide a Jupyter notebook to visualize the results.</p>
<p>Please use the public GitHub repository of the project https://github.com/gururaj-s/streamline for the most updated version of the code.</p>

},
keywords = {Asynchronous Protocol, Cache Side-Channels, Covert-channel Attacks, Last-Level Cache, Shared Caches}
}

@software{10.5281/zenodo.4322105,
author = {Kasampalis, Theodoros and Park, Daejun and Lin, Zhengyao and Adve, Vikram S. and Ro\c{s}u, Grigore},
title = {Language-Parametric Compiler Validation with Application to LLVM - Artifact Evaluation for ASPLOS 2020},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4322105},
abstract = {
    <p>A VirtualBox VM image that is fully set up to reproduce experiments mentioned in the ASPLOS 2021 paper titled “Language-Parametric Compiler Validation with Application to LLVM”. The included README.md file contains detailed instructions on how to use the artifact both for reproduction of experiments and for general use.</p>

},
keywords = {Compilers, Program Equivalence, Simulation, Translation Validation}
}

@software{10.5281/zenodo.4322285,
author = {Liu, Sihang and Mahar, Suyash and Ray, Baishakhi and Khan, Samira},
title = {PMFuzz: Test Case Generation for Persistent Memory Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4322285},
abstract = {
    <p>PMFuzz is a test case generator for PM programs, aiming to generate high-value test cases for PM testing tools. The generated test cases include both program inputs and initial PM images (normal images and crash images). The key idea of PMFuzz is to perform a targeted fuzzing on PM-related code regions and generate valid PM images by reusing the program logic. After generating the test cases, PMFuzz feeds them to the PM program and uses existing testing tools (XFDetector and PMemcheck) to detect crash consistency and performance bugs. The archived version of this artifact can be accessed using this DOI. We also maintain a GitHub repository at https://pmfuzz.persistentmemory.org/. For the latest version, please check our GitHub repository.</p>

},
keywords = {Crash Consistency, Debugging, Fuzzing, Persistent Memory, Testing}
}

@software{10.5281/zenodo.4329804,
author = {Tang, Wei and Tomesh, Teague and Suchara, Martin and Larson, Jeffrey and Martonosi, Margaret},
title = {Replication Package for Article: CutQC: Using Small Quantum Computers for Large Quantum Circuit Evaluations},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4329804},
abstract = {
    <p>Our artifact provides the source codes for the end-to-end CutQC toolflow. We also provide the benchmarking codes for several sample runtime and fidelity experiments. The HPC parallel version of the code is not provided, as different HPC platforms require very different setups.</p>

},
keywords = {Hybrid Computing, Quantum Circuit Cutting, Quantum Computing (QC)}
}

@software{10.5281/zenodo.4331404,
author = {VanHattum, Alexa and Nigam, Rachit and Lee, Vincent T. and Bornholt, James and Sampson, Adrian},
title = {Diospyros Software Artifact: Vectorization for Digital Signal Processors via Equality Saturation},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4331404},
abstract = {
    <p>Our artifact packages an environment to reproduce the main empirical results of our paper. Specifically, we package: (1) the Diospyros compiler: a search-aided compiler for generating vectorized DSP kernels, (2) implementations of a range of benchmarks in Diospyros, (3) implementation of the Theia open-source application case study, and (4) scripts for recreating the experiments and charts in the paper.</p>

},
keywords = {DSPs, Equality Saturation, Program Synthesis, Vectorization}
}

@software{10.5281/zenodo.4331660,
author = {Jayarajan, Anand and Hau, Kimberly and Goodwin, Andrew and Pekhimenko, Gennady},
title = {LifeStream},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4331660},
abstract = {
    <p>This artifact contains code and a synthetic data set to evaluate LifeStream, Trill, and numerical library-based data processing pipelines.</p>

},
keywords = {LifeStream, Numpy, Python, Scikit-learn, SciPy, stream data analytics, temporal query processing, Trill}
}

@software{10.5281/zenodo.4429956,
author = {Skarlatos, Dimitrios and Zhao, Zirui Neil and Paccagnella, Riccardo and Fletcher, Christopher W. and Torrellas, Josep},
title = {Replication for article: Jamais Vu: Thwarting Microarchitectural Replay Attacks},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4429956},
abstract = {
    <p>Our artifact provides a complete gem5 implementation of Jamais Vu, along with scripts to evaluate the SPEC’17 benchmarks. We also provide a GitHub repository with the gem5 implementation and required scripts to reproduce our simulation results. Finally, we provide a binary analysis infrastructure based on Radare2 that allows the compilation of binaries with the proposed Epoch markings.</p>

},
keywords = {Gem5, Processor design, Replay attack, Side-channel countermeasures}
}

@software{10.5281/zenodo.4432747,
author = {Nigam, Rachit and Thomas, Samuel and Li, Zhijing and Sampson, Adrian},
title = {Replication Package for Article: Compiler Infrastructure for Accelerator Generators},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4432747},
abstract = {
    <p>Our artifact packages an environment that can be used to reproduce the figures in the paper and perform similar evaluations. It is available at the following link:https://zenodo.org/record/4432747</p>
<p>It includes the following: - futil: The Calyx compiler. - fud: Driver for the futil compiler and hardware tools. - Linear algebra PolyBench written in Dahlia</p>

},
keywords = {Accelerator Design, Intermediate Language}
}

@software{10.5281/zenodo.4435970,
author = {Farshin, Alireza and Barbette, Tom and Roozbeh, Amir and Maguire Jr., Gerald Q. and Kosti\'{c}, Dejan},
title = {PacketMill: Toward Per-Core 100-Gbps Networking - Artifact for ASPLOS'21},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4435970},
abstract = {
    <p>This is the artifact for the “PacketMill: Toward per-core 100-Gbps Networking” paper published at ASPLOS’21.</p>
<p>PacketMill is a system that optimizes the performance of network functions via holistic inter-stack optimizations. More specifically, PacketMill provides a new metadata management model, called X-Change, enabling the packet processing frameworks to provide their custom buffer to DPDK and fully bypass rte_mbuf. Additionally, PacketMill performs a set of source-code \&amp; intermediate representation (IR) code optimizations.</p>
<p>Our paper’s artifact contains the source code, the experimental workflow, and additional information to (i) set upPacketMill \&amp; its testbed, (ii) perform some of the experiments presented in the paper, and (iii) validates the reusability \&amp; effectiveness of PacketMill.</p>
<p>For more information, please refer to https://github.com/aliireza/packetmill</p>

},
keywords = {DPDK., FastClick, LLVM, Middleboxes, Packet Processing, PacketMill, X-Change}
}

@software{10.5281/zenodo.4446702,
author = {Bl\"{o}cher, Marcel and Wang, Lin and Eugster, Patrick and Schmidt, Max},
title = {Switches for HIRE: Resource Scheduling for Data Center In-Network Computing},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4446702},
abstract = {
    <p>The artifact consists of three parts. (1) the source code of the HIRE simulator, including the implementations of Yarn++, Sparrow++, K8++, and CoCo++; (2) the runner tool (a Python3 program) that runs the experiments with the configurations presented in the paper and plotting scripts; and (3) Docker configurations to ease the setup. Users can reproduce all simulation results (Fig. 8 and Fig. 7). Furthermore, the artifact can be easily extended/modified to bench- mark other schedulers, INC configurations, and workloads.</p>

},
keywords = {data center, heterogeneity, in-network computing, non-linear resource usage, scheduling}
}

@software{10.5281/zenodo.4501773,
author = {Chen, Daming D. and Lim, Wen Shih and Bakhshalipour, Mohammad and Gibbons, Phillip B. and Hoe, James C. and Parno, Bryan},
title = {Artifact for 'HerQules: Securing Programs via Hardware-Enforced Message Queues'},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4501773},
abstract = {
    <p>Source code, experiment data, and virtual machines with precompiled benchmarks</p>

},
keywords = {compiler, fpga, ipc, llvm, nginx, ripe, spec, zsim}
}

@software{10.5281/zenodo.4504602,
author = {Calciu, Irina and Imran, M. Talha and Puddu, Ivan and Kashyap, Sanidhya and Maruf, Hasan Al and Mutlu, Onur and Kolli, Aasheesh},
title = {Artifacts for Article: Rethinking Software Runtimes for Disaggregated Memory},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4504602},
abstract = {
    <p>These artifacts have been developed for the ASPLOS 2021 article “Rethinking Software Runtimes for Disaggregated Memory”. The artifacts provide tools to track applications and determine their memory accesses: cache-line granularity memory writes and average memory access time (AMAT).</p>

},
keywords = {average memory access time, cache-line granularity dirty data tracking}
}

@software{10.5281/zenodo.4527305,
author = {Patel, Tirthak and Tiwari, Devesh},
title = {QRAFT ASPLOS 21 Code and Dataset},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4527305},
abstract = {
    <p>The artifacts can be divided into three categories: (1) Raw data: circuit metadata and output generated as a direct result of running quantum circuits. (2) Processed and Trained data: the data processed to be fed as input to the machine learning model training, as well as the output data of testing samples using the trained model. (3) Tools: code and scripts used for running circuits on quantum computers, processing the output, as well as training models and generating the final output (prediction of state probabilities).</p>

},
keywords = {NISQ Computing, Quantum Computing, Quantum Error Mitigation}
}

@software{10.5281/zenodo.4537132,
author = {Zhang, Yanqi and Hua, Weizhe and Zhou, Zhuangzhuang and Suh, G. Edward and Delimitrou, Christina},
title = {Replication package for article: Sinan: ML-Based and QoS-Aware Resource Management for Cloud Microservices},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4537132},
abstract = {
    <p>The artifact includes codes and documentation to reproduce the google cloud experiments presented in Sinan: ML-Based and QoS-Aware Resource Management for Cloud Microservices</p>

},
keywords = {cloud computing, cluster management, datacenter, machine learn-ing for systems, mi-croservices, quality of service, resource efficiency, tail latency}
}

@software{10.5281/zenodo.4539728,
author = {Zhang, Mengchi and Alawneh, Ahmad and Rogers, Timothy G.},
title = {Replication package for Article: Judging a Type by Its Pointer: Optimizing Virtual Function Calls on GPUs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4539728},
abstract = {
    <p>The artifact contains the source code for the SharedOA, COAL, and TypePointer that applied to all workloads. We also include the instructions to configure, build, run, and acquire the workload’s performance. Users can reproduce the results in Figure 6. We also contain a tutorial with examples to apply SharedOA, COAL and TypePointer to show that the three techniques are reusable on other CUDA applications.</p>

},
keywords = {GPU, Object-oriented Programming, Virtual Function Call}
}

@software{10.5281/zenodo.4539743,
author = {Hoseinzadeh, Morteza and Swanson, Steven},
title = {Replication Package for Artifact: Corundum: Statically-Enforced Persistent Memory Safety},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4539743},
abstract = {
    <p>Corundum is a persistent memory programming library in Rust which enforces safety rules statically. The artifact contains the source code of Corundum, the installation scripts for Corundum and other libraries listed in the paper, source code of the workloads, and experiments run scripts.</p>

},
keywords = {debugging, formal verification, persistent memory programming}
}

@software{10.5281/zenodo.4540633,
author = {Meng, Xiaozhu and Liu, Weijie},
title = {Software Artifact for Incremental CFG Patching for Binary Rewriting},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4540633},
abstract = {
    <p>Software artifact needed for paper “Incremental CFG Patching for Binary Rewriting”. It includes scripts for setting environments, software dependencies, and running experiments, and template configuration files for SPEC CPU 2017.</p>

},
keywords = {Docker, Dyninst, Firefox, Spack}
}

@software{10.5281/zenodo.4540866,
author = {Li, Guangpu and Chen, Dongjie and Lu, Shan and Musuvathi, Madanlal and Nath, Suman},
title = {SherLock-v2},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4540866},
abstract = {
    <p>Synchronizations are fundamental to the correctness and performance of concurrent software. They determine which operations can execute concurrently and which can-not—the key to detecting and fixing concurrency bugs, as well as understanding and tuning performance. Unfortunately, correctly identifying all synchronizations has become extremely difficult in modern software systems due to the various forms of concurrency and various types of synchronizations.</p>
<p>Previous work either only infers specific type of synchronization by code analysis or relies on manual effect to annotate the synchronization. This paper proposes SherLock, a tool that automatically infers synchronizations without code analysis or annotation. SherLock leverages the fact that most synchronizations appear around the conflicting operations and encodes the inference problem into a linear system with properties and hypotheses about how synchronizations are typically used. To collect useful observations, SherLock runs the target problem for a small number of runs with feedback-guided delay injection.</p>
<p>We have applied SherLock on 8 C# open-source applications. Without any prior knowledge, SherLock automatically inferred more than 120 unique synchronizations, with few false positives. These inferred synchronizations cover a wide variety of types, including lock operations, fork-join operations, asynchronous operations, framework synchronization, and custom synchronization.</p>

},
keywords = {Happens-before inducing, Synchronization Detection}
}

@software{10.5281/zenodo.4541351,
author = {Duta, Victor and Giuffrida, Cristiano and Bos, Herbert and van der Kouwe, Erik},
title = {Replication Package for Article "PIBE: Practical Kernel Control-Flow Hardening with Profile-Guided Indirect Branch Elimination"},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4541351},
abstract = {
    <p>Our artifact provides x86-64 kernel binaries for most of the kernel configurations we evaluated in the paper, along with scripts to configure LMBench, run and benchmark each kernel configuration and regenerate the syscall latencies and overheads discussed in the main tables of the paper. This allows the evaluation of our results on an Intel i7-8700K (Skylake) CPU or similar micro-architectures.</p>
<p>We also provide source code for the tools used during the kernel build process (e.g., binutils, LLVM 10), the code of our LLVM optimization passes and the kernel source code to regenerate the kernel binaries used in the workflow of our evaluation. We sup- ply the user with scripts to regenerate our Apache and LMBench profiling workloads, rebuild the kernel binaries provided in the evaluation or customize the kernels with a user-specified selection of transient mitigations and optimization strategies.</p>
<p>Furthermore, we also provide portable Apache and LMBench profiling workloads to speedup the customization process without the necessity of creating your own profiling workloads.</p>

},
keywords = {kernel, LMBench, profile-guided optimizations, transient execution}
}

@software{10.5281/zenodo.4546175,
author = {Hadidi, Ramyad and Asgari, Bahar and Jijina, Sam and Amyette, Adriana and Shoghi, Nima and Kim, Hyesoon},
title = {Paper Quantifying the Design-Space Tradeoffs in Autonomous Drones artifact, including software, data, and build giude for the open-source drone},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4546175},
abstract = {
    <p>This artifact describes our open-source experimental drone framework that is customizable across its hardware-software stack. The main and first portion of the artifact focuses on building the drone, which compliments the beginning sections of the paper. The build guide consists of two parts: hardware and software. Second, as an example of possible experiments, we provide sample scripts for important metrics measurements such as Linux perf and SLAM. Third, the artifact contains raw data for graphs in the paper.</p>

},
keywords = {autonomous drones, build guide, design-space analysis, open-source platform, power measurements, SLAM}
}

@software{10.5281/zenodo.4556045,
author = {Qiu, Junqiao and Sun, Xiaofan and Sabet, Amir Hossein Nodehi and Zhao, Zhijia},
title = {Replication Package for Article: Scalable FSM Parallelization via Path Fusion and Higher-Order Speculation},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4556045},
abstract = {
    <p>This artifact contains the source code of BoostFSM, including the five FSM parallelization schemes discussed in the paper and some benchmarks along with their inputs used for evaluation. In addition, this artifact provides bash scripts to compile the source code and reproduce the key experimental results reported in the paper. Considering the software dependencies, a software environment with Linux Centos 7 or other similar Linux distributions, GCC, Bash, Pthread, CMake and Boost library, is needed before the evaluation. Moreover, to reproduce all results reported in the paper, especially the speedup comparison and scalability analysis, the artifact needs to run on Intel Xeon Phi processor (Knights Landing/KNL).</p>

},
keywords = {Finite State Machine, FSM, Parallelization, Scalability, Speculation}
}

@software{10.6084/m9.figshare.13392338,
author = {Gorjiara, Hamed and Xu, Guoqing Harry and Demsky, Brian},
title = {Replication Package for Article: Jaaru: Efficiently Model Checking Persistent Memory Programs},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.13392338},
abstract = {
    <p>This artifact contains a vagrant repository that downloads and compiles the source code for Jaaru, its companion compiler pass, and benchmarks. The artifact enables users to reproduce the bugs that are found by in PMDK (i.e., Figure 11 of the paper) and RECIPE (i.e., Figure 12) as well as the performance results to compare with Yat (i.e., Figure 13).</p>

},
keywords = {Crash Consistency, Debugging, Jaaru, Persistent Memory, Testing}
}

@software{10.1145/3410275,
author = {L\"{u}cke, Martin and Steuwer, Michel and Smith, Aaron},
title = {Replication Package for Article: Integrating a Functional Pattern-Based IR into MLIR},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3410275},
abstract = {
    <p>The artifact for this paper includes the MLIR infrastructure with the Rise dialect and corresponding passes. IR to reproduce the experiments of the paper is included. A Dockerfile and scripts are provided to enable easy installation, execution, and plotting of results.</p>

},
keywords = {Intermediate Representation, MLIR, Rise}
}

@software{10.5281/zenodo.4399900,
author = {Miu, Anson and Ferreira, Francisco and Yoshida, Nobuko and Zhou, Fangyi},
title = {Communication-Safe Web Programming in TypeScript with Routed Multiparty Session Types},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4399900},
abstract = {
    <p>Our paper presents STScript, a toolchain that generates TypeScript APIs for communication-safe web development over WebSockets, and RouST, a new session type theory that supports multiparty communications with routing mechanisms.</p>

},
keywords = {API generation, deadlock freedom, session types, TypeScript, web programming, WebSocket}
}

@software{10.5281/zenodo.4416117,
author = {Silva, Anderson Faustino da and de Lima, Bernardo N. B. and Pereira, Fernando Magno Quint\~{a}o},
title = {Replication Package for Article: Exploring the Space of Optimization Sequences for Code-Size Reduction: Insights and Tools},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4416117},
abstract = {
    <p>Predictive compilation is the problem of determining good sequences of analyses and optimizations for particular programs. Although predictive compilers have enjoyed much progress in recent years, their development still faces a difficult challenge: the vastness of the space of possible optimizations that can be matched with each program. The effective exploration of this space is a community task that must be carried out gradually and systematically. Towards this vision, this artifact provides an Docker image that contains an optimization cache for research on code-size reduction. In addition, it provides a set of building blocks so that the user can build his/her own application.</p>

},
keywords = {code size, Compiler, sequence}
}

@software{10.5281/zenodo.4451492,
author = {Panchenko, Maksim and Auler, Rafael and Sakka, Laith and Ottoni, Guilherme},
title = {Replication Package for Article: Lightning BOLT: Powerful, Fast, and Scalable Binary Optimization},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4451492},
abstract = {
    <p>This artifact contains the software required to reproduce the experimental findings of the paper “Lightning BOLT: Powerful, Fast, and Scalable Binary Optimization”, CC 2021. This package is a copy of https://github.com/facebookincubator/BOLT/tree/master/paper/reproduce-bolt-cc2021 revision 4990ee5. Please access the github page for an updated version of this artifact, if available.</p>
<p>The open-source workloads evaluated for this paper are clang 11 and gcc 10. These two workloads need to be bootstrapped (built with themselves). Our goal is to demonstrate reductions in wall time and memory consumption when running BOLT on these workloads with different techniques: parallelization and selective optimizations. This is accomplished with the first experiment (exp1.sh script, Figures 3, 4 and 5 in the paper). The second experiment (exp2.sh script, Figures 6 and 7 in the paper) shows how can we trade BOLT speed for output binary performance.</p>

},
keywords = {Binary Optimization, Compilers, Performance}
}

@software{10.5281/zenodo.4456774,
author = {Merigoux, Denis and Monat, Rapha\"{e}l and Protzenko, Jonathan},
title = {A Modern Compiler for the French Tax Code - Artifact},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4456774},
abstract = {
    <p>In France, income tax is computed from taxpayers’ individual returns, using an algorithm that is authored, designed and maintained by the French Public Finances Directorate (DGFiP). This algorithm relies on a legacy custom language and compiler originally designed in 1990, which unlike French wine, did not age well with time. Owing to the shortcomings of the input language and the technical limitations of the compiler, the algorithm is proving harder and harder to maintain, relying on ad-hoc behaviors and workarounds to implement the most recent changes in tax law. Competence loss and aging code also mean that the system does not benefit from any modern compiler techniques that would increase confidence in the implementation.</p>
<p>We overhaul this infrastructure and present Mlang, an open-source compiler toolchain whose goal is to replace the existing infrastructure. Mlang is based on a reverse-engineered formalization of the DGFiP’s system, and has been thoroughly validated against the private DGFiP test suite. As such, Mlang has a formal semantics; eliminates previous hand-written workarounds in C; compiles to modern languages (Python); and enables a variety of instrumentations, providing deep insights about the essence of French income tax computation. The DGFiP is now officially transitioning to Mlang for their production system.</p>
<p>This is the artifact accompanying the published paper at Compiler Construction 2021.</p>

},
keywords = {compiler, legal expert system, tax code}
}

@software{10.5281/zenodo.4458159,
author = {Palmkvist, Viktor and Castegren, Elias and Haller, Philipp and Broman, David},
title = {Resolvable Ambiguity - CC Artifact},
year = {2021},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.4458159},
abstract = {
    <p>This Docker image contains the software required to reproduce the results in the paper “Resolvable Ambiguity: Principled Resolution of Syntactically Ambiguous Programs” to be published in ACM SIGPLAN 2021 International Conference on Compiler Construction (CC 2021).</p>
<p>Note that as there is an element of randomness in the composition of language fragments, we include the same configuration used for Section 6, but also allow selecting new random combinations. For completeness, we also include the source code of our tool, but as it is not the main focus, it will not be as approachable as running the experiments.</p>

},
keywords = {Ambiguity, Syntax}
}

@software{10.5281/zenodo.3597725,
author = {Kr\"{u}ger, Stefan and Ali, Karim and Bodden, Eric},
title = {CogniCrypt_GEN - Generating Code for the Secure Use of Crypto APIs (Artefact)},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3597725},
abstract = {
    <p>In this artefact, we present Cognicrypt_GEN, a code generation approach that allows for the generation of functionally correct, type-safe, and secure Java code that implements common use cases of cryptographic APIs. To implement a given use case, Cognicrypt_GEN requires two artefacts: a) a set of API-usage rules in the specification language CrySL and b) a Java code template specifying which CRYSL rules are to be used and how. The artefact comes with an Eclipse environment, in which Cognicrypt_GEN may be executed with all eleven use cases from the original paper. It further contains the artefacts to all use cases to allow for modification and extension. We finally include a tutorial on how Cognicrypt_GEN is used.</p>
},
keywords = {Code Generation, Cryptography, Eclipse, Java}
}

@software{10.1145/3373125,
author = {Pizzuti, Federico and Steuwer, Michel and Dubach, Christophe},
title = {Replication Packager for 'Generating Fast Sparse Matrix Vector Multiplicationfrom a High Level Generic Functional IR'},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373125},
abstract = {
    <p>The artefact contains the version of the Lift compiler used within the paper, together with the reference cuSparse benchmark and detailed instructions on how to reproduce the experiment</p>
},
keywords = {Code Generation, Dependent Types, GPU programming, Sparse Matrix}
}

@software{10.1145/3373123,
author = {Serrano, Manuel and Findler, Robert Bruce},
title = {Replication package for: Dynamic Property Caches, A Step towards Faster JavaScript Proxy Objects},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373123},
abstract = {
    <p>The artifact associated with the submission Dynamic Property Caches is the Hop JavaScript static native compiler and the test suite that is described and used in the paper. The compiler and the tests are packaged in a way that facilitates the reproduction of the experimental results of the paper. The artifact contains two automatic procedures. One that re-runs the portion of the performance evaluation for Hop and V8 and one that re-runs the full experiment.</p>
},
keywords = {ahead-of-time compilation., AOT, compiler, compiler optimization, dynamic languages, JavaScript, runtime representation}
}

@software{10.1145/3373126,
author = {Thakur, Manas and Nandivada, V. Krishna},
title = {Artifact for Paper: Mix Your Contexts Well},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373126},
abstract = {
    <p>Our artifact includes Java code for our techniques proposed in this paper: lsrvH and lsrvkobjH. We have also provided the code for our implementation of the object-sensitive analysis (kobjH). Instructions to use can be found in the included appendix.pdf and README.txt.</p>
},
keywords = {Context-sensitivity, Java, Static analysis}
}

@software{10.1145/3373124,
author = {Castro-Perez, David and Yoshida, Nobuko},
title = {Tool and Benchmarks for Article: Compiling First-Order Functions to Session-Typed Parallel Code},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373124},
abstract = {
    <p>This is the artifact for the paper 'Compiling First-Order Functions to Session-Typed Parallel Code'. It contains a prototyle EDSL for the language described in the paper, as well as the benchmarks that we used for its evaluation.</p>
},
keywords = {arrows, Haskell, multiparty session types, parallel programming}
}

@software{10.5281/zenodo.3579301,
author = {L\'{o}pez-G\'{o}mez, Javier and Fern\'{a}ndez, Javier and Astorga, David del Rio and Vassilev, Vassil and Naumann, Axel and Garc\'{\i}a, J. Daniel},
title = {Replication Package for Article: Relaxing the One Definition Rule in Interpreted C++},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3579301},
abstract = {
    <p>This package contains the required scripts and source code to run the required evaluation tests -both, those included in the paper, and additional tests-. For convenience, we provide a VM image in OVA format that contains all the required dependencies. Users should import the image and see the README file for further instructions. Alternatively, the `master' branch can be built from sources in the Cling repository.</p>
},
keywords = {C++, Cling, interpreter, One-Definition-Rule}
}

@software{10.5281/zenodo.3607141,
author = {Chida, Nariyoshi and Kawakoya, Yuhei and Ikarashi, Dai and Takahashi, Kenji and Sen, Koushik},
title = {PoC Implementation of parser generators based on existing/SG/CM-stateful packrat parsing},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3607141},
abstract = {
    <p>This is an artifact of the paper titled "Is Stateful Packrat Parsing Really Linear in Practice  -- A Counter-Example, an Improved Grammar, and Its Parsing Algorithms --".</p>
},
keywords = {Parser Generator, Parsing Expression Grammar, Stateful Packrat Parser}
}

@software{10.5281/zenodo.3605359,
author = {Kang, Seokwon and Choi, Kyunghwan and Park, Yongjun},
title = {[Evaluation Package] PreScaler: An Efficient System-aware Precision Scaling Framework on Heterogeneous Systems},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3605359},
abstract = {
    <p>This package provides all the binaries, libraries, benchmarks, and scripts, for evaluating the PreScaler implementations. These require target heterogeneous systems that contain Intel CPUs and NVIDIA GPUs. This package provides PreScaler artifact in two forms: ocker images and native binaries for several different system environments. These include installation scripts for software dependencies except NVIDIA Graphic Driver and CUDA toolkit. When you use a Docker image, all the software dependencies are preinstalled.</p>
},
keywords = {Compiler, HSA, OpenCL, Precision Scaling, Profile-guided, Runtime}
}

@software{10.1145/3373121,
author = {Ismail, Mohamed and Suh, G. Edward},
title = {Artifact for Article: Efficient Nursery Sizing for Managed Languages on Multi-core Processors with Shared Caches},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373121},
abstract = {
    <p>Our artifact provides a full framework to evaluate the performance of our Dynamic Nursery Allocator. The framework is provided as a Docker image to ensure repeatability and to make setup and running it easy on any platform. Our framework consists of: (1) The compiled PyPy binary that supports DNA along with the PyPy source code and the DNA source code, (2) The Python and PyPy benchmark suite programs used in the evaluation, (3) Scripts to setup the experiments and automate running the benchmarks, (4) An analysis script to summarize the results as CSV files, and (5) Graphing scripts to generate graphs from the CSV files. We additionally provide reference CSV files with the results presented in the paper for inspection and comparison.</p>
},
keywords = {automatic memory management, managed languages, PyPy, Python, shared caches}
}

@software{10.1145/3373122,
author = {Taneja, Jubi and Liu, Zhengyang and Regehr, John},
title = {Replication Package for Article: Testing Static Analyses for Precision and Soundness},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373122},
abstract = {
    <p>This artifact provides the source code that implements our work on testing precision and soundness of LLVM s dataflow analyses. Our work builds on the open source superoptimizer, Souper and evaluates LLVM 8.0. We use SPEC CPU 2017 benchmarks version 1.0.1 to evaluate the precision and soundness, and measure the impact of maximal precision on code generation by testing some open source applications like, Gzip, Bzip2, Stockfish, and SQLite . We provide a Dockerfile in our artifact to automatically build the Docker image, which takes care of installing all required dependencies, benchmark suite, and Souper for the experimental evaluation.</p>
},
keywords = {Dataflow analysis, Precision, Soundness}
}

@software{10.1145/3373120,
author = {Haj-Ali, Ameer and Ahmed, Nesreen K. and Willke, Ted and Shao, Yakun Sophia and Asanovic, Krste and Stoica, Ion},
title = {GitHub Version 0.0.1: NeuroVectorizer: End-to-End Vectorization with Deep Reinforcement Learning},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3373120},
abstract = {
    <p>This artifact can be used to produce similar results to ours. It runs training of our NeuroVectorizer framework that trains end-to-end from the code to the optimal factors. Data is provided in the README. It is best if you keep using the updated github repo for fixes/updates.</p>
},
keywords = {Automatic Vectorization., Code Optimization, Deep Reinforcement Learning, LLVM}
}

@software{10.5281/zenodo.3581199,
author = {Zhang, Yunming and Brahmakshatriya, Ajay and Chen, Xinyi and Dhulipala, Laxman and Kamil, Shoaib and Amarasinghe, Saman and Shun, Julian},
title = {Optimizing Ordered Graph Algorithms with GraphIt},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3581199},
abstract = {
    <p>Instructions to test the compiler extension and replicate the performance numbers.</p>
},
keywords = {Compiler Optimizations, Graph Processing}
}

@software{10.5281/zenodo.3542289,
author = {Cheng, Lin and Ilbeyi, Berkin and Bolz-Tereick, Carl Friedrich and Batten, Christopher},
title = {Replication package for Type Freezing: Exploiting Attribute Type Monomorphism in Tracing JIT Compilers},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3542289},
abstract = {
    <p>In this artifact we provide the source code of type freezing equipped PyPy, our microbenchmarks, and PyPy benchmarks we used in our paper -- Type Freezing: Exploiting Attribute Type Monomorphism in Tracing JIT Compilers. Along with the source code, we also provide a prebuilt Docker image. Be noted that running performance experiments inside Docker can have unexpected behaviors. Please refer to the README file for how to import the docker image, translate PyPy from source code, and run the experiments we did in this paper.</p>
},
keywords = {dynamic languages, just-in-time compiler, PyPy, type monomorphism}
}

@software{10.5281/zenodo.3597890,
author = {Cowan, Meghan and Moreau, Thierry and Chen, Tianqi and Bornholt, James and Ceze, Luis},
title = {Replication Package for Automatic Generation of High-Performance Quantized Machine Learning Kernels},
year = {2020},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3597890},
abstract = {
    <p>This artifact contains the source code for generating quantized operators for ARM devices as well as scripts to reproduce the experimental results. Quantized microkernels are synthesized for ARM NEON, which are used by TVM, a machine learning compiler.</p>
},
keywords = {code generation, program synthesis, Quantization}
}

@software{10.17863/CAM.46071,
author = {Savage, Joe and Jones, Timothy M.},
title = {Research data supporting "HALO: Post-Link Heap-Layout Optimisation"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.17863/CAM.46071},
abstract = {
    <p>Source code for the HALO optimisation pipeline. This includes a client for the Pin binary instrumentation framework, a patch for the BOLT binary optimiser, a custom memory allocator, and scripts to assist in applying our optimisations and extracting performance results. See the README.md file within the repository for a more detailed description and usage instructions.</p>
},
keywords = {binary analysis, binary optimisation, data layout optimisation}
}

@software{10.5281/zenodo.2678161,
author = {Das, Sourav and Unnithan, R. Harikrishnan and Menon, Arjun and Rebeiro, Chester and Veezhinathan, Kamakoti},
title = {SHAKTI-MS Artifacts},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2678161},
abstract = {
    <p>Artifacts for SHAKTI-MS: A RISC-V Processor for Memory Safety in C</p>
},
keywords = {c, compiler, LLVM, memory corruption, security}
}

@software{10.5281/zenodo.2648959,
author = {Daruwalla, Kyle and Zhuo, Heng and Schulz, Carly and Lipasti, Mikko},
title = {BitBench Artifact Evaluation},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2648959},
abstract = {
    <p>A ZIP file containing the source files and scripts to verify the results of BitBench.</p>
},
keywords = {bitstream computing, high level synthesis, pulse density modulation, stochastic computing, verilog}
}

@software{10.5281/zenodo.2669678,
author = {Hsiao, Luke and Wu, Sen and Chiang, Nicholas and R\'{e}, Christopher and Levis, Philip},
title = {Software for Automating the Generation of Hardware Component Datasheets},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2669678},
abstract = {
    <p>This artifact provides a Python package and datasets which can be used to replicate our methodology for automating the generation of hardware component knowledge bases. We describe how the software and datasets can be obtained, how the software and dependencies can be installed, and how the software can be used to run our experiments. Our artifact outlines the workflow from the input data (PDF and HTML documents, along with gold labels) to the final quality metrics we used to evaluate the approach. We also include scripts used for our analysis and performance experiments.</p>
},
keywords = {design tools, hardware components, knowledge base construction}
}

@software{10.1145/3300171,
author = {Zhao, Qi and Qiu, Zhengyi and Jin, Guoliang},
title = {Software for Semantics-Aware Scheduling Policies for Synchronization Determinism},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3300171},
abstract = {
    
},
keywords = {deterministic multithreading, semantics-aware policies, stable multithreading, synchronization determinism, synchronization scheduling}
}

@software{10.1145/3300172,
author = {Winter, Martin and Mlakar, Daniel and Zayer, Rhaleb and Seidel, Hans-Peter and Steinberger, Markus},
title = {Software for "Adaptive Sparse Matrix-Matrix Multiplication on the GPU"},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3300172},
abstract = {
    
},
keywords = {Adaptive, bit-stable, ESC, GPU, Sparse Matrix, SpGEMM}
}

@software{10.1145/3300173,
author = {Henriksen, Troels and Thor\o{}e, Frederik and Elsman, Martin and Oancea, Cosmin},
title = {Software for Incremental Flattening for Nested Data Parallelism},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3300173},
abstract = {
    
},
keywords = {compilers, functional language, GPGPU, parallel}
}

@software{10.1145/3300174,
author = {Li, Xiuhong and Liang, Yun and Yan, Shengen and Jia, Liancheng and Li, Yinghan},
title = {Software for A Coordinated Tiling and Batching Framework for Efficient GEMM on GPUs},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3300174},
abstract = {
    
},
keywords = {Batching, GEMM, GPGPU, Tiling}
}

@software{10.1145/3300175,
author = {Wang, Qingsen and Su, Pengfei and Chabbi, Milind and Liu, Xu},
title = {Software for Lightweight Hardware Transactional Memory Profiling},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3300175},
abstract = {
    
},
keywords = {Hardware Transactional Memory, optimization, profiling}
}

@software{10.5281/zenodo.2240193,
author = {Qiao, Bo and Reiche, Oliver and Hannig, Frank and Teich, J\"{u}rgen},
title = {From Loop Fusion to Kernel Fusion: A Domain-specific Approach to Locality Optimization},
year = {2019},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2240193},
abstract = {
    <p>This artifact describes the steps to reproduce the results for the CUDA code generation with kernel fusion in Hipacc (an image processing DSL and source-to-source compiler embedded in C++), as presented in the CGO19 paper “From Loop Fusion to Kernel Fusion: A Domain-specific Approach to Locality Optimization”. We provide the original binaries as well as the source code to regenerate the binaries, which can be executed on x86_64 Linux system with CUDA enabled GPUs. Furthermore, we include two python scripts to run the application and compute the statistics as depicted in Figure 6 in the paper.</p>
<p>Hardware Dependencies: CUDA enabled GPUs are required. We used three Nvidia cards, as discussed in Section 5.1 in the paper: (a) Geforce GTX 745 facilitates 384 CUDA cores with a base clock of 1,033 MHz and 900 MHz memory clock. (b) Geforce GTX 680 has 1,536 CUDA cores with a base clock of 1,058 MHz and 3,004 MHz memory clock. (c) Tesla K20c has 2,496 CUDA cores with a base clock of 706 MHz and 2,600 MHz memory clock. For all three GPUs, the total amount of shared memory per block is 48 Kbytes, the total number of registers available per block is 65,536. GPUs with similar configurations are expected to generate comparable results.</p>
<p>Software Dependencies: Clang/LLVM (6.0), compiler_rt and libcxx for Linux (6.0). CMake (3.4 or later), Git (2.7 or later). Nvidia CUDA Driver (9.0 or later). OpenCV for producing visual output in the samples.</p>

},
keywords = {DSL, Image Processing, Kernel Fusion}
}

@software{10.5281/zenodo.2229779,
author = {Lim, Jay P. and Nagarakatte, Santosh},
title = {CASM_Verify},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.2229779},
abstract = {
    <p>This is the artifact of the tool, CASM_Verify, for the paper, “Automatic Equivalence Checking for Assembly Implementations of Cryptography Libraries,” which will appear in CGO 2019.</p>
<p>CASM_Verify is a tool that automatically checks whether the equivalence of highly optimized assembly implementation of cryptographic implementations are equivalent to the reference implementation.</p>
<p>The artifact contains the source code of CASM_Verify, the benchmarks used for the evaluation, and the Dockerfile that can automatically create a Docker image containing all the required software and CASM_Verify.</p>
<p>To use CASM_Verify without Docker, install Python3 and z3.</p>

},
keywords = {CGO 2019}
}

@software{10.1145/3287760,
author = {Bentaleb, Abdelhak and Begen, Ali C. and Harous, Saad and Zimmermann, Roger},
title = {Software for GTA: A Game Theoretic Approach for Adaptive Streaming over HTTP},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3287760},
abstract = {
    <p>Our video contents are obtained from the DASH dataset (http://www-itec.uni-klu.ac.at/dash/__?__page_id=207). This dataset consists of various genres including animation, sports, movie and documentary. The set of videos are encoded using an H.264/AVC codec into 20 bitrate levels, different resolutions {240, 360, 480, 720, 1080}p, and chunk durations of {1, 2, 4, 10} seconds. Also, check Section 7.5 in the paper for Throughput Profiles.</p>
},
keywords = {ABR scheme, consensus, DASH, fastMPC, game theory, HTTP adaptive streaming, QoE optimization}
}

@software{10.1145/3289158,
author = {Tavares da Costa Filho, Roberto Iraja and Torres Vega, Maria and Caggiani Luizelli, Marcelo and van der Hooft, Jeroen and Petrangeli, Stefano and Wauters, Tim and De Turck, Filip and Paschoal Gaspary, Luciano},
title = {Predicting the Performance of Virtual Reality Video Streaming in Mobile Networks},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3289158},
abstract = {
    <p>Predicting the Performance of Virtual Reality Video Streaming in Mobile Networks</p>
},
keywords = {HTTP Adaptive Streaming, Mobile Networks, Quality of Experience, Quality of Service, Virtual Reality}
}

@software{10.1145/3276990,
author = {Wei, Jiayi and Chen, Jia and Feng, Yu and Ferles, Kostas and Dillig, Isil},
title = {Artifact for 'Singularity: Pattern Fuzzing for Worst Case Complexity'},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3276990},
abstract = {
    <p>Singularity is an automatic fuzzing tool for generating inputs (called patterns) that demonstrate the maximal resource usage behavior of a given program.</p>
},
keywords = {availability vulnerability, Complexity testing, fuzzing, genetic programming, optimal program synthesis, performance bug}
}

@software{10.1145/3289159,
author = {Corbillon, Xavier and De Simone, Francesca and Simon, Gwendal and Frossard, Pascal},
title = {MultiViewpoint360 MMSys18},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3289159},
abstract = {
    <p>MultiViewpoint360 MMSys18</p>
},
keywords = {Adaptive Streamning, DASH, HEVC, HEVC MCTS, Multi-Viewport Omnidirectional Video, User Navigation Traces}
}

@software{10.1145/3229769,
author = {Gong, Jiong and Shen, Haihao and Zhang, Guoming and Liu, Xiaoli and Li, Shane and Jin, Ge and Maheshwari, Niharika and Fomenko, Evarist and Segal, Eden},
title = {Collective Knowledge Workflow for Highly Efficient 8-bit Low Precision Inference of Convolutional Neural Networks with IntelCaffe},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3229769},
abstract = {
    <p>A unified Collective Knowledge workflow with reusable components for the ReQuEST'18 submission “Highly Efficient 8-bit Low Precision Inference of Convolutional Neural Networks with IntelCaffe”.</p>
},
keywords = {Convolutional Neural Network, Deep Learning, Intel Caffe, Model Optimization}
}

@software{10.1145/3229770,
author = {Zheng, Lanmin and Chen, Tianqi},
title = {Collective Knowledge Workflow for Optimizing Deep Learning Workloads on ARM GPU with TVM},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3229770},
abstract = {
    <p>A unified Collective Knowledge workflow with reusable components for the ReQuEST'18 submission “Optimizing Deep Learning Workloads on ARM GPU with TVM”.</p>
},
keywords = {ARM GPU, Deep Learning, GPU Kernel, TVM}
}

@software{10.1145/3229771,
author = {Hadidi, Ramyad and Cao, Jiashen and Woodward, Matthew and Ryoo, Michael S. and Kim, Hyesoon},
title = {Collective Knowledge Workflow for Real-Time Image Recognition Using Collaborative IoT Devices},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3229771},
abstract = {
    <p>A unified Collective Knowledge workflow with reusable components for the ReQuEST'18 submission “Real-Time Image Recognition Using Collaborative IoT Devices”.</p>
}
}

@software{10.1145/3229772,
author = {Moreau, Thierry and Chen, Tianqi and Ceze, Luis},
title = {Collective Knowledge Workflow for Leveraging the VTA-TVM Hardware-Software Stack for FPGA Acceleration of 8-bit ResNet-18 Inference},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3229772},
abstract = {
    <p>A unified Collective Knowledge workflow with reusable components for the ReQuEST'18 submission "Leveraging the VTA-TVM Hardware-Software Stack for FPGA Acceleration of 8-bit ResNet-18 Inference"</p>
}
}

@software{10.1145/3229773,
author = {Lokhmotov, Anton and Chunosov, Nikolay and Vella, Flavio and Fursin, Grigori},
title = {Collective Knowledge Workflow for Multi-objective autotuning of MobileNets across the full software/hardware stack},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3229773},
abstract = {
    <p>A unified Collective Knowledge workflow with reusable components for the ReQuEST'18 submission “Multi-objective autotuning of MobileNets across the full software/hardware stack”.</p>
},
keywords = {accuracy, autotuning, Collective Knowledge, crowdtuning, customizable workflows, live scoreboard, MobileNets, performance, reproducible experimentation, system co-design}
}

@software{10.1145/3229311,
author = {Santos, Rodrigo C. M. and Lima, Guilherme F. and Sant'Anna, Francisco and Ierusalimschy, Roberto and Haeusler, Edward H.},
title = {Replication Package for Article: A Memory-Bounded, Deterministic and Terminating Semantics for the Synchronous Programming Language C\'{e}u},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3229311},
abstract = {
    <p>Our artifact includes an open-source implementation of the programming language C\'{e}u. The implementation is based on and should conform with the formal semantics presented in this paper. The artifact also includes an executable script with over 3500 test cases of valid and invalid programs in C\'{e}u. The script is customizable and allows to create new tests providing inputs and expected outputs.</p>
},
keywords = {Determinism, Operational semantics, Synchronous languages, Termination}
}

@software{10.5281/zenodo.1242627,
author = {Devine, James and Finney, Joe and de Halleux, Peli and Moskal, Micha? and Ball, Thomas and Hodges, Steve},
title = {Documentation for MakeCode and CODAL: Intuitive and Efficient Embedded Systems Programming for Education Artifact Evaluation},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1242627},
abstract = {
    <p>This artifact contains documentation of artifact 10.5281/zenodo.1242605, this documentation is also contained within the artifact 10.5281/zenodo.1242605 as well.</p>
},
keywords = {BBC micro:bit., CODAL, education, MakeCode, physical computing}
}

@software{10.5281/zenodo.1242605,
author = {Devine, James and Finney, Joe and de Halleux, Peli and Moskal, Micha\l{} and Ball, Thomas and Hodges, Steve},
title = {Artifact for the LCTES 2018 paper: MakeCode and Codal: Intuitive and Efficient Embedded Systems Programming for Education},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1242605},
abstract = {
    <p>This artifact allows others to reproduce the results seen in this paper for MakeCode and CODAL, using the BBC micro:bit. The artifact contains an offline build environment for CODAL and MakeCode, allowing evaluators to test and build programs locally. In addition, we also provide espruino and micropython virtual machines to further increase repeatability of our results. Evaluators should download the virtual machine containing all pre-requisite tools, and use an oscilloscope to observe wave forms (used for timing) generated by the micro:bit, and a serial terminal to observe results reported from the micro:bit over serial.</p>
},
keywords = {BBC micro:bit, CODAL, evaluation, lctes, MakeCode}
}

@software{10.5281/zenodo.1242583,
author = {Taylor, Ben and Marco, Vicent Sanz and Wolff, Willy and Elkhatib, Yehia and Wang, Zheng},
title = {Adaptive Deep Learning Model Selection on Embedded Systems},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1242583},
abstract = {
    <p>Our research artefact enables the reproduction of the figures from our experimental results (Section 5 of the paper). Please see the Appendix of the paper for detailed Artifact Description.</p>
},
keywords = {Adaptive computing, Deep learning, Embedded systems}
}

@software{10.1145/3218967,
author = {Arora, Akhil and Galhotra, Sainyam and Ranu, Sayan},
title = {Debunking the Myths of Influence Maximization: An In-Depth Benchmarking Study},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3218967},
abstract = {
    <p>This software includes the experimental environment for the results produced in our Influence Maximization (IM) benchmarking paper, which introduces a unified framework for benchmarking state-of-the-art algorithms for the IM problem. The study benchmarks 11 techniques proposed in the literature over a collection 8 datasets of varying size.</p>
},
keywords = {benchmarking, independent cascade, influence maximization, information diffusion, linear threshold, social networks}
}

@software{10.1145/3190498,
author = {Fu, Xinwei and Lee, Dongyoon and Jung, Changhee},
title = {Replication Package for Article: nAdroid: Statically Detecting Ordering Violations in Android Applications},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3190498},
abstract = {
    <p>Our artifact provides all the runnable jar files of nAdroid and all the Android applications tested in this paper, along with scripts to use these to regenerate the results in our evaluation section. We tested our artifact on a quad-core Intel i7 3.6 GHz system with 16GB of memory, running the 3.13 Linux kernel. We also provide a virtual machine image with all dependencies installed. To validate the results, run the scripts and check the results according to the README file.</p>
},
keywords = {Android, Data race, Debugging, Ordering violation, Static analysis, Threadification, Use-after-free}
}

@software{10.1145/3190500,
author = {Zhou, Qing and Li, Lian and Wang, Lei and Xue, Jingling and Feng, Xiaobing},
title = {Replication Package for Article: May-Hppen-in-Parallel Analysis with Static Vector Clocks},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3190500},
abstract = {
    <p>This is a virtual box image. You can use it to run the default data race detector LDruid with Static Vector Clocks. Static vector clocks are used to do MHP analysis. The image does not consist of source code, and we plan to open source in future. The relevant algorithm and experimental results can be found in paper CGO2018: MHP analysis with Static Vector Clocks.</p>
},
keywords = {Data race detector, MHP, Static vector clocks}
}

@software{10.6084/m9.figshare.5673880.v1,
author = {Zhang, Feng and Xue, Jingling},
title = {Artifact of: “POKER:Permutation-based SIMD Execution of Intensive Tree Search by Path Encoding”},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.5673880.v1},
abstract = {
    <p>This is the artifact for the paper titled “POKER: Permutation-based SIMD Execution of Intensive Tree Search by Path Encoding\'{Y} accepted at CGO 2018. This artifact helps reproduce the results presented in Figures 7 - 9 and Tables 2 - 3 in Section 4. For more information on how to use it, please refer to our paper and the README.txt file in this package. Please note that POKER is a work in progress. This artifact is a snapshot of this work and thus is only applicable under the experimental settings described in this paper. Please feel free to contact the authors if you have any questions.</p>
},
keywords = {Intensive Tree Search, Permute, SIMD}
}

@software{10.1145/3190495,
author = {Xie, Biwei and Zhan, Jianfeng and Liu, Xu and Gao, Wanling and Jia, Zhen and He, Xiwen and Zhang, Lixin},
title = {Replication Package for Article, CVR: Efficient Vectorization of SpMV on X86 Processors},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3190495},
abstract = {
    <p>The artifact contains the source code of SpMV using CVR after converting a sparse matrix from CSR to CVR. It can support the experiment results in section 8 of our CGO'2018 paper, CVR: Efficient SpMV Vectorization on X86 Processors. To validate the results, build CVR and run the benchmarks with provided scripts. This artifact provides general instructions to evaluate CVR, while more details are provided on Github (
 <ext-link xlink:href="https://github.com/puckbee/CVR">
  https://github.com/puckbee/CVR)
 </ext-link>.</p>
},
keywords = {Knights Landing, Many core, SIMD, SpMV}
}

@software{10.1145/3190499,
author = {Hagedorn, Bastian and Stoltzfus, Larisa and Steuwer, Michel and Gorlatch, Sergei and Dubach, Christophe},
title = {Artifact for the CGO 2018 paper: High Performance Stencil Code Generation with Lift},
year = {2018},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3190499},
abstract = {
    <p>This artifact encapsulates the workflows to supplement the paper “High Performance Stencil Code Generation With Lift” accepted for presentation at the International Symposium on Code Generation and Optimization in 2018.</p>
},
keywords = {Lift, Performance Portability, Stencil}
}

@software{10.5281/zenodo.1112358,
author = {Buchwald, Sebastian and Fried, Andreas and Hack, Sebastian},
title = {Synthesizing an Instruction Selection Rule Library from Semantic Specifications},
year = {2017},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.1112358},
abstract = {
    <p>This is the software accompanying the paper of the same name, to appear at CGO 2018. The goal of the software is to automatically synthesize rules for translating a compiler's intermediate representation into the assembly language of a processor (a process called ”instruction selection“). The software is distributed along with benchmarks in a Docker container. For some benchmarks, a copy of the SPEC CPU2000 benchmark suite is required.</p>
},
keywords = {Compiler, Instruction Selection, Program Synthesis}
}

@software{10.1145/3190496,
author = {Kruse, Michael and Grosser, Tobias},
title = {CGO '18 Artifact for DeLICM},
year = {2017},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3190496},
abstract = {
    <p>The artifact contains the scripts used to obtain the data from the article, including the results we obtained ourselves.</p>
},
keywords = {experiment, LLVM, Polly, result}
}

@software{10.1145/3192720,
author = {Zahran, Ahmed H. and Quinlan, Jason J. and Ramakrishnan, K. K. and Sreenan, Cormac J.},
title = {SAP: Stall-Aware Pacing for Improved DASH Video Experience in Cellular Networks},
year = {2017},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3192720},
abstract = {
    <p>A step by step guide is offerred in https://www.ucc.ie/en/misl/research/software/sap-testbed/.</p>
},
keywords = {DASH, LTE networks, Stall aware pacing, Video streaming}
}

@software{10.1145/3218889,
author = {Jin, Zhongjun and Anderson, Michael R.},
title = {Software for Foofah: Transforming Data by Example},
year = {2017},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3218889},
abstract = {
    <p>These are the instructions to run this software:</p>
},
keywords = {data transformation, heuristic search, program synthesis, programming by example, semi-structured data}
}

@software{10.1145/3289155,
author = {Koch, Christian and Pfannm\"{u}ller, Johannes and Rizk, Amr and Hausheer, David and Steinmetz, Ralf},
title = {Software for: Category-aware Hierarchical Caching for Video-on-Demand Content on YouTube},
year = {2017},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3289155},
abstract = {
    <p>Software for: Category-aware Hierarchical Caching for Video-on-Demand Content on YouTube</p>
},
keywords = {Caching Hierarchies, Content-Awareness, Video Streaming}
}

@software{10.1145/3192701,
author = {Hsu, Hwai-Jung and Chen, Kuan-Ta},
title = {DroneFace: An Open Dataset for Drone Research},
year = {2017},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3192701},
abstract = {
    <p>DroneFace contains following contents: 11 subjects including 7 males and 4 females. 2,057 pictures including 620 raw images, 1,364 frontal face images, and 73 portrait images The raw images are taken in 3,680x2,760 resolution with ultra-wide field of view (170\'{z}) under daylights. The resolutions of the facial images are between 23x31 and 384x384. The raw images are taken from 1.5, 3, 4, and 5 meters high. The raw images are taken 2 to 17 meters away from the subjects with 0.5 meters interval. The 3-direction portrait images are taken by sport and phone camera for comparison. DroneFace contains following contents: 11 subjects including 7 males and 4 females. 2,057 pictures including 620 raw images, 1,364 frontal face images, and 73 portrait images The raw images are taken in 3,680x2,760 resolution with ultra-wide field of view (170\'{z}) under daylights. The resolutions of the facial images are between 23x31 and 384x384. The raw images are taken from 1.5, 3, 4, and 5 meters high. The raw images are taken 2 to 17 meters away from the subjects with 0.5 meters interval. The 3-direction portrait images are taken by sport and phone camera for comparison. All the images in DroneFace are named in the following manner: subjectID_cameraType_heightID_imageType_distanceID.jpg subjectID [[a-k]|ab|cd|ef|gh|ijk] cameraType [gp|cam|na] heightID [0|3|4|5|na] imageType [eo|ef|por|por[F|L|R] distanceID [00-30|na] 11 subjects are named with English letters, a to k. The subject a, b, c, e, g, j, and k are males, and the remainders are females. If the subjectID part contains merely one letter means only one subject is in the image; on the other hand, there are multiple ones. The code "gp" in cameraType means the picture is taken using our sport camera (GoPro Hero3+ Silver Edition), and "cam" indicates that the pictures is taken using the HTC One M8 smart phone. heightID 0, 3, 4, and 5 represents that the camera is 1.5, 3, 4, and 5 meters high from the ground accordingly while the picture is taken. imageType "eo" means that the picture is a raw image, "ef" means thay the image is a frontal facial image extracted from a raw image, "por" means that the picture is the portrait handed by the subject, and "porF", "porL", or "porR" means the pictures is the portrait images of the subjects\'{z} front, left, or right faces. The distance ID is a two digit number, and the actual distance from the subject to the camera equals to 17-(distanceID/2) meters. For any of the components in the filename, "na" represents that the corresponding information is not available.</p>
},
keywords = {Aerial Drone, Face Recognition, UAV}
}

@software{10.1145/3159287,
author = {Hadian, Ali and Nobari, Sadegh and Minaei-Bidgoli, Behrouz and Qu, Qiang},
title = {Software for ROLL: Fast In-Memory Generation of Gigantic Scale-free Networks},
year = {2016},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3159287},
abstract = {
    <p>You can retrieve the zip file for this Artifact by clicking on the Zip Link above or by going to the github repository listed below. </p> ROLL(available at 
<ext-link xlink:href="https://github.com/alihadian/ROLL">
 https://github.com/alihadian/ROLL
</ext-link>) 
<break></break> 
<break></break>Tested in Ubuntu Linux 14.04 and 16.04. No specific hardware needed. The code can be compiled using Maven. 
<break></break> 
<break></break> The package includes scripts that enable: 
<p>
 <list> 
  <list-item>
   graph generation
  </list-item> 
  <list-item>
   run experiments.
  </list-item> 
 </list></p>Executing ./runAll.sh initiates the data generation process and the process of executing all the experiments that were part of the paper. No parameters needed. There is a master script (runAll.sh) that runs all experiments. The scripts generate all result data from to plot the graphs of the paper. For more information, please visit the project's GitHub page: 
<ext-link xlink:href="https://github.com/alihadian/ROLL">
 https://github.com/alihadian/ROLL
</ext-link> 
<break></break> 
<break></break> The code associated with this paper is in the src folder. Use ./runAll.sh to execute the code it. The experiments of the paper can be reproduced using the runAll.sh script. For that to work, maven and JDK 8+ is required. Note that generating the entire set of charts can take over a month. However, the data points of each chart are generated in order of execution time, so that partial results for each chart can be obtained in a shorter time by simply killing the application and using the partial data that is stored in the corresponding output files. 
<break></break> 
<break></break> 
<bold>
 Data Documentation:
</bold> 
<break></break>ROLL is a graph GENERATOR. Therefore, it does not require any input dataset. 
<break></break> 
<break></break> 
<bold>
 Linked Article:
</bold> 
<p>
 <list> 
  <list-item>
   <ext-link xlink:href="https://github.com/alihadian/ROLL">
     ROLL: Fast In-Memory Generation of Gigantic Scale-free Networks 
   </ext-link>
  </list-item> 
 </list></p> 
<bold>
 Provenance:
</bold> ROLL is developed by Ali Hadian. Contact the developer at 
<ext-link xlink:href="https://github.com/alihadian/ROLL">
 http://hadian.org
</ext-link> 
<break></break> 
<break></break> 
<bold>
 Copyright:
</bold> Held by Authors 
<break></break> 
<break></break> 
<bold>
 License:
</bold> 
<break></break> Licensed under the Apache License, Version 2.0. This repository is adapted with ACM reproducibility. Owner of artifact grants ACM permission to serve the artifact to users of the ACM Digital Library. 
<break></break> 
<break></break> This code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ACM, THE AUTHORS AND THEIR AFFILIATED INSTITUTES DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.<p></p>
},
keywords = {Algorithms, Barabasi-Albert, Complex Networks, Graph, Graph Generation, Random Graphs}
}

@software{10.1145/3192770,
author = {Bhat, Divyashri and Rizk, Amr and Zink, Michael and Steinmetz, Ralf and Simon, Gwendal},
title = {Network Assisted Content Distribution for Adaptive Bitrate Video Streaming},
year = {2016},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3192770},
abstract = {
    <p>The implementation is based on the implementation of OpenNetMon and AStream and the corresponding files used for the Openflow controller and DASH player emulator are distributed with the OpenNetmon project and AStream project, respectively. The code associated with this paper is in the controllerSABR folder. The experiments of the paper can be collected and analyzed using the scripts in the folder results_parse. For that to work python and BASH is required. The MATLAB folder contains all necessary scripts to reproduce the plots in the paper.</p>
},
keywords = {ABR streaming, Caching, DASH, Network assisted streaming, OpenFlow, QoE, SDN, Video quality metrics}
}

@software{10.1145/3192927,
author = {Lo, Wenchih and Fan, Chingling and Lee, Jean and Huang, Chungying and Chen, Kuanta and Hsu, Chenghsin},
title = {360° Video Viewing Dataset in Head-Mounted Virtual Reality},
year = {2016},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3192927},
abstract = {
    <p>Our dataset provides both content data (such as image saliency maps and motion maps derived from 360° videos) and sensor data (such as viewer head positions and orientations derived from HMD sensors). We also put extra efforts to align the content and sensor data using the timestamps in the raw log files. The information of the dataset subfolders is given below: 1. Saliency: contains the videos with the saliency map of each frame based on Cornia's work (available at https://arxiv.org/abs/1609.01064), where the saliency maps indicate the attraction level of the original video frame. 2. Motion: contains the videos with the optical flow analyzed from each pair of consecutive frames, where the optical flow indicates the relative motions between the objects in 360-degree videos and the viewer. 3. Raw: contains the raw sensing data (raw x, raw y, raw z, raw yaw, raw roll, and raw pitch) with timestamps captured when the viewers watch 360-degree videos using OpenTrack. 4. Orientation: contains the orientation data (raw x, raw y, raw z, raw yaw, raw roll, and raw pitch), which have been aligned with the time of each frame of the video. The calibrated orientation data (cal. yaw, cal. pitch, and cal. roll) are provided as well. 5. Tile: contains the tile numbers overlapped with the Field-of-View (FoV) of the viewer according to the orientation data, where the tile size is 192x192. Knowing the tiles that are overlapped with the FoV of the viewer is useful for optimizing 360-degree video to HMD streaming system, for example, the system can only stream those tiles to reduce the required bandwidth or allocate higher bitrate to those tiles for better user experience.</p>
},
keywords = {360° dataset, 360° video, Head tracking dataset, HMD, Virtual reality}
}

@software{10.1145/3193701,
author = {Corbillon, Xavier and De Simone, Francesca and Simon, Gwendal},
title = {360-Degree Videos Head Movements Dataset},
year = {2016},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3193701},
abstract = {
    <p>The artifact is a Head Movement Dataset of 59 users watching 5 360-degree videos. We provide a tar.gz archive that contains an organized set of folder and files. The dataset was recorded using an open source software available inside another artifact.</p>
},
keywords = {360-degree video, head movement dataset, omnidirectional video}
}

