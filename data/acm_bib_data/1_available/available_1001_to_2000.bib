@software{10.5281/zenodo.6685674,
author = {Ostermann, Klaus and Binder, David and Skupin, Ingo and S\"{u}berkr\"{u}b, Tim and Downen, Paul},
title = {Introduction and Elimination, Left and Right - Coq Formalization},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6685674},
abstract = {
    <p>Coq formalization of the ICFP 2022 paper “Introduction and Elimination, Left and Right”.</p>

},
keywords = {Abstract machines, Duality, Lambda calculus, Linear logic, Natural Deduction, Proof theory, Sequent Calculus, Type theory}
}

@software{10.5281/zenodo.6689803,
author = {Koppel, James and Kearl, Jackson and Solar-Lezama, Armando},
title = {Automatically Deriving Control-Flow Graph Generators from Operational Semantics},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6689803},
abstract = {
    <p>This artifact contains information needed to evaluate all claims in the paper. Specifically, it contains a QEMU image and sources containing Mandate, along with instructions for running. It also features pre-generated control-flow graphs and generators.</p>

},
keywords = {control flow, haskell, program synthesis, term rewriting}
}

@software{10.5281/zenodo.6702804,
author = {Spies, Simon and G\"{a}her, Lennard and Tassarotti, Joseph and Jung, Ralf and Krebbers, Robbert and Birkedal, Lars and Dreyer, Derek},
title = {Coq development for "Later Credits: Resourceful Reasoning for the Later Modality"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6702804},
abstract = {
    <p>This is the artifact for the ICFP’22 paper “Later Credits: Resourceful Reasoning for the Later Modality”. It contains the Coq development mechanizing the results of the paper. The artifact contains the development both in a VM image (QEMU) with pre-built sources and as a .zip source archive. In addition, the technical appendix is included.</p>

},
keywords = {Iris, later modality, Separation logic, step-indexing, transfinite}
}

@software{10.5281/zenodo.6710298,
author = {Vasilenko, Elizaveta and Vazou, Niki and Barthe, Gilles},
title = {Library Implementation for Article "Safe Couplings: Coupled Refinement Types"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6710298},
abstract = {
    <p>This artifact includes an appendix with the soundness proof and source code of safe-coupling library and case studies.</p>

},
keywords = {Haskell, program verification, refinement types, relational types}
}

@software{10.5281/zenodo.6727752,
author = {Ramsey, Norman},
title = {Reproduction Package for Article "Beyond Relooper: Recursive Translation of Unstructured Control Flow to Structured Control Flow"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6727752},
abstract = {
    <p>A development branch of the Glasgow Haskell Compiler extended with a translation from arbitrary control flow to WebAssembly control flow. Includes source code, compiled binary, and test cases. Packaged as a QEMU virtual machine.</p>

},
keywords = {compilers, control-flow analysis, dominator
tree, functional languages, GHC, Glasgow Haskell Compiler, Haskell, reverse postorder numbering, WebAssembly}
}

@software{10.5281/zenodo.6757373,
author = {Kov\'{a}cs, Andr\'{a}s},
title = {Supplementary artifact for the paper "Staged Compilation with Two-Level Type Theory"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6757373},
abstract = {
    <p>A demo implementation of the type theory described in the titular paper.</p>

},
keywords = {staged compilation, two-level type theory, type theory}
}

@software{10.5281/zenodo.6767057,
author = {Escot, Lucas and Cockx, Jesper},
title = {Generics, a library for datatype-generic programming in Agda},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6767057},
abstract = {
    <p>This artifact contains the source code for the Generics library for safe, typed datatype-generic programming in Agda.</p>

},
keywords = {Agda, Datatype, Dependent, Generic Programming, Types, Universe}
}

@software{10.5281/zenodo.6778257,
author = {Hoang, Tram and Trunov, Anton and Lampropoulos, Leonidas and Sergey, Ilya},
title = {ICFP-2022 Artifact for the paper "Random Testing of a Higher-Order Blockchain Language (Experience Report)"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6778257},
abstract = {
    <p>The artifact contains Scilla-Chick – a QuickChick-based tool for property-based randomized testing of the Scilla smart-contract language.</p>
<p>The tool developed for the paper is located in the <code>~/scilla-chick</code> directory. The (pseudo)random type-and-term generator is located in the file <code>~/scilla-chick/src/scilla.v</code> and is written in Coq (see <code>gen_type</code> and <code>gen_term</code> functions) using the QuickChick framework. QuickChick works by translating Coq code into OCaml for the sake of performance (it runs compiled OCaml code). We translate between Coq and OCaml representations using some glue OCaml code in <code>~/scilla-chick/src/extr/extr.ml</code> file. Various kinds of tests are located in the <code>X_test.v</code> files: <code>gen_test.v</code>, <code>eval_test.v</code>, etc.</p>
<p>The rest of the files and directories in the home directory are used to pin particular dependency versions needed to build the Scilla-Chick project. In particular, we re-use the Scilla implementation as an OCaml library.</p>
<p>For more information, please see the <code>~/scilla-chick/README.md</code> file in the <code>master</code> branch of the <code>~/scilla-chick</code> repository (note that the other branches contain an outdated version of <code>README.md</code>).</p>

},
keywords = {definitional interpreters, functional languages, higher-order control-flow analysis, property-based testing, QuickChick, random testing, Scilla, smart contracts}
}

@software{10.5281/zenodo.6786796,
author = {Biernacka, Ma\l{}gorzata and Charatonik, Witold and Drab, Tomasz},
title = {Abstract Machines Workshop},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6786796},
abstract = {
    <p>This project contains the code accompanying the paper <em>A Simple and Efficient Implementation of Strong Call by Need by an Abstract Machine</em>.</p>
<p>This research is supported by the National Science Centre of Poland, under grant number 2019/33/B/ST6/00289.</p>

},
keywords = {Abstract Machines, Computational Complexity, Normalization by Evaluation, Reduction Strategies, λ-calculus}
}

@software{10.5281/zenodo.6794696,
author = {Bahr, Patrick and Hutton, Graham},
title = {Supplementary Material for "Monadic Compiler Calculation"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6794696},
abstract = {
    <p>This artifact includes Agda formalisations of all calculations in the paper. In addition, we also include Agda formalisations for calculations that were mentioned but not explicitly carried out in the paper.</p>

},
keywords = {bisimilarity, divergence, non-determinism, program calculation}
}

@software{10.5281/zenodo.6865817,
author = {Keuchel, Steven and Huyghebaert, Sander and Lukyanov, Georgy and Devriese, Dominique},
title = {Source Code, Case Study and Reproduction for 'Verified Symbolic Execution with Kripke Specification Monads (and No Meta-programming)'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6865817},
abstract = {
    <p>The provided artifact contains the source code for our verifier Katamaran and instructions how to reproduce and verify all claims of the paper. Furthermore, we provide a QEMU VM-image of Debian that comes with all dependencies preinstalled and that does not require any additional online resources.</p>

},
keywords = {coq, iris, logical relations, predicate transformers, program verification, refinement, separation logic, symbolic execution}
}

@software{10.5281/zenodo.6874025,
author = {Materzok, Marek},
title = {Reproduction Package for Article 'Generating Circuits with Generators'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6874025},
abstract = {
    <p>The artifact source archive contains four repositories:</p>
<ul>
<li><code>yieldfsm</code> – the implementation of the YieldFSM compiler.</li>
<li><code>yieldfsm-hd44780</code> – the implementation of the HD44780 display driver described in the paper.</li>
<li><code>yieldfsm-riscv</code> – the implementation of RISC-V cores described in the paper.</li>
<li><code>yieldfsm-icfp2022</code> – various examples from the paper and calculation of the data in Table 2.</li>
</ul>
<p>Each of the repositories contains its own README file. Building requires <code>stack</code> (https://haskellstack.org). When additional packages are needed, this is described in a README for a given repository.</p>
<p>The <code>stack.yaml</code> files in the <code>yieldfsm-hd44780</code> and <code>yieldfsm-riscv</code> repositories were modified to use the local version of <code>yieldfsm</code> rather than the version on Github.</p>

},
keywords = {generators, hardware description languages, haskell, yieldfsm}
}

@software{10.5281/zenodo.6884760,
author = {Jacobs, Jules and Balzer, Stephanie and Krebbers, Robbert},
title = {Multiparty GV: Functional Multiparty Session Types With Certified Deadlock Freedom (Coq mechanization)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6884760},
abstract = {
    <p>This artifact contains mechanized Coq proofs of the theorems in the associated paper.</p>

},
keywords = {concurrency, deadlocks, memory leaks, multi-party., Session types}
}

@software{10.5281/zenodo.6913915,
author = {Yoon, Irene and Zakowski, Yannick and Zdancewic, Steve},
title = {Artifact for "Formal Reasoning about Layered Monadic Interpreters"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6913915},
abstract = {
    <p>This is the artifact for the paper submission of “Formal Reasoning About Layered Monadic Interpreters”. We have mechanized and proved all claims made in the paper in Coq.</p>

},
keywords = {Coq (language), Functional Programming, Monads, Program Verification}
}

@software{10.5281/zenodo.6946310,
author = {Lorenzen, Anton and Leijen, Daan},
title = {Implementation and Benchmarks for "Reference Counting with Frame Limited Reuse"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6946310},
abstract = {
    <p>Contains the implementation of Koka with the new frame-limited reuse algorithm, and the various benchmarks and language implementations we compare against. All benchmark results in the paper were produced using this software.</p>

},
keywords = {frame-limited, koka, reference counting, reuse}
}

@software{10.5281/zenodo.6954977,
author = {Ko, Hsiang-Shang and Chen, Liang-Ting and Lin, Tzu-Chi},
title = {Repository and virutal machine image for paper "Datatype-Generic Programming Meets Elaborator Reflection"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6954977},
abstract = {
    <p>There are three files in the artifact package: The tarball “NDGP.tar.gz” consists of a patch for compiling Agda, necessary libraries, metaprograms, and examples mentioned in the main text; “vm-image.tar.gz” is a disk image file of a working operating system, on which a patched Agda is installed, and an exact same repository is presented in the home directory; “README.md” contains the documentation for patching and compiling Agda, as well as how to execute our proofs, metaprograms, and examples.</p>

},
keywords = {datatype-generic programming, dependently typed programming, elaborator reflection, inductive families, metaprogramming, universe polymorphism}
}

@software{10.5281/zenodo.6957191,
author = {Valliappan, Nachiappan and Ruch, Fabian and Tom\'{e} Corti\~{n}as, Carlos},
title = {Artifact for "Normalization for Fitch-Style Modal Calculi"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6957191},
abstract = {
    <p>The artifact contains the Agda mechanization of the normalization functions for the Fitch-style modal calculi λ<sub>IK</sub> and λ<sub>IS4</sub> as described in the article.</p>
<p>See <code>README.md</code> in <code>source.tar.xz</code> for details.</p>

},
keywords = {Fitch-style lambda calculi, Normalization by Evaluation, Possible-world semantics}
}

@software{10.1145/3554298,
author = {Willis, Jamie and Wu, Nicolas and Schrijvers, Tom},
title = {Source Code for Oregano Library from Staging Regular Expressions with Moore Cayley Fusion},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554298},
abstract = {
    <p>This artifact contains the source code and benchmarks</p>

},
keywords = {Parsing, Regular Expressions, Staging}
}

@software{10.1145/3554299,
author = {McDonell, Trevor L. and Meredith, Joshua D. and Keller, Gabriele},
title = {Implementation demonstrating the techniques of the paper 'Embedded Pattern Matching'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554299},
abstract = {
    <p>This artefact contains three implementations demonstrating the techniques described in the paper ‘Embedded Pattern Matching’. With this technique we can use pattern matching in the host language to introduce case expressions in the embedded language, in much the same way the user would do in the host language. This enables a natural and user-friendly embedding of user-defined algebraic data types into the embedded language.</p>

},
keywords = {algebraic data types, embedded languages, Haskell, pattern matching, Scala}
}

@software{10.1145/3554300,
author = {Hollenbeck, Celeste and O'Boyle, Michael F. P. and Steuwer, Michel},
title = {Reproduction Package for Article `Investigating Magic Numbers: Improving the Inlining Heuristic in the Glasgow Haskell Compiler'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554300},
abstract = {
    <p>These are the necessary files to recreate the modified version of GHC; download, build, modify, and time a given list of Hackage projects; and visualize the results in the paper.</p>

},
keywords = {GHC, Haskell, Inlining}
}

@software{10.1145/3554301,
author = {Vazou, Niki and Greenberg, Michael},
title = {Artifact for How to Safely Use Extensionality in Liquid Haskell},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554301},
abstract = {
    <p>Implementation and examples from How to Safely Use Extensionality in Liquid Haskell</p>

},
keywords = {function extensionality, Liquid Haskell, refinement types}
}

@software{10.1145/3554302,
author = {Blanchette, Henry and Vazou, Niki and Lampropoulos, Leonidas},
title = {Reproduction Package for Liquid Proof Macros},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554302},
abstract = {
    <p>The implementation and evaluation of liquid proof macros.</p>

},
keywords = {Haskell, Liquid Haskell, macros, proof engineering, tactics}
}

@software{10.1145/3554303,
author = {Mastorou, Lykourgos and Papaspyrou, Nikolaos and Vazou, Niki},
title = {Reproduction Package for Article `Coinduction Inductively: Mechanizing Coinductive Proofs in Liquid Haskell`},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554303},
abstract = {
    <p>Coinductive proofs encoded in Liquid Haskell using the approaches described in the paper.</p>

},
keywords = {coinduction, refinement types, theorem proving}
}

@software{10.1145/3554304,
author = {Ingle, Apoorv and Hubers, Alex and Morris, J. Garrett},
title = {Artifact for paper titled "Partial Type constructors in Practice"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554304},
abstract = {
    <p>The artifact is a fork of the Glasgow Haskell Compiler (GHC) that demonstrates the claims made in the paper</p>

},
keywords = {Data Types, GHC, Haskell, Type System}
}

@software{10.5281/zenodo.6928465,
author = {Maillard, Kenji and Lennon-Bertrand, Meven and Tabareau, Nicolas and Tanter, \'{E}ric},
title = {A Reasonably Gradual Type Theory – Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6928465},
abstract = {
    <p>Accompanying artifact to the article A Reasonably Gradual Type Theory.</p>
<p>It consists of two parts:</p>
<ul>
<li><p>a Coq formalization of the model described in the article,</p></li>
<li><p>a proof of concept using rewrite rules in Agda to present the source system of the article and the examples of usage of that source system.</p></li>
</ul>
<p>A virtual machine is also available, where all the necessary components needed to immediately check these two parts are installed. The artefact already available in the virtual machine is the one of the first uploaded version (with only minor differences with the post-reviewing one). If one wishes to check the newer version, they should simply upload this newer version into the virtual machine and build it.</p>

},
keywords = {Agda, Coq}
}

@software{10.5281/zenodo.3731856,
author = {Beyer, Dirk and Dangl, Matthias and Dietsch, Daniel and Heizmann, Matthias and Lemberger, Thomas and Tautschnig, Michael},
title = {Reproduction Package for TOSEM Article `Verification Witnesses'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.3731856},
abstract = {
    <p>This is the reproduction package for the TOSEM article DOI:10.1145/3477579. The archive contains the tools that we executed and the data that we produced.</p>
},
keywords = {Certifying algorithm, Correctness witness, Data-flow analysis, Formal methods, Model checking, Program analysis, Software verification, Violation witness, Witness validation}
}

@software{10.1145/3550216,
author = {Kelly, Terence},
title = {Source code for the article "Decentralized Computing"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550216},
abstract = {
    <p>Two maximal independent set (MIS) solver implementations are provided: "mixer" and "mis".  Shell scripts run both implementations on the example graph.<br>The "mixer.py" Python program is a decentralized implementation.  For each vertex in the graph we create a process that decides for itself whether to be "in" or "out" of the MIS after communicating as necessary with other processes representing adjacent vertices in the graph.  Read "mixer.csh" to see how the set of processes run. Without options, "mixer.csh" runs a set of "mixer.py" processes on the example graph.  With the "renum" option, the script also runs the Python code again on a different graph created by re-numbering the vertices of the original example graph.<br>The "mis.c" C program is a centralized implementation.  It reads the graph in file "example_graph.txt" and uses the same basic algorithm as the decentralized implementation to compute the same MIS.  Shell script "mis.csh" compiles the C code, runs the executable under the control of Valgrind, and uses the "check.awk" script to verify that the output is indeed an MIS of the input graph.  Run "indent" to adjust the layout of the C program to taste.</p>
}
}

@software{10.1145/3554329,
author = {Laurel, Jacob and Yang, Rem and Ugare, Shubham and Nagel, Robert and Singh, Gagandeep and Misailovic, Sasa},
title = {Reproduction Package for the article: A General Construction for Abstract Interpretation of Higher-Order Automatic Differentiation},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554329},
abstract = {
    <p>This artifact contains the implementation and experiments for the paper “A General Construction for Abstract Interpretation of Higher-Order Automatic Differentiation” (OOPSLA 2022) by Jacob Laurel, Rem Yang, Shubham Ugare, Robert Nagel, Gagandeep Singh, and Sasa Misailovic. For both the interval and zonotope domains, we implement abstract first- and second-order automatic differentiation. We use our technique to study (1) robustly explaining a neural network via their first and second derivatives and (2) computing the Lipschitz constant of neural networks.</p>

},
keywords = {Abstract Interpretation, Automatic Differentiation, Differentiable Programming}
}

@software{10.1145/3554330,
author = {Ghica, Dan and Lindley, Sam and Bravo, Marcos Maro\~{n}as and Pir\'{o}g, Maciej},
title = {Cpp-effects: High-level effect handlers in C++},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554330},
abstract = {
    <p>Effect handlers allow for programming with user-defined computational effects, with applications including custom lightweight concurrency (threads, async-await, actors, generators), error handling, dependency injection, etc. Effect handlers originate from the realm of functional programming, and the main goal of this experimental library is to explore how they fit in the more object-oriented setting of C++.</p>

},
keywords = {algebraic effects, control structures, Effect handlers, lightweight concurrency}
}

@software{10.1145/3554331,
author = {Murali, Adithya and Pe\~{n}a, Lucas and Blanchard, Eion and L\"{o}ding, Christof and Madhusudan, P.},
title = {Artifact for OOPSLA 2022 Article Model-Guided Synthesis of Inductive Lemmas for FOL with Least Fixpoints},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554331},
abstract = {
    <p>This artifact contains benchmarks and the source code for the FOSSIL tool reported in the paper, as well as instructions on how to reproduce the corresponding experiments. Please see the README.md file in the artifact for more details.</p>

},
keywords = {Counterexample-Guided Inductive Synthesis, Inductive Hypothesis Synthesis, Learning Logics, Solver for First Order Logic with Least Fixpoints, Verifying Linked Data Structures}
}

@software{10.5281/zenodo.6818171,
author = {Ritter, Fabian and Hack, Sebastian},
title = {AnICA: Analyzing Inconsistencies in Microarchitectural Code Analyzers (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6818171},
abstract = {
    <p>This artifact consists of a Vagrant virtual machine providing a functional version of our software development with extensive documentation, the AnICA campaigns produced in our evaluation, as well as (where permitted by licenses) installed versions of the throughput predictors used in our evaluation. Its purpose is to demonstrate our approach (with the provided throughput predictors and the possibility to integrate new ones), to show AnICA’s results in more detail than possible in the paper, and to allow researchers to build upon our work.</p>

},
keywords = {Abstraction, Basic Blocks, Differential Testing, Throughput Prediction}
}

@software{10.5281/zenodo.6819031,
author = {Yuan, Charles and Carbin, Michael},
title = {Tower: Data Structures in Quantum Superposition},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6819031},
abstract = {
    <p>The artifact contains: README.md, a description document tower.tgz, a Docker image containing source code, pre-built binaries, and tests tower.dockerfile, a Dockerfile that generates the above image from scratch The directory oopsla22-artifact, a copy of the contents of the Docker image, containing the source code of the Tower language interpreter (src/) and the tests (tests/)</p>

},
keywords = {data structures, history independence, quantum programming, quantum random-access memory, reversible programming}
}

@software{10.5281/zenodo.6826341,
author = {Moiseenko, Evgenii and Kokologiannakis, Michalis and Vafeiadis, Viktor},
title = {Replication Package for "Model Checking for a Multi-Execution Memory Model},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6826341},
abstract = {
    <p>The artifact contains WMC, as well as the other tools and benchmarks used in the paper.</p>

},
keywords = {software verification, stateless model checking, weak memory models}
}

@software{10.5281/zenodo.6885003,
author = {Zhao, Zihan and Beillahi, Sidi Mohamed and Song, Ryan and Cai, Yuxi and Veneris, Andreas and Long, Fan},
title = {Artifact for the OOPSLA 2022 paper: SigVM: Enabling Event-Driven Execution for Truly Decentralized Smart Contracts},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6885003},
abstract = {
    <p>The artifact consists of a VM image that is based on an Ubuntu-20.04-desktop-LTS image. It was tested using Oracle VM VirtualBox Manager Version 6.1 (and the default config: 4 processors and 8192 MB base memory). The admin password is <code>test</code>. The image includes all the tools (with their dependencies) and the benchmarks (and tool parameters) used to carry out the experiments in the paper.</p>

},
keywords = {Blockchain Client, Conflux, Ethereum Virual Machine (EVM), Event-Driven, Smart Contracts, Solidity Compiler (solc)}
}

@software{10.5281/zenodo.6899919,
author = {Dalvandi, Sadegh and Dongol, Brijesh},
title = {Implementing and Verifying Release-Acquire Transactional Memory (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6899919},
abstract = {
    <p>Isabelle / HOL theories for all proofs and C++ implementation of TML and TML-RA (a release-acquire version of TML).</p>

},
keywords = {C11, Refinement, Transactional Memory, Verification, Weak Memory}
}

@software{10.5281/zenodo.7051651,
author = {Dexter, Philip and Liu, Yu David and Chiu, Kenneth},
title = {The Essence of Online Data Processing - Coq Mechanization},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7051651},
abstract = {
    <p>Coq mechanization for the paper “The Essence of Online Data Processing” appearing in OOPSLA 22</p>

},
keywords = {Coq, Incremental Evaluation, Online Data Optimization, Online Data Processing}
}

@software{10.5281/zenodo.7054373,
author = {Liu, Hongming and Fu, Hongfei and Yu, Zhiyong and Song, Jiaxin and Li, Guoqiang},
title = {StInGX: An extension of StInG},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7054373},
abstract = {
    <p>StInGX is an invariant generator extended and modified from original StInG (https://theory.stanford.edu/~srirams/Software/sting.html), so that to be more scalable and efficient.</p>

},
keywords = {Constraint Solving, Farkas' Lemma, Invariant Generation}
}

@software{10.5281/zenodo.7055010,
author = {Nieto, Abel and Gondelman, L\'{e}on and Reynaud, Alban and Timany, Amin and Birkedal, Lars},
title = {Modular Verification of Op-Based CRDTs in Separation Logic (Proof Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7055010},
abstract = {
    <p>Coq implementation of the libraries described in the paper, as well mechanized safety proofs.</p>

},
keywords = {causal broadcast, Coq, CRDT, distributed systems, Iris, separation logic, verification}
}

@software{10.5281/zenodo.7055030,
author = {Moosbrugger, Marcel and Stankovi\v{c}, Miroslav and Bartocci, Ezio and Kov\'{a}cs, Laura},
title = {This is the Moment for Probabilistic Loops - Artifact (Polar)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7055030},
abstract = {
    <p>The artifact contains the tool “Polar” together with scripts to reproduce all the scientific claims from the corresponding paper “This Is the Moment for Probabilistic Loops” published at OOPSLA 2022.</p>
<p>The artifact consists of a single ZIP-file. The ZIP-file comes with a Docker image and a README-file containing all information necessary to reproduce the results from the corresponding paper.</p>
<p>The tool “Polar” - central to the artifact and the paper - is a program analysis tool capable of exactly computing higher moments of program variables for a class of probabilistic loops.</p>

},
keywords = {Distribution
Recovery, Higher Moments, Linear Recurrences, Loops, Probabilistic Programs}
}

@software{10.5281/zenodo.7058421,
author = {Chen, Adam and Fathololumi, Parisa and Koskinen, Eric and Pincus, Jared},
title = {Veracity: Declarative Multicore Programming with Commutativity},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7058421},
abstract = {
    <p>Veracity is a c-like language that features the commute statement, which can describe conditional commutativity of sequential code. When such code’s commutativity condition is satisfied, and proper (scoped) serializability constraints are met, it may be run in parallel, benefiting from multi-core architecture.</p>
<p>Veracity is provided as an interpreter that is implemented in Multicore OCaml. The artifact contains a version of the interpreter, provided with Servois2 to drive the commutativity analysis. The benchmark suite used in the paper is provided, as well as the programs/scripts used to generate the benchmarks seen in the paper.</p>
<p>The extended technical report can be found of Arxiv and is linked at http://www.veracity-lang.org/.</p>

},
keywords = {commutativity analysis, commutativity conditions, parallelization, pre-condition synthesis, serializability}
}

@software{10.5281/zenodo.7061819,
author = {Susag, Zachary and Lahiri, Sumit and Hsu, Justin and Roy, Subhajit},
title = {Artifact for Symbolic Execution for Randomized Programs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7061819},
abstract = {
    <p>This is the primary artifact for ‘Symbolic Execution for Randomized Programs’. It contains the source code for Plinko and our modified version of KLEE. Plinko is our prototype tool to verify probabilistic properties of randomized programs which universally quantify over all inputs. Additionally, it contains C++ source code for each of the case studies presented in the paper. Scripts to reproduce all of the experiments in the paper are also included.</p>

},
keywords = {probabilistic programs, symbolic execution, Verification}
}

@software{10.5281/zenodo.7062933,
author = {Xie, Ningning and Cong, Youyou and Ikemori, Kazuki and Leijen, Daan},
title = {OOPSLA'22 Paper Artifact: First Class Names for Effect Handlers},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7062933},
abstract = {
    <p>The artifact is a docker image that contains a Koka implementation of named handlers as well as examples in the paper. Also available at: https://hub.docker.com/repository/docker/daanx/oopsla22-namedh</p>

},
keywords = {Algebraic Effect Handlers, Koka, Named Handlers}
}

@software{10.5281/zenodo.7065424,
author = {Sun, Yaozhu and Dhandhania, Utkarsh and Oliveira, Bruno C. d. S.},
title = {Compositional Embeddings of Domain-Specific Languages (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7065424},
abstract = {
    <p>This is the artifact of the OOPSLA’22 paper Compositional Embeddings of Domain-Specific Languages. The artifact contains an in-browser interpreter of the CP language with support for the ExT DSL. The code examples and applications mentioned in the paper are also included.</p>

},
keywords = {Domain-Specific Languages, Interpreter}
}

@software{10.5281/zenodo.7065694,
author = {Mishra, Ashish and Jagannathan, Suresh},
title = {Cobalt tool and reproduction package accompanied with OOPLSA' 22 paper "Specification-Guided Component-Based Synthesis from Effectful Libraries"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7065694},
abstract = {
    <p>This Oopsla22_artifact.md file contains two sections. The <strong>Getting Started</strong> section gives the main steps for installing the dependencies using OCaml package manager (opam) followed by introducing small scripts for building and running Cobal on a sample test case.</p>
<p>The second section <strong>Step-by-step Instructions</strong> explains the structure of the directory, how to run Cobalt on all the benchmarks in the paper?, understanding the results and how to run Cobal on an individual synthesis task in different ablation modes.</p>

},
keywords = {Component-based Synthesis, Conflict-Driven Learning, Effects, Type Specifications}
}

@software{10.5281/zenodo.7066264,
author = {Muduli, Sujit Kumar and Roy, Subhajit},
title = {Satisfiability Modulo Fuzzing: A Synergistic Combination of SMT Solving and Fuzzing (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7066264},
abstract = {
    <p>This repository contains the artifact for the paper “Satisfiability Modulo Fuzzing: A Synergistic Combination of SMT Solving and Fuzzing” accepted at the OOPSLA’22 conference.</p>
<p>The docker image saadhak-image.tar.gz has the source code and executable of our tool Sundefineddhak installed. A manual README.pdf provides step-by-step instructions on how to evaluate our tool on the benchmarks. The license file LICENSE.txt provides permission to copy, modify and re-distribute Sundefineddhak.</p>

},
keywords = {Closed-Box Functions, Fuzzing, Program Verification, SMT Solver, Testing Conflict-Driven Fuzz Loop}
}

@software{10.5281/zenodo.7066401,
author = {Lei, Yuxiang and Sui, Yulei and Ding, Shuo and Zhang, Qirun},
title = {Artifact of "Taming Transitive Redundancy for Context-Free Reachability"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7066401},
abstract = {
    <p>This is the artifact of the paper “Taming Transitive Redundancy for Context-Free Reachability” accepted to OOPSLA 2022. The artifact is packaged as a Docker image “pocr-release.tar.gz”, which is to reproduce the experiment results of the paper. Please see README.pdf for detailed usage of the artifact.</p>

},
keywords = {CFL-reachability, performance, redundancy, transitive relation}
}

@software{10.5281/zenodo.7067362,
author = {Ellis, Stephen and Zhu, Shuofei and Yoshida, Nobuko and Song, Linhai},
title = {Artifact of "Generic Go to Go: Dictionary-Passing, Monomorphisation, and Hybrid"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7067362},
abstract = {
    <p>This artifact is a docker image that contains the implementation of the two translators and the benchmark set used in the paper. For more information, please refer to the README document.</p>

},
keywords = {Artifact, Benchmark, Dictionary-passing translation, Generic types}
}

@software{10.5281/zenodo.7068972,
author = {Li, Liyi and Voichick, Finn and Hietala, Kesha and Peng, Yuxiang and Wu, Xiaodi and Hicks, Michael},
title = {Reproduction Package for "Verified Compilation of Quantum Oracles"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7068972},
abstract = {
    <p>This repository contains the code used in our paper “Verified Compilation of Quantum Oracles.” This includes OQASM, PQASM, and OQIMP. It includes programs implemented in these languages, Coq proofs, and QuickChick tests.</p>

},
keywords = {Compiler Verification, Programming Language Design, Quantum Oracle, Type System}
}

@software{10.5281/zenodo.7071281,
author = {Chaliasos, Stefanos and Gervais, Arthur and Livshits, Benjamin},
title = {Artifact: A Study of Inline Assembly in Solidity Smart Contracts},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7071281},
abstract = {
    <p>This is the artifact for the OOPSLA’22 paper “A Study of Inline Assembly in Solidity Smart Contracts”. You can also find the latest version of this artifact at https://github.com/StefanosChaliasos/solidity-inline-assembly.</p>

},
keywords = {Blockchain, Corpus Study, Ethereum, Inline Assembly, Solidity, YUL}
}

@software{10.5281/zenodo.7071393,
author = {Zwaan, Aron and van Antwerpen, Hendrik and Visser, Eelco},
title = {Incremental Type-Checking for Free: Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7071393},
abstract = {
    <p>The artifact consists of the following: - An executable JAR of the benchmark. - Sources of the incremental type checker framework. - Sources of the Statix implementation based on the incremental type checker framework. - Sources of the Statix specifications, of a subset of Java and WebDSL, that is used in the benchmark. - Sources of the Java and WebDSL projects that are used in the benchmark.</p>
<p>The artifact is executable on the host machine as well as in a VirtualBox/QEMU virtual machine.</p>
<p>The artifact allows executing the benchmarks, in order to reproduce the performance results reported in the paper.</p>

},
keywords = {incremental type-checking, name binding, reference resolution, scope graphs, Statix, type systems, type-checker}
}

@software{10.5281/zenodo.7071693,
author = {Liu, Si and Meseguer, Jose and \"{O}lveczky, Peter Csaba and Zhang, Min and Basin, David},
title = {Reproduction package for article "Bridging the Semantic Gap between Qualitative and Quantitative Models of Distributed Systems"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7071693},
abstract = {
    <p>This package contains the artifacts used to (re)produce the experimental results in the article “Bridging the Semantic Gap between Qualitative and Quantitative Models of Distributed Systems”.</p>

},
keywords = {actors, distributed systems, formal model transformation, Maude, rewriting logic, statistical model checking}
}

@software{10.5281/zenodo.7072457,
author = {Dardinier, Thibault and M\"{u}ller, Peter and Summers, Alexander J.},
title = {Fractional Resources in Unbounded Separation Logic (artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7072457},
abstract = {
    <p>This artifact contains an Isabelle/HOL (version 2021-1) formalisation that proves the technical claims of the paper “Fractional Resources in Unbounded Separation Logic”.</p>

},
keywords = {(co)inductive predicates, automatic deductive verifiers, combinability, fractional permissions, Isabelle, magic
wands, separation logic}
}

@software{10.5281/zenodo.7072506,
author = {Krogmeier, Paul and Lin, Zhengyao and Murali, Adithya and Madhusudan, P.},
title = {Reproduction Docker Image for Article `Synthesizing Axiomatizations using Logic Learning'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7072506},
abstract = {
    <p>This is the Docker image for the paper `Synthesizing Axiomatizations using Logic Learning’. It contains detailed instructions on how to reproduce the experiments performed in the paper. Please see the README.md file inside the compressed tarball for usage of the artifact.</p>

},
keywords = {Axiomatization, Inductive Synthesis, Learning Logics}
}

@software{10.5281/zenodo.7074690,
author = {van der Rest, Cas and Poulsen, Casper Bach and Rouvoet, Arjen and Visser, Eelco and Mosses, Peter},
title = {Intrinsically-Typed Definitional Interpreters \`{a} la Carte (artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7074690},
abstract = {
    <p>Formalization of the code shown/discussed in the paper + the case study discussed in Section 5.</p>

},
keywords = {Definitional Interpreters, Dependently Typed Programming, Modularity, Reuse, Type Safety}
}

@software{10.5281/zenodo.7079022,
author = {Zhu, Fengmin and Sammler, Michael and Lepigre, Rodolphe and Dreyer, Derek and Garg, Deepak},
title = {Artifact of "BFF: Foundational and Automated Verification of Bitfield-Manipulating Programs"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7079022},
abstract = {
    <p>This is the artifact for the OOPSLA’22 paper “BFF: Foundational and Automated Verification of Bitfield-Manipulating Programs”.</p>
<p>After unzipping the archive <code>bff_artifact.zip</code>, the <code>README.md</code> provides instructions on how to use this artifact.</p>

},
keywords = {bit vectors, bitfield manipulation, C programming language, Coq, Iris, proof automation, refinement types}
}

@software{10.5281/zenodo.7079463,
author = {Boruch-Gruszecki, Aleksander and Wa\'{s}ko, Rados\l{}aw and Xu, Yichen and Parreaux, Lionel},
title = {Mechanized proof of «A case for DOT: Theoretical Foundations for Objects With Pattern Matching and GADT-style Reasoning»},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7079463},
abstract = {
    <p>This artifact contains: - mechanized proofs of soundness for cDOT and our variant of λ2,Gµ - mechanized proofs of lemmas related to our translation from λ2,Gµ to cDOT</p>

},
keywords = {classes, Coq, DOT, GADT, pattern matching}
}

@software{10.5281/zenodo.7079674,
author = {Haas, Thomas and Meyer, Roland and Ponce de Le\'{o}n, Hern\'{a}n},
title = {CAAT: Consistency as a Theory (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7079674},
abstract = {
    <p>This artifact allows to reproduce the results from Section 7 of the paper CAAT: Consistency as a Theory published at OOPSLA 2022.</p>

},
keywords = {BMC, concurrency, SMT, weak memory models}
}

@software{10.5281/zenodo.7079830,
author = {Blaudeau, Cl\'{e}ment and Liu, Fengyun},
title = {Coq formalization of the Celsius language},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7079830},
abstract = {
    <p>This artifact contains the Coq project that supports the paper. The calculus is defined, semantics and typing rules are given. It contains all the results presented in the paper.</p>

},
keywords = {annotations, Celsius, Coq, initialization, object, soundness, typing}
}

@software{10.5281/zenodo.7079930,
author = {Abuah, Chik\'{e} and Darais, David and Near, Joseph P.},
title = {Implementation of the Solo Library},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7079930},
abstract = {
    <p>Solo is a Haskell library for static verification of differential privacy. Our paper makes the following claims supported by the artifact:</p>
<ul>
<li>Solo encodes sensitivity and privacy analysis in Haskell’s types</li>
<li>Solo can be used to write and verify useful differentially private programs</li>
<li>Solo does not impose significant annotation burden on the programmer</li>
</ul>

},
keywords = {differential privacy, Haskell, type system, verification}
}

@software{10.5281/zenodo.7079982,
author = {Sela, Gal and Petrank, Erez},
title = {Concurrent Size - Artifact for OOPSLA'22},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7079982},
abstract = {
    <p>Artifact for the paper Concurrent Size published in OOPSLA’22</p>

},
keywords = {Concurrent Size}
}

@software{10.5281/zenodo.7080246,
author = {Wu, Haoze and Barrett, Clark and Sharif, Mahmood and Narodytska, Nina and Singh, Gagandeep},
title = {Artifact for Paper Scalable Verification of GNN-Based Job Schedulers},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080246},
abstract = {
    <p>Please follow the instructions in the readme to replicate the results in the paper.</p>

},
keywords = {Abstract Interpretation, Artifact, Cluster Scheduling, Formal Verification, Forward-backward Analysis, Graph Neural Networks, Neural Networks}
}

@software{10.5281/zenodo.7080357,
author = {Sakkas, Georgios and Endres, Madeline and Guo, Philip J. and Weimer, Westley and Jhala, Ranjit},
title = {Reproduction package and code for "Seq2Parse: Neurosymbolic Parse Error Repair"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080357},
abstract = {
    <p>The artifact consists of the code to extract ML-appropriate datasets, train the sequence models and repair and parse ill-parsed programs with Seq2Parse. A pre-trained model for repairing and parsing Python programs is included.</p>

},
keywords = {machine learning, parsers, seq2parse, syntax errors}
}

@software{10.5281/zenodo.7080459,
author = {Meyer, Roland and Wies, Thomas and Wolff, Sebastian},
title = {Artifact for "A Concurrent Program Logic with a Future and History"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080459},
abstract = {
    <p>Experimental automatic verifier for lock-free data structures, accompanying the OOPSLA’22 paper “A Concurrent Program Logic with a Future and History” by Roland Meyer, Thomas Wies, and Sebastian Wolff. The artifact consists of the verifier’s source code and a virtual machine (VM) to reproduce the experiments from the paper.</p>

},
keywords = {Automated Verification, Linearizability, Lock-free Data Structures, Program Logic, Separation Logic}
}

@software{10.5281/zenodo.7080559,
author = {Chowdhary, Sangeeta and Nagarakatte, Santosh},
title = {Artifact for "Fast Shadow Execution for Debugging Numerical Errors using Error Free Transformations"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080559},
abstract = {
    <p id="artifact-for-the-paper-fast-shadow-execution-for-debugging-numerical-errors-using-error-free-transformations-at-oopsla-2022">Artifact for the paper “Fast Shadow Execution for Debugging Numerical Errors using Error Free Transformations” at OOPSLA 2022</p>
<p id="abstract-of-the-paper"><strong>Abstract of the paper</strong></p>
<p>This paper proposes, EFTSanitizer, a fast shadow execution framework for detecting and debugging numerical errors during late stages of testing especially for long-running applications. Any shadow execution framework needs an oracle to compare against the floating point (FP) execution. This paper makes a case for using error free transformations, which is a sequence of operations to compute the error of a primitive operation with existing hardware supported FP operations, as an oracle for shadow execution. Although the error of a single correctly rounded FP operation is bounded, the accumulation of errors across operations can result in exceptions, slow convergences, and even crashes. To ease the job of debugging such errors, EFTSanitizer provides a directed acyclic graph (DAG) that highlights the propagation of errors, which results in exceptions or crashes. Unlike prior work, DAGs produced by EFTSanitizer’s include operations that span various function calls while keeping the memory usage bounded. To enable the use of such shadow execution tools with long-running applications, EFTSanitizer also supports starting the shadow execution at an arbitrary point in the dynamic execution, which we call selective shadow execution. EFTSanitizer is an order of magnitude faster than prior state-of-art shadow execution tools such as FPSanitizer and Herbgrind. We have discovered new numerical errors and debugged them in many long-running applications using EFTSanitizer.</p>
<p id="claims-to-validatereproduce"><strong>Claims to validate/reproduce</strong></p>
<p>In this artifact, we provide instructions to reproduce and validate the following claims in the paper.</p>
<ol type="1">
<li><p>Ability to detect known errors in microbenchmarks.</p></li>
<li><p>Debugging with gdb to diagnose the bug in the case study.</p></li>
<li><p>Performance slowdown of EFTSanitizer</p></li>
<li><p>Speedups for EFTSanitizer when compared to FPSanitizer</p></li>
</ol>
<p>Note: To make it feasible to run the artifact quickly, we have created mini-versions especially for (4) above. Otherwise it takes more than a day on a native machine to get the performance numbers.</p>

},
keywords = {EFTSanitizer, floating point, rounding errrors}
}

@software{10.5281/zenodo.7080821,
author = {Laddad, Shadaj and Power, Conor and Milano, Mae and Cheung, Alvin and Hellerstein, Joseph M.},
title = {Reproduction Package for Paper "Katara: Synthesizing CRDTs with Verified Lifting"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080821},
abstract = {
    <p>The software artifact accompanying the OOPSLA’22 paper “Katara: Synthesizing CRDTs with Verified Lifting”. This includes the sources of our synthesis algorithm, VM images that can be used for testing the software, and an artifact overview that walks through the steps needed to evaluate the synthesis algorithm.</p>

},
keywords = {distributed systems, program synthesis}
}

@software{10.5281/zenodo.7082520,
author = {Atkinson, Eric and Yuan, Charles and Baudart, Guillaume and Mandel, Louis and Carbin, Michael},
title = {Semi-Symbolic Inference for Efficient Streaming Probabilistic Programming},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7082520},
abstract = {
    <p>This is an artifact accompanying the OOPSLA 2022 paper “Semi-Symbolic Inference for Efficient Streaming Probabilistic Programming”. It consists of a tarball containing the following components:</p>
<p>A Docker image that may be used to execute the artifact in the file semi-symbolic-artifact.tgz. We have tested the Docker image in Docker Engine version 20.10.17.</p>
<p>A directory of the source code located at source-code.</p>
<p>A PDF of this guide can be found at guide.pdf.</p>
<p>In both the docker file and the source code directory, the semi-symbolic-impl directory is the main package implementing semi-symbolic inference – with the source in semi-symbolic-impl/src – while semi-symbolic-probzelus contains the ProbZelus bindings.</p>

},
keywords = {probabilistic programming, streaming inference}
}

@software{10.5281/zenodo.7083308,
author = {Kolesar, John C. and Piskac, Ruzica and Hallahan, William T.},
title = {Checking Equivalence in a Non-strict Language: &nbsp;Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7083308},
abstract = {
    <p>The artifact is a zip file that contains a VM image, a README, and the file expected-results.txt. The code for our tool Nebula is downloaded on the VM image, along with all of the dependencies for it. The purpose of the artifact is to allow readers to verify the claims from the Evaluation section of our paper. The README provides instructions on how to run the evaluation suite, and it includes instructions for running Nebula outside the VM as well. The file expected-results.txt lists the specific theorems in the evaluation suite that Nebula should be able to prove or disprove.</p>

},
keywords = {coinduction, equivalence, Haskell, non-strictness, symbolic execution}
}

@software{10.5281/zenodo.7086231,
author = {Goldstein, Harrison and Pierce, Benjamin C.},
title = {Parsing Randomness: Free Generators Development},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7086231},
abstract = {
    <p>The Haskell code for reproducing the experiments from the Parsing Randomness paper.</p>

},
keywords = {Formal languages, Parsing, Random generation}
}

@software{10.5281/zenodo.7087913,
author = {Mackay, Julian and Eisenbach, Susan and Noble, James and Drossopoulou, Sophia},
title = {Necessity Specifications for Robustness},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7087913},
abstract = {
    <p>Coq sources for the paper Necessity Specifications for Robustness, published at OOPSLA 2022. The artifact consists of a model of the Necessity and Assert specification languages, along with a proof system for Necessity, a soundness proof of the Necessity proof system, and proofs using Necessity that two examples detailed in the paper satisfy their specifications.</p>

},
keywords = {Formal Methods, Necessity, Robustness, Verification}
}

@software{10.5281/zenodo.7088869,
author = {Sivaraman, Aishwarya and Sanchez-Stern, Alex and Chen, Bretton and Lerner, Sorin and Millstein, Todd},
title = {Data-Driven Lemma Synthesis for Interactive Proofs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7088869},
abstract = {
    <p>Interactive proofs of theorems often require auxiliary helper lemmas to prove the desired theorem. Existing approaches for automatically synthesizing helper lemmas fall into two broad categories. Some approaches are goal-directed, producing lemmas specifically to help a user make progress from a given proof state, but they have limited expressiveness in terms of the lemmas that can be produced. Other approaches are highly expressive, able to generate arbitrary lemmas from a given grammar, but they are completely undirected and hence not amenable to interactive usage. In this paper, we develop an approach to lemma synthesis that is both goal-directed and expressive. The key novelty is a technique for reducing lemma synthesis to a data-driven program synthesis problem, whereby examples for synthesis are generated from the current proof state. We also describe a technique to systematically introduce new variables for lemma synthesis, as well as techniques for filtering and ranking candidate lemmas for presentation to the user. We implement these ideas in a tool called lfind, which can be run as a Coq tactic. In an evaluation on four benchmark suites, lfind produces useful lemmas in 68\% of the cases where a human prover used a lemma to make progress. In these cases lfind synthesizes a lemma that either enables a fully automated proof of the original goal or that matches the human-provided lemma.</p>

},
keywords = {lemma synthesis, program synthesis, theorem proving}
}

@software{10.5281/zenodo.7089827,
author = {Chitre, Khushboo and Kedia, Piyus and Purandare, Rahul},
title = {Reproduction Package for the Article "The Road Not Taken: Exploring Alias Analysis Based Optimizations Missed by the Compiler"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7089827},
abstract = {
    <p>The artifact includes the source code for Scout (LLVM), our custom allocator (jemalloc2k) and the build scripts to help in the verification and the replication of the claimed results.</p>

},
keywords = {alias analysis, dynamic checks, LLVM, loop-versioning, optimizations}
}

@software{10.5281/zenodo.7092952,
author = {Kalita, Pankaj Kumar and Muduli, Sujit Kumar and D’Antoni, Loris and Reps, Thomas and Roy, Subhajit},
title = {Synthesizing Abstract Transformers},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7092952},
abstract = {
    <p>This artifact consists of the source code of AMURTH and other dependencies installed to reproduce the results shown in the paper. This artifact contains README.pdf, where step-by-step instructions to reproduce the results are provided.</p>

},
keywords = {abstract transformer, DSL, program synthesis}
}

@software{10.5281/zenodo.7093079,
author = {Titzer, Ben L.},
title = {Artifact for "A Fast In-Place Interpreter for WebAssembly "},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7093079},
abstract = {
    <p>This archive includes supplementary data and code for the OOPSLA 2022 paper entitled “A Fast In-Place Interpreter for WebAssembly”.</p>
<ul>
<li>source-code snapshots of 3 Web Engines for executing WebAssembly</li>
<li>3 non-Web engines: Wasm3, the WebAssembly Micro-Runtime, and the Wizard Research Engine</li>
<li>binary builds for Linux x86-64</li>
<li>build instructions</li>
<li>PolyBenchC benchmark Wasm binaries</li>
<li>benchmarking setup and scripts</li>
<li>data collected from experiments included in the OOPSLA 2022 paper</li>
<li>instructions for running the benchmarks on Linux systems</li>
</ul>

},
keywords = {interpreters, performance, virtual machines, WebAssembly}
}

@software{10.5281/zenodo.7121838,
author = {Parreaux, Lionel and Chau, Chun Yin},
title = {MLstruct: Principal Type Inference in a Boolean Algebra of Structural Types (Artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7121838},
abstract = {
    <p>This is the artifact release for our OOPSLA 2022 paper MLstruct: Principal Type Inference in a Boolean Algebra of Structural Types, version 2.</p>

},
keywords = {principal type inference, structural typing, union and intersection types}
}

@software{10.1145/3550217,
author = {Kelly, Terence},
title = {Source code for the article "Offline Algorithms in Low-Frequency Trading"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550217},
abstract = {
    <p>The source code has been compiled with GCC and tested on Linux.  It is intended to be portable to other compilers and OSes without excessive fuss.  Re-format to taste with the "indent" utility. I recommend compiling with GCC's "-fsanitize=undefined" flag if your version of GCC supports it.  That should catch out-of-bounds array subscripts and signed integer overflow errors at run time. Program "rb" generates random bids.  Program "auclear" clears two-resource auctions.  Script "run.csh" compiles and runs both programs.</p>
}
}

@software{10.1145/3554332,
author = {Giacobbe, Mirco and Kroening, Daniel and Parsert, Julian},
title = {Code and Problem sets for 'Neural Termination Analysis'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554332},
abstract = {
    <p>The artifact contains the code used to perform Neural Termination Analysis. Furthermore, it contains the benchmark data sets that were used for the experimental evaluation.</p>

},
keywords = {Artificial Intelligence and Machine Learning for Software Engineering, Computer-aided Verification, Formal Methods, Neural Termination Analysis, Program Analysis, Ranking Function Synthesis, Termination Analysis}
}

@software{10.1145/3554333,
author = {Smytzek, Marius and Zeller, Andreas},
title = {SFLKit},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554333},
abstract = {
    <p>SFLKit is an out-of-the-box library and tool for statistical fault localization. Statistical fault localization aims at detecting execution features that correlate with failures, such as whether individual lines are part of the execution.</p>

},
keywords = {spectrum-based fault localization, statistical debugging, statistical fault localization}
}

@software{10.1145/3554334,
author = {Zheng, Ye and Liu, Jiaxiang and Shi, Xiaomu},
title = {Source code and reproduction files for article “MpBP: Verifying Robustness of Neural Networks with Multi-path Bound Propagation”},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554334},
abstract = {
    <p>MpBP (Multipath Bound Propagaiton) extends classical bound propagation methods with multiple propagation paths. Multiple propagation paths provides multiple pairs of bounds for a DNN. MpBP is based on the widely-used PyTorch machine learning framework, hence providing efficient parallel verification on GPUs.</p>
<p>A video demonstration is available at https://youtu.be/3KyPMuPpfR8.</p>

},
keywords = {bound propagation, formal verification, neural networks}
}

@software{10.1145/3554335,
author = {Orvalho, Pedro and Janota, Mikol\'{a}\v{s} and Manquinho, Vasco},
title = {MultIPAs: Applying Program Transformations to Introductory Programming Assignments for Data Augmentation},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554335},
abstract = {
    <p>MultIPAs is a program transformation tool that can augment IPAs benchmarks by: (1) applying six syntactic mutations that conserve the program’s semantics and (2) applying three semantic mutilations that introduce faults in the IPAs.</p>

},
keywords = {Automated Program Repair, Data Augmentation, Introductory Programming Assignments, MOOCs, Program Transformation}
}

@software{10.1145/3554336,
author = {Steinh\"{o}fel, Dominic and Zeller, Andreas},
title = {Replication Package for "Input Invariants"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554336},
abstract = {
    <p>This artifact describes how to</p>
<ul>
<li><em>obtain</em> the ISLa and ISLearn tools for the paper “Input Invariants” (ESEC/FSE’22),</li>
<li><em>reproduce</em> the results reported in the paper, and</li>
<li><em>apply</em> the tools to your examples.</li>
</ul>
<p>We describe these aspects separately for the ISLa and ISLearn systems. Both tools are referred to with URLs and bundled in the artifact file.</p>

},
keywords = {constraint mining, fuzzing, grammars, specification language}
}

@software{10.5281/zenodo.6369874,
author = {Le-Cong, Thanh and Kang, Hong Jin and Nguyen, Truong Giang and Haryono, Stefanus Agus and Lo, David and Le, Xuan-Bach D. and Huynh, Quyet Thang},
title = {Dataset for "AutoPruner: Transformer-based Call Graph Pruning"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6369874},
abstract = {
    <p>This repository contains data for research paper “AutoPruner: Transformer-based Call Graph Pruning”, which is published at ESEC/FSE 2022</p>
<p>The structure of our data’s repository is as follows:</p>
<ul>
<li>dl_dataset: contains our processed dataset for AutoPruner;</li>
<li>gnn_dataset: contains our processed dataset for GNN benchmark;</li>
<li>gnn_model: contains our trained models for GNN benchmarks;</li>
<li>info_data: contains the lists of training and testing programs;</li>
<li>model: contains our trained models for AutoPruner;</li>
<li>npe_result: contains the results of manual evaluation for Null-pointer analysis;</li>
<li>processed_data: contains extracted source code for methods in programs in <a href="https://zenodo.org/record/5806537">cgPruner’s dataset</a></li>
<li>raw_data: contains the static call graphs generated by static analysis tools from <a href="http://web.cs.ucla.edu/~akshayutture/papers/icse22_firstPaper_preprint.pdf">cgPruner</a></li>
</ul>

},
keywords = {Call Graph Pruning, Pretrained Language Model, Static Analysis, Transformer}
}

@software{10.5281/zenodo.6668462,
author = {Yusuf, Imam Nur Bani and Jamal, Diyanah Binte Abdul and Jiang, Lingxiao and Lo, David},
title = {Model Checkpoints for RecipeGen++},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6668462},
abstract = {
    <p>This artifact contains model checkpoints to replicate the results that are attached in the paper.</p>

},
keywords = {Deep Learning, IFTTT, TAP, Trigger Action Programs}
}

@software{10.5281/zenodo.6906415,
author = {Park, Jihyeok and An, Seungmin and Ryu, Sukyoung},
title = {JSAVER: JavaScript Static Analyzer via ECMAScript Representation},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6906415},
abstract = {
    <p>JSAVER is a JavaScript Static Analyzer via ECMAScript Representation. It is the first tool that automatically derives JavaScript static analyzers from language specifications using an interpreter-based approach called meta-level static analysis instead of a traditional compiler-based approach.</p>
<p>This artifact extends JISET to extract JavaScript definitional interpreters written in Intermediate Representations for ECMAScript Specifications (IRES) from diverse versions of ECMA-262.</p>

},
keywords = {definitional interpreter, JavaScript, meta-level static analysis}
}

@software{10.5281/zenodo.6941292,
author = {Martin-Lopez, Alberto and Segura, Sergio and Ruiz-Cort\'{e}s, Antonio},
title = {[Supplementary material] Online Testing of RESTful APIs: Promises and Challenges},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6941292},
abstract = {
    <p>This is the artifact for the paper entitled “Online Testing of RESTful APIs: Promises and Challenges”. This artifact comprises two main resources: 1) a ready-to-use testing ecosystem consisting of a multi-bot architecture for online testing of RESTful APIs; and 2) the dataset of test cases generated in our experiments. In addition, we provide instructions on how to use the testing ecosystem, how to replicate the results reported in the paper, and how our work could serve as the basis for multiple future research opportunities in varied scenarios.</p>

},
keywords = {black-box testing, bot, online testing, REST, web API}
}

@software{10.5281/zenodo.6955909,
author = {Li, Zeyan and Zhao, Nengwen and Li, Mingjie and Lu, Xianglin and Wang, Lixin and Chang, Dongdong and Nie, Xiaohui and Cao, Li and Zhang, Wenchi and Sui, Kaixin and Wang, Yanhua and Du, Xu and Duan, Guoqiang and Pei, Dan},
title = {Replicate Package for "Actionable and Interpretable Fault Localization for Recurring Failures in Online Service Systems"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6955909},
abstract = {
    <p>We provide an artifact for our ESEC/FSE 2022 Research Track paper, “Actionable and Interpretable Fault Localization for Recurring Failures in Online Service Systems”. In this paper, we propose an actionable and interpretable fault localization approach, named DejaVu. This artifact includes 1) the four datasets used in the paper, 2) the implementation of DejaVu and the baselines, and 3) the scripts used to build the Train-Ticket benchmark and collect monitoring data for dataset D. The artifact is made public on GitHub (https://github.com/NetManAIOps/DejaVu).</p>

},
keywords = {fault localization, graph neural network, online service system, recurring failures}
}

@software{10.5281/zenodo.6958312,
author = {Palma, Marco Edoardo and Salza, Pasquale and Gall, Harald C.},
title = {On-the-Fly Syntax Highlighting Using Neural Networks - Replication Package (Source Code)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6958312},
abstract = {
    <p>This archive includes the source code to replicate the study for the paper On-the-Fly Syntax Highlighting Using Neural Networks.</p>
<p>The data to replicate the study can be found at: https://doi.org/10.5281/zenodo.6949491</p>

},
keywords = {deep learning, neural networks, regular expressions, syntax highlighting}
}

@software{10.5281/zenodo.6969369,
author = {Braz, Larissa and Bacchelli, Alberto},
title = {Artifacts Package for Software Security during Modern Code Review: The Developer's Perspective},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6969369},
abstract = {
    <p>Artifacts Package of the accepted FSE 22 paper: “Software Security during Modern Code Review: The Developer’s Perspective”.</p>
<p>Our artifact package contains the following material:</p>
<ol type="1">
<li>ethics: the ethics proposal’s form and detailed documentation, and the Human Subjects Committee approval.</li>
<li>questions: the questions we asked during the interviews and the complete survey questionnaire.</li>
<li>scripts: the R script used in our analysis and to automatically generate latex commands for our full paper.</li>
<li>results: the raw transcripts of the interviews and card sorting results. This folder also contains the complete survey results and the results excluding the data of participants who did not agree to share their data in a public research dataset.</li>
</ol>

},
keywords = {code review, Software security engineering}
}

@software{10.5281/zenodo.6970062,
author = {Ibrahimzada, Ali Reza and Varli, Yigit and Tekinoglu, Dilara and Jabbarvand, Reyhaneh},
title = {Reproduction Package for Article "Perfect Is the Enemy of Test Oracle"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6970062},
abstract = {
    <p>Artifact repository for the paper Perfect Is the Enemy of Test Oracle, accepted at ESEC/FSE 2022. Authors are Ali Reza Ibrahimzada, Yi\u{g}it Varl\i{}, Dilara Tekino\u{g}lu, and Reyhaneh Jabbarvand.</p>
<p>The artifact mainly consists of Python scripts which were used for automating dataset generation, mutation testing, and deep learning model implementation. We have split each distinct component of SEER into a separate directory in this repository. Please refer to each directory for a detailed explanation of the component.</p>
<p>Plesae refer to README file on GitHub repository (https://github.com/Intelligent-CAT-Lab/SEER) for more details.</p>

},
keywords = {Deep Learning, Software Testing, Test Automation, Test Oracle}
}

@software{10.5281/zenodo.6973860,
author = {Wang, Jue and Jiang, Yanyan and Su, Ting and Li, Shaohua and Xu, Chang and Lu, Jian and Su, Zhendong},
title = {Artifact `Detecting Non-crashing Functional Bugs in Android Apps via Deep-State Differential Analysis'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6973860},
abstract = {
    <p>An artifact of our prototype tool Odin, which is an implementation of our proposed deep-state differential analysis algorithm that brings the classical ``bugs as deviant behaviors’’ oracles to Android apps as a generic automatic test oracle for detecting non-crashing functional bugs.</p>

},
keywords = {mobile apps, non-crashing functional bugs, Software testing}
}

@software{10.5281/zenodo.6975558,
author = {Dyer, Robert and Chauhan, Jigyasa},
title = {Replication package for "An Exploratory Study on the Predominant Programming Paradigms in Python Code"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6975558},
abstract = {
    <p>This dataset includes scripts and data files used to generate all analysis and results from the paper. A README.md file is included for details on using the scripts - though all of the data the scripts generate should already be cached and none of the scripts actually need run.</p>
<p>It also includes a spreadsheet containing the human judgements from Table 4 of the paper.</p>
<p>Always current source for the scripts is available on GitHub: https://github.com/psybers/python-paradigms</p>

},
keywords = {empirical study, programming paradigms, Python}
}

@software{10.5281/zenodo.6977413,
author = {Song, Yang and Mahmud, Junayed and Zhou, Ying and Chaparro, Oscar and Moran, Kevin and Marcus, Andrian and Poshyvanyk, Denys},
title = {A Replication Package for "Toward Interactive Bug Reporting for (Android App) End-Users"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6977413},
abstract = {
    <p>This is the replication package for our ESEC/ FSE’22 paper: “Toward Interactive Bug Reporting for (Android App) End-Users”. The package provides data, source code, and documentation that aims to enable verification/validation of our work and future research on the topic of bug reporting systems.</p>

},
keywords = {Android Apps, Bug Reporting, Task-Oriented Chatbots}
}

@software{10.5281/zenodo.6977595,
author = {Chakraborty, Saikat and Ahmed, Toufique and Ding, Yangruibo and Devanbu, Premkumar T. and Ray, Baishakhi},
title = {Pre-Processing and Pre-Training code for "NatGen: NatGen: Generative Pre-training by “Naturalizing” Source Code"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6977595},
abstract = {
    <p>This artifact demonstrates the pre-processing and training procedure for NatGen’s pre-training. For fine-tuning, we used CodeT5’s scripts.</p>

},
keywords = {Neural Network, Source Code Pre-training, Source Code Transformer}
}

@software{10.5281/zenodo.7033365,
author = {OBrien, David and Biswas, Sumon and Imtiaz, Sayem and Abdalkareem, Rabe and Shihab, Emad and Rajan, Hridesh},
title = {Artifact for the ESEC/FSE'22 Paper: "23 Shades of Self-Admitted Technical Debt: An Empirical Study on Machine Learning Software"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7033365},
abstract = {
    <p>This artifact contains the code, data, and additional information for reproducing the results found in the ESEC/FSE 2022 paper entitled “23 Shades of Self-Admitted Technical Debt: An Empirical Study on Machine Learning Software”. This study analyzes the occurrence of self-admitted technical debt (SATD) in a dataset consisting of 2,641 open-source machine learning repositories. The artifact contains the Boa scripts ran to acquire the comment data, as well as the Python scripts which were used to filter the dataset into 68,820 SATD comments. During the dataset creation, a sample was taken for two authors to independently label before settling disagreements in discussion of a moderator. The authors’ labels and the agreed upon labels are included within the artifact.</p>

},
keywords = {data science, machine learning, open-source, technical debt}
}

@software{10.5281/zenodo.7036047,
author = {Kim, Seulbae and Kim, Taesoo},
title = {Artifact of "RoboFuzz: Fuzzing Robotic Systems over Robot Operating System (ROS) for Finding Correctness Bugs"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7036047},
abstract = {
    <p>RoboFuzz is a fuzzing framework for testing Robot Operating System 2 (ROS 2), and robotic systems that are built using ROS 2. Any developer-defined prop- erties relating to the correctness of the robotic system under test, e.g., conformance to specification, can be tested using RoboFuzz.</p>
<p>The artifact (i.e., a docker image and a repository) contains the following: 1. Source code of RoboFuzz 2. Pre-compiled target sytstems and their code 3. Utilities for running experiments 4. Instructions on installing and executing RoboFuzz 5. Description of detected bugs and the links to the original bug reports</p>
<p>The six targets we tested with RoboFuzz are: * Two from the internal layers of ROS2 foxy: 1. Type system (ROSIDL) 2. ROS Client Library APIs (rclpy and rclcpp) * Four ROS-based robotic systems and libraries: 3. Turtlesim (apt package: ros-foxy-turtlesim) 4. Move It 2 + PANDA manipualtor 5. Turtlebot3 Burger (version foxy) 6. PX4 quadcopter (firmware v1.12 + fmu-v5)</p>
<p>Running RoboFuzz with the in-house oracles we built for each target, we discovered 30 new correctness bugs. We reported all bugs and 25 are acknowledged and 6 have been fixed so far.</p>

},
keywords = {Correctness bugs, Robot Operating System 2 (ROS 2), Semantic feedback-driven fuzzing}
}

@software{10.5281/zenodo.7036218,
author = {Zhao, Yixue and Talebipour, Saghar and Baral, Kesina and Park, Hyojae and Yee, Leon and Khan, Safwat Ali and Brun, Yuriy and Medvidovi\'{c}, Nenad and Moran, Kevin},
title = {Artifacts for "AVGUST: Automating Usage-Based Test Generation from Videos of App Executions"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7036218},
abstract = {
    <p>This artifact contains code and data related to the paper “Avgust: Automating Usage-Based Test Generation from Videos of App Executions”. Avgust is a human-in-the-loop technique that assists developers in generating usage-based tests for mobile apps by learning from videos of app usage. This artifact is made public to foster future research in automated testing of mobile applications and app comprehension in general. This repository contains the main source code of Avgust, processed video frames, screenshots, cropped widgets, and all the intermediate results such as IR models and generated tests.</p>

},
keywords = {AI/ML, Mobile Application, Test Generation, UI Understanding}
}

@software{10.5281/zenodo.7036747,
author = {Luo, Chuan and Zhao, Qiyuan and Cai, Shaowei and Zhang, Hongyu and Hu, Chunming},
title = {Artifact for ESEC/FSE 2022 Article `SamplingCA: Effective and Efficient Sampling-based Pairwise Testing for Highly Configurable Software Systems'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7036747},
abstract = {
    <p>Combinatorial interaction testing (CIT) is a popular testing methodology for testing interactions of options of highly configurable systems. In the context of CIT, covering arrays are the test suites that can cover all such interactions, possibly under certain constraints. Particularly, pairwise covering arrays (PCAs) are widely employed, since they can achieve a good balance between testing costs and fault detection capability.</p>
<p>SamplingCA is a state-of-the-art algorithm for generating small-sized PCAs efficiently. In our implementation of SamplingCA, the input is a system under test (SUT) modeled as a Boolean formula in CNF. It outputs a PCA of the given SUT, where each line represents a valid configuration.</p>

},
keywords = {Covering Array, Pairwise Testing, Sampling, Satisfiability}
}

@software{10.5281/zenodo.7037946,
author = {Eghbali, Aryaz and Pradel, Michael},
title = {DynaPyt},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7037946},
abstract = {
    <p>Dynamic analysis framework for Python.</p>

},
keywords = {dynamic analysis, python}
}

@software{10.5281/zenodo.7047061,
author = {Riley, Daniel and Fedyukovich, Grigory},
title = {Artifact for Multi-Phase Invariant Synthesis},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7047061},
abstract = {
    <p>This is an artifact for the FSE’22 paper “Multi-Phase Invariant Synthesis”.</p>
<p>The purpose of the artifact is to provide an environment to reproduce the results presented in the paper. This is not a full documentation of the <code>ImplCheck</code> method within <code>FreqHorn</code>. It is meant to allow for an individual to run the tools used in the paper’s experiments for themselves.</p>

},
keywords = {automated safety verification, inductive invariant synthesis, model based projection, satisfiability modulo theories}
}

@software{10.5281/zenodo.7048525,
author = {Nong, Yu and Ou, Yuzhe and Pradel, Michael and Chen, Feng and Cai, Haipeng},
title = {Reproduction Package for Article "Generating Realistic Vulnerabilities via Neural Code Editing: An Empirical Study"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7048525},
abstract = {
    <p>Using a commonly used synthetic dataset and one real-world dataset, we investigate the potential and gaps of three state-of-the-art neural code editors (Graph2Edit, Hoppity, SequenceR) for DL-based realistic vulnerability data generation, and two state-of-the-art vulnerability detectors (Devign, ReVeal) to evaluate the usefulness of the generated realistic vulnerability data in improving the effectiveness of such detectors.</p>

},
keywords = {benchmarking, data augmentation, data generation, datasets, deep learning, software vulnerability, vulnerability detection}
}

@software{10.5281/zenodo.7060209,
author = {Cao, Junming and Chen, Bihuan and Sun, Chao and Hu, Longjie and Wu, Shuaihong and Peng, Xin},
title = {Reproduction Package for Article "Understanding Performance Problems in Deep Learning Systems"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7060209},
abstract = {
    <p>In this document, we provide a detailed experiment reproduction of the paper. Each case has an independent directory, in which the Readme.md file that describes the environment required to run, the root cause of the bug, and how to reproduce the bug. It also provides a comparison of the running results of the two versions of the code on our machine. These results can show that the repaired code has better performance. DeepPerf is a rule-based static code checker capable of detecting Performance bugs in DL systems. Also, we provide code to test this tool.</p>

},
keywords = {Deep Learning, Deep Learning Bugs, Performance Problems}
}

@software{10.5281/zenodo.7080252,
author = {Chen, Haoxian and Whitters, Gerald and Amiri, Mohammad Javad and Wang, Yuepeng and Loo, Boon Thau},
title = {Reproduction package for "Declarative Smart Contracts"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080252},
abstract = {
    <p>This artifact contains two docker images: (1) the main tool developed in this paper, a compiler that translates Declarative smart contracts into Solidity programs. (2) software and scripts for reproducing experiment results in the paper.</p>

},
keywords = {declarative programming, domain-specific language, Smart contracts}
}

@software{10.5281/zenodo.7080271,
author = {Fu, Michael and Tantithamthavorn, Chakkrit and Le, Trung and Nguyen, Van and Phung, Dinh},
title = {Reproduction Package for VulRepair: A T5-Based Automated Software Vulnerability Repair},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080271},
abstract = {
    <p>The replication package of the VulRepair paper supports future research to reproduce the experiment results in the paper.</p>

},
keywords = {Automated Vulnerability Repair, Software Vulnerability Repair}
}

@software{10.5281/zenodo.7080276,
author = {Jodavi, Mehran and Tsantalis, Nikolaos},
title = {CodeTracker},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080276},
abstract = {
    <p>CodeTracker is a refactoring-aware tool that can generate the commit change history for method and variable declarations in a Java project with a very high accuracy. https://github.com/jodavimehran/code-tracker https://search.maven.org/artifact/io.github.jodavimehran/code-tracker</p>

},
keywords = {commit change history, refactoring-aware source code tracking}
}

@software{10.5281/zenodo.7080369,
author = {Qin, Qi and JiYang, JulianAndres and Song, Fu and Chen, Taolue and Xing, Xinyu},
title = {DeJITLeak Tool Proposed in Article "DeJITLeak: Eliminating JIT-Induced Timing Side-Channel Leaks"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7080369},
abstract = {
    <p>This artifact contains the two main components of the DeJITLeak tool, the Joana-based type inference tool and the patched JVM for fine-grained JIT control. It also includes the dataset and evaluation results and all the scripts used in the evaluation.</p>

},
keywords = {detection, formal semantics, JIT compilation, mitigation, timing side-channel, type inference}
}

@software{10.5281/zenodo.7081378,
author = {Silva, Pedro and Oliveira, Jos\'{e} N. and Macedo, Nuno and Cunha, Alcino},
title = {QAlloy Artifact, ESEC/FSE 2022},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7081378},
abstract = {
    <p>This artifact complements the paper Quantitative relational modelling with QAlloy submitted to the ESEC/FSE 2022 conference. It provides the necessary tools and instructions to run QAlloy and apply it to the examples discussed throughout the paper. Moreover, the benchmarking models and data are also provided, so that its results can be reproduced.</p>

},
keywords = {Alloy, linear algebra, model finding, quantitative modelling, relational specifications, SMT}
}

@software{10.5281/zenodo.7082252,
author = {Di Grazia, Luca and Pradel, Michael},
title = {Reproduction Package for Article 'The Evolution of Type Annotations in Python: An Empirical Study'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7082252},
abstract = {
    <p>The artifact contains script and data to reproduce all the results of the paper. Moreover, there are instructions to use the source code with a different dataset. The file README.md contains all the information to run the artifact.</p>

},
keywords = {artifact, empirical study, Python, Type annotations, type errors}
}

@software{10.5281/zenodo.7082407,
author = {Winter, Stefan and Timperley, Christopher S. and Hermann, Ben and Cito, J\"{u}rgen and Bell, Jonathan and Hilton, Michael and Beyer, Dirk},
title = {Reproduction Package (Docker container) for the FSE 2022 Article `A Retrospective Study of one Decade of Artifact Evaluations`},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7082407},
abstract = {
    <p>This is the artifact accompanying our study of artifact evaluations at SE/PL conferences and their effects, accepted for presentation at the ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE) 2022. For ease of artifact evaluation and usage, we ship our artifact as a Docker container, which comprises our datasets, the tools we built to collect those datasets, and the scripts used to obtain the results presented in the paper. It also contains the Dockerfile to create the submitted image in order to make the software dependencies for our artifact explicit.</p>

},
keywords = {Artifact Evaluation, Reproducibility, Research Artifacts, Software Engineering}
}

@software{10.5281/zenodo.7083445,
author = {Alon, Yoav and David, Cristina},
title = {Reproduction Package for Article: "Using Graph Neural Networks for Program Termination"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7083445},
abstract = {
    <p>Classifier for program termination based on Graph Attention layers. Published in ESEC/FSE 2022 - The 30th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering. The repository contains a sample dataset that can be used to train a classifier for program termination based on the abstract syntax tree representation as described in our paper. The repository can be tested using a python virtual environment. All necessary instruction are contained in the readme and install files. The central file is train.py that performs training of a model according to a dataset with sample programs (where programs in folders with folder name 0 represent non-terminating programs and programs in folders with folder name 1 represent terminating programs). Utils.py contains code that transforms programs into their respective abstract syntax tree representation. The final models are saved in the models folder. Essentially, the runs folder create on runtime will contain all tensorboard event files that enable evaluation of all training and test metrics.</p>

},
keywords = {Graph Attention Networks, Graph Neural Networks, Program Nontermination, Program Termination}
}

@software{10.5281/zenodo.7088367,
author = {Pai, Rekha and Uppar, Abhishek and Shenoy, Akshatha and Kushwaha, Pranshul and D'Souza, Deepak},
title = {The tool AndRacer for Static Executes-Before Analysis for Event Driven Programs},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7088367},
abstract = {
    <p>The tool AndRacer presents an implementation of sound, efficient, and effective static analysis technique to compute executes-before pairs of tasks for a general class of event driven programs. The executes-before information to identify disjoint-blocks in Android applications and hence use them for data race detection of the applications. Furthermore, we check for the shared resources protected by disjoint blocks due to locks and hence decide on the possible Redundant Synchronisation Blocks.</p>
<p>The artifact is submitted as an Installation Package. The Installation Package is a Virtual Machine for Virtual Box. Details on installation and usability of the artifact are given in repo hosted at https://zenodo.org/record/7088367#.Yy7WDi0RpQI</p>

},
keywords = {Android applications., asynchronous calls, event driven programming, executes-before, race detection, static analysis}
}

@software{10.5281/zenodo.7088613,
author = {Tomy, Chris and Wang, Tingmao and Barr, Earl T. and Mechtaev, Sergey},
title = {Reproduction package for the article "Modus: A Datalog Dialect for Building Container Images"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7088613},
abstract = {
    <p>This software is an artifact used to reproduce the results of our paper. Below is the abstract of our paper.</p>
<p>Containers help share and deploy software by packaging it with all its dependencies. Tools, like Docker or Kubernetes, spawn containers from images as specified by a build system’s language, such as Dockerfile. A build system takes many parameters to build an image, including OS and application versions. These build parameters can interact: setting one can restrict another. Dockerfile lacks support for reifying and constraining these interactions, thus forcing developers to write a build script per workflow. As a result, developers have resorted to creating ad hoc solutions such as templates or domain-specific frameworks that harm performance and complicate maintenance because they are verbose and mix languages.</p>
<p>To address this problem, we introduce Modus, a Datalog dialect for building container images. Modus’ key insight is that container definitions naturally map to proof trees of Horn clauses. In these trees, container configurations correspond to logical facts, build instructions correspond to logic rules, and the build tree is computed as the minimal proof of the Datalog query specifying the target image. Modus relies on Datalog’s expressivity to specify complex workflows with concision and facilitate automatic parallelisation.</p>

},
keywords = {Build system, Containers, Datalog}
}

@software{10.5281/zenodo.7110095,
author = {Bittner, Paul Maximilian and Tinnes, Christof and Schulthei\ss{}, Alexander and Viegener, S\"{o}ren and Kehrer, Timo and Th\"{u}m, Thomas},
title = {Appendix and Replication Package for Article: Classifying Edits to Variability in Source Code},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7110095},
abstract = {
    <p>This replication package consists of four parts:</p>
<ol type="1">
<li><strong>DiffDetective</strong>: For our validation, we built <em>DiffDetective</em>, a java library and command-line tool to classify edits to variability in git histories of preprocessor-based software product lines.</li>
<li><strong>Appendix</strong>: The appendix of our paper is given in PDF format in the file <a href="https://github.com/VariantSync/DiffDetective/raw/esecfse22/appendix.pdf">appendix.pdf</a>.</li>
<li><strong>Haskell Formalization</strong>: We provide an extended formalization in the Haskell programming language as described in our appendix. Its implementation can be found in the Haskell project in the proofs directory.</li>
<li><strong>Dataset Overview</strong>: We provide an overview of the 44 inspected datasets with updated links to their repositories in the file <a href="https://github.com/VariantSync/DiffDetective/blob/esecfse22/docs/datasets.md">docs/datasets.md</a>.</li>
</ol>

},
keywords = {feature traceability, mining version histories, software evolution, software product lines, software variability}
}

@software{10.5281/zenodo.7110215,
author = {Yeow, Matthew Yit Hang and Chong, Chun Yong and Lim, Mei Kuan},
title = {Data, Results and Code for Article 'On the Application of Machine Learning Models to Assess and Predict Software Reusability'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7110215},
abstract = {
    <p>This is the dataset, results and notebook for the workshop paper submission into the 6th edition of the International Workshop on Machine Learning Techniques for Software Quality Evolution (MaLTeSQuE 2022) which is held at Singapore, collocated with the ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE 2022).</p>

},
keywords = {Machine Learning, Software Metrics, Software Reusability}
}

@software{10.5281/zenodo.7111136,
author = {Dong, Liming and Zhang, He and Liu, Wei and Weng, Zhiluo and Kuang, Hongyu},
title = {Reproduction Package for "Semi-supervised Pre-processing for Learning-Based Traceability Framework on Real-World Software Projects"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7111136},
abstract = {
    <p>Materials provided include public OSS datasets, source code, and experiment results for the FSE 2022 paper: “Semi-supervised Pre-processing for Learning-Based Traceability Framework on Real-World Software Projects”</p>

},
keywords = {Data Imbalance, Data Sparsity, Industry Practice, Learning-based Model, Semi-supervised Learning, Software Traceability}
}

@software{10.6084/m9.figshare.16528521.v1,
author = {Li, Wen and Li, Li and Cai, Haipeng},
title = {Reproduction Package for Article "On the Vulnerability Proneness of Multilingual Code"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.16528521.v1},
abstract = {
    <p>The artifact contains the tool–PolyFax and dataset for the paper “On the Vulnerability Proneness of Multilingual Code”. PolyFax can be applied for repository grabbing on GitHub, vulnerability-fixing commit classification and language interfacing mechanism identification.</p>

},
keywords = {language interface, multi-language, program analysis, vulnerability proneness}
}

@software{10.6084/m9.figshare.19354547.v1,
author = {Al Debeyan, Fahad and Hall, Tracy and Bowes, David},
title = {Replication Package for article "Improving the Performance of Code Vulnerability Prediction using Abstract Syntax Tree Information"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.19354547.v1},
abstract = {
    <p>The replication package includes the datasets as well as the knowledge flow files for our WEKA models</p>

},
keywords = {Vulnerability Prediction, Weka}
}

@software{10.6084/m9.figshare.20199986.v1,
author = {Bludau, Peter and Pretschner, Alexander},
title = {Feature sets in just-in-time defect prediction: An empirical evaluation},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.20199986.v1},
abstract = {
    <p>This archive was created for evaluation purposes of the work described in detail in “Feature sets in just-in-time defect prediction: An empirical evaluation” submitted to PROMISE 2022. It contains all data sets and evaluation results created and used in the study.</p>

},
keywords = {Empirical study, JIT defect prediction, Machine learning}
}

@software{10.6084/m9.figshare.20448573.v1,
author = {Oh, Wonseok and Oh, Hakjoo},
title = {A Replication Package for PyTER: Python TypeError Repair by Type-Aware Generation},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.20448573.v1},
abstract = {
    <p>It can reproduce the result of PyTER’s main table using Docker container provided. In Docker container, our PyTER system and TypeBugs benchmark are provided. Moreover, the guide to run arbitrary test cases is also served. The detailed information is written on README in our artifact.</p>

},
keywords = {Debugging, Program Analysis, Program Repair}
}

@software{10.6084/m9.figshare.20486556.v1,
author = {Li, Haofeng and Lu, Jie and Meng, Haining and Cao, Liqing and Huang, Yongheng and Li, Lian and Gao, Lin},
title = {Generic Sensitivity: Customizing Context-Sensitive Pointer Analysis for Generics},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.20486556.v1},
abstract = {
    <p>Generic programming has been extensively used in object-oriented programs such as Java. However, existing context-sensitive pointer analyses perform poorly in analyzing generics. This paper introduces generic sensitivity, a new context customization scheme targeting generics. We design our context customization scheme in such a way that generic instantiation sites, i.e., locations instantiating generic classes/methods with concrete types, are always preserved as key context elements. This is realized by augmenting contexts with a type variable lookup map, which is efficiently updated during the analysis in a context-sensitive manner.</p>
<p>We have implemented different variants of generic-sensitive analysis in Wala and experimental results show that the generic customization scheme can significantly improve performance and precision of context-sensitive pointer analyses. For instance, generic context customization significantly improves precision of 1-object-sensitive analysis, with an average speedup of 1.8 times. In addition, generic context customization enables a 1-object-sensitive analysis to achieve overall better precision than a 2-object-sensitive analysis, with an averagely speed up of 12.6 times (62 times for chart).</p>

},
keywords = {context sensitivity, generic programming, pointer analysis}
}

@software{10.6084/m9.figshare.20493042.v4,
author = {Pandya, Prahar and Tiwari, Saurabh},
title = {Dataset for CORMS: &nbsp;A GitHub and Gerrit based Hybrid Code Reviewer Recommendation Approach for Modern Code Review},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.20493042.v4},
abstract = {
    <p>The artifact contains 20 code-review datasets used for evaluation of CORMS and RevFinder along with 14 other code-review datasets which can be used for the further testing purpose.</p>

},
keywords = {Code Reviews, Modern Code Review (MCR), Reviewer Recommendation}
}

@software{10.6084/m9.figshare.20748235.v1,
author = {Fregnan, Enrico and Braz, Larissa and D'Ambros, Marco and \c{C}al\i{}kl\i{}, G\"{u}l and Bacchelli, Alberto},
title = {Artefact Package - First come first served: the impact of file position on code review},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.20748235.v1},
abstract = {
    <p>Artifacts Package of the accepted FSE 22 paper: “First come first served: the impact of file position on code review”.</p>
<p>The “pr_data.zip” file contains the Json data of the mined Pull Requests. Given its size, we separated it from the rest of the replication package (contained in the fse22-fregnan.zip file).</p>
<p>Our artifact package contains the following material:</p>
<ul>
<li>Mining script. The script used to mine PRs from online repositories. The script is available in the folder ‘data-retrieval’.</li>
<li>Pull Requests dataset. The dataset of 219,476 PRs from 138 java-based open-source projects considered in our investigation. Repeating the mining process might lead to different results if, for instance, the projects have been updated. The dataset is contained in the pr_data.zip archive.</li>
<li>PRs analysis scripts. The Java script used to extract the metrics considered in our analysis from the PRs dataset (contained in the ‘metrics’ folder) and the R script used for the analysis of the result (in the ‘PR_analysis_script’ folder).</li>
<li>Experiment tool. The tool used for the online experiment. We extended CRExperiment, a publicly available tool to perform code review experiments. The tool is available in the folder ‘tool’. The subfolder ‘resources’ contains the object code snippets used in the experiment.</li>
<li>Experiment results and analysis script. The results from the valid participants are in the ‘validParticipantsPublic.csv’ file. Among the original 106 valid participants, four did not give their consent for their data to be shared publicly. For this reason, the provided dataset only contains the results of 102 participants. This leads to slightly different results than the ones in the paper but our findings are preserved.</li>
<li>The ‘results_analysis.R’ script contains the code used to analyze the collected experiment data.</li>
<li>Ethics authorization. The experiment approval by the Human Subjects Committee of the University of Zurich, Switzerland.</li>
</ul>
<p>See README.md for more information.</p>

},
keywords = {Code review, Empirical Software Engineering, Pull requests}
}

@software{10.6084/m9.figshare.c.6137217.v2,
author = {Tao, Guanhong and Sun, Weisong and Han, Tingxu and Fang, Chunrong and Zhang, Xiangyu},
title = {A Replication Package for Article 'RULER: Discriminative and Iterative Adversarial Training for Deep Neural Network Fairness'},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.c.6137217.v2},
abstract = {
    <p>The full package contains all the details needed to replicate the results as we claimed in our paper. In the package, the README.md file describes the structure of the package and provides basic information of the content of this package. The software and hardware requirements are described in the requirements.txt and REQUIREMENTS.md files, respectively.</p>

},
keywords = {Adversarial Training, Deep Neural Network, Fairness}
}

@software{10.1145/3550218,
author = {Kelly, Terence},
title = {Source code for the article "Drill Bits 04: Schrodingers Code"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550218},
abstract = {
    <p>The example programs, Roman numerals I, II, III, and IV, each has a shell script that shows how I compiled and ran them; sample output is listed below.  The code has been compiled and tested with GCC 10.2.1 and Clang 11.0.0.  In my experience the .c source files compile as both C17 and C++17 and other relatively modern dialects.</p>
}
}

@software{10.1145/3550219,
author = {Kelly, Terence},
title = {Source code for Drill Bits 6 article "Steampunk Machine Learning"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550219},
abstract = {
    <p>Script "run.csh" generates the data sets discussed in my column and runs R to estimate regression parameters for a linear model using two techniques, least-squares and least absolute residuals.  Read this script to understand how the sample data were created and analyzed with R.  File "cmds.R" contains the actual R commands.</p>
}
}

@software{10.1145/3550220,
author = {Kelly, Terence},
title = {Source code for Drill Bits 7 article "Persistent Memory Allocation"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550220},
abstract = {
    <p>Most of the test programs bundled with pma are primarily intended to exercise pma functionality for my benefit; they're not optimized for tutorial value.  However they illustrate basic usage and you might learn a trick or two by studying them.  For example, test5 shows how to use the root pointer; test6 shows how to make pma fall back on the conventional ephemeral memory allocator (standard malloc); and test7 shows an easy way to create a persistent C++ STL container by sliding a pma persistent heap beneath an STL <map>.  The tests also show how to create an uninitialized backing file for a persistent heap using the "truncate" command-line utility.  Some tests run under Valgrind. Tests come in .c/.csh file pairs; the scripts run under the C Shell (csh).  My test scripts might not be perfectly compatible with every OS and compiler.  Edit as necessary.</map></p>
}
}

@software{10.1145/3550221,
author = {Kelly, Terence},
title = {Source code for pmgawk in Drill Bits 7 article "Persistent Memory Allocation"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3550221},
abstract = {
    <p>To use persistent gawk, first create for the persistent heap a sparse file whose size is a multiple of the system page size. The media beneath the filesystem containing the backing file are unconstrained, i.e., pma supports persistent memory programming  on conventional hardware as well as NVM.</p>
}
}

@software{10.1145/3554338,
author = {Ishio, Chiaki and Asai, Kenichi},
title = {Supplementary material for the paper "Type System for Four Delimited Control Operators"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554338},
abstract = {
    <p>This supplementary material formalizes the underlying CPS interpreter and the type system proposed in the paper “Type System for Four Delimited Control Operators” submitted in GPCE’22. It also includes the formalization the relationship between the type systems of existing studies and ours.</p>

},
keywords = {continuation, delimited control operators, type system}
}

@software{10.5281/zenodo.7183177,
author = {Verano Merino, Mauricio and van Wijk, Koen},
title = {Blocklybench},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7183177},
abstract = {
    <p>We present Blocklybench, a meta-block-based environment for describing block-based languages for both programming and semi-structured data languages; it allows developers to express the specific elements of both types of block-based languages using blocks. We present three case studies created with Blocklybench to evaluate the proposed solution. Our results show that the block meta-environment allows developers to describe block-based specific aspects of the language constructs such as layout and color.</p>

},
keywords = {block-based environments, Blockly, data languages, IDEs, Projectional editors, visual languages}
}

@software{10.5281/zenodo.7188801,
author = {Chen, Zilin and Rizkallah, Christine and O'Connor, Liam and Susarla, Partha and Klein, Gerwin and Heiser, Gernot and Keller, Gabriele},
title = {Property-Based Testing: Climbing the Stairway to Verification (Artefact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7188801},
abstract = {
    <p>In the artefact, we provide the source code of the Cogent compiler that has been extended with the property-based testing infrastructure, and the source code of the examples studied in the paper.</p>

},
keywords = {formal verification, functional programming, QuickCheck, systems programming}
}

@software{10.5281/zenodo.7189905,
author = {Smits, Jeff and Hartman, Toine and Cockx, Jesper},
title = {Optimising First-Class Pattern Matching - Artefact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7189905},
abstract = {
    <p>This is the artefact for the paper Optimising First-Class Pattern Matching, accepted at the International Conference on Software Language Engineering. It contains a Docker image with the setup to rerun the benchmarks we used in the evaluation of the paper.</p>
<h3 id="table-of-contents">Table of Contents</h3>
<ul>
<li>Preliminary PDF version of the accepted paper.</li>
<li>Docker image archive, containing:
<ul>
<li>A Linux installation.</li>
<li>A development version of Spoofax pre-installed (based on release 2.5.17) (libraries only, no GUI).</li>
<li>The benchmark setup as used in the paper, with a check-out of the Tiny Imperative Language Spoofax project.</li>
<li>Benchmark results from one previous run.</li>
</ul></li>
</ul>

},
keywords = {First-Class Pattern Matching, Pattern Match Optimisation, Pattern Matching, Spoofax, Stratego}
}

@software{10.5281/zenodo.7211893,
author = {van der Storm, Tijs and Hermans, Felienne},
title = {Gradual Grammars: Syntax in Levels and Locales (artifact)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7211893},
abstract = {
    <p>The artifact contains the source code of the Fabric gradual grammar formalism, including its compiler to LARK. Additionally, it demonstrates the embedding of Fabric in the Rascal metaprogramming language. Both approaches are evaluated with case-studies. Finally, the artifact contains the scripts to reproduce the benchmark result about the performance overhead of <code>unravel</code>.</p>

},
keywords = {gradual languages, grammars, internationalization, modularity, parsing}
}

@software{10.5281/zenodo.7223815,
author = {Rein, Patrick and Beckmann, Tom and Geier, Leonard and Mattis, Toni and Hirschfeld, Robert},
title = {Materials for Conducting Debugging Contests},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7223815},
abstract = {
    <p>This archive includes materials to conduct Competitive Debugging contests, as described in the corresponding publication “Competitive Debugging: Towards Contests Promoting Debugging as a Skill”.</p>
<p>The archive contains the following materials</p>
<pre><code>environment-main-event/: The programming environment used for the main event. To get it running, see below.
environment-training/: The programming environment participants received for training before the main event.
RealmsOfZaltia/: The source code of the game the participants worked on.
tasks/:
    *.cs: The patches that introduce the faults into the game source code.
    selected-task-descriptions.txt: The task descriptions for several of the patches. Not all are included, as some were not used in the contest. The file has the format: task number, steps to reproduce, observable failure.
Competitive Debugging Season 1 - Game 2 - Intro Text.pdf: A sketch of the introduction to the contest (in German).</code></pre>
<p>Starting the Environment</p>
<p>The environment is a Squeak/Smalltalk system. To start the environment you need a corresponding Squeak virtual machine for your operating system. You can then start the VM by passing the *.image file to it.</p>
<p>The specifications for the image file are 64bit, Spur memory layout, SISTAV1 bytecode.</p>

},
keywords = {competitive debugging, debugging, debugging contest, tasks, teaching, training}
}

@software{10.5281/zenodo.7259115,
author = {Risberg Alak\"{u}la, Anton and Hedin, G\"{o}rel and Fors, Niklas and Pop, Adrian},
title = {Property Probe Artifact},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7259115},
abstract = {
    <p>Artifact and Docker images for the paper “Property Probes: Source Code Based Exploration of Program Analysis Results”, to appear in ACM SLE 2022.</p>
<p>Main instructions on how to evaluate this artifact can be found in the README.pdf inside the Artifact.zip file.</p>
<p>There are two prebuilt Docker images available, each with a different target Docker architecture. Make sure to download the one that matches your local architecture to get best performance while evaluating the artifact.</p>
<p>Version 1.1.0 of this artifact contains some updates to the README inside Artifact.zip.</p>

},
keywords = {programming language tools}
}

@software{10.5281/zenodo.7260980,
author = {Khorram, Faezeh and Bousse, Erwan and Garmendia, Antonio and Mottu, Jean-Marie and Suny\'{e}, Gerson and Wimmer, Manuel},
title = {Coverage Computation and Fault Localization for Executable DSLs Artefacts},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7260980},
abstract = {
    <p>This repository contains the tool and the evaluation data of our paper titled “From Coverage Computation to Fault Localization: A Generic Framework for Domain-Specific Languages”, accepted at SLE 2022. The provided tool is built atop the Eclipse GEMOC Studio.</p>

},
keywords = {Coverage, Executable Domain-Specific Languages, Executable Models, Fault Localization, Testing}
}

@software{10.5281/zenodo.7342082,
author = {Turcotte, Alexi and Donat-Bouillud, Pierre and K\v{r}ikava, Filip and Vitek, Jan},
title = {Artifact for signatr: A Data-Driven Fuzzing Tool for R},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7342082},
abstract = {
    <p>The artifact contains the signatr tool, and the pipelines to create an R value database and to fuzz R functions with the database to find type signatures. The pipeline to create a value database is in pipeline-dbgen. The fuzzing pipeline will generate the inputs for the sle.Rmd R markdown notebook. That notebook can then be rendered to get all the results (tables, figures) we use in the paper.</p>

},
keywords = {dynamic program analysis, dynamic programming languages, fuzzing, R}
}

@software{10.6084/m9.figshare.21325200.v3,
author = {Ahmadi, Sharar and Dongol, Brijesh and Griffin, Matt},
title = {Proving Memory Access Violations in Isabelle/HOL (Extended Version)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21325200.v3},
abstract = {
    <ul>
<li><p>The Isabelle/HOL conformance predicates for modelling memory access restrictions imposed by S𝜇V.</p></li>
<li><p>The C code and their corresponding BIL (AIRv2) translation of the test examples that violate at least one of the conformance predicates, defined for S𝜇V</p></li>
<li><p>The Isabelle/HOL conformant predicates for modelling memory access restrictions for assembly instructions: Load and Store. The restrictions are managed by EA-MPU of TrustLite, which is used to implement the CRA protocol SEDA.</p></li>
<li><p>The C code and their corresponding BIL (AIRv2) translation of the test examples that violate at least one of the conformant rules defined for TrustLite, as used to implement the SEDA protocol.</p></li>
<li><p>The Isabelle/HOL control-flow conformance predicates for modelling memory access restrictions for TrustLite, as used to implement the SEDA protocol</p></li>
<li><p>The C code and their corresponding BIL (AIVv2) translation of the test examples that violate at least one of the control-flow conformance rules defined for TrustLite, as used to implement the SEDA protocol SEDA.</p></li>
</ul>

},
keywords = {Isabelle/HOL
formal verification
conformance rules
micro controller units}
}

@software{10.6084/m9.figshare.21381864.v1,
author = {Potter, Hannah and Madadi, Ardi and Just, Ren\'{e} and Omar, Cyrus},
title = {Contextualized Programming Language Documentation},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21381864.v1},
abstract = {
    <p>This artifact contains the following materials from the study presented in the Onward! ’22 paper “Contextualized Programming Language Documentation”:</p>
<ul>
<li>executable - Executable webpage source files for the UI presented to participants (MIT license)</li>
<li>hazel-in-situ-doc-evaluation - Source code to regenerate the executable (MIT license)</li>
<li>expert-code-explanations-study-main - Scripts used for data analysis</li>
<li>docs - Study materials (e.g., surveys) and results</li>
</ul>

},
keywords = {documentation, Functional programming, programming education, structure editing}
}

@software{10.5281/zenodo.6640549,
author = {Pfandzelter, Tobias and Bermbach, David},
title = {Implementation of the article "Celestial: Virtual Software System Testbeds for the LEO Edge"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6640549},
abstract = {
    <p></p><p>Artifact appendix item for Middleware 2022</p><p></p>
}
}

@software{10.5281/zenodo.7311277,
author = {S\'{a}nchez-Artigas, Marc and Eizaguirre, Germ\'{a}n T.},
title = {Implementation of the article "A seer knows best: optimized object storage shuffling for serverless analytics"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7311277},
abstract = {
    <p></p><p>Artifact appendix item for Middleware 2022</p><p></p>
}
}

@software{10.5281/zenodo.7317366,
author = {Mao, Yunhao and Liu, Zongxin and Jacobsen, Hans-Arno},
title = {rKVDB - Implementation of the article "Reversible Conflict-free Replicated Data Types"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7317366},
abstract = {
    <p></p><p>Artifact appendix item for Middleware 2022</p><p></p>
}
}

@software{10.5281/zenodo.7345983,
author = {Wang, Yu-Ping and Dong, Yuejiang and Tan, Gang},
title = {Implementation of the article "ROS-SF: A Transparent and Efficient ROS Middleware using Serialization-Free Message"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7345983},
abstract = {
    <p></p><p>Artifact appendix item for Middleware 2022</p><p></p>
}
}

@software{10.5281/zenodo.7346345,
author = {Rocha, Isabelly and Schiavoni, Valerio},
title = {Implementation of the article "EdgeTune: Inference-Aware Hyperparameter Tuning"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7346345},
abstract = {
    <p></p><p>Artifact appendix item for Middleware 2022</p><p></p>
}
}

@software{10.5281/zenodo.7351673,
author = {Zandberg, Koen and Yuan, Shenghao and Baccelli, Emmanuel and Fr\'{e}d\'{e}ric, Besson and Talpin, Jean-Pierre},
title = {Femto-Containers: Lightweight Virtualization and Fault Isolation For Small Software Functions on Low-Power IoT Microcontrollers},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7351673},
abstract = {
    <p></p><p>Artifact appendix item for Middleware 2022</p><p></p>
}
}

@software{10.1145/3576916,
author = {Kelly, Terence},
title = {Source code for Drill Bits 8 article "Literate Executables"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3576916},
abstract = {
    <p>Literate executables redefine the relationship between compiled binaries and source code to be that of chicken and egg, so it’s easy to derive either from the other. This episode of Drill Bits provides a general-purpose literacy tool and showcases the advantages of literacy by retrofitting it onto everyone's favorite command-line utility.</p>
}
}

@software{10.5281/zenodo.6991219,
author = {Norlinder, Jonas and \"{O}sterlund, Erik and Wrigstad, Tobias},
title = {Compressed Forwarding Tables Reconsidered (code)},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.6991219},
abstract = {
    <p>This artifact contains the code used in the paper Compressed Forwarding Tables Reconsidered, which explores a design that guarantees a low memory bound for forwarding information used by the GC. The design is evaluated on-top of generational ZGC.</p>

},
keywords = {concurrent object relocation, forwarding information, garbage collection, OpenJDK, ZGC}
}

@software{10.5281/zenodo.7173860,
author = {Yin, Xizhe and Zhao, Zhijia and Gupta, Rajiv},
title = {Reproduction Package for Article `Glign: Taming Misaligned Graph Traversals in Concurrent Graph Processing’},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7173860},
abstract = {
    <p>This artifact contains the source code of Glign, including the five concurrent query evaluation designs discussd in the paper and some graph benchmarks along with their inputs used in the experiments. In addition, this artifact provides bash scripts to compile Glign and reproduce the key experimental results reported in the paper.</p>

},
keywords = {concurrent graph processing, data locality, graph system}
}

@software{10.5281/zenodo.7182800,
author = {Sutherland, Mark and Falsafi, Babak and Daglis, Alexandros},
title = {Discrete-Event Simulation Software and Results Accompanying "Cooperative Concurrency Control for Write Intensive Key-Value Workloads"},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7182800},
abstract = {
    <p>This archive contains the code, datasets, and instructions to generate the discrete-event simulation results appearing in the paper: “Cooperative Concurrency Control for Write-Intensive Key-Value Workloads”.</p>
<p>All instructions and tutorials for using the artifact are contained in the paper’s artifact appendix.</p>

},
keywords = {concurrency control, discrete-event simulation, key-value store, load balancing}
}

@software{10.5281/zenodo.7198195,
author = {Gouicem, Redha and Sprokholt, Dennis and Ruehl, Jasper and Rocha, Rodrigo C. O. and Spink, Tom and Chakraborty, Soham and Bhatotia, Pramod},
title = {Risotto: A Dynamic Binary Translator for Weak Memory Model Architectures},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7198195},
abstract = {
    <p>Artifact for the Risotto: A Dynamic Binary Translator for Weak Memory Model Architectures paper published at ASPLOS’23.</p>

},
keywords = {binary translation, formal verification, memory models}
}

@software{10.5281/zenodo.7220659,
author = {Luo, Shutian and Xu, Huanle and Ye, Kejiang and Xu, Guoyao and Zhang, Liping and He, Jian and Yang, Guodong and Xu, Chengzhong},
title = {Reproduction Package for Article &nbsp;Erms: Efficient Resource Management for Shared Microservices with SLA Guarantees},
year = {2022},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7220659},
abstract = {
    <p>Erms is a cluster-level resource management system for shared microservices with SLA guarantees. This artifact includes a proto- type implementation of Erms and the experimental workflows for running DeathStarBench on Erms.</p>

},
keywords = {Resource Management, Shared Microservices, SLA Guarantees}
}

@software{10.1145/3554339,
author = {Arrial, Victor and Guerrieri, Giulio and Kesner, Delia},
title = {An Implementation of the Quantitative Inhabitation for Different Lambda Calculi in a Unifying Framework},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554339},
abstract = {
    <p>This artifact provides an implementation in OCaml of the inhabitation algorithm presented in the paper “Quantitative Inhabitation for Different Lambda Calculi in a Unifying Framework”.</p>

},
keywords = {call-by-push-value, inhabitation, lambda-calculus, ocaml, quantitative types}
}

@software{10.1145/3554340,
author = {Hou (Favonia), Kuen-Bang and Angiuli, Carlo and Mullanix, Reed},
title = {Artifact of “An Order-Theoretic Analysis of Universe Polymorphism”},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554340},
abstract = {
    <p>An OCaml implementation of the paper and an Agda formalization of various parts of the paper.</p>

},
keywords = {type theory, universe polymorphism, universes}
}

@software{10.1145/3554341,
author = {Lemerre, Matthieu},
title = {Artifact for the paper "SSA Translation Is an Abstract Interpretation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554341},
abstract = {
    <p>The artifact contains the source code of a small plugin for the Frama-C platform (http://www.frama-c.com), which takes a C file (in the supported subset of C) and translate it to LLVM code, using a dataflow algorithm pass as described in the paper “SSA translation is an abstract interpretation”. The main entry point of the plugin is online_ssa_complete.ml, with okasakimap.ml (an implementation of Chris Okasaki’s Fast Mergeable Integer Maps) and fixpoint_wto.ml (an implementation of Bourdoncle’s Efficient chaotic iteration strategies with widenings) as support files.</p>
<p>The artifact also contains the csmith files generated for use in the experiments described in the paper; a result.org file containing the results of our run of evaluation; a Makefile to compile the plugin and run the experiments; a Dockerfile to recreate a working environment; and a README.org file further documenting the artifact.</p>

},
keywords = {abstract interpretation, dataflow analysis., SSA translation}
}

@software{10.1145/3554342,
author = {Gancher, Joshua and Sojakova, Kristina and Fan, Xiong and Shi, Elaine and Morrisett, Greg},
title = {Repository for Article 'A Core Calculus for Equational Proofs of Cryptographic Protocols'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554342},
abstract = {
    <p>This repository contains the Coq proofs and technical information for our work. Installation instructions are in the README, while the protocols themselves are in theories/protocols.</p>

},
keywords = {cryptographic protocols, equational proof, multiparty computation, verification}
}

@software{10.1145/3554343,
author = {Zhou, Li and Barthe, Gilles and Strub, Pierre-Yves and Liu, Junyi and Ying, Mingsheng},
title = {Coq Development for Article `CoqQ: Foundational Verification of Quantum Programs`},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554343},
abstract = {
    <p>CoqQ is a framework for reasoning about quantum programs in the Coq proof assistant. Its main components are: a deeply embedded quantum programming language, in which classic quantum algorithms are easily expressed, and an expressive program logic for proving properties of programs.</p>

},
keywords = {Mathematical Libraries, Program Logics, Proof Assistants, Quantum Programs}
}

@software{10.1145/3554344,
author = {Michael, Alexandra E. and Gollamudi, Anitha and Bosamiya, Jay and Johnson, Evan and Denlinger, Aidan and Disselkoen, Craig and Watt, Conrad and Parno, Bryan and Patrignani, Marco and Vassena, Marco and Stefan, Deian},
title = {Reproduction Package for "MSWasm: Soundly Enforcing Memory-Safe Execution of Unsafe Code"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554344},
abstract = {
    <p>The artifact contains a Dockerfile that automates the setup of the MSWasm toolchain, as well as a README with instructions on installing and using the toolchain.</p>

},
keywords = {Memory-safety, Secure Compilation, WebAssembly}
}

@software{10.1145/3554346,
author = {Kallas, Konstantinos and Zhang, Haoran and Alur, Rajeev and Angel, Sebastian and Liu, Vincent},
title = {Reproduction package for article "Executing Microservice Applications on Serverless, Correctly"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554346},
abstract = {
    <p>Our artifact contains all claims made in the paper regarding the prototype and its evaluation. The proofs in the paper are not mechanized and therefore are not part of the artifact. The claims made in our paper are: 1. We have developed the mu2sls prototype that generates a serverless implementation from a set of service specifications. You can find information about this claim in the “Additional Artifact Information” section, where we describe the structure of the artifact code, and how it corresponds to the paper. 2. We have evaluated our prototype w.r.t. the three questions (Q1), (Q2), (Q3) described in Section 8. You can reproduce the experiments for this claim by following the “Evaluation Instructions Section”.</p>

},
keywords = {microservices, stateful serverless, transactions}
}

@software{10.5281/zenodo.7120897,
author = {Cao, David and Kunkel, Rose and Nandi, Chandrakana and Willsey, Max and Tatlock, Zachary and Polikarpova, Nadia},
title = {Artifact for "babble: Learning Better Abstractions with E-Graphs and Anti-Unification"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7120897},
abstract = {
    <p>This is the artifact for the paper “babble: Learning Better Abstractions with E-Graphs and Anti-Unification”.</p>
<p>The canonical source for this artifact is the Github repo: https://github.com/dcao/babble/tree/popl23 An archival copy is on Zenodo with DOI: 10.5281/zenodo.7120897.</p>

},
keywords = {e-graphs, library learning, program synthesis}
}

@software{10.5281/zenodo.7129302,
author = {Moine, Alexandre and Chargu\'{e}raud, Arthur and Pottier, Fran\c{c}ois},
title = {A High-Level Separation Logic for Heap Space under Garbage Collection - Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7129302},
abstract = {
    <p>This is the artifact corresponding to&nbsp;the article entitled “A High-Level Separation Logic for Heap Space under Garbage Collection”, and its associated documentation.</p>

},
keywords = {Coq, Iris, live data, program verification, separation logic, tracing garbage collection}
}

@software{10.5281/zenodo.7130343,
author = {Smeding, Tom J. and V\'{a}k\'{a}r, Matthijs I. L.},
title = {Artifact for Efficient Dual-Numbers Reverse AD via Well-Known Program Transformations},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7130343},
abstract = {
    <p>Artifact for the POPL23 submission titled “Efficient Dual-Numbers Reverse AD via Well-Known Program Transformations”. Includes a VirtualBox virtual disk image (tested with VirtualBox 6.1.38), as well as a zip file with just the code. The artifact allows reproduction of the experimental results in the paper.</p>

},
keywords = {automatic differentiation, functional programming, source transformation}
}

@software{10.5281/zenodo.7144067,
author = {Antonopoulos, Timos and Koskinen, Eric and Le, Ton Chanh and Nagasamudram, Ramana and Naumann, David A. and Ngo, Minh},
title = {Mechanization of some results in: An Algebra of Alignment for Relational Verification},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7144067},
abstract = {
    <p>Relational verification encompasses information flow security, regression verification, translation validation for compilers, and more. Effective alignment of the programs and computations to be related facilitates use of simpler relational invariants and relational procedure specs, which in turn enables automation and modular reasoning. Alignment has been explored in terms of trace pairs, deductive rules of relational Hoare logics (RHL), and several forms of product automata. This article shows how a simple extension of Kleene Algebra with Tests (KAT), called BiKAT, subsumes prior formulations, including alignment witnesses for forall-exists properties, which brings to light new RHL-style rules for such properties. Alignments can be discovered algorithmically or devised manually but, in either case, their adequacy with respect to the original programs must be proved; an explicit algebra enables constructive proof by equational reasoning. Furthermore our approach inherits algorithmic benefits from existing KAT-based techniques and tools, which are applicable to a range of semantic models.</p>
<p>The artifact formalizes some results from the paper in Coq. These include constructions of models of BiKAT, general consequences of BiKAT axioms, and the encoding of forall-forall relational triples. In addition, the artifact proves soundness and completeness of a technique for establishing forall-exists properties using BiKAT.</p>

},
keywords = {hyperproperties, Kleene algebra with tests, program algebra, relational verification}
}

@software{10.5281/zenodo.7147007,
author = {Das, Ankush and Wang, Di and Hoffmann, Jan},
title = {Probabilistic Resource-Aware Session Types (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7147007},
abstract = {
    <p>This artifact accompanies the paper titled “Probabilistic Resource-Aware Session Types” appearing at POPL 2023. The artifact contains a VM (Virtual Machine) image that contains an implementation of the NomosPro core calculus (our main contribution) and benchmark examples to test the implementation.</p>

},
keywords = {Amortized Analysis, Markov Chains, Nested Multiverse Semantics, Probabilistic Concurrency, Probabilistic Programming, Randomized Distributed Protocols, Resource Analysis, Semantics, Session Types, Type Systems}
}

@software{10.5281/zenodo.7148055,
author = {Thokair, Mosaad Al and Zhang, Minjian and Mathur, Umang and Viswanathan, Mahesh},
title = {Artifact: Dynamic Race Detection With O(1) Samples},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7148055},
abstract = {
    <p>This document provides instructions on how to evaluate the implementation and reproduce the results from the POPL 2023 article titled “Dynamic Race Detection With O(1) Samples”</p>

},
keywords = {Concurrency, Dynamic program analysis, Happens-before, Property testing, Race detection}
}

@software{10.5281/zenodo.7149192,
author = {Barri\`{e}re, Aur\`{e}le and Blazy, Sandrine and Pichardie, David},
title = {Reproduction Package for "Formally Verified Native Code Generation in an Effectful JIT"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7149192},
abstract = {
    <p>A Virtual Machine Image where FM-JIT is installed (in /home/popl23/FM-JIT/coqjit) and ready to be run.</p>

},
keywords = {CompCert compiler, just-in-time compilation, verified compilation}
}

@software{10.5281/zenodo.7150549,
author = {Jacobs, Jules and Balzer, Stephanie},
title = {Higher-Order Leak and Deadlock Free Locks (Coq mechanization)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7150549},
abstract = {
    <p>Coq mechanization for the paper “Higher-Order Leak and Deadlock Free Locks”.</p>

},
keywords = {Coq, deadlocks, locks, mechanization, proofs}
}

@software{10.5281/zenodo.7150677,
author = {Bembenek, Aaron and Greenberg, Michael and Chong, Stephen},
title = {From SMT to ASP: Solver-Based Approaches to Solving Datalog Synthesis-as-Rule-Selection Problems (POPL 2023 Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7150677},
abstract = {
    <p>This artifact includes the application code, benchmarks, and scripts for reproducing the experiments in the POPL’23 paper “From SMT to ASP: Solver-Based Approaches to Solving Datalog Synthesis-as-Rule-Selection Problems” by Aaron Bembenek, Michael Greenberg, and Stephen Chong.</p>

},
keywords = {answer set programming, Datalog, inductive logic programming, program synthesis, satisfiability}
}

@software{10.5281/zenodo.7150706,
author = {Jacobs, Jules and Wi\ss{}mann, Thorsten},
title = {Fast Coalgebraic Bisimilarity Minimization (artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7150706},
abstract = {
    <p>This is the artifact for the paper “Fast Coalgebraic Bisimilarity Minimization”.</p>
<p>It contains a Rust program called “boa”, which implements the algorithm for the paper.</p>

},
keywords = {automata, bisimilarity, Coalgebra, minimization}
}

@software{10.5281/zenodo.7150943,
author = {Dash, Swaraj and Kaddar, Younesse and Paquet, Hugo and Staton, Sam},
title = {LazyPPL: Affine monads and lazy structures for Bayesian programming},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7150943},
abstract = {
    <p>A Haskell library for probabilistic programming with lazy structures, to accompany the paper “Affine monads and lazy structures for Bayesian programming”.</p>

},
keywords = {Probabilistic programming}
}

@software{10.5281/zenodo.7151663,
author = {Bowers, Matthew and Olausson, Theo X. and Wong, Lionel and Grand, Gabriel and Tenenbaum, Joshua B. and Ellis, Kevin and Solar-Lezama, Armando},
title = {Artifact for Reproducing Results From "Top-Down Synthesis for Library Learning"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7151663},
abstract = {
    <p>This Artifact is for reproducing the results of “Top-Down Synthesis for Library Learning” (POPL 2023). While this remains as the static version submitted to POPL, some small changes/fixes for broader OS compatibility were made during the evaluation process and are present in the GitHub repo https://github.com/mlb2251/stitch-artifact which will remain more up to date, so <strong>for most use-cases the GitHub version will be preferable</strong>. All instructions for installation, running, etc can be found in the ReadMe of the artifact.</p>

},
keywords = {Abstraction Learning, Library Learning, Program Synthesis}
}

@software{10.5281/zenodo.7151842,
author = {Kokologiannakis, Michalis and Lahav, Ori and Vafeiadis, Viktor},
title = {Reproduction package for article: "Kater: Automating Weak Memory Metatheory and Consistency Checking"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7151842},
abstract = {
    <p>The artifact comprises the version of Kater used for the paper benchmarks, as well as a version of GenMC that employs Kater-generated consistency checks.</p>

},
keywords = {declarative semantics, kleene algebra with tests, software model checking, weak memory models}
}

@software{10.5281/zenodo.7152484,
author = {Klimis, Vasileios and Clark, Jack and Baker, Alan and Neto, David and Wickerson, John and Donaldson, Alastair F.},
title = {Artifact for POPL 2023 Paper: Taking Back Control in an Intermediate Representation for GPU Computing},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7152484},
abstract = {
    <p>The artifact provides evidence to back up the claims made in our POPL 2023 Paper: “Taking Back Control in an Intermediate Representation for GPU Computing”. It is a Docker image that has all the necessary tooling/software pre-installed; this includes the tools produced by us for the paper and this artifact, as well as some third-party tooling for assembling, parsing, disassembling and validating SPIR-V modules.</p>

},
keywords = {Alloy, control flow, fuzz testing, GPU graphics, SPIR-V}
}

@software{10.5281/zenodo.7220452,
author = {Chen, Zilin and Lafont, Ambroise and O'Connor, Liam and Keller, Gabriele and McLaughlin, Craig and Jackson, Vincent and Rizkallah, Christine},
title = {Dargent: A Silver Bullet for Verified Data Layout Refinement (Artefact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7220452},
abstract = {
    <p>The artefact contains the source code of the Cogent compiler and its verification framework extended with Dargent, a test suite consisting of small Dargent programs, and the case studies presented in the paper.</p>

},
keywords = {certifying compiler, data layout description, data refinement, systems programming}
}

@software{10.5281/zenodo.7227966,
author = {Chappe, Nicolas and He, Paul and Henrio, Ludovic and Zakowski, Yannick and Zdancewic, Steve},
title = {Choice Trees: Representing Nondeterministic, Recursive, and Impure Programs in Coq},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7227966},
abstract = {
    <p>Snapshot of the “ctrees” library as per its description in the paper “Choice Trees: Representing Nondeterministic, Recursive, and Impure Programs in Coq”.</p>
<p>This library provides a constructive semantic model supporting native support for divergence and non-determinism, while being parameterized by a non-axiomatized signature of external interaction. It is shown to be a valid interpretation target from itrees, as well as to support further interpretation towards other iterative monads.</p>

},
keywords = {Concurrency, Formal Semantics, Interaction Trees, Nondeterminism}
}

@software{10.5281/zenodo.7246597,
author = {Lee, Wonyeol and Rival, Xavier and Yang, Hongseok},
title = {Artifact for the Paper "Smoothness Analysis for Probabilistic Programs with Application to Optimised Variational Inference"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7246597},
abstract = {
    <p>The artifact includes (i) our implementation of the static analysis for smoothness properties, (ii) the Pyro programs used in our experiments, and (iii) information on how to reproduce the results reported in the paper. For more details, please refer to `pyppai/README.txt’ in the artifact, and Section 7 of the paper.</p>

},
keywords = {probabilistic programming, smoothness, static analysis, variational inference}
}

@software{10.5281/zenodo.7260815,
author = {Palmkvist, Viktor and Castegren, Elias and Haller, Philipp and Broman, David},
title = {Implementation, Experiments, and Mechanization for 'Statically Resolvable Ambiguity'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7260815},
abstract = {
    <p>This artifact contains all supplementary material for the ‘Statically Resolvable Ambiguity’ paper, including the modified OCaml compiler, the library implementing our grouper, the benchmarks and resulting data used in the paper, and the mechanized proof of static resolvability.</p>

},
keywords = {Coq, OCaml, Parsing}
}

@software{10.5281/zenodo.7305612,
author = {Abreu, Pedro and Delaware, Benjamin and Hubers, Alex and Jenkins, Christa and Morris, J. Garrett and Stump, Aaron},
title = {Artifact, Documentation, and Code for POPL'23 Paper &nbsp;"A Type-Based Approach to Divide-and-Conquer Recursion in Coq"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7305612},
abstract = {
    <p>Artifact for POPL’23 Paper “A Type-Based Approach to Divide-and-Conquer Recursion in Coq”. The paper describes a development in Coq for writing divide-and-conquer recursion with type-based termination checking. This artifact contains this development and many example applications.</p>

},
keywords = {Algebraic Semantics, Coq, Divide-and-Conquer Recursion, Mendler Algebras, Mergesort, Strong Normalization, Type-Based Termination Checking}
}

@software{10.5281/zenodo.7306313,
author = {Sammler, Michael and Spies, Simon and Song, Youngju and D'Osualdo, Emanuele and Krebbers, Robbert and Garg, Deepak and Dreyer, Derek},
title = {Artifact and Appendix of "DimSum: A Decentralized Approach to Multi-language Semantics and Verification"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7306313},
abstract = {
    <p>This is the artifact for the POPL’23 paper “DimSum: A Decentralized Approach to Multi-language Semantics and Verification”. It contains the Coq development and the appendix for the paper.</p>

},
keywords = {compilers, Coq, Iris, multi-language semantics, non-determinism, separation logic, verification}
}

@software{10.5281/zenodo.7308911,
author = {Popescu, Andrei and Traytel, Dmitriy},
title = {POPL'23 artifact for "Admissible Types-To-PERs Relativization in Higher-Order Logic"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7308911},
abstract = {
    <p>The artifact contains the tool support we developed to experiment with relativization in Isabelle/HOL.</p>

},
keywords = {higher-order logic (HOL), interactive theorem proving, Isabelle/HOL, partial equivalence relation, proof theory, relativization, type definition}
}

@software{10.5281/zenodo.7310633,
author = {Pitts, Andrew M.},
title = {Agda code accompanying the paper "Locally Nameless Sets"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7310633},
abstract = {
    <p>The zip archive locns-agda.zip contains code for Agda (version 2.6.2.2) that was used to develop the theory of locally nameless sets and to check some of the proofs in the paper: Andrew M. Pitts. 2023. Locally Nameless Sets. Proc. ACM Program. Lang. 7, POPL, Article 17 (January 2023), 27 pages. https://doi.org/10.1145/3571210. The code mainly targets proofs that involve equational reasoning combined with the use of atoms and indices that are sufficiently fresh (via cofinite quantification). Some of these proofs involve a lot of nested case analysis on elements of sets with decidable equality (atoms and indices); some of the equational axioms are unfamiliar-looking and combinatorially complicated; and it is easy to forget to check necessary freshness conditions are satisfied when doing informal proofs. For all these reasons the use of an interactive theorem prover to produce machine-checked proofs was essential to gain assurance that the results in the paper are correct. The Agda code is stand-alone: the root is the file Everything.agda (for browsable code start at html/Everything.html). Some standard definitions (that might otherwise be called from the Agda Standard Library) are collected in the file Prelude.agda. The last part of the development requires function extensionality, which we postulate in the file FunExt.agda.</p>

},
keywords = {Agda, category theory, cofinite quantification, initial algebra, locally nameless, metatheory of syntax, name binding}
}

@software{10.5281/zenodo.7315899,
author = {Bach Poulsen, Casper and van der Rest, Cas},
title = {Hefty Algebras -- the Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7315899},
abstract = {
    <p>This artifact contains the code accompanying the POPL 2023 paper Hefty Algebras: Modular Elaboration of Higher-Order Algebraic Effects.</p>

},
keywords = {Agda, Algebraic Effects, Dependent Types, Modularity, Reuse}
}

@software{10.5281/zenodo.7320806,
author = {Lee, Woosuk and Cho, Hangyeol},
title = {Artifacts for "Inductive Synthesis of Structurally Recursive Functional Programs from Non-recursive Expressions"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7320806},
abstract = {
    <p>This artifact includes all things necessary􏰛 for reproducing experimental results in the paper “Inductive Synthesis of Structurally Recursive Functional Programs from Non-recursive Expressions”. The source code for Trio, which is the tool presented in the paper, and the other baseline synthesizers (Burst and Smyth), and the scripts for running the experiments are contained.</p>

},
keywords = {Program synthesis, Programming-by-example, Recursive functional programs, Version space}
}

@software{10.5281/zenodo.7321183,
author = {Kincaid, Zachary and Koh, Nicolas and Zhu, Shaowei},
title = {Artifact for the article "When Less is More: Consequence Finding in a Weak Theory of Arithmetic"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7321183},
abstract = {
    <p>This is the artifact for the POPL 2023 paper, When Less is More: Consequence Finding in a Weak Theory of Arithmetic. The artifact is an OVA virtual machine that can be opened through VirtualBox. The artifact contains all necessary software and dependencies to reproduce the experimental results in Section 6 of the paper. The accompanying README file contains detailed instructions to reproduce the results and how to run the tool on new tasks.</p>

},
keywords = {computational commutative algebra, Groebner basis, invariants, monotone, non-linear invariant generation, predictable, program analysis, theory of arithmetics}
}

@software{10.5281/zenodo.7332066,
author = {Pujet, Lo\"{\i}c and Tabareau, Nicolas},
title = {CoqHott/logrel-mltt: POPL23 version},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7332066},
abstract = {
    <p>A Logical Relation for Impredicative Observational Equality in Agda.</p>
<p>This is a formalized proof of the decidability of conversion for an extension of the calculus of inductive constructions (CIC) with an equality satisfying UIP, function extensionality, and propositional extensionality.</p>

},
keywords = {Agda, Impredicativity, Logical Relation, Proof Irrelevance, Type Theory}
}

@software{10.5281/zenodo.7382711,
author = {Voichick, Finn and Li, Liyi and Rand, Robert and Hicks, Michael},
title = {Qunity: A Unified Language for Quantum and Classical Computing (Type Checker)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7382711},
abstract = {
    <p>This code repository is designed to accompany the paper “Qunity: A Unified Language for Quantum and Classical Computing.” You can run the “make” command to compile our proofs. See the README.md file for more details.</p>

},
keywords = {programming languages, quantum computing, type checking}
}

@software{10.5281/zenodo.7409103,
author = {Rioux, Nick and Huang, Xuejing and Oliveira, Bruno C. d. S. and Zdancewic, Steve},
title = {A Bowtie for a Beast: Overloading, Eta Expansion, and Extensible Data Types in F⋈ (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7409103},
abstract = {
    <p>Our companion paper presents F⋈, a core language that demonstrates how unions, intersections, and overloading can all coexist with a tame merge operator. Merging values from overlapping types may be ambiguous, so disjointness relations have been introduced to rule out undesired nondeterminism and obtain a well-behaved semantics. Our design principle states that any two types can support either the deterministic merging of their values, or the ability to distinguish their values, but never both. To realize this invariant, We decompose previously studied notions of disjointness into two new, dual relations that permit the operation that best suits each pair of types. This artifact contains Coq code that formalizes certain type-level parts of the semantics of F⋈, including subtyping, dispatch, and some key properties of the two disjointness relations.</p>

},
keywords = {Coq, intersection types, subtyping, union types}
}

@software{10.5281/zenodo.7472859,
author = {Xu, Han and Huang, Xuejing and Oliveira, Bruno C. d. S.},
title = {Coq Formalization for "Making a Type Difference: Subtraction on Intersection Types as Generalized Record Operations"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7472859},
abstract = {
    <p>Coq formalization that contains the definitions and proves the claims in the paper. We provide the source code and a virtual machine image with all the dependencies installed. The appendix of the paper is also included.</p>

},
keywords = {Coq, functional programming, object-oriented programming, type systems}
}

@software{10.5281/zenodo.7491759,
author = {Lu, Sirui and Bod\'{\i}k, Rastislav},
title = {Reproduction Package for Article "Grisette: Symbolic Compilation as a Functional Programming Library"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7491759},
abstract = {
    <p>The artifact contains the Grisette library, a modified leanette POPL’22 artifact, and the reimplementation of some leanette benchmarks in Grisette.</p>

},
keywords = {State Merging, Symbolic Compilation}
}

@software{10.5281/zenodo.7492757,
author = {Fu, Peng and Kishida, Kohei and Ross, Neil J. and Selinger, Peter},
title = {An implementation for the paper "Proto-Quipper with Dynamic Lifting"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7492757},
abstract = {
    <p>It contains source code of an interpreter for Proto-Quipper-Dyn.</p>

},
keywords = {Proto-Quipper-Dyn, Quantum programming language}
}

@software{10.5281/zenodo.7493157,
author = {Song, Youngju and Cho, Minki and Lee, Dongjae and Hur, Chung-Kil and Sammler, Michael and Dreyer, Derek},
title = {Artifact Package for "Conditional Contextual Refinement"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7493157},
abstract = {
    <p>This is the artifact for the paper “Conditional Contextual Refinement”. Please refer to the included “README.md” for more detailed instructions.</p>

},
keywords = {abstraction, CompCert, compiler verification, compositionality, Coq, interactive theorem proving, Iris, layered abstraction, modular reasoning principles, program logic, program verification, refinement, separation logic, specification}
}

@software{10.5281/zenodo.7495380,
author = {Zhou, Litao and Zhou, Yaoda and Oliveira, Bruno C. d. S.},
title = {Recursive Subtyping for All (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7495380},
abstract = {
    <p>This artifact contains the formalization of the <span class="math inline"><em>F</em><sub>≤</sub><sup><em>μ</em></sup></span> calculus (and its extension <span class="math inline"><em>F</em><sub> ≤ ≥</sub><sup><em>μ</em></sup></span>), together with its soundness, decidability, and conservativity proof in the Coq proof assistant. All definitions, lemmas and theorems with their proofs presented in the paper “Recursive Subtyping for All” can be found in the Coq.zip file. We show the correspondence between the paper and the proofs in the README file. The proof in Coq.zip can be built with Coq 8.13.1.</p>

},
keywords = {Bounded Polymorphism, Iso-Recursive Subtyping, Object Encodings}
}

@software{10.1145/3554345,
author = {Peterson, Rudy and Campbell, Eric Hayden and Chen, John and Isak, Natalie and Shyu, Calvin and Doenges, Ryan and Ataei, Parisa and Foster, Nate},
title = {Reproduction Package for "P4Cub: A Little Language for Big Routers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554345},
abstract = {
    <p>We have included poulet4, a library for the petr4 system. petr4 is an in-development compiler for P4. Within poulet4/lib/P4cub is the code for P4cub. P4cub is an IR for P4 mechanized in Coq. The most up-to-date version can be found on github in the poulet4 branch of petr4.</p>

},
keywords = {Coq, domain-specific languages., formal semantics, formal verification, intermediate representations, P4}
}

@software{10.5281/zenodo.7441725,
author = {van Doorn, Floris and Massot, Patrick and Nash, Oliver},
title = {Supplementary material for the CPP 2023 paper Formalising the h-Principle and Sphere Eversion},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7441725},
abstract = {
    <p>The supplementary material for the CPP 2023 paper Formalising the h-Principle and Sphere Eversion contains the formalisation of the result. It is a frozen version of the repository</p>
<p>https://github.com/leanprover-community/sphere-eversion</p>
<p>at commit</p>
<p>9cd599b74a419209e4204829efcd50008fdd1c2b</p>
<p>Only cpp2023.zip is required to compile the project, by extracting the files and following the instructions in the README.</p>
<p>These instructions will download mathlib (https://github.com/leanprover-community/mathlib) at commit cf9386b56953fb40904843af98b7a80757bbe7f9. For convenience, this version of mathlib has been provided as a separate compressed file mathlib.zip. Instead of following the step <code>leanproject get-mathlib-cache</code> in the README, one can extract that in the same folder.</p>

},
keywords = {Convex Integration, Formalization, Homotopy Principle, Lean, Mathematics, Sphere Eversion}
}

@software{10.5281/zenodo.7502156,
author = {Carette, Jacques and Ortiz, Gerardo and Sabry, Amr},
title = {Software for `Symbolic Execution of Hadamard-Toffoli Quantum Circuits '},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7502156},
abstract = {
    <p>Haskell code, as described in the paper.</p>

},
keywords = {Haskell, Quantum, Symbolic Evaluation}
}

@software{10.25442/hku.21342192.v1,
author = {Gao, Yizhao and Zhang, Baoheng and Qi, Xiaojuan and So, Hayden Kwok-Hay},
title = {DPACS: Hardware Accelerated Dynamic Neural Network Pruning through Algorithm-Architecture Co-design},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.25442/hku.21342192.v1},
abstract = {
    <p>DPCAS is an algorithm-architecture co-design framework for dynamic neural network pruning. It utilizes a hardware-aware dynamic spatial and channel pruning mechanism in conjunction with a dynamic dataflow engine in hardware to facilitate efficient processing of the pruned network.</p>

},
keywords = {Deep Learning Applications, hardware accelerators}
}

@software{10.5281/zenodo.7196061,
author = {Levine, Reese and Guo, Tianhao and Cho, Mingun and Baker, Alan and Levien, Raph and Neto, David and Quinn, Andrew and Sorensen, Tyler},
title = {MC Mutants Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7196061},
abstract = {
    <p>This artifact contains information for both collecting analyzing the results we present in the paper. On the collection side, we provide the means to run the exact experiments included in the paper. Using the exact devices from the paper will show very similar results to ours, but any GPU can be used to evaluate the way in which we collect and analyze data. On the analysis side, we include the results from running the experiments on the four devices in the paper, as well as the analysis tools we used to generate the main figures in the paper.</p>

},
keywords = {memory consistency, mutation testing, parallel programming models}
}

@software{10.5281/zenodo.7215748,
author = {Song, Yongju and Kim, Wook-Hee and Monga, Sumit Kumar and Min, Changwoo and Eom, Young Ik},
title = {Prism: Optimizing Key-Value Store for Modern Heterogeneous Storage Devices},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7215748},
abstract = {
    <p>We addressed the question: “How should we design a key-value store for the non-hierarchical storage landscape?”. We designed and implemented a novel key-value store named Prism that utilizes modern heterogeneous storage devices. This artifact contains three major components: 1) the source code of Prism, 2) a benchmark suite, and 3) a workload generator to evaluate the system. Additionally, the scripts enclosed allow readers to configure, build, and run Prism conveniently and precisely. For reference, since Prism is built on modern heterogeneous storage devices including non-volatile memory and NVMe SSDs, there are some hardware dependencies. For the software side, Prism needs PMDK and liburing libraries. Although it could be challenging to make up an identical testbed to ours, it is necessary to satisfy both the hardware and software requirements in order to get the expected key outcomes.</p>

},
keywords = {Key-value Stores, Non-volatile Memory}
}

@software{10.5281/zenodo.7217356,
author = {Qureshi, Zaid and Mailthody, Vikram Sharma and Gelado, Isaac and Min, Seungwon and Masood, Amna and Park, Jeongmin and Xiong, Jinjun and Newburn, C. J. and Vainbrand, Dmitri and Chung, I-Hsin and Garland, Michael and Dally, William and Hwu, Wen-mei},
title = {Reproduction Package for Article "GPU-Initiated On-Demand High-Throughput Storage Access in the BaM System Architecture"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7217356},
abstract = {
    <p>The artifact is the source code the BaM system that enables efficient, on-demand accesses to storage from GPU thread. The artifact includes the source code for the system’s kernel module, library, and micro-benchmarks and applications. The applications and micro-benchmarks support multiple state-of-the-art implementations as well as BaM implementations for easy comparison.</p>

},
keywords = {GPUDirect, GPUs, Memory capacity, Memory hierarchy, SSDs, Storage systems}
}

@software{10.5281/zenodo.7217959,
author = {Xiao, Haocheng and Ainsworth, Sam},
title = {Reproduction package for article 'Hacky Racers: Exploiting Instruction-Level Parallelism to Generate Stealthy Fine-Grained Timers'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7217959},
abstract = {
    <p>Our artifact provides source code and scripts for four timing side-channel experiments mentioned in this paper, corresponding to sections 7.3 to 7.5, and each demonstrates the efficiency and portability of either/both Racing and Magnifier Gadgets. Our results should be evaluated on an Intel or AMD x86 machine (we used an i7-8750h, but systems of a similar architecture will work out-of-the-box). Migration to systems with other ISAs or significantly different micro-architectures require minor source-code modifications.</p>

},
keywords = {Caches, Instruction-level Parallelism, JavaScript, Microarchitectural Security, Spectre}
}

@software{10.5281/zenodo.7218057,
author = {Wang, Theodore Luo and Tian, Yongqiang and Dong, Yiwen and Xu, Zhenyang and Sun, Chengnian},
title = {DFusor},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7218057},
abstract = {
    <p>ASPLOS 2023 Artifact for “Compilation Consistency Modulo Debug Information”</p>

},
keywords = {Compiler Testing, Debug Information}
}

@software{10.5281/zenodo.7218907,
author = {Chen, Yun and Pei, Lingfeng and Carlson, Trevor E.},
title = {AfterImage: Leaking Control Flow Data and Tracking Load Operations via the Hardware Prefetcher},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7218907},
abstract = {
    <p>AfterImage is a hardware side-channel inside specific Intel processors. In this artifact, we provide the needed information to reproduce the main results presented in the paper.</p>

},
keywords = {Hardware Security, Prefetcher, Side-channel Attacks}
}

@software{10.5281/zenodo.7220824,
author = {Song, Jaeyong and Yim, Jinkyu and Jung, Jaewon and Jang, Hongsun and Kim, Hyung-Jin and Kim, Youngsok and Lee, Jinho},
title = {Optimus-CC: Efficient Large NLP Model Training with 3D Parallelism Aware Communication Compression},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7220824},
abstract = {
    <p>This repository is for AE (Artifact Evaluation) process of ASPLOS’23.</p>
<p>In ASPLOS23/ folder, scripts for pretraining (TABLE 2), speedup check (TABLE 2, Fig. 10), memory consumption check (Fig. 12), comp/decomp throughput check (Fig. 14), and cosine similarity check (Fig. 11) are available. We give a detailed guideline for these evaluations in Evaluation Reproducing section. For accuracy check of zero-shot (TABLE 3 and TABLE 4), the process is quite complex, so please refer to Zero-Shot Task Running section. Note that training script for TABLE 4 is available in TABLE 2 training script folder. Other experiments (not main evaluation) for figures can be run by changing options in speedup check scripts.</p>
<p>UPDATE: GPT-335M version scripts are added to ASPLOS23/fig10/ directory to test functionality in a small clutster.</p>
<p>Dataset making is explained in Dataset Preprocessing. Make the pretraining dataset based on the guideline and use the binarized dataset.</p>
<p>For detailed arguments and settings, please refer to below explanations.</p>

},
keywords = {3D Parallelism, Communication Optimization, Distributed Systems, Gradient Compression, Large-scale NLP Training, Pipeline Parallelism, Systems for Machine Learning}
}

@software{10.5281/zenodo.7221411,
author = {Won, Jaeyeon and Mendis, Charith and Emer, Joel S. and Amarasinghe, Saman},
title = {Artifact for paper "WACO: Learning Workload-Aware Co-optimization of the Format and Schedule of a Sparse Tensor Program"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7221411},
abstract = {
    <p>Our artifact includes programs for 1. training a cost model, 2. searching with a nearest neighbor search, and 3. a performance evaluator of the SuperSchedule. Our artifact is available at https://github.com/nullplay/Workload-Aware-Co-Optimization. Please follow the README.md instructions.</p>

},
keywords = {Approximate Nearest Neighbor Search, Auto-scheduling, Auto-tuning, Sparse Matrix, Sparse Tensor}
}

@software{10.5281/zenodo.7222132,
author = {Liu, Jiawei and Lin, Jinkun and Ruffy, Fabian and Tan, Cheng and Li, Jinyang and Panda, Aurojit and Zhang, Lingming},
title = {ASPLOS2023 Artifact for "NNSmith: Generating Diverse and Valid Test Cases for Deep Learning Compilers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222132},
abstract = {
    <p>The artifact contains evidence of bug finding, source code of NNSmith’s prototype, and user-friendly HTML documentation for re-generating the results. Specifically, it includes (1) links to bugs reported by the authors as real-world bug finding evidence, and (2) scripts and code to re-generate main results in § 5. To make artifact evaluation as simple as possible, our artifact is packaged into a pre-built docker image, along with a detailed and friendly HTML documentation. To fully evaluate the artifact, a X86-CPU platform with docker access is needed, with approximately 21 hours of machine time and 1 hour of manual inspection time.</p>

},
keywords = {Compiler, Fuzzing, Machine Learning Systems, Testing}
}

@software{10.5281/zenodo.7222728,
author = {Berlstein, Griffin and Nigam, Rachit and Gyurgyik, Christophe and Sampson, Adrian},
title = {Evaluation for "Stepwise Debugging for Hardware Accelerators"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222728},
abstract = {
    <p>This artifact consists of one piece of software, the Cider Interpreter and Debugger for Calyx, alongside data and helper scripts. Cider is a simulator and debugger for hardware accelerators written in the Calyx IR. Since Cider is also a simulator, it can be used to interpreter and debug hardware designs without lowering them from the IR to RTL.</p>
<p>This artifact seeks to reproduce the benchmark results discussed in our performance evaluation as well as the debugging process shown in section 3 of our paper. This supports our paper by showing the usability of Cider and how it compares to related tools, alongside demonstrating the debugging interface.</p>

},
keywords = {Accelerator Design, Accelerator Simulation, Debugging, Intermediate Language}
}

@software{10.5281/zenodo.7222794,
author = {Shen, Han and Pszeniczny, Krzysztof and Lavaee, Rahman and Kumar, Snehasish and Tallam, Sriraman and Li, Xinliang David},
title = {Artifacts for "Propeller: A Profile Guided, Relinking Optimizer for Warehouse Scale Applications"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222794},
abstract = {
    <p>The disassembly-driven, monolithic design of post link optimizers face scaling challenges with large binaries and is at odds with distributed build systems. To reconcile and enable post link optimizations within a distributed build environment, we propose Propeller, a relinking optimizer for warehouse scale workloads. Propeller uses basic block sections (a novel linker abstraction) to enable a new approach to post link optimization without disassembly. Propeller achieves scalability by relinking the binary using precise profiles instead of rewriting the binary. The overhead of relinking is lowered by caching and leveraging distributed compiler actions during code generation.</p>
<p>In this artifact, we present the means to replicate the results on a standalone machine. We provide a cloud-hosted bare metal machine which has been provisioned with the tooling and dependencies to run Propeller and Lightning BOLT. We use this environment to demonstrate Propeller’s approach to post link optimizations on a bootstraped build of clang. We show Propeller can achieve equitable performance to Lightning BOLT with lower peak memory consumption. A key aspect of Propeller enabled optimizations is the integration with a distributed build system which provides caching. To demonstrate the effect of caching we provide scripting which emulates the effect on a single machine. The scripts used to replicate the results are also publicly available at https://github.com/google/llvm-propeller.</p>

},
keywords = {Binary Optimization, Datacenters, Distributed Build System, Post-Link Optimization, Profile Guided Optimization, Warehouse-Scale Applications}
}

@software{10.5281/zenodo.7222849,
author = {Kim, Thomas and Jeon, Jekyeom and Arora, Nikhil and Li, Huaicheng and Kaminsky, Michael and Andersen, David G. and Ganger, Gregory R. and Amvrosiadis, George and Bj\o{}rling, Matias},
title = {RAIZN: Redundant Array of Independent Zoned Namespaces},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7222849},
abstract = {
    <p>Source code for RAIZN: Redundant Array of Independent Zoned Namespaces (ASPLOS 23)</p>

},
keywords = {RAID, Reliability, Storage, ZNS, Zoned Namespaces}
}

@software{10.5281/zenodo.7225459,
author = {Gao, Mingyu and Chakraborty, Soham and Ozkan, Burcu Kulahcioglu},
title = {Probabilistic Concurrency Testing for Weak Memory Programs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7225459},
abstract = {
    <p>The upload is a VagrantBox package, containing the artifact for the paper Probabilistic Testing for Weak Memory Programs. This vagrant package offers the experimental environment, which contains all code, benchmarks, and scripts to reproduce the experimental results in the paper.</p>

},
keywords = {Concurrency, Randomized algorithms, Testing, Weak memory}
}

@software{10.5281/zenodo.7240401,
author = {Liu, Congyu and Gong, Sishuai and Fonseca, Pedro},
title = {ASPLOS' 23 Artifact of "KIT: Testing OS-Level Virtualization for Functional Interference Bugs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7240401},
abstract = {
    <p>Container isolation is implemented through OS-level virtualization, such as Linux namespaces. Unfortunately, these mechanisms are extremely challenging to implement correctly and, in practice, suffer from functional interference bugs, which compromise container security. In particular, functional interference bugs allow an attacker to extract information from another container running on the same machine or impact its integrity by modifying kernel resources that are incorrectly isolated. Despite their impact, functional interference bugs in OS-level virtualization have received limited attention in part due to the challenges in detecting them. Instead of causing memory errors or crashes, many functional interference bugs involve hard-to-catch logic errors that silently produce semantically incorrect results. This paper proposes KIT, a dynamic testing framework that discovers functional interference bugs in OS-level virtualization mechanisms, such as Linux namespaces. The key idea of KIT is to detect inter-container functional interference by comparing the system call traces of a container across two executions, where it runs with and without the preceding execution of another container. To achieve high efficiency and accuracy, KIT includes two critical components: an efficient algorithm to generate test cases that exercise inter-container data flows and a system call trace analysis framework that detects functional interference bugs and clusters bug reports. KIT discovered 9 functional interference bugs in Linux kernel 5.13, of which 6 have been confirmed. All bugs are caused by logic errors, showing that this approach is able to detect hard-to-catch semantic bugs.</p>

},
keywords = {Bugs, OS-level Virtualization, Testing}
}

@software{10.5281/zenodo.7275326,
author = {Hu, Qinghao and Zhang, Meng and Sun, Peng and Wen, Yonggang and Zhang, Tianwei},
title = {Lucid Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7275326},
abstract = {
    <p>This artifact appendix describes how to reproduce main results in our paper. In our public repository, we provide the source code, related dataset and the instructions to perform artifact evaluation. Please refer to the README file for more details.</p>

},
keywords = {Cluster Management, Machine Learning, Workload Scheduling}
}

@software{10.5281/zenodo.7275790,
author = {Han, Sungsoo and Jang, Minseong and Kang, Jeehoon},
title = {Artifact for “ShakeFlow: Functional Hardware Description with Latency-Insensitive Interface Combinators”},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7275790},
abstract = {
    <p>This artifact contains our port of the Corundum 100Gbps NIC and BaseJump STL’s dataflow and network-on-chip modules to the ShakeFlow hardware description language, and scripts to reproduce the results presented in the paper.</p>
<p>For a full reproduction, the following hardware equipment is necessary:</p>
<ul>
<li><p>Xilinx Alveo U200</p></li>
<li><p>100Gbps NIC (e.g., Mellanox MCX556A-EDAT)</p></li>
<li><p>QSFP28 DAC cable</p></li>
<li><p>Two machines with a PCIe 3.0+ x16 slot</p></li>
</ul>
<p>For the full details, refer to the README.md of https://github.com/kaist-cp/shakeflow.</p>

},
keywords = {combinator, functional programming, hardware description language, latency insensitive interface}
}

@software{10.5281/zenodo.7277139,
author = {Fingler, Henrique and Tarte, Isha and Yu, Hangchen and Szekely, Ariel and Hu, Bodun and Akella, Aditya and Rossbach, Christopher J.},
title = {Artifacts of LAKE},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7277139},
abstract = {
    <p>Kernel API remoting system, kernel drivers of workloads and benchmarks scripts.</p>

},
keywords = {api remoting, kernel, ml for systems, systems for ml}
}

@software{10.5281/zenodo.7306303,
author = {Pandey, Shweta and Kamath, Aditya K and Basu, Arkaprava},
title = {Scoped Buffered Release Persistency Model for GPUs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7306303},
abstract = {
    <p>We provide the source code and setup for our GPU persistency model, Scoped Buffered Release Persistency (SBRP). SBRP is a scope-aware, buffered persistency model that provides high performance to GPU applications that wish to persist data on Non-Volatile Memory (NVM). SBRP modifies the GPU hardware and has been implemented using GPGPU-Sim, a GPU simulator. For more details on the simulator requirements, check the README in the simulator folder.</p>
<p>This repository consists of the source code of the simulator, benchmarks used for evaluation and all scripts needed to replicate the figures in the paper.</p>

},
keywords = {Grpahics Processing Unit, Persistent Memory}
}

@software{10.5281/zenodo.7311322,
author = {You, Xin and Yang, Hailong and Lei, Kelun and Luan, Zhongzhi and Qian, Depei},
title = {Reproduction Package for Article "VClinic: A Portable and Efficient Framework for Fine-Grained Value Profilers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7311322},
abstract = {
    <p>The provided docker images contain pre-built VClinic and compared value profilers. For X86 platforms, docker image “vclinic_artifact_x86.tar” should be used; otherwise, for ARM platforms, docker image “vclinic_artifact_arm.tar” should be used. As pin-based value profilers only support X86 platforms, we only include the built pin-based value profilers in the “vclinic_artifact_x86.tar” docker image. The detailed instructions for evaluating the artifacts as well as the estimated evaluation time for each step on both platforms are listed in “/home/vclinic_artifact/README.md”. The summary of how to set up the experimental environment is listed in README. Note that both “vclinic_artifact_x86.tar” and <code>vclinic_artifact_arm.tar</code> are pre-built docker images and one can directly follow the instructions in the README file to reproduce the evaluation results.</p>

},
keywords = {Dynamic Binary Instrumentation, Performance Analysis, Value Profiler}
}

@software{10.5281/zenodo.7319957,
author = {Porter, Chris and Khan, Sharjeel and Pande, Santosh},
title = {Decker},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7319957},
abstract = {
    <p>The Decker framework consists of a compiler pass and runtime library. Its main objective is to debloat software at runtime. The artifact includes a Docker image that encapsulates basic dependencies, the<br>
Decker code itself, benchmarks, and the scripts to drive artifact evaluation.</p>

},
keywords = {program security, software debloating}
}

@software{10.5281/zenodo.7330354,
author = {Aguilera, Marcos K. and Ben-David, Naama and Guerraoui, Rachid and Murat, Antoine and Xygkis, Athanasios and Zablotchi, Igor},
title = {Artifacts to reproduce all experiments in `uBFT: Microsecond-Scale BFT using Disaggregated Memory`},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7330354},
abstract = {
    <p>This artifact contains all the necessary source code to compile, execute and generate the data of all the figures in <code>uBFT: Microsecond-Scale BFT using Disaggregated Memory</code>.</p>

},
keywords = {Byzantine fault tolerance, disaggregated memory, fast path, finite memory, microsecond scale, RDMA, replication, signatureless}
}

@software{10.5281/zenodo.7333207,
author = {Hildenbrand, David and Schulz, Martin and Amit, Nadav},
title = {Software artifacts for the paper "Copy-on-Pin: The Missing Piece for Correct Copy-on-Write"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7333207},
abstract = {
    <p>Software artifacts for the paper “Copy-on-Pin: The Missing Piece for Correct Copy-on-Write”.</p>

},
keywords = {copy-on-write, COW, fork, memory deduplication, page pinning, page sharing, virtual memory}
}

@software{10.5281/zenodo.7339970,
author = {Sun, Jinghan and Li, Shaobo and Sun, Yunxin and Sun, Chao and Vucinic, Dejan and Huang, Jian},
title = {Artifact of "LeaFTL: A Learning-Based Flash Translation Layer for Solid-State Drives"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7339970},
abstract = {
    <p>This artifact is for reproducing the experiment results in the paper. The artifact includes the simulator source code with LeaFTL implementation, datasets for evaluation, and also scripts and instructions for reproducing the results. More details on the artifact can be found in the GitHub README File.</p>

},
keywords = {Flash Translation Layer, Learning-Based Storage, Solid-State Drive}
}

@software{10.5281/zenodo.7423535,
author = {Duan, Zhuohui and Yao, Jiabo and Liu, Haikun and Liao, Xiaofei and Jin, Hai and Zhang, Yu},
title = {Reproduction Package for Article `Revisiting Log-structured Merging for KV Stores in Hybrid Memory Systems’},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7423535},
abstract = {
    <p>All experimental results in Figures 6, 7, 8, 9, 10, 11, and 12 can be reproduced. These results can reflect the performance of MioDB.</p>

},
keywords = {Key-Value Store, Log-Structured Merge, LSM-tree Compaction, Non-Volatile Memory, Skip List}
}

@software{10.5281/zenodo.7425382,
author = {Huang, Haochen and Shen, Bingyu and Zhong, Li and Zhou, Yuanyuan},
title = {Reproduction Package for Paper `Protecting Data Integrity of Web Applications with Database Constraints Inferred from Application Code`},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7425382},
abstract = {
    <p>This repo is for the code release of our paper <code>Protecting Data Integrity of Web Applications with Database Constraints Inferred from Application Code.</code> in ASPLOS 2023.</p>
<p>In the paper, we developed a static analysis tool to infer the missing database constraints from the application source code.</p>

},
keywords = {Data integrity, Database constraints, Static analysis, Web applications}
}

@software{10.5281/zenodo.7429879,
author = {Ding, Yaoyao and Yu, Cody Hao and Zheng, Bojian and Liu, Yizhi and Wang, Yida and Pekhimenko, Gennady},
title = {Artifact for paper "Hidet: Task Mapping Programming Paradigm for Deep Learning Tensor Programs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7429879},
abstract = {
    <p>This artifact helps readers to reproduce all experiments in the evaluation section of our paper. In Section 6, there are 6 experiments (one end to end experiment and 5 case studies). These experiments compare Hidet with other DNN frameworks and compilers on representative DNN models from the perspective of execution latency, optimization time, schedule space, input sensitivity, and different batch sizes. In the public artifact, we provide scripts to launch the 6 experiments automatically. With the hardware and software described in Section A.3.2 and A.3.3, the artifact should reproduce all experimental results in the evaluation section.</p>

},
keywords = {artifact, deep learning compiler, deep nerual networks, inference}
}

@software{10.5281/zenodo.7430228,
author = {Hackett, Finn and Hosseini, Shayan and Costa, Renato and Do, Matthew and Beschastnikh, Ivan},
title = {Compiling Distributed System Models with PGo [evaluation]},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7430228},
abstract = {
    <p>This repository aggregates all the tools and data necessary to reproduce the results in the evaluation section of our ASPLOS 2023 paper.</p>
<p>Our artifact has two components. We provide the PGo compiler itself, which can compile MPCal specifications, and we also provide a method for reproducing our performance results from our ASPLOS 2023 paper. These files describe how to reproduce our performance results.</p>
<p>Our own set of results is included in the <code>results_paper/</code> folder. For how to use the included tools and how to interpret the included results, see the README.</p>

},
keywords = {Compilers, Distributed systems, Formal methods, PlusCal, TLA+}
}

@software{10.5281/zenodo.7439846,
author = {Yang, Shuangyan and Zhang, Minjia and Dong, Wenqian and Li, Dong},
title = {Betty: Enabling Large-Scale GNN Training with Batch-Level Graph Partitioning},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7439846},
abstract = {
    <p>The directory of the Betty includes dataset/, Figures/, pytorch/, README.md, requiremnets.sh. We can execute ‘bash install_requirements.sh’ to install requirments. After downloading benchmarks and generating full batch data into folder /Betty/dataset/. The directory pytorch contains all necessary files for the micro-batch training and mini-batch training. In folder micro_batch_train, graph_partitioner.py contains our implementation of redundancy embedded graph partitioning. block_dataloader.py is implemented to construct the micro-batch based on the partitioning results of REG. The folder Figures contains these important figures for analysis and performance evaluation.</p>

},
keywords = {Graph neural network, Graph partition, Redundancy reduction}
}

@software{10.5281/zenodo.7481637,
author = {Gu, Diandian and Zhao, Yihao and Zhong, Yinmin and Xiong, Yifan and Han, Zhenhua and Cheng, Peng and Yang, Fan and Huang, Gang and Jin, Xin and Liu, Xuanzhe},
title = {ElasticFlow Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7481637},
abstract = {
    <p>The artifact provides source code for the prototype of the proposed system ElasticFlow, including the main implementation of ElasticFlow, testbed experiment scripts (Section 6.2 \&amp; Section 6.6), and cluster simulation scripts (Section 6.3 \&amp; Section 6.4 \&amp; Section 6.5). We provide a docker image with pre-installed prerequisites to simplify the testbed experiment workflow. Users can also use a script to install all software dependencies from scratch. Please refer to the documents in our repository for more details.</p>

},
keywords = {Cluster Scheduling, Distributed Deep Learning, GPU Cluster, Serverless Computing}
}

@software{10.5281/zenodo.7493145,
author = {Jayarajan, Anand and Zhao, Wei and Sun, Yudi and Pekhimenko, Gennady},
title = {Reproduction package for the article 'TiLT: A Time-Centric Approach for Stream Query Optimization and Parallelization'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7493145},
abstract = {
    <p>This artifact appendix includes the source code and scripts to reproduce the scalability results and the real-world applications performance in the article ‘TiLT: A Time-Centric Approach for Stream Query Optimization and Parallelization’. We include docker containers to setup the runtime environment for all the experiments in order to support portability. Therefore, the artifact can be executed on any multi-core machine with docker engine installed. We also use Linux gnuplot utility to generate figures from the collected performance numbers. We  using Ubuntu 20.04 operating system for running the scripts provided in the artifact.</p>

},
keywords = {compiler, intermediate representation, stream data analytics, temporal query processing}
}

@software{10.5281/zenodo.7553144,
author = {Chen, Zhenpeng and Zhang, Jie M. and Sarro, Federica and Harman, Mark},
title = {Artifact for "MAAT: A Novel Ensemble Approach to Addressing Fairness and Performance Bugs for Machine Learning Software"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7553144},
abstract = {
    <p>This artifact is for the paper entitled “MAAT: A Novel Ensemble Approach to Addressing Fairness and Performance Bugs for Machine Learning Software”, which is accepted by ESEC/FSE 2022. MAAT is a novel ensemble approach to improving the fairness-performance trade-off for machine learning software. It outperforms state-of-the-art bias mitigation methods. In this artifact, we provide the source code of MAAT and other existing bias mitigation methods that we use in our study, as well as the intermediate results, the installation instructions, and a replication guideline (included in the README). The replication guideline provides detailed steps to replicate all the results for all the research questions.</p>

},
keywords = {bias mitigation, ensemble learning, fairness-performance trade-off, machine learning software, Software fairness}
}

@software{10.6084/m9.figshare.21354552.v2,
author = {Yuan, Ziqi and Hong, Siyu and Chang, Rui and Zhou, Yajin and Shen, Wenbo and Ren, Kui},
title = {Artifact of Article "VDom: Fast and Unlimited Virtual Domains on Multiple Architectures"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21354552.v2},
abstract = {
    <p>The artifact of paper “VDom: Fast and Unlimited Virtual Domains on Multiple Architectures”, consists of the source code of VDom modified Linux kernel, user-space libraries, all evaluation benchmarks, and scripts necessary to reproduce the paper’s evaluation results.</p>

},
keywords = {computer system security, operating system, operating systems, software security, virtualization}
}

@software{10.1145/3554347,
author = {Popoola, Tobi and Zhao, Tuowen and St. George, Aaron and Bhetwal, Kalyan and Strout, Michelle Mills and Hall, Mary and Olschanowsky, Catherine},
title = {Reproduction Package for Code Synthesis for Sparse Tensor Format Conversion and Optimization},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554347},
abstract = {
    <p>This artifact introduces a technique for data layout transformations based on constrained relationships between different forms of data. In this artifact, we apply this technique to generate code for transforming from one source format to another. We provide a docker container to replicate results. To ease testing we provide already generated transformation codes wrapped around necessary macros to evaluate our work. We also provide artifacts from the state-of-the-art discussed in our work.</p>

},
keywords = {Code synthesis, Index array properties, Polyhedral compilation, Sparse Format Conversion, Sparser Format Descriptors, Transformations, Uninterpreted functions}
}

@software{10.1145/3554348,
author = {Li, Bolun and Su, Pengfei and Chabbi, Milind and Jiao, Shuyin and Liu, Xu},
title = {Reproduction Package for Article "DJXPerf: Identifying Memory Inefficiencies via Object-Centric Profiling for Java"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554348},
abstract = {
    <p>DJXPerf is a lightweight, object-centric memory profiler for Java, which associates memory-hierarchy performance metrics (e.g., cache/TLB misses) with Java objects. DJXPerf uses statistical sampling of hardware performance monitoring counters to attribute metrics to not only source code locations but also Java objects.</p>

},
keywords = {Java, performance optimization, PMU, profiling}
}

@software{10.1145/3554349,
author = {Thangamani, Arun and Jost, Tiago Trevisan and Loechner, Vincent and Genaud, St\'{e}phane and Bramas, B\'{e}renger},
title = {Artifact for Lifting Code Generation of Cardiac Physiology Simulation to Novel Compiler Technology},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554349},
abstract = {
    <p>This artifact provides all required tools and dependencies needed to compile and execute applications, and generate figures 2, 3, 4 (optional), and 5 mentioned in the paper titled Lifting Code Generation of Cardiac Physiology Simulation to Novel Compiler Technology published in CGO’23.</p>

},
keywords = {Code Generation and Optimization, Code translation and transformation, Domain-specific languages, Parallel computing, Vectorization}
}

@software{10.1145/3554350,
author = {Mu, Wenlong and Zhang, Yilei and Huang, Bo and Guo, Jianmei and Cui, Shiqiang},
title = {Reproduction Package for Article “A Hotspot-Driven Semi-automated Competitive Analysis Framework for Identifying Compiler Key Optimizations”},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554350},
abstract = {
    <p>In order to identify the key optimizations adopted by some high-performance compilers, we propose a hotspot-driven semi-automatic framework for identifying key compiler optimizations through comparing the binaries generated by two different compilers. Firstly, the framework obtains the execution time and hotspot distribution information of binaries generated by two different compilers with the same source code through a performance analysis tool(Linux perf), and then the framework automatically selects the identified hotspots that cause the binaries‘ performance difference. We use DynamoRIO Client to analyze the instruction distribution characteristics of specific hotspots, which help us narrow down the scope of hotspots‘s binary analysis. All the above steps can be done automatically by the framework.</p>

},
keywords = {dynamic binary instrumentation, hotspots detection, semi-automated framework}
}

@software{10.1145/3554351,
author = {Rasch, Ari and Schulze, Richard and Shabalin, Denys and Elster, Anne and Gorlatch, Sergei and Hall, Mary},
title = {Reproduction Package for Article `(De/Re)-Compositions Expressed Systematically via MDH-Based Schedules'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554351},
abstract = {
    <p>This artifact contains the workflow to reproduce the experiments presented in the paper `(De/Re)-Compositions Expressed Systematically via MDH-Based Schedules’ accepted for publication at the ACM SIGPLAN 2023 International Conference on Compiler Construction. The user is invited to perform the steps described in file README.txt.</p>

},
keywords = {CPU, GPU, scheduling languages}
}

@software{10.1145/3554352,
author = {Patabandi, Tharindu R. and Hall, Mary},
title = {Reproduction package for "Efficiently Learning Locality Optimizations by Decomposing Transformation Domains"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554352},
abstract = {
    <p>The artifact contains executable binaries and trained predictive models to reproduce the results presented in the publication.</p>

},
keywords = {convolutional neural networks, data locality, loop permutation, Loop tiling, x86}
}

@software{10.5281/zenodo.7369395,
author = {Aanjaneya, Mridul and Nagarakatte, Santosh},
title = {Artifact for "Fast Polynomial Evaluation for Correctly Rounded Elementary Functions using the RLIBM Approach"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7369395},
abstract = {
    <p>Our library with the correctly rounded functions and the polynomial generator for them is available open source and publicly available at https://github.com/rutgers-apl/cgo23- artifact. It is available with the MIT license. The artifact includes: (1) 24 correctly rounded implementations for six elementary functions using the coefficient adaptation proce- dure by Knuth, Estrin’s method, and Estrin’s method with fused multiply-add operations for polynomial evaluation, (2) correctness testing framework for the 24 functions, (3) perfor- mance testing framework to demonstrate the performance improvements over RLibm and CRLIBM, and (4) polynomial generator for generating the polynomials using the Estrin’s method with fused multiply-add operations.</p>

},
keywords = {coefficient adaptation, correctly rounded, Estrin's procedure, fused-multiply-add, Horner's method, RLIBM}
}

@software{10.5281/zenodo.7374334,
author = {Wilkins, Michael and Westrick, Sam and Kandiah, Vijay and Bernat, Alex and Suchy, Brian and Deiana, Enrico Armenio and Campanoni, Simone and Acar, Umut A. and Dinda, Peter and Hardavellas, Nikos},
title = {Artifact for "WARDen: Specializing Cache Coherence for High-Level Parallel Languages"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7374334},
abstract = {
    <p>This artifact is a virtual machine of Red Hat Enterprise Linux (RHEL) containing the WARDen prototype and its dependen- cies. The artifact is pre-installed in the “cgo_artifact” account. The password is the same as the username: cgo_artifact. All the PBBS benchmarks used in the paper are also included. This artifact requires VMware Workstation 17 player to load and run the VM, which can be freely downloaded online.</p>

},
keywords = {cache coherence, disentanglement}
}

@software{10.5281/zenodo.7374649,
author = {Dam\'{a}sio, Tha\'{\i}s and Canesche, Michael and Pacheco, Vin\'{\i}cius and Botacin, Marcus and Faustino da Silva, Anderson and Quint\~{a}o Pereira, Fernando M.},
title = {Reproduction Package for Article `A Game-Based Framework to Compare Program Classifiers and Evaders'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7374649},
abstract = {
    <p>This artifact compares different program classification techniques and pits them against different evasion techniques. In total, this artifact let us evaluate nine program encoding techniques; seven code obfuscation passes; and seven stochastic classification models. The artifact consists of a docker container with accompanying scripts to replicate Figures 5-15 automatically, plus the dataset and accompanying instructions to replicate Figure 16 manually. For a more up-to-date version of this source code, check: https://github.com/lac-dcc/yali</p>

},
keywords = {deep learning, obfuscation, ollvm, optimization}
}

@software{10.5281/zenodo.7374843,
author = {Deiana, Enrico Armenio and Suchy, Brian and Wilkins, Michael and Homerding, Brian and McMichen, Tommy and Dunajewski, Katarzyna and Dinda, Peter and Hardavellas, Nikos and Campanoni, Simone},
title = {Artifact for "Program State Element Characterization" CGO 2023.},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7374843},
abstract = {
    <p>This artifact is a podman image containing the CARMOT system and its dependencies, and it generates the main results of this paper in text format. All benchmark suites are included in the artifact, except for SPEC CPU 2017, which we cannot share directly (please refer to README.md in the artifact on how to include SPEC CPU 2017 results). This artifact requires podman (or docker) to load and run the image, and a network connection to download additional dependencies of the CARMOT system. The execution of this artifact requires an Intel multicore processor with shared memory.</p>

},
keywords = {code optimization, dynamic analysis, program characterization}
}

@software{10.5281/zenodo.7459640,
author = {Brahmakshatriya, Ajay and Amarasinghe, Saman},
title = {Artifacts for the CGO23 paper: D2X: An eXtensible conteXtual Debugger for modern DSLs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7459640},
abstract = {
    <p>Artifacts for the CGO23 paper: D2X: An eXtensible conteXtual Debugger for modern DSLs</p>

},
keywords = {compilers, debuggers, DSLs}
}

@software{10.5281/zenodo.7496594,
author = {Zhang, Peihua and Wu, Chenggang and Peng, Mingfan and Zeng, Kai and Yu, Ding and Lai, Yuanming and Kang, Yan and Wang, Wei and Wang, Zhe},
title = {Reproduction Package for Article 'Khaos: The Impact of Inter-procedural Code Obfuscation on Binary Diffing Techniques'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7496594},
abstract = {
    <p>Artifact for article ‘Khaos: The Impact of Inter-procedural Code Obfuscation on Binary Diffing Techniques’, including diffing files of 5 diffing works, scripts to parse the diffing result, and all the result of the paper.</p>

},
keywords = {binary diffing, code obfuscation}
}

@software{10.5281/zenodo.7499096,
author = {Basso, Matteo and Ros\`{a}, Andrea and Omini, Luca and Binder, Walter},
title = {Artifact associated to the paper "Java Vector API: Benchmarking and Performance Analysis" published in CC'23},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7499096},
abstract = {
    <p>JVBench is the first open-source benchmark suite for the Java Vector API. It includes several realistic and diversified benchmarks, specifically designed for evaluating vectorization. This artifact consists of a ready-to-use Docker image embedding JVBench together with a set of tools/scripts that can be used to execute the JVBench workloads as well as collect, process and plot performance measurements to replicate the evaluation of JVBench presented in the paper “Java Vector API: Benchmarking and Performance Analysis” (CC’23). The artifact also contains the complete pre-collected performance measurements used to generated the original figures of the paper.</p>

},
keywords = {Benchmarks, Code optimization, Java, Just-in-time compilation, Parallelism, SIMD, Vector API}
}

@software{10.5281/zenodo.7499790,
author = {Ahrens, Willow and Donenfeld, Daniel and Kjolstad, Fredrik and Amarasinghe, Saman},
title = {Looplets: A Language For Structured Coiteration (The Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7499790},
abstract = {
    <p>An artifact supporting the results in the submitted version of our paper. The submitted version is included as a PDF with the artifact instructions at the end, though they are also available as a readme in the artifact itself.</p>

},
keywords = {Array, Coiteration, Compiler, Compressed, Sparse, Tensor}
}

@software{10.5281/zenodo.7517506,
author = {Salvador Rohwedder, Caio and Henderson, Nathan and De Carvalho, Jo\~{a}o P. L. and Chen, Yufei and Amaral, Jos\'{e} Nelson},
title = {Artifact for "To Pack or Not to Pack: A Generalized Packing Analysis and Transformation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7517506},
abstract = {
    <ul>
<li>docker-packing-artifact.tar.gz: docker image for the execution of experiments</li>
<li>llvm-packing-v0.5.zip: LLVM source code with packing implementation (binary in docker image)</li>
<li>logs-and-graphs.zip: Log files and graphs that were used in the paper</li>
<li>packing-scripts.zip: scripts used to run experiments and Dockerfile source&nbsp;(also provided in docker image) -&nbsp;polybench-c-4.2.1-plus-contract-3d.zip: Polybench 4.2 and running example of paper (also provided in docker image)</li>
</ul>

},
keywords = {Packing Optimization LLVM Compiler}
}

@software{10.5281/zenodo.7519936,
author = {Ben-Nun, Tal and Ates, Berke and Calotoiu, Alexandru and Hoefler, Torsten},
title = {Reproduction package for the paper Bridging Control-Centric and Data-Centric Optimization},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7519936},
abstract = {
    <p>Contains the benchmarking suite for the benchmarks shown in the paper as well as scripts and instructions on how to reproduce them.</p>

},
keywords = {DaCe, data-centric programming, MLIR}
}

@software{10.5281/zenodo.7521260,
author = {Mitenkov, George and Magkanaris, Ioannis and Awile, Omar and Kumbhar, Pramod and Sch\"{u}rmann, Felix and Donaldson, Alastair F.},
title = {Reproduction package for "MOD2IR: High-Performance Code Generation for a Biophysically Detailed Neuronal Simulation DSL"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7521260},
abstract = {
    <p>The artifact was created to complement the submission of the “MOD2IR: High-Performance Code Generation for a Biophysically Detailed Neuronal Simulation DSL” paper to the ACM SIGPLAN 2023 International Conference on Compiler Construction. It contains all the necessary source code, data and scripts to reproduce the results published in the paper.</p>

},
keywords = {Code Generation, Compiler, DSL, LLVM, NEURON, NMODL, Vectorization}
}

@software{10.5281/zenodo.7524279,
author = {Kandiah, Vijay and Lustig, Daniel and Villa, Oreste and Nellans, David and Hardavellas, Nikos},
title = {Artifact for CGO'23 paper titled "Parsimony: Enabling SIMD/Vector Programming in Standard Compiler Flows"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7524279},
abstract = {
    <p>Parsimony is a SPMD programming approach built with semantics designed to be compatible with multiple languages and to cleanly integrate into the standard optimizing compiler toolchains for those languages. This artifact is for our CGO’23 paper titled “Parsimony: Enabling SIMD/Vector Programming in Standard Compiler Flows” and includes a LLVM prototype of the Parsimony model along with a build and test framework for the Simd Library benchmarks and ispc benchmarks. It also includes scripts to build our prototype compiler, build and run the SimdLibrary and ispc benchmarks, and reproduce the figures 4 and 5 presented in our CGO’23 paper.</p>

},
keywords = {Code Transformation, Compiler Design, Single-instruction Multiple-data, Single-program Multiple-data, Vectorization}
}

@software{10.5281/zenodo.7533561,
author = {Mart\'{\i}nez, Pablo Antonio and Woodruff, Jackson and Armengol-Estap\'{e}, Jordi and Bernab\'{e}, Gregorio and Garc\'{\i}a, Jos\'{e} Manuel and O’Boyle, Michael F. P.},
title = {Reproduction package for 'Matching Linear Algebra and Tensor Code to Specialized Hardware Accelerators'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7533561},
abstract = {
    <p>The artifact contains the ATC compiler implemented with OCaml, the JIT compiler implemented in LLVM, the SVM classifier implemented with scikit-learn and the list of GEMM and convolution programs used in the paper. The artifact also contains other compilers used in the evaluation such as KernelFaRer, IDL and LLVM-Polly.</p>

},
keywords = {GEMM, JIT, LLVM, Program synthesis}
}

@software{10.5281/zenodo.7573782,
author = {Fried, Andreas and Stemmer-Grabow, Maximilian and Wachter, Julian},
title = {Register Allocation for Compressed ISAs in LLVM},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7573782},
abstract = {
    <p>We provide a Docker image to reproduce the central result of our work. Our artifact builds two versions of LLVM+Clang, with and without the compression-aware register allocator. It then compiles the SPEC CPU2000 and CPU2006 benchmarks with both compilers. The result of the experiment is a reproduction of figure 1 of our paper, along with other graphs not present in the paper.</p>
<p>Reviewers can also experiment with the parameters of the register allocator and observe their effect on the compression achieved.</p>

},
keywords = {compressed instruction sets, LLVM, register allocation, RISC-V}
}

@software{10.5281/zenodo.7574403,
author = {Matsumura, Kazuaki and De Gonzalo, Simon Garcia and Pe\~{n}a, Antonio J.},
title = {PTXASW},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7574403},
abstract = {
    <p>A symbolic emulator works for shuffle synthesis on the NVIDIA PTX code. Also, this artifact contains the benchmarks.</p>

},
keywords = {CUDA, NVIDIA PTX, OpenACC}
}

@software{10.5281/zenodo.7575072,
author = {VenkataKeerthy, S. and Jain, Siddharth and Kundu, Anilava and Aggarwal, Rohit and Cohen, Albert and Upadrasta, Ramakrishna},
title = {Artifacts for the paper "RL4ReAl: Reinforcement Learning for Register Allocation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7575072},
abstract = {
    <p>This artifact corresponds to the publication “RL4ReAl: Reinforcement Learning for Register Allocation”, published in CC 2023. This artifact consists of a docker image submitted for the artifact evaluation.</p>

},
keywords = {Graph Coloring, Register Allocation, Reinforcement Learning}
}

@software{10.5281/zenodo.7584642,
author = {Mezdour, Lina and Kadem, Khadidja and Merouani, Massinissa and Haichour, Amina Selma and Amarasinghe, Saman and Baghdadi, Riyadh},
title = {Reproduction Artifact for Article: A Deep Learning Model for Loop Interchange},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7584642},
abstract = {
    <p>This artifact introduces the model presented in the paper: A Deep Learning Model for Loop Interchange, published in CC23 conference, dedicated to predicting the best loop interchange instance for a Tiramisu program given as input. It reproduces the model’s training using the provided datasets, as well as all tests, performed on both the test set and the benchmark. It uses Python and PyTorch mainly.</p>
<p>This tool is presented through python scripts and pickle/json datasets. We present the different scripts in the following: - Model_training.py: It requires no input, provided that all scripts and dataset files are in the same folder, locally, and all default values are being used. It outputs the model with a pickle format. It shows throughout execution the loss values that the model is getting in both the training and the validation set, as well as the accuracy of the resulting model on both sets by the end. - Model_tests.py: It uses the default name of the pickle model (produced in the precedent script) to perform the tests described in the paper. It outputs: the results of the tests (on both the synthetic test set and the benchmark): the accuracy and the search performance. Moreover, it outputs a text file presenting the results for the search performance. - Utils.py: Helper functions</p>

},
keywords = {automatic code optimization, compilers, cost model, deep learning, loop interchange, Tiramisu}
}

@software{10.5281/zenodo.7639153,
author = {Shin, Yongwon and Park, Juseong and Cho, Sungjun and Sung, Hyojin},
title = {Reproduction Package for Article " PIMFlow: Compiler and Runtime Support for CNN Models on Processing-in-Memory DRAM"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7639153},
abstract = {
    <p>Our artifact consists of four parts: (1) PIM-aware ONNX transformation passes, (2) hardware measurement scripts for execution mode and granularity search, (3) an extended TVM compiler with DRAM-PIM back-end, and (4) GPU and DRAM-PIM simulators. For pre-generated input data, we provide GPU traces for the CNN models evaluated in the paper. You can also generate these traces by using NVBit2. For the compiler, we provide modified binaries and source codes for the TVM compiler extended with DRAM-PIM back- end. Artifact evaluation and testing are streamlined with a top-level script (pimflow) that controls different features of PIMFlow with lower-level scripts (Details in Section A.5). The evaluation and reproduction of the results in the paper can be done on any platform with the simulators, as long as the traces are generated on NVIDIA GeForce RTX 2080 Ti GPU.</p>

},
keywords = {CNN models, Processing-in-memory}
}

@software{10.6084/m9.figshare.21964787.v1,
author = {Peng, Mai Jacob and Dubach, Christophe},
title = {Reproduction Package for Artifact "LAGrad: Statically Optimized Differentiable Programming in MLIR"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21964787.v1},
abstract = {
    <p>This artifact contains the source code for LAGrad, pinned versions of LLVM and Enzyme, and the necessary scripts to reproduce the comparison against the state-of-the-art (Figures 7 and 8) in the CC ’23 paper “LAGrad: Statically Optimized Differentiable Programming in MLIR”.</p>

},
keywords = {automatic differentiation, differentiable programming, MLIR, sparsity, static analysis}
}

@software{10.6084/m9.figshare.21976358.v1,
author = {Rocha, Rodrigo C. O. and Saumya, Charitha and Sundararajah, Kirshanthan and Petoumenos, Pavlos and Kulkarni, Milind and O’Boyle, Michael F. P.},
title = {Artifact for "HyBF : A hybrid branch fusion strategy for code size reduction"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21976358.v1},
abstract = {
    <p>This is the artifact of the paper</p>
<p>“HyBF : A hybrid branch fusion strategy for code size reduction” Rodrigo Rocha, Charitha Saumya, Kirshanthan Sundararajah, Pavlos Petoumenos, Milind Kulkarni, Michael O’Boyle</p>
<p>published at the Conference on Compiler Construction, 2023.</p>
<p>We provide scripts that automate the installation and use of this artifact. Read README.md for detailed instructions.</p>

},
keywords = {branch fusion, code size, compiler optimizations, compilers, function merging, llvm}
}

@software{10.1145/3554353,
author = {Landgraf, Joshua and Giordano, Matthew and Yoon, Esther and Rossbach, Christopher J.},
title = {File System for Reconfigurable Fabrics Codebase},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554353},
abstract = {
    <p>This artifact contains the software and hardware code for FSRF, File System for Reconfigurable Fabrics, along with corresponding scripts and documentation for preparing test data, setting up the system, and running workloads and experiments.</p>

},
keywords = {FPGAs, Operating Systems, Virtual Memory, Virtualization}
}

@software{10.5281/zenodo.7564087,
author = {Feng, Yuan and Xu, Yingte},
title = {NQPV},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7564087},
abstract = {
    <p>NQPV is a verification assistant prototype of nondeterministic quantum programs. It implements the verification logic of partial correctness in the numerical form, with soundness guaranteed by the theory and experiments.</p>

},
keywords = {nondeterminism, program verification, quantum programming}
}

@software{10.5281/zenodo.7583154,
author = {Chen, Zizhan and Shao, Zili},
title = {Reproduction Package for Article ‘Transparent Runtime Change Handling for Android Apps’},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7583154},
abstract = {
    <p>The artifact provides the source code of RCHDroid, along with the instructions to generate the results. The artifact allows users to reproduce key results from the paper, including Figure 7, Figure 8, Figure 9, Figure 10, and Figure 14. The hardware must contain the ROC-RK3399-PC-PLUS development board connected to a screen. We provide compiled images to simplify the experiment workflow. Users can also build images from the source code.</p>

},
keywords = {embedded systems, mobile systems, operating systems}
}

@software{10.5281/zenodo.7583399,
author = {Bi, Jun and Guo, Qi and Li, Xiaqing and Zhao, Yongwei and Wen, Yuanbo and Guo, Yuxuan and Zhou, Enshuai and Hu, Xing and Du, Zidong and Li, Ling and Chen, Huaping and Chen, Tianshi},
title = {Reproduction pakage for Heron},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7583399},
abstract = {
    <p>This artifact describes how to set up the compilation infrastructure of HERON and how to run the workloads described in Section 6.2. Concretely, this guide provides instructions to: • Set up the experimental environment of HERON. • Run experiments to demonstrate the optimization ability of HERON as shown in Figure 6, Figure 7, Figure 8, and Figure 10. • Visualization of the search spaces as shown in Figure 11. • Run experiments to demonstrate the effectiveness of CGA as shown in Figure 12 and Figure 13.</p>

},
keywords = {code generation, compiler optimization, tensor computation}
}

@software{10.5281/zenodo.7588406,
author = {Lin, Mao and Zhou, Keren and Su, Pengfei},
title = {Reproduction Package for Article 'DrGPUM: Guiding Memory Optimization for GPU-Accelerated Applications'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7588406},
abstract = {
    <p>The artifact includes DrGPUM and benchmarks, along with instructions to reproduce the results shown in the paper.</p>

},
keywords = {CUDA, GPU profilers, GPUs, Memory management}
}

@software{10.5281/zenodo.7590151,
author = {Kolokasis, Iacovos G. and Evdorou, Giannos and Akram, Shoaib and Kozanitis, Christos and Papagiannis, Anastasios and Zakkak, Foivos S. and Pratikakis, Polyvios and Bilas, Angelos},
title = {TeraHeap: Reducing Memory Pressure in Managed Big Data Frameworks},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7590151},
abstract = {
    <p>How to Access. All scripts are available in the GitHub repository https://github.com/CARV-ICS-FORTH/asplos2023_ae. All sources, including JVM, frameworks, and benchmarks, are included as public git submodules. Also, the artifact is available at https://doi.org/10.5281/zenodo.7590151.</p>
<p>Hardware Dependencies. We recommend a dual-socket server that is equipped with two Intel(R) Xeon(R) CPU E5-2630 v3 CPUs running at 2.4 GHz, each with eight physical cores and 16 hyper-threads for a total of 32 hyper-threads. The server should have at least 128 GB DRAM. We recommend using two 1 TB Samsung PM983 PCI Express NVMe SSDs and an HDD (larger than 1.5 TB) to allocate the datasets. For the evaluation with NVM, we consider using a dual-socket server with two Intel Xeon Platinum 8260M CPUs at 2.4 GHz, with 24 cores and (96 hyper-threads), and 192 GB of DDR4 DRAM. We use Intel Optane DC Persistent Memory with a total capacity of 3 TB, of which 1 TB is in Memory mode and 2 TB are in AppDirect mode.</p>
<p>Software Dependencies. The compilation environment and the provided scripts assume Centos 7, which uses Linux Kernel v.3.10 and v.4.14.</p>
<p>Data Sets. The required datasets for Spark workloads (except BC) are automatically generated using the SparkBench suite dataset generator. The dataset will be generated when executing the specific scripts to run Spark workloads. The datasets for Spark-BC and Giraph workloads are downloaded automatically before each workload execution.</p>

},
keywords = {fast storage devices, garbage collection, Java Virtual Machine (JVM), large analytics datasets, large managed heaps, memory hierarchy, memory management, serialization}
}

@software{10.5281/zenodo.7591603,
author = {Malik, Raghav and Sheth, Kabir and Kulkarni, Milind},
title = {Coyote: A Compiler for Vectorizing Encrypted Arithmetic Circuits (artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7591603},
abstract = {
    <p>This artifact contains everything necessary to replicate the results of the paper, including: * An implementation of the compiler described in the paper * A backend test harness for profiling vectorized code * Implementations of all benchmarks used in the evaluation * Scripts necessary to automate the process of compiling, running, and collecting data from the benchmarks.</p>

},
keywords = {arithmetic circuits, Homomorphic encryption, vectorization}
}

@software{10.5281/zenodo.7591742,
author = {Hsu, Olivia and Strange, Maxwell and Sharma, Ritvik and Won, Jaeyeon and Olukotun, Kunle and Emer, Joel S. and Horowitz, Mark A. and Kj\o{}lstad, Fredrik},
title = {Reproduction Package for 'The Sparse Abstract Machine'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7591742},
abstract = {
    <p>This artifact describes how to set up and run our Sparse Abstract Machine (SAM) Python simulator and the C++ CUSTARD compiler, which compiles from concrete index notation (CIN) to SAM graphs (represented and stored in the DOT file format). The artifact also describes how to reproduce the quantitative experimental results in this paper. The artifact can be executed with any X86-64 or M-series Apple machine with Docker support and Python 3, at least 32 GB of RAM, and more than 20 GB of disk space.</p>
<p>Additionally, all instructions and dependencies for using the artifact are contained in the artifact appendix of the paper.</p>

},
keywords = {abstract machine, compilers, cycle-approximate modeling, sparse tensor algebra, streaming dataflow}
}

@software{10.5281/zenodo.7592823,
author = {Tan, Zujun and Chon, Yebin and Kruse, Michael and Doerfert, Johannes and Xu, Ziyang and Homerding, Brian and Campanoni, Simone and August, David I.},
title = {SPLENDID: Supporting Parallel LLVM-IR Enhanced Natural Decompilation for Interactive Development},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7592823},
abstract = {
    <p>The artifact for this paper contains tools and data to reproduce, with minimal effort, the entire testing flow and corroborate its claims. All results can be generated from scratch (source codes) and run across different platforms with the provided docker image. The pre-built docker image supports runs across different platforms with software dependencies taken care of, including a pre-compiled copy of the proposed decompiler, its variants, state-of-the-art decompilers used for comparison, and miscellaneous software such as vim and python. We provide an easy top level interface,  to simplify the testing process.</p>

},
keywords = {ASPLOS'23, Automatic Parallelization, Decompiler}
}

@software{10.5281/zenodo.7592848,
author = {Norman, Chase and Godbole, Adwait and Manerkar, Yatin A.},
title = {Code for Article 'PipeSynth: Automated Synthesis of Microarchitectural Axioms for Memory Consistency'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7592848},
abstract = {
    <p>This is the code for the ASPLOS 2023 paper ‘PipeSynth: Automated Synthesis of Microarchitectural Axioms for Memory Consistency’.</p>

},
keywords = {formal methods, memory consistency, microarchitecture, synthesis}
}

@software{10.5281/zenodo.7592970,
author = {Gao, Xiangyu and Raghunathan, Divya and Fang, Ruijie and Wang, Tao and Zhu, Xiaotong and Sivaraman, Anirudh and Narayana, Srinivas and Gupta, Aarti},
title = {Reproduction Package for Article CaT: A Solver-Aided Compiler for Packet-Processing Pipelines},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7592970},
abstract = {
    <p>This is the artifact evaluation part for the CaT compiler, proposed in our paper. The instruction helps reproduce the results from all tables and figures in IMPLEMENTATION AND EVALUATION section.</p>

},
keywords = {code generation, integer linear programming, packet processing pipelines, program synthesis, Programmable switches}
}

@software{10.5281/zenodo.7598726,
author = {Shu, Junyi and Zhu, Ruidong and Ma, Yun and Huang, Gang and Mei, Hong and Liu, Xuanzhe and Jin, Xin},
title = {Reproduction Package for Article 'Disaggregated RAID Storage in Modern Datacenters'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7598726},
abstract = {
    <p>We provide the artifact for the ASPLOS 2023 paper “Disaggregated RAID Storage in Modern Datacenters”, including:</p>
<ul>
<li>The main implementation of dRAID.</li>
<li>CloudLab testbed setup scripts.</li>
<li>FIO experiment scripts (Sec 9.2-9.5), which get the main results of the paper.</li>
<li>YCSB experiment scripts (Sec 9.6).</li>
</ul>

},
keywords = {Disaggregated Storage, NVMe-oF, RAID, RDMA}
}

@software{10.5281/zenodo.7612226,
author = {Li, Shaohua and Su, Zhendong},
title = {Artifact for "Finding Unstable Code via Compiler-Driven Differential Testing"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7612226},
abstract = {
    <p>The artifact contains the code and datasets we used for our experiments, as well as scripts to generate the numbers, tables, and figures of our evaluation. Specifically, it includes (a) the Juliet testsuite used for evaluation; (b) scripts for running CompDiff, sanitizers, Coverity, CppCheck, and Infer on the Juliet testsuite; (c) scripts for reporting detection results of these tools; (d) scripts for generating bug statistics on 23 real-world programs; and (e) scripts for fuzzing a target with CompDiff-AFL++. Everything is packaged and pre-built as a docker image. A standard X86 Linux machine running docker is necessary to evaluate this artifact.</p>

},
keywords = {compiler, fuzzing, undefined behavior, Unstable code}
}

@software{10.5281/zenodo.7621336,
author = {Wang, Haoyuan and Beamer, Scott},
title = {RepCut: Superlinear Parallel RTL Simulation with Replication-Aided Partitioning},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7621336},
abstract = {
    <p>This package contains the artifact for of RepCut: Superlinear Parallel RTL Simulation with Replication-Aided Partitioning, DOI 10.1145/3582016.3582034</p>
<p>This artifact contains the source code for RepCut, as well as other open source projects that are required to reproduce the results in the paper. We include Verilator 4.226 as a baseline. In addition, this artifact also contains scripts and a Makefile to compile and run the generated simulators, as well as to reproduce every figure and table from experiment data.</p>
<p>Please find more details in README.md</p>

},
keywords = {Parallel RTL Simulation, RepCut}
}

@software{10.5281/zenodo.7633678,
author = {Garimella, Karthik and Ghodsi, Zahra and Jha, Nandan Kumar and Garg, Siddharth and Reagen, Brandon},
title = {Source Code for "Characterizing and Optimizing End-to-End Systems for Private Inference"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7633678},
abstract = {
    <p>We open source our private inference simulator at the following GitHub repo: <a href="https://github.com/kvgarimella/characterizing-private-inference">https://github.com/kvgarimella/characterizing-private-inference</a>. We construct a model of a system for private inference and a simulator using Simpy to explore and evaluate tradeoffs under different system conditions. We model a single-client, single-server setting where inferences are queued in a FIFO manner and are generated by sampling from a Poisson distribution.</p>
<p>The repository itself contains four high-level directories. The directory <code>garbled_circuits</code> contains the raw data for benchmarking ReLU Garbling and Evaluation on an Intel Atom Z8350 embedded device (1.92GHz, 4 cores, 2GB RAM) and an AMD EPYC 7502 server (2.5GHz, 32 cores, 256GB RAM). These two devices represent our client and server, respectively. Next, the directory <code>layer_parallel_HE</code> contains our code and the raw data for applying layer-parallelism to linear layer homomorphic evaluations. The directory <code>simulator</code> contains our private inference simulator. Finally, <code>artifact</code> contains scripts to replicate key figures in our paper.</p>

},
keywords = {cryptography, machine learning, private inference protocols, systems for machine learning}
}

@software{10.5281/zenodo.7643745,
author = {Ye, Zihao and Lai, Ruihang and Shao, Junru and Chen, Tianqi and Ceze, Luis},
title = {SparseTIR Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7643745},
abstract = {
    <p>This repository contains scripts for setting up environments and reproducing results presented in the ASPLOS 2023 paper entitled SparseTIR: Composable Abstractions for Deep Learning.</p>
<p>Please read the README.md file or visit https://github.com/uwsampl/sparsetir-artifact for instructions on how to run and install this artifact.</p>

},
keywords = {Deep-Learning-Compilers, Sparse-Computation, Tensor-Compilers}
}

@software{10.5281/zenodo.7651655,
author = {Khazraee, Moein and Forencich, Alex and Papen, George C. and Snoeren, Alex C. and Schulman, Aaron},
title = {Code for Rosebud, Making FPGA-Accelerated Middlebox Development More Pleasant},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7651655},
abstract = {
    <p>This artifact contains the code to generate the Rosebud image, alongside code for simulation and runtime development. It also describes how new applications can be accelerated using this framework.</p>

},
keywords = {200G, FPGA, Hardware-Software Co-design, Middlebox}
}

@software{10.5281/zenodo.7668541,
author = {Raina, Ashwini and Lu, Jianan and Cidon, Asaf and Freedman, Michael J.},
title = {ASPLOS 2023 Artifact for "Efficient Compactions Between Storage Tiers with PrismDB"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7668541},
abstract = {
    <p>This artifact consists of the source code of PrismDB and the necessary scripts to reproduce the evaluation of the paper “Efficient Compactions Between Storage Tiers with PrismDB”, ASPLOS 23.</p>
<p>NOTE: Source code for the baselines rocksdb and mutant is not provided here. For rocksdb baseline, please refer to its official documentation on GitHub. For mutant baseline please follow the mutant SoCC paper.</p>

},
keywords = {compaction, key-value store, PrismDB, storage, tiered}
}

@software{10.5281/zenodo.7680535,
author = {Zuo, Gefei and Ma, Jiacheng and Quinn, Andrew and Kasikci, Baris},
title = {Reproduction Package for Article "Vidi: Record Replay for Reconfigurable Hardware"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7680535},
abstract = {
    <p>Source code is available at https://github.com/efeslab/aws-fpga</p>
<p>This artifact is prepared for ASPLOS 2023 artifact evaluation. Please refer to the <code>artifact-eval/README.md</code> for usage instructions.</p>

},
keywords = {Debugging, FPGA, Record Replay}
}

@software{10.5281/zenodo.7685681,
author = {Laeufer, Kevin and Iyer, Vighnesh and Biancolin, David and Bachrach, Jonathan and Nikoli\'{c}, Borivoje and Sen, Koushik},
title = {Simulator Independent Coverage for RTL Hardware Languages - Software Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7685681},
abstract = {
    <p>The code to reproduce results from our ASPLOS’23 paper on “Simulator Independent Coverage for RTL Hardware Languages”. Most results can be reproduced on a standard x86 Linux computer, however, for the FireSim performance and area/frequency results a more complicated setup on AWS cloud FPGAs is necessary. Please consult the Readme.md in <code>simulator-independent-coverage.tar.gz</code> for more instructions.</p>

},
keywords = {Chisel, ChiselTest, FireSim, FIRRTL, FPGA, FSM Coverage, Hardware Compiler, Line Coverage, RTL, Toggle Coverage}
}

@software{10.5281/zenodo.7699872,
author = {Ye, Haojie and Vedula, Sanketh and Chen, Yuhan and Yang, Yichen and Bronstein, Alex and Dreslinski, Ronald and Mudge, Trevor and Talati, Nishil},
title = {Reproduction Package for Article "GRACE: A Scalable Graph-Based Approach To Accelerating Recommendation Model Inference"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7699872},
abstract = {
    <p>Our paper “GRACE: A Scalable Graph-Based Approach To Accelerating Recommendation Model Inference” presents an algorithm-system co-design for improving the performance of the embedding layer in Deep Learning Recommendation Models (DLRMs). This artifact reproduces some of the main results of our paper. The performance results shown in the paper are machine-dependent. For example, Fig. 8, Fig. 13, and Fig. 14 show results on a CPU-GPU system, HBM-only system, and DIMM-HBM system with Processing-In-Memory (PIM) capability, respectively. To enable reproducing results in a timely fashion on different machines, we reproduce the main result of our paper that is machine-independent (Fig. 10). Specifically, our instructions include 1) how to download the input datasets, 2) how to pre-process these datasets, 3) how to reproduce the memory traffic reduction results for each baseline, and 4) how to generate a plot similar to Fig. 10. Expected result: compared to a no-reduction baseline, GRACE reduces the memory traffic by 1.7x.</p>

},
keywords = {Algorithm-System Co-Design, DLRM, Embedding Reduction}
}

@software{10.5281/zenodo.7702231,
author = {Liu, Jiesong and Zhang, Feng and Guan, Jiawei and Sung, Hsin-Hsuan and Guo, Xiaoguang and Du, Xiaoyong and Shen, Xipeng},
title = {Artifact for Article "Space Efficient TREC for Enabling Deep Learning on Microcontrollers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7702231},
abstract = {
    <p>This directory contains the artifact for Space Efficient TREC for Enabling Deep Learning on Microcontrollers published in ASPLOS 2023. For detailed information, please see the readme.md in TREC-Artifact.zip.</p>

},
keywords = {Compiler Optimization, Real-time Machine Learning}
}

@software{10.5281/zenodo.7709303,
author = {Gosakan, Krishnan and Han, Jaehyun and Kuszmaul, William and Mubarek, Ibrahim N. and Mukherjee, Nirjhar and Sriram, Karthik and Tagliavini, Guido and West, Evan and Bender, Michael A. and Bhattacharjee, Abhishek and Conway, Alex and Farach-Colton, Martin and Gandhi, Jayneel and Johnson, Rob and Kannan, Sudarsun and Porter, Donald E.},
title = {Mosaic Pages: Big TLB Reach with Small Pages},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709303},
abstract = {
    <p>There are three artifacts for this paper: a Gem5 model to reproduce Figure 4, a modified Linux kernel to reproduce Tables 3 and 4, and Verilog code to reproduce Table 5. The Linux artifact includes scripts to setup a KVM environment with Mosaic and vanilla Linux kernels. The artifact also includes scripts to run the Linux workloads in a VM and a script to generate tables.</p>

},
keywords = {address translation, gem5, hashing, linux, paging, TLB, verilog, virtual memory}
}

@software{10.6084/m9.figshare.22029956.v1,
author = {Ma, Teng and Chen, Shanpei and Wu, Yihao and Deng, Erwei and Song, Zhuo and Chen, Quan and Guo, Minyi},
title = {Reproduction Package for Paper "Efficient Scheduler Live Update for Linux Kernel with Modularization"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.22029956.v1},
abstract = {
    <p>Plugsched is a SDK that enables live updating the Linux kernel scheduler. It can dynamically replace the scheduler subsystem without rebooting the system or applications, with milliseconds downtime. Plugsched can help developers to dynamically add, delete and modify kernel scheduling features in the production environment, which allows customizing the scheduler for different specific scenarios.</p>

},
keywords = {kernel, Linux scheduler, live update}
}

@software{10.6084/m9.figshare.22081901.v1,
author = {Swamy, Tushar and Zulfiqar, Annus and Nardi, Luigi and Shahbaz, Muhammad and Olukotun, Kunle},
title = {Artifact for "Homunculus: Auto-Generating Efficient Data-Plane ML Pipelines for Datacenter Networks" - ASPLOS 2023},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.22081901.v1},
abstract = {
    <p>The artifact contains the source code for the titular Homunculus compiler, a backend for the Taurus ASIC switch architecture, as well as three representative applications. We used these applications to demonstrate the core results of our paper, i.e., how Homunculus-generated models outperform or match the hand-tuned baseline versions. We include applications for anomaly detection, traffic classification, and botnet detection. Homunculus also generates the appropriate hardware code for each of these applications to run on a Taurus switch architecture.</p>

},
keywords = {ML Compilers, Per-packet ML, Self-driving Networks}
}

@software{10.5281/zenodo.7114594,
author = {Waleffe, Roger and Mohoney, Jason and Rekatsinas, Theodoros and Venkataraman, Shivaram},
title = {Accompanying artifact for the paper "MariusGNN: Resource-Efficient Out-of-Core Training of Graph Neural Networks"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7114594},
abstract = {
    <p>This release contains the initial artifact for the paper MariusGNN: Resource-Efficient Out-of-Core Training of Graph Neural Networks to be published at EuroSys 2023. The artifact contains the necessary code to reproduce experiments reported in the paper.</p>
}
}

@software{10.1145/3554354,
author = {Wang, Chenglin and Lin, Fangzhen},
title = {Reproduction package for paper "Solving Conditional Linear Recurrences for Program Verification: The Periodic Case"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554354},
abstract = {
    <p>This repo contains a conditional recurrence solver which tries to solve a conditional linear recurrence. As claimed by the Theorem 5.2 in the paper, if the index sequence of the input recurrence is ultimately periodic and the periodic constraints (formula (14) in the paper) lie in language <span class="math inline">ℒ</span>, then a closed-form solution to the recurrence will be computed successfully.</p>
<p>Solving parameterized conditional linear recurrences (Sec 7.1 of the paper), in which the initial values are unknown, is also be implemented.</p>
<p>To show the effectiveness of our recurrence solver for program verification, a program verifier that tries to verify the correctness of an assertion in a C program is also implemented.</p>

},
keywords = {invariant generation, loop summarization, Recurrence solving}
}

@software{10.5281/zenodo.7503088,
author = {Lin, Zhengyao and Chen, Xiaohong and Trinh, Minh-Thai and Wang, John and Ro\c{s}u, Grigore},
title = {Reproduction Docker Image for `Generating Proof Certificates for a Language-Agnostic Deductive Program Verifier'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7503088},
abstract = {
    <p>This artifact is an Docker image containing code and experiment setup for our paper.</p>

},
keywords = {Matching Logic, Program Verification, Reachability Logic}
}

@software{10.5281/zenodo.7510752,
author = {Winter, Levin N. and Buse, Florena and de Graaf, Daan and von Gleissenthall, Klaus and Kulahcioglu Ozkan, Burcu},
title = {Artifact for "Randomized Testing of Byzantine Fault Tolerant Consensus Algorithms"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7510752},
abstract = {
    <p>This upload is a virtual machine (VM) containing the artifact accompanying our paper “Randomized Testing of Byzantine Fault Tolerant Algorithms”. The VirtualBox VM image contains the source code for our testing algorithm and the systems under test. The VM has all the dependencies resolved.</p>

},
keywords = {Byzantine fault-tolerance, Distributed algorithms, Distributed consensus, Random testing, Software testing and debugging}
}

@software{10.5281/zenodo.7511039,
author = {Lattuada, Andrea and Hance, Travis and Cho, Chanhee and Brun, Matthias and Subasinghe, Isitha and Zhou, Yi and Howell, Jon and Parno, Bryan and Hawblitzel, Chris},
title = {Software Artifact (virtual machine, pre-built distributions) for "Verus: Verifying Rust Programs using Linear Ghost Types"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7511039},
abstract = {
    <p>This is the software artifact accompanying the OOPSLA 2023 Paper “Verus: Verifying Rust Programs using Linear Ghost Types”. Verus is an SMT-based tool for formally verifying Rust programs. With Verus, programmers express proofs and specifications using the Rust language, allowing proofs to take advantage of Rust’s linear types and borrow checking. We show how this allows proofs to manipulate linearly typed permissions that let Rust code safely manipulate memory, pointers, and concurrent resources. We demonstrate Verus on a series of examples, including pointer-manipulating code (an xor-based doubly linked list), code with interior mutability, and concurrent code.</p>
<p>The artifact contains a virtual machine image and pre-built distributions of Verus, and the examples and scripts used for evaluation in the paper. The artifact demonstrates that (i) Verus runs correctly, (ii) it successfully verifies example code that exercises the paper’s claims and (iii) the examples verify quickly. More detail is available on the artifact page on Zenodo.</p>

},
keywords = {linear types, Rust, systems verification}
}

@software{10.5281/zenodo.7574712,
author = {Wagner, Christopher and Jaber, Nouraldin and Samanta, Roopsha},
title = {Enabling Bounded Verification of Doubly-Unbounded Distributed Agreement-Based Systems via Bounded Regions (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7574712},
abstract = {
    <p>Venus is a tool for formal verification of doubly-unbounded distributed agreement-based (DAB) systems that combines a variable domain reduction with a recent tool, QuickSilver (ref: https://zenodo.org/record/5501650), for parameterized verification of DAB systems with finite-state processes.</p>

},
keywords = {Data Saturation, Layered Verification, Reduction}
}

@software{10.5281/zenodo.7697453,
author = {Goharshady, Amir Kafshdar and Hitarth, S. and Mohammadi, Fatemeh and Motwani, Harshit Jitendra},
title = {PolySynth},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7697453},
abstract = {
    <p>PolySynth is a tool for synthesis of polynomial programs in a C-like imperative programming language where all assignments, guards, and assertions are restricted to be polynomial expression over the program variables. Our tool is implemented in Python3 is open source. Our algorithm, as described in our paper, is based on Farkas’ Lemma, Handelman Theorem, and Putinar’s Positivstellensatz.</p>
<p>The artifact code consists of the following main directories.</p>
<ol type="1">
<li><p>The directory <code>benchmarks-polysynth</code> contains all the benchmarks in theformat that can be passed to our tool PolySynth.</p></li>
<li><p>The directory <code>benchmarks-rosette</code> contains all the benchmarks that can bepassed to Rosette.</p></li>
<li><p>The directory <code>benchmarks-sketch</code> contains all the benchmarks that can bepassed to Sketch.</p></li>
<li><p>The directory <code>Code</code> contains the code for our main algorithms.</p></li>
<li><p>The directory <code>polysynth-outputs</code> contains the output programs and other intermediate files our tool Polysynth creates for all of the benchmarks.</p></li>
</ol>
<p>Follow the following steps to run the synthesizer on a given benchmark:</p>
<p>Open the terminal and change the directory to <code>Code/</code></p>
<p>All the examples/benchmarks are stored in the folder <code>benchmarks-polysynth</code></p>
<p>The easiest way to run an example is to type the following command: sh run_polysynth_all_benchmarks.sh from the root directory of the repository.</p>
<p>Suppose you want to run the synthesizer for the example Closest_cube_root, then you would run the following command:</p>
<p><code>python3 synthesizer.py --filename Examples/Closest_cube_root/closest_cube_root.c</code></p>

},
keywords = {algebro-geometric algorithm, polynomial programs, program synthesis, template-based synthesis}
}

@software{10.5281/zenodo.7698353,
author = {Zhang, Xing and Guo, Guanchen and He, Xiao and Hu, Zhenjiang},
title = {Reproduction Package for Article 'Bidirectional Object-Oriented Programming: Towards Programmatic and Direct Manipulation of Objects'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7698353},
abstract = {
    <p>Our paper presents a bidirectional object-oriented language BiFJ (a Featherweight-Java-like language) that supports programmatic and direct manipulation of objects. The artifact BiOOP is a programming environment to support BiFJ in single web-page GUI design. As shown below, BiOOP supports developers not only to write object-oriented programs in the left editor and get the output (e.g., a web page) in the right Output window, but also to directly manipulate the output on the right, and automatically synchronize the manipulated output with the object-oriented program.</p>

},
keywords = {Bidirectional Transformation, Direct Manipulation Programming, Object-oriented Programming}
}

@software{10.5281/zenodo.7709003,
author = {Wang, Bo and Kolluri, Aashish and Nikoli\'{c}, Ivica and Baluta, Teodora and Saxena, Prateek},
title = {DuoGlot: User-Customizable Transpilation of Scripting Languages (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709003},
abstract = {
    <p>This is the artifact named DuoGlot from the paper User-Customizable Transpilation of Scripting Languages accepted by the conference OOPSLA 2023. DuoGlot is a customizable code translator. Translation rules in DuoGlot are synthesized from user-provided code snippets. DuoGlot iteratively explores possible translations given the provided translation rules until finding a translation that passes tests. It currently supports customized translation from Python to JavaScript for single-file standalone programs. This artifact includes code and datasets to reproduce all the main results in the paper.</p>

},
keywords = {Program Synthesis, Program Translation}
}

@software{10.5281/zenodo.7710436,
author = {Kang, Chan Gu and Oh, Hakjoo},
title = {Artifact for paper "Modular Component-Based Quantum Circuit Synthesis"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7710436},
abstract = {
    <p>This artifact manual aims to reproduce results in the paper “Modular Component-based Quantum Circuit Synthesis” submitted to OOPSLA 2023. Our algorithm produces a quantum circuit, given user-provided in/output spec and component gates for circuit synthesis. Following the artifact manual (attached artifiact_manual.pdf) will give:</p>
<ul>
<li>Reproduction of Table 3 in our paper, which is main result of our synthesis experiment</li>
<li>Explanation on how to give new input (i.e, new synthesis problem) to our program</li>
<li>Reproduction of qiskit’s transpiled circuit appeared in Figure 2, 7, 8 of our paper</li>
</ul>
<p>Our project also can be found in Github Repository (https://github.com/kupl/qsyn).</p>

},
keywords = {Quantum circuit synthesis, Quantum programming}
}

@software{10.5281/zenodo.7711788,
author = {Dardinier, Thibault and Parthasarathy, Gaurav and M\"{u}ller, Peter},
title = {Verification-Preserving Inlining in Automatic Separation Logic Verifiers (artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7711788},
abstract = {
    <p>This artifact contains: 1. An Isabelle/HOL mechanization that fully supports the technical claims from the paper. 2. A reproducible analysis of the test suites of VeriFast, GRASShopper, RSL-Viper, and Nagini, corresponding to the results shown in table 1. 3. An inlining tool for Viper, which inlines calls and unrolls loops, while also checking the structural condition. 4. A test framework that runs the inlining tool on the examples in table 2 (main paper) and table 3 (appendix in the extended version).</p>

},
keywords = {Bounded Verification, GRASShopper, Isabelle, Isabelle/HOL, Loop Unrolling, Method Inlining, Modular Verification, Nagini, RSL-Viper, VeriFast, Viper}
}

@software{10.5281/zenodo.7712620,
author = {Mulder, Ike and Krebbers, Robbert},
title = {Artifact of 'Proof Automation for Linearizability in Separation Logic'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7712620},
abstract = {
    <p>This is the artifact for the OOPSLA ‘23 paper ’Proof Automation for Linearizability in Separation Logic’. It contains the Diaframe 2.0 source code, a VM containing a compiled version of this source code, and instructions for evaluation.</p>
<p>Diaframe 2.0’s current development can be found at https://gitlab.mpi-sws.org/iris/diaframe .</p>

},
keywords = {automated reasoning, Coq, Iris, program verification, Separation logic}
}

@software{10.5281/zenodo.7713722,
author = {Yuan, Yongwei and Guest, Scott and Griffis, Eric and Potter, Hannah and Moon, David and Omar, Cyrus},
title = {Artifact for "Live Pattern Matching with Typed Holes"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7713722},
abstract = {
    <p>The artifact includes a proof mechanization that concludes the type safety of the system presented in the paper, and a minimal solver-based implementation of exhaustiveness and redundancy checker.</p>

},
keywords = {Functional Programming, Pattern Matching, Typed Holes}
}

@software{10.5281/zenodo.7713789,
author = {Barke, Shraddha and James, Michael B. and Polikarpova, Nadia},
title = {Replication Package for Article: "Grounded Copilot: How Programmers Interact with Code-Generating Models"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7713789},
abstract = {
    <p>This artifact contains: - The scripts to generate our plots - Detailed study information to re-run our user study - Livestreams that we observed and included in our dataset - Our codebook</p>

},
keywords = {AI Assistants, Grounded Theory, Program Synthesis}
}

@software{10.5281/zenodo.7714175,
author = {Emre, Mehmet and Boyland, Peter and Parekh, Aesha and Schroeder, Ryan and Dewey, Kyle and Hardekopf, Ben},
title = {Artifact for "Aliasing Limits on Translating C to Safe Rust"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7714175},
abstract = {
    <p>The artifact is a Docker image that contains (1) the prototype of our pseudo-safety transformations, (2) the affected pointer set analysis we implemented on top of SVF, (3) Laertes with our extensions for directionality, and (4) data analysis scripts to produce the tables and the figures in the paper. It also contains C2Rust, SVF, and Laertes themselves to run these prototypes, as well as a corpus of programs we use to evaluate our method.</p>

},
keywords = {C, Empirical Study, Memory Safety, Rust, Translation}
}

@software{10.5281/zenodo.7719431,
author = {Zhou, Jie and Criswell, John and Hicks, Michael},
title = {Artifact of the `Fat Pointers for Temporal Memory Safety of C Paper` of OOPSLA23},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7719431},
abstract = {
    <p>This artifact provides a VM and a docker image that contain all the source code to perform experiments of the Fat Pointers for Temporal Memory Safety of C Paper of OOPSLA’23.</p>

},
keywords = {Checked C, Fat Pointers, LLVM, Temporal Memory Safety}
}

@software{10.5281/zenodo.7720410,
author = {Chiang, David and McDonald, Colin and Shan, Chung-chieh},
title = {Reproduction Package for Article "Exact Recursive Probabilistic Programming"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7720410},
abstract = {
    <p>This Docker image contains everything needed to reproduce the experiments in the paper “Exact Recursive Probabilistic Programming.”</p>

},
keywords = {linear types, probabilistic programming, recursive types}
}

@software{10.5281/zenodo.7722241,
author = {Ji, Ruyi and Kong, Chaozhe and Xiong, Yingfei and Hu, Zhenjiang},
title = {Artifact for OOPSLA'23: Improving Oracle-Guided Inductive Synthesis by Efficient Question Selection},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7722241},
abstract = {
    <p>Artifact for OOPSLA’23: Improving Oracle-Guided Inductive Synthesis by Efficient Question Selection</p>
<p>This project will be maintained at https://github.com/jiry17/LearnSy, and details about this artifact can be found in README.md.</p>

},
keywords = {Oracle-Guided Inductive Synthesis, Question Selection Problem}
}

@software{10.5281/zenodo.7723110,
author = {Roth, Ori and Gil, Yossi},
title = {Flunct: Functional Fluent API Generator},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7723110},
abstract = {
    <p>Accompanying artifact for the OOPSLA 2023 paper “Fluent APIs in Functional Languages”. Flunct compiles finite state machines specifying regular domain-specific languages or API protocols into functional fluent APIs in Standard ML.</p>

},
keywords = {API protocols, embedded DSLs, fluent API}
}

@software{10.5281/zenodo.7727577,
author = {Li, Shaohua and Su, Zhendong},
title = {Accelerating Fuzzing through Prefix-Guided Execution},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7727577},
abstract = {
    <p>This is the artifact for “Accelerating Fuzzing through Prefix-Guided Execution”, published in SPLASH/OOPSLA 2023. All instructions can be found in the zip file.</p>

},
keywords = {code coverage, fuzzing, software testing}
}

@software{10.1145/3594731,
author = {Kelly, Terence},
title = {Source code for Drill Bits 9 article "Catch-23: The New C Standard Sets the World on Fire"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3594731},
abstract = {
    <p>File stack.c contains the code shown in Figure 1 of my column, which illustrates idiomatic use of standard C realloc(). The stack assumes a sane "zero-null" memory allocator, i.e., a memory allocator that works the way C89 and C99 strongly recommended: Zero-length allocation requests return NULL, which means that realloc(p,0) unconditionally frees p and returns NULL and cannot fail.  Standards from C89 through C17 have *permitted* zero-null implementations of the standard library but have not *required* zero-null behavior.  Historically, many wise and good implementations have followed the zero-null rule.  Unfortunately, some implementations have done otherwise.</p>
}
}

@software{10.1145/3594732,
author = {Kelly, Terence},
title = {Source code for "Persistent Memory Programming on Conventional Hardware"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3594732},
abstract = {
    <p>"famus" is "failure-atomic msync() in user space", a library for C/C++ applications on Linux that provides an interface similar to conventional POSIX mmap()/msync() but with stronger semantics.  Like its conventional counterpart, famus enables applications to manipulate a backing file via LOADs and STOREs to the file's in-memory image.  However, unlike conventional mmap()/msync(), famus provides a strong fault tolerance guarantee: Following recovery, the state of the backing file will always reflect the most recent successful sync operation, even in the presence of failures such as power outages, OS kernel panics, and application process crashes.</p>
}
}

@software{10.1145/3594733,
author = {Kelly, Terence},
title = {Source code for "Is Persistent Memory Persistent?"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3594733},
abstract = {
    <p>This file contains instructions for running sudden whole-system power interruption tests on a Raspberry Pi 3 Model B+, as described in the accompanying article.</p>
}
}

@software{10.5281/zenodo.7141105,
author = {Abdelmoniem, Ahmed M. and Sahu, Atal and Canini, Marco and Fahmy, Suhaib A},
title = {Accompanying artifact for the paper "REFL: Resource-Efficient Federated Learning"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7141105},
abstract = {
    <p>First release after the artifact evaluation by ACM EuroSys artifacts evaluation committee.</p>
}
}

@software{10.6084/m9.figshare.22223914.v1,
author = {Zhang, Jian and Ji, Ye and Mu, Shuai and Tan, Cheng},
title = {Accompanying artifact for the paper "Viper: A Fast Snapshot Isolation Checker"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.22223914.v1},
abstract = {
    <p>Viper is an SI checker that is sound, complete, and fast. Viper checks black-box databases and hence is transparent to both users and databases.</p>
}
}

@software{10.6084/m9.figshare.22233487.v1,
author = {Wang, Zhuang and Lin, Haibin and Zhu, Yibo and Ng, T. S. Eugene},
title = {Accompanying artifact for the paper "Hi-Speed DNN Training with Espresso: Unleashing the Full Potential of Gradient Compression with Near-Optimal Usage Strategies"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.22233487.v1},
abstract = {
    <p>Artifact evaluation for Espresso accepted in EuroSys23</p>
}
}

@software{10.5281/zenodo.7143413,
author = {Bilal, Muhammad and Canini, Marco and Fonseca, Rodrigo and Rodrigues, Rodrigo},
title = {Accompanying artifact for the paper "With Great Freedom Comes Great Opportunity: Rethinking Resource Allocation for Serverless Functions"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7143413},
abstract = {
    <p>This repository contains the code and data related to the research paper: With Great Freedom Comes Great Opportunity: Rethinking Resource Allocation for Serverless Functions. It includes&nbsp;the serverless applications, input data for the applications, the optimization algorithms, analysis notebooks and the performance data collected for the experimental scenarios described in the paper.&nbsp;</p>
}
}

@software{10.5281/zenodo.7654817,
author = {Wang, Dong and Dou, Wensheng and Gao, Yu and Wu, Chenao and Wei, Jun and Huang, Tao},
title = {Accompanying artifact for the paper "Model Checking Guided Testing for Distributed Systems"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7654817},
abstract = {
    <p>Persistent artifact for EuroSys 2023 AE.</p>
}
}

@software{10.5281/zenodo.7703209,
author = {Alzayat, Mohamed and Mace, Jonathan and Druschel, Peter and Garg, Deepak},
title = {Accompanying artifact for the paper "Groundhog: Efficient Request Isolation in FaaS"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7703209},
abstract = {
    <p>Groundhog is a lightweight in-memory snapshot and restore tool that enforces sequential request isolation in Function-as-a-Service (FaaS).
In FaaS each function executes in its own container&nbsp;to isolate concurrent executions of different functions from one another. However, successive invocations of the same function commonly reuse the runtime state of a previous invocation in order to avoid container cold-start delays when invoking a function. Although efficient, this container reuse has security implications for functions that are invoked on behalf of differently privileged users or administrative domains: bugs in a function's implementation --- or a third-party library/runtime it depends on --- may leak private data from one invocation of the function to subsequent invocations of the same function.
Groundhog isolates sequential invocations of a function by efficiently reverting to a clean state, free from any private data, after each invocation. The system exploits two properties of typical FaaS platforms: each container executes at most one function at a time and legitimate functions do not retain state across invocations. This enables Groundhog to efficiently snapshot and restore function state between invocations in a manner that is independent of the programming language/runtime and does not require any changes to existing functions, libraries, language runtimes, or OS kernels.
Please visit&nbsp;https://groundhog.mpi-sws.org/ for the latest version and documentation of Groundhog.</p>
}
}

@software{10.5281/zenodo.7703530,
author = {Jeong, Jinwoo and Baek, Seungsu and Ahn, Jeongseob},
title = {Accompanying artifact for the paper "Fast and Efficient Model Serving Using Multi-GPUs with Direct-Host-Access"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7703530},
abstract = {
    <p>This is the artifact of the paper: "Fast and Efficient Model Serving Using Multi-GPUs with Direct-Host-Access" to appear in 'EuroSys 2023'. This artifact includes the DeepPlan tool generating the inference execution plans for given DNN models, the libTorch execution engine guided by the generated plans, and the DL inference server prototype powered by our libTorch engine. It also includes the DNN workloads used in our paper and script files to set up and test our artifact.</p>
}
}

@software{10.5281/zenodo.7703583,
author = {Koo, Jinhyung and Bae, Jinwook and Yuk, Minjeong and Oh, Seonggyun and Kim, Jungwoo and Park, Jung-Soo and Lee, Eunji and Kim, Bryan S. and Lee, Sungjin},
title = {Accompanying artifact for the paper "All-Flash Array Key-Value Cache for Large Objects"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7703583},
abstract = {
    <p>BigKV is a key-value cache specifically designed for caching large objects in an all-flash array (AFA).
The original paper that introduced BigKV is currently in the camera-ready stage of&nbsp;ACM/SIGOPS EuroSys 2023.
Please reference the README file in the zip file for the test.</p>
}
}

@software{10.5281/zenodo.7704577,
author = {Yoon, Wonsup and Ok, Jisu and Oh, Jinyoung and Moon, Sue and Kwon, Youngjin},
title = {Accompanying artifact for the paper "DiLOS: Do Not Trade Compatibility for Performance in Memory Disaggregation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7704577},
abstract = {
    <p>DiLOS: Do Not Trade Compatibility for Performance in Memory Disaggregation (Artifact)
&nbsp;
See README.md.</p>
}
}

@software{10.5281/zenodo.7706922,
author = {Wang, Yu Chen and Brown, Angela Demke and Goel, Ashvin},
title = {Accompanying artifact for the paper "Integrating Non-Volatile Main Memory in a Deterministic Database"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7706922},
abstract = {
    <p>Artifact for Pmem Caracal for Eurosys 2023</p>
}
}

@software{10.5281/zenodo.7707312,
author = {Gramoli, Vincent and Guerraoui, Rachid and Natoli, Chris and Lebedev, Andrei and Voron, Gauthier},
title = {Accompanying artifact for the paper "Diablo: A Benchmark Suite for Blockchains"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7707312},
abstract = {
    <p>This upload contains the artifact for Diablo: A Benchmark Suite for Blockchains, EuroSys 2023

diablo-benchmark-eurosys23.zip —&nbsp;Diablo source code
diablo-workloads.zip — workloads used in the paper
diablo.mp4&nbsp;— screencast which explains how to run a simple demo using the VirtualBox image
diablo.ova&nbsp;— VirtualBox image used to run a simple demo
diablobench.github.io-main.zip&nbsp;— Diablo website source code containing all the required information, such as the simple demo instruction and&nbsp;steps to reproduce the experiments from the paper
minion-eurosys23.zip&nbsp;— Minion source code
results.csv.gz&nbsp;— results from the paper, which can be used to generate the plots
scripts.tar.gz&nbsp;—&nbsp;scripts used to generate the plots from the paper
</p>
}
}

@software{10.5281/zenodo.7709922,
author = {Wei, Junyu and Zhang, Guangyan and Chen, Junchao and Wang, Yang and Zheng, Weimin and Sun, Tingtao and Wu, Jiesheng and Jiang, Jiangwei},
title = {Accompanying artifact for the paper "LogGrep: Fast and Cheap Cloud Log Storage by Exploiting both Static and Runtime Patterns"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709922},
abstract = {
    <p>Open-source repository for paper "LogGrep: Fast and Cheap Cloud Log Storage by Exploiting both Static and Runtime Patterns"(ACM Eurosys 2023)</p>
}
}

@software{10.5281/zenodo.7710637,
author = {Stoica, Bogdan Alexandru and Lu, Shan and Musuvathi, Madan and Nath, Suman},
title = {Accompanying artifact for the paper "WAFL: Exposing Memory Ordering Bugs Efficiently with Active Delay Injection"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7710637},
abstract = {
    <p>WAFFLE is an active delay injection tool for .NET platforms that aims to find memory ordering bugs - or MemOrder bugs, for short - such as use-after-free and use-before-init faults. This is a snapshot of the original code release from Sep 12, 2022. For the latest version of our tool, a link to our EuroSys'23 paper and slide decks describing WAFFLE's key features, please visit: https://github.com/bastoica/waffle.</p>
}
}

@software{10.5281/zenodo.7719328,
author = {Narayanan, Vikram and Detweiler, David and Huang, Tianjiao and Burtsev, Anton},
title = {Accompanying artifact for the paper "DRAMHiT: A Hash Table Architected for the Speed of DRAM"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7719328},
abstract = {
    <p>Artifact evaluation for the paper "DRAMHiT: A Hash Table Architected for the Speed of DRAM" (Eurosys 2023)</p>
}
}

@software{10.5281/zenodo.7721895,
author = {Yang, Jin and Yoon, Heejin and Yun, Gyeongchan and Noh, Sam H. and Choi, Young-ri},
title = {Accompanying artifact for the paper "DyTIS: A Dynamic Dataset Targeted Index Structure Simultaneously Efficient for Search, Insert, and Scan"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7721895},
abstract = {
    <p>The version for EuroSys'23 AE.
@sheepjin11 @heejin5178 @gyeongchan-yun</p>
}
}

@software{10.5281/zenodo.7725803,
author = {Chuang, Ho-Ren and Manaouil, Karim and Xing, Tong and Barbalace, Antonio and Olivier, Pierre and Heerekar, Balvansh and Ravindran, Binoy},
title = {Accompanying artifact for the paper "Aggregate VM: Why Reduce or Evict VM’s Resources When You Can Borrow Them From Other Nodes?"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7725803},
abstract = {
    <p>FragVisor: The Borrowing Hypervisor
&nbsp;
This upload contains the source code and the artifact evaluation appendix for&nbsp;FragVisor, a system developed for the EuroSys23 paper "Aggregate VM: Why Reduce or Evict VM’s Resources When You Can Borrow Them From Other Nodes?".
&nbsp;
FragVisor reduces VM fragmentation by creating distributed VMs by borrowing resources from multiple physical servers. FragVisor supports resource mobility and the VM will eventually consolidates when resources gets freed.

The git repo contains two submodules, the modified host Linux kernel source code in fragvisor-linux and the modified hypervisor in fragvisor-kvmtool. An artifact evaluation PDF document is also included.
&nbsp;
This Artifact is also available on github: https://github.com/systems-nuts/FragVisor</p>
}
}

@software{10.5281/zenodo.7726172,
author = {Tang, Lilia and Bhandari, Chaitanya and Zhang, Yongle and Karanika, Anna and Ji, Shuyang and Gupta, Indranil and Xu, Tianyin},
title = {Accompanying artifact for the paper "Fail through the Cracks: Cross-System Interaction Failures in Modern Cloud Systems"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7726172},
abstract = {
    <p>EuroSys '23 artifact for&nbsp;Fail through the Cracks: Cross-System Interaction Failures in Modern Cloud Systems</p>
}
}

@software{10.5281/zenodo.7726928,
author = {Chen, Ruobing and Shi, Haosen and Li, Yusen and liu, xiaoguang and Wang, Gang},
title = {Accompanying artifact for the paper "OLPart: Online Learning based Resource Partitioning for Colocating Multiple Latency-Critical Jobs on Commodity Computers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7726928},
abstract = {
    <p>A paper published in EuroSys 2023.
Coloating multiple jobs on a same server has been a commonly used approach for improving resource utilization in cloud environments. However, performance interference due to the contention over shared resources makes resource partitioning an important research problem. Partitioning multiple resources coordinately is particularly challenging when multiple latency-critical (LC) jobs are colocated with best-effort (BE) jobs, since the QoS needs to be protected for all the LC jobs. So far, this problem is not well-addressed in the literature. We propose an online learning based solution, named OLPart, for partitioning resources among multiple colocated LC jobs and BE jobs. OLPart is designed based on our observation that runtime performance counters can approximately indicate resource sensitivities of jobs. Based on this finding, OLPart leverages contextual multi-armed bandit (CMAB) to design the partitioning solution, which employs the performance counters to enable an intelligent exploration of the search space. Applying CMAB to the resource partitioning problem faces several critical challenges. OLPart proposes several techniques to overcome these challenges. OLPart does not require priori knowledge of jobs and incurs very small overhead. Evaluations demonstrate that OLPart is optimally efficient and robust, which outperforms state-of-theart solutions with significant margins. OLPart is publicly available at https://github.com/oksdfncsj/OLPart.</p>
}
}

@software{10.5281/zenodo.7728972,
author = {Berlakovich, Felix and Brunthaler, Stefan},
title = {Accompanying artifact for the paper "R2C: AOCR-Resilient Diversity with Reactive and Reflective Camouflage"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7728972},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.7732935,
author = {Lupu, Costin and Albiundefinedoru, Andrei and Nichita, Radu and Bl\^{a}nzeanu, Doru-Florin and Pogonaru, Mihai and Deaconescu, R\u{a}zvan and Raiciu, Costin},
title = {Accompanying artifact for the paper "Nephele: extending virtualization environments for cloning unikernel-based VMs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7732935},
abstract = {
    <p>The current artifact contains all the components needed for building and running Nephele on Xen.</p>
}
}

@software{10.5281/zenodo.7734495,
author = {Gupta, Suyash and Rahnama, Sajjad and Pandey, Shubham and Crooks, Natacha and Sadoghi, Mohammad},
title = {Accompanying artifact for the paper "Dissecting BFT Consensus: In Trusted Components we Trust!"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7734495},
abstract = {
    <p>Creating a persistent release using Zenodo.</p>
}
}

@software{10.5281/zenodo.7734627,
author = {Weng, Lingmei and Hu, Yigong and Huang, Peng and Yang, Junfeng and Nieh, Jason},
title = {Accompanying artifact for the paper "Effective Performance Issue Diagnosis with Value-Assisted Cost Profiling"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7734627},
abstract = {
    <p>This artifact contains the software vprof, a profiler that aims to improve the performance issues debugging. It calibrates the function cost and annotates the function with variables, corresponding suspicious values, and bug patterns.&nbsp;</p>
}
}

@software{10.5281/zenodo.7734815,
author = {Park, Misun and Bhardwaj, Ketan and Gavrilovska, Ada},
title = {Accompanying artifact for the paper "Pocket: ML Serving from the Edge"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7734815},
abstract = {
    <p>Artifact-evaluation release.</p>
}
}

@software{10.5281/zenodo.7735158,
author = {Yildiz, Eren and Ahmed, Saad and Islam, Bashima and Hester, Josiah and Yildirim, Kasim Sinan},
title = {Accompanying artifact for the paper "Efficient and Safe I/O Operations for Intermittent Systems"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7735158},
abstract = {
    <p>This is the Digital Object Identifier (DOI) page for persistently indexing the source code and artifact of EaseIO. Their latest version can be found in the following GitHub repository:&nbsp;
https://github.com/tinysystems/easeIO</p>
}
}

@software{10.5281/zenodo.7737645,
author = {Raza, Ali and Unger, Thomas and Boyd, Matthew and Munson, Eric and Sohal, Parul and Drepper, Ulrich and Jones, Richard and de Oliveira, Daniel Bristot and Woodman, Larry and Mancuso, Renato and Appavoo, Jonathan and Krieger, Orran},
title = {Accompanying artifact for the paper "Unikernel Linux (UKL)"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7737645},
abstract = {
    <p>Unikernel Linux (UKL) is a small patch to Linux and glibc which allows you to build many programs, unmodified, as unikernels. That means they are linked with the Linux kernel into a final vmlinuz and run in kernel space. You can boot these kernels on baremetal or inside a virtual machine. Almost all features and drivers in Linux are available for use by the unikernel.</p>
}
}

@software{10.5281/zenodo.7737776,
author = {Ng, Harald and Carbone, Paris and Haridi, Seif},
title = {Accompanying artifact for the paper "Omni-Paxos: Breaking the Barriers of Partial Connectivity"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7737776},
abstract = {
    <p>Omni-Paxos: Breaking the Barriers of Partial Connectivity --- Artifact Evaluation
The source code is also available on GitHub:&nbsp;https://github.com/haraldng/omnipaxos-artifacts/releases/tag/artifact_evaluation</p>
}
}

@software{10.5281/zenodo.7737994,
author = {Lim, Hwijoon and Kim, Jaehong and Cho, Inho and Jang, Keon and Bai, Wei and Han, Dongsu},
title = {Accompanying artifact for the paper "FlexPass: A Case for Flexible Credit-based Transport for Datacenter Networks"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7737994},
abstract = {
    <p>Official Github repository for the EuroSys '23 paper "FlexPass: A Case for Flexible Credit-based Transport for Datacenter Networks"</p>
}
}

@software{10.5281/zenodo.7738934,
author = {Seneviratne, Yasas and Seemakhupt, Korakit and Liu, Sihang and Khan, Samira},
title = {Accompanying artifact for the paper "NearPM: A Near-memory Processing Prototype for Storage-class Workloads"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7738934},
abstract = {
    <p>No description provided.</p>
}
}

@software{10.5281/zenodo.7684001,
author = {Isemann, Raphael and Giuffrida, Cristiano and Bos, Herbert and van der Kouwe, Erik and Gleissenthall, Klaus von},
title = {Artifact for "Don’t Look UB: Exposing Sanitizer-Eliding Compiler Optimizations"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7684001},
abstract = {
    <p>This artifact contains the fuzzing and static analysis setups of the respective paper.</p>

},
keywords = {compilers, fuzzing, sanitizers}
}

@software{10.5281/zenodo.7703886,
author = {Gopinathan, Kiran and Keoliya, Mayank and Sergey, Ilya},
title = {Reproduction Artefact for Article 'Mostly Automated Proof Repair for Verified Libraries'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7703886},
abstract = {
    <p>This artefact is for our tool, Sisyphus, which is a functional, reusable, and extensible framework for automated repair of Coq proofs.</p>
<p>The artefact contains the source code and build scripts for Sisyphus, a corpus of individual OCaml programs which can be used to reproduce the experimental results in the paper, and a self-contained Docker file to automate setting up the development environment.</p>
<p>The artefact also contains a README in markdown that provides detailed step-by-step instructions for running Sisyphus and reproducing the experimental results.</p>

},
keywords = {invariant inference, mechanised proofs, proof repair, separation logic}
}

@software{10.5281/zenodo.7706984,
author = {Muller, Stefan K. and Singer, Kyle and Keeney, Devyn Terra and Neth, Andrew and Agrawal, Kunal and Lee, I-Ting Angelina and Acar, Umut A.},
title = {Responsive Parallelism with Synchronization Case Studies},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7706984},
abstract = {
    <p>Implementations of the type system described in “Responsive Parallelism with Synchronization” in C++ and Rust, as well as implementations of the case studies. Included are instructions on how to build and execute the case studies, as well as a Docker container environment that can be used for compilation and execution.</p>

},
keywords = {C++, Cilk, condition variable, cost semantics, priority inversion, Rust, type system}
}

@software{10.5281/zenodo.7709500,
author = {Moseley, Dan and Nishio, Mario and Perez Rodriguez, Jose and Saarikivi, Olli and Toub, Stephen and Veanes, Margus and Wan, Tiki and Xu, Eric},
title = {Artifact for "Derivative Based Nonbacktracking Real-World Regex Matching with Backtracking Semantics"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709500},
abstract = {
    <p>This artifact contains the necessary software and data for reproducing results for the paper “Derivative Based Nonbacktracking Real-World Regex Matching with Backtracking Semantics”. It is based on a benchmark of regex engines available in various programming languages by Mario Ju\'{a}rez. A docker image with all the necessary software for running the benchmark is included. The work described in the paper is part of .NET 7, the source code of which is also included.</p>

},
keywords = {.net, benchmark, dotnet, regex, regular expression, source code}
}

@software{10.5281/zenodo.7709681,
author = {Huang, Yulong and Yallop, Jeremy},
title = {Defunctionalization with Dependent Types: Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709681},
abstract = {
    <p>We provide a portable standalone implementation of the defunctionalization translation, written in OCaml and compiled to run in a web browser using js_of_ocaml. The implementation performs type checking of CC and DCC terms, abstract defunctionalization and backwards translation from DCC to CC, allowing the interested reader to experiment with the effects of the translation on real examples. We include several ready-made examples, including dependent composition, dependent pairs and finite sets.</p>

},
keywords = {compilation, dependent types, type preservation, type systems}
}

@software{10.5281/zenodo.7709704,
author = {Prinz, Jacob and Lampropoulos, Leonidas},
title = {Reproduction Package for "Merging Inductive Relations"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709704},
abstract = {
    <p>VM that allows for replicating all the experiments in the PLDI 2023 paper “Merging Inductive Relations”.</p>

},
keywords = {Merging Inductive Relations, Property-Based Testing, QuickChick}
}

@software{10.5281/zenodo.7709794,
author = {Zhang, Yihong and Wang, Yisu Remy and Flatt, Oliver and Cao, David and Zucker, Philip and Rosenthal, Eli and Tatlock, Zachary and Willsey, Max},
title = {Artifact for "Better Together: Unifying Datalog and Equality Saturation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709794},
abstract = {
    <p>This artifact contains the egglog system, as well as data and scripts needed to reproduce the microbenchmarks and two case studies as described in the paper.</p>

},
keywords = {Datalog, program optimization, program synthesis}
}

@software{10.5281/zenodo.7709916,
author = {Nigam, Rachit and Azevedo de Amorim, Pedro Henrique and Sampson, Adrian},
title = {Reproduction Package for "Modular Hardware Design with Timeline Types"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7709916},
abstract = {
    <p>The artifact contains the source code for the language and compiler presented in the paper (Filament) along with Verilog modules generated from the Aetherling and Reticle compilers. It provides scripts to regenerate the tables and results in the paper. The reproducer must manually install the Vivado toolchain, as instructed in the README, in order to obtain the resource usage numbers.</p>

},
keywords = {Hardware design language, type system}
}

@software{10.5281/zenodo.7710435,
author = {Kuepper, Joel and Erbsen, Andres and Gross, Jason and Conoly, Owen and Sun, Chuyue and Tian, Samuel and Wu, David and Chlipala, Adam and Chuengsatiansup, Chitchanok and Genkin, Daniel and Wagner, Markus and Yarom, Yuval},
title = {Evaluation package for ‘ CryptOpt: Verified Compilation with Randomized Program Search for Cryptographic Primitives’},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7710435},
abstract = {
    <p>This artifact contains copies of CryptOpt, Fiat Cryptography and AssemblyLine. It also contains Dockerfiles to create a Docker container to run optimizations for the cryptographic primitives mentioned in the paper. It contains scripts to validate the claims, along with instructions how to build, run and evaluate. To create and build, an Internet connection is required to download dependencies.</p>

},
keywords = {Assembly, asymmetric cryptography, bet-and-run, C, Coq, cryptography, Docker, formal verification, Intel x86-64, Node.js, performance, performance measurements, random local search, straight line code}
}

@software{10.5281/zenodo.7711063,
author = {Lee, Dongjae and Cho, Minki and Kim, Jinwoo and Moon, Soonwon and Song, Youngju and Hur, Chung-Kil},
title = {Coq development for Fair Operational Semantics},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7711063},
abstract = {
    <p>This artifact is the Coq development for the 2023 PLDI paper `Fair Operational Semantics’. It contains the formalization of the theory of FOS and proofs for the examples in the paper.</p>

},
keywords = {Concurrency, Coq Proof Assistant, Fairness, Separation Logic}
}

@software{10.5281/zenodo.7711823,
author = {Beurer-Kellner, Luca and Fischer, Marc and Vechev, Martin},
title = {LMQL as described in Prompting Is Programming: A Query Language for Large Language Models},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7711823},
abstract = {
    <p>LMQL is a query language for large language models (LLMs). It facilitates LLM interaction by combining the benefits of natural language prompting with the expressiveness of Python. With only a few lines of LMQL code, users can express advanced, multi-part and tool-augmented LM queries, which then are optimized by the LMQL runtime to run efficiently as part of the LM decoding loop.</p>
<p>An up to date version can be found at https://github.com/eth-sri/lmql</p>

},
keywords = {language model programming, prompt programming}
}

@software{10.5281/zenodo.7712285,
author = {Brandon, William and Driscoll, Benjamin and Dai, Frank and Berkow, Wilson and Milano, Mae},
title = {Reproduction Package for Article "Better Defunctionalization Through Lambda Set Specialization"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7712285},
abstract = {
    <p>The repository contains a compressed docker image file, containing the artifact for the PLDI 2023 paper “Better Defunctionalization through Lambda Set Specialization.” To use this artifact, first decompress the file (using <code>tar</code> or an archiving program like 7zip), and then use <code>docker load</code> to load up the decompressed docker image. Information for reproducing the results from our PLDI paper is available in README.md files in the ‘morphic/’ and ‘LSSIsabelle/’ directories inside the Docker image. Note: the Docker archive must be decompressed and then loaded with <code>docker load</code> (<em>not</em> <code>docker import</code>, as our archive does not use squashed layers).</p>

},
keywords = {defunctionalization, monomorphization, type systems}
}

@software{10.5281/zenodo.7776035,
author = {Pailoor, Shankara and Chen, Yanju and Wang, Franklyn and Rodr\'{\i}guez, Clara and Van Geffen, Jacob and Morton, Jason and Chu, Michael and Gu, Brian and Feng, Yu and Dillig, I\c{s}\i{}l},
title = {Automated Detection of Under-constrained Circuits in Zero-Knowledge Proofs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7776035},
abstract = {
    <p>Research Artifact for PLDI’23 Paper “Automated Detection of Under-constrained Circuits in Zero-Knowledge Proofs”</p>

},
keywords = {Automated reasoning, Cryptographic protocols, Program analysis, Program verification}
}

@software{10.5281/zenodo.7782305,
author = {Kanabar, Hrutvik and Vivien, Samuel and Abrahamsson, Oskar and Myreen, Magnus O. and Norrish, Michael and Pohjola, Johannes \r{A}man and Zanetti, Riccardo},
title = {Artifact for “PureCake: A Verified Compiler for a Lazy Functional Language”},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7782305},
abstract = {
    <p><code>README.md</code> describes how to understand and use this artifact. <code>correspondences.md</code> links the artifact to the paper.</p>

},
keywords = {compiler verification, Haskell, HOL4, interactive theorem proving}
}

@software{10.5281/zenodo.7787371,
author = {Lei, Yuxiang and Sui, Yulei and Tan, Shin Hwei and Zhang, Qirun},
title = {Artifact of "Recursive State Machine Guided Graph Folding for Context-Free Language Reachability"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7787371},
abstract = {
    <p>This is the artifact of the paper “Recursive State Machine Guided Graph Folding for Context-Free Language Reachability” accepted to PLDI 2023. The artifact is packaged as a Docker image “gf.tar.gz”, which is to reproduce the experiment results of the paper. Please see README.pdf for detailed usage of the artifact.</p>

},
keywords = {CFL-reachability, graph simplification, recursive state machines}
}

@software{10.5281/zenodo.7787547,
author = {Park, Jihyeok and Youn, Dongjun and Lee, Kanguk and Ryu, Sukyoung},
title = {Artifact For "Feature-Sensitive Coverage for Conformance Testing of Programming Language Implementations"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7787547},
abstract = {
    <p>Artifact For “Feature-Sensitive Coverage for Conformance Testing of Programming Language Implementations”</p>

},
keywords = {conformance test synthesis, coverage-guided fuzzing, feature-sensitive coverage, mechanized specification}
}

@software{10.5281/zenodo.7798646,
author = {Goens, Andr\'{e}s and Chakraborty, Soham and Sarkar, Susmit and Agarwal, Sukarn and Oswald, Nicolai and Nagarajan, Vijay},
title = {Compound Memory Models: Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7798646},
abstract = {
    <p>This is the artifact to the paper “Compound Memory Models”. It includes the LOST-POP model implementation in Lean 4, the CMM implementation in Alloy, multiple litmus tests for both and accompanying gem5 simulations for some litmus tests.</p>

},
keywords = {alloy, axiomatic, compositional, gem5, lean4, memory models, operational, simulator}
}

@software{10.5281/zenodo.7799158,
author = {Alberdingk Thijm, Timothy and Beckett, Ryan and Gupta, Aarti and Walker, David},
title = {Artifact associated with the PLDI 2023 submission "Modular Control Plane Verification via Temporal Invariants".},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7799158},
abstract = {
    <p>The artifact provides the code of the Timepiece GitHub repository, which includes the code implementing our modular verification procedure, along with libraries to reproduce and run the benchmarks given in the paper. Fattree benchmarks are contained in the Timepiece.Benchmarks subproject. The Internet2 benchmark can be run by using the Timepiece.Angler subproject to convert an .angler.json file into a Timepiece benchmark: such a .json file can be created from the included Angler repository, which translates network configurations read by Batfish to the .angler.json format. The core of our implementation can be found in the Timepiece subproject of the repository.</p>
<p>Tooling is included to generate the plots from our paper via pgfplots, using a template plot.tex file. We also include a run_all.py Python script for conveniently running and gathering data on our fattree benchmarks, and a Dockerfile for building a Docker image to run the code.</p>

},
keywords = {control plane, dotnet, modular verification, network configurations, network verification, python}
}

@software{10.5281/zenodo.7799173,
author = {Mulder, Ike and Czajka, \L{}ukasz and Krebbers, Robbert},
title = {Artifact and Appendix of 'Beyond Backtracking: Connections in Fine-Grained Concurrent Separation Logic'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7799173},
abstract = {
    <p>This is the artifact and appendix for the PLDI ‘23 paper ’Beyond Backtracking: Connections in Fine-Grained Concurrent Separation Logic’. It contains the source code of an extension of Diaframe that has better support for disjunctions, a VM containing a compiled version of this source code, instructions for evaluation, and the technical appendix.</p>

},
keywords = {backtracking, Coq, disjunctions, fine-grained concurrency, Iris, proof automation, Separation logic}
}

@software{10.5281/zenodo.7800226,
author = {Jin, Ende and Amin, Nada and Zhang, Yizhou},
title = {Artifact for Extensible Metatheory Mechanization via Family Polymorphism},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7800226},
abstract = {
    <p>This artifact includes 3 components: (1) a complete document for interacting with this artifact; (2) a docker image for directly interacting with our plugin without setup; and (3) source code to build our plugin and work with it without virtualization</p>

},
keywords = {Coq., dependent type theory, expression problem, extensible frameworks, inductive types, interactive theorem proving, late binding, mixins, modules, Proof engineering, reuse}
}

@software{10.5281/zenodo.7801911,
author = {Avanzini, Martin and Moser, Georg and Schaper, Michael},
title = {Ev-Imp: Research Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7801911},
abstract = {
    <p>Ev-imp implements an expected value analysis for probabilistic, imperative programs featuring dynamic sampling instructions, non-deterministic choice, nested loops and most crucially recursive procedure declarations. Concretely, it estimates the value returned by a procedure, in average, as a function of the initial state. To this end, it implements the inference machinery described in Section 5 of our paper. For an overview of the concrete syntax of programs and usage of the tool, we kindly refer the reader to the accompanying README.md.</p>

},
keywords = {automation, expected value analysis, probabilistic programming, weakest pre-expectation semantics}
}

@software{10.5281/zenodo.7803910,
author = {Elsman, Martin},
title = {Artifact for the PLDI 2023 paper 'Garbage-Collection Safety for Region-Based Type-Polymorphic Programs'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7803910},
abstract = {
    <p>This artifact reproduces the content of Figure 9 in the paper. For a detailed overview of the artifact, including instructions on how to use it, please consult the Zenodo page.</p>

},
keywords = {Garbage collection, PLDI, Region inference, SML}
}

@software{10.5281/zenodo.7804200,
author = {Li, Ziyang and Huang, Jiani and Naik, Mayur},
title = {Reproduction package for article "Scallop: A Language for Neurosymbolic Programming"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7804200},
abstract = {
    <p>This artifact includes source code of the software and experiments presented in the paper `Scallop: A Language for Neurosymbolic Programming’. Instructions to reproduce the results are documented in the artifact.</p>

},
keywords = {Differentiable Programming, Logic Programming, Neurosymbolic Method, Programming Language}
}

@software{10.5281/zenodo.7804667,
author = {Mordido, Andreia and Spaderna, Janek and Thiemann, Peter and Vasconcelos, Vasco T.},
title = {AlgST},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7804667},
abstract = {
    <p>Implementation of “Parameterized Algebraic Protocols”</p>

},
keywords = {algebraic datatypes, algebraic session types, interpreter, nominal types, parameterized protocols, polymorphism, session types, type checker}
}

@software{10.5281/zenodo.7805564,
author = {Tardieu, Olivier and Grove, David and Bercea, Gheorghe-Teodor and Castro, Paul and Cwiklik, Jaroslaw and Epstein, Edward},
title = {Software Artifact for PACMPL Article "Reliable Actors with Retry Orchestration"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7805564},
abstract = {
    <p>Software artifact supporting the claims of the PACMPL (PLDI) 2023 paper “Reliable Actors with Retry Orchestration”.</p>

},
keywords = {actors, distributed systems, fault tolerance, workflows}
}

@software{10.5281/zenodo.7806981,
author = {Ye, Qianchuan and Delaware, Benjamin},
title = {Taype: A Policy-Agnostic Language for Oblivious Computation: PLDI23 Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7806981},
abstract = {
    <p>This is the artifact for the PLDI23 paper “Taype: A Policy-Agnostic Language for Oblivious Computation”. Visit the Zenodo link for more details.</p>

},
keywords = {Algebraic Data Types, Dependent type systems, Oblivious computation}
}

@software{10.5281/zenodo.7807290,
author = {Tao, Zhe and Nawas, Stephanie and Mitchell, Jacqueline and Thakur, Aditya V.},
title = {Reproduction Package for the PLDI 2023 Article "Architecture-Preserving Provable Repair of Deep Neural Networks"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7807290},
abstract = {
    <p>This is the artifact of the PLDI 2023 article “Architecture-Preserving Provable Repair of Deep Neural Networks”. Please refer to the README.md file for the instructions. The latest version of the artifact can be found at https://github.com/95616ARG/APRNN/</p>

},
keywords = {Bug fixing, Deep Neural Networks, Repair, Synthesis}
}

@software{10.5281/zenodo.7808384,
author = {Ma, Wenjie and Yang, Shengyuan and Tan, Tian and Ma, Xiaoxing and Xu, Chang and Li, Yue},
title = {Context Sensitivity without Contexts: A Cut-Shortcut Approach to Fast and Precise Pointer Analysis (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7808384},
abstract = {
    <p>This is the artifact of PLDI’23 paper Context Sensitivity without Contexts: A Cut-Shortcut Approach to Fast and Precise Pointer Analysis.</p>

},
keywords = {Alias Analysis, Context Sensitivity, Java, Pointer Analysis}
}

@software{10.5281/zenodo.7808708,
author = {Rao, Xiaojia and Georges, A\"{\i}na Linn and Legoupil, Maxime and Watt, Conrad and Pichon-Pharabod, Jean and Gardner, Philippa and Birkedal, Lars},
title = {Iris-Wasm: Robust and Modular Verification of WebAssembly Programs (Artefact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7808708},
abstract = {
    <p>This is the artefact for the paper “Iris-Wasm: Robust and Modular Verification of WebAssembly Programs”.</p>
<p>The artefact contains the Coq proofs accompanying the paper. These proofs are built using the Iris framework.</p>
<p>These proofs are available either as a .tar.gz archive, which can be compiled following the instructions in the README contained, or as a virtual machine image for VirtualBox (7.0.6) containing the already compiled Coq proofs with browsing tools (Emacs + Proof General) installed. The credentials for the account of the VM are provided in the README inside the .tar.gz archive.</p>

},
keywords = {Coq, Iris, Mechanized proofs, Separation logic, WebAssembly}
}

@software{10.5281/zenodo.7809285,
author = {Xu, Amanda and Molavi, Abtin and Pick, Lauren and Tannu, Swamit and Albarghouthi, Aws},
title = {Synthesizing Quantum-Circuit Optimizers Artifact (QUESO)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7809285},
abstract = {
    <p>This software artifact includes the source code for QUESO (a tool for synthesizing quantum-circuit optimizers) as well as a README.md with instructions for reproducing results using the provided scripts and benchmarks in the Docker image. See https://arxiv.org/abs/2211.09691 for the full version of the paper.</p>

},
keywords = {probabilistic verification, quantum circuit optimization, quantum computing}
}

@software{10.5281/zenodo.7809333,
author = {Bagnall, Alexander and Stewart, Gordon and Banerjee, Anindya},
title = {Artifact for PLDI'23 paper 'Formally Verified Samplers From Probabilistic Programs With Loops and Conditioning'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7809333},
abstract = {
    <p>The artifact contains the Coq proof development and empirical evaluation scripts for reproducing the results of the paper ‘Formally Verified Samplers From Probabilistic Programs With Loops and Conditioning’. A Dockerfile is included for building a Docker container image with all dependencies installed.</p>

},
keywords = {Probabilistic Programming, Verified Compilers}
}

@software{10.5281/zenodo.7809339,
author = {Kovach, Scott and Kolichala, Praneeth and Gu, Tiancheng and Kjolstad, Fredrik},
title = {Benchmark Reproduction for "Indexed Streams: A Formal Intermediate Representation for Fused Contraction Programs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7809339},
abstract = {
    <p>Contains formal proofs in Lean3 and benchmarking code for evaluation (section 8).</p>

},
keywords = {contractions, functional programming, operational semantics, streams}
}

@software{10.5281/zenodo.7809600,
author = {Tun\c{c}, H\"{u}nkar Can and Mathur, Umang and Pavlogiannis, Andreas and Viswanathan, Mahesh},
title = {Artifact for Article "Sound Dynamic Deadlock Prediction in Linear Time"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7809600},
abstract = {
    <p>The artifact contains the source codes of the deadlock prediction tools developed in our paper. Moreover, the artifact contains the compared tools (partially), experimental data, and scripts that can reproduce the experimental evaluation performed in the paper. The artifact does not contain all the compared tools as we lack the necessary rights to redistribute certain tools.</p>

},
keywords = {concurrency, predictive analyses, runtime analyses}
}

@software{10.5281/zenodo.7810545,
author = {Elsman, Martin and Henriksen, Troels},
title = {Artifact for the PLDI 2023 paper 'Parallelism in a Region Inference Context'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7810545},
abstract = {
    <p>The artifact reproduces Figures 6(a), 6(b) and Tables 1 and 2 of the paper. For a detailed overview, including instructions for using the artifact, please consult the README.md file at the Zenodo page.</p>

},
keywords = {Parallelism, PLDI, SML}
}

@software{10.5281/zenodo.7810840,
author = {Milovan\v{c}evi\'{c}, Dragana and Kun\v{c}ak, Viktor},
title = {Proving and Disproving Equivalence of Functional Programming Assignments (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7810840},
abstract = {
    <p>This artifact contains the complete data set and instructions for reproducing the results from the PLDI’23 paper Proving and Disproving Equivalence of Functional Programming Assignments</p>

},
keywords = {automated grading, equivalence checking, functional induction}
}

@software{10.5281/zenodo.7810841,
author = {Barnaby, Celeste and Chen, Qiaochu and Samanta, Roopsha and Dillig, I\c{s}\i{}l},
title = {Reproduction Package for 'ImageEye: Batch Image Editing with Program Synthesis'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7810841},
abstract = {
    <p>This artifact contains the source code for ImageEye, along with a Docker image that runs the experiments described in the paper. In particular, the Docker image runs the benchmarks, ablations, and comparison with EUSolver.</p>

},
keywords = {computer vision, neuro-symbolic synthesis, program synthesis}
}

@software{10.5281/zenodo.7811004,
author = {Zhou, Zhe and Mishra, Ashish and Delaware, Benjamin and Jagannathan, Suresh},
title = {PLDI2023 Artifact: Covering All the Bases: Type-Based Verification of Test Input Generators},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7811004},
abstract = {
    <p>This artifact contains:</p>
<ol type="1">
<li>README.md : the artifact guide.</li>
<li>poirot-full.pdf: full paper with the appendix.</li>
<li>poirot_pldi-2023.tar.gz: the docker image (optional, we recommend to pull from the docker hub, see README.md).</li>
<li>Dockerfile: the docker file that can reproduce the docker image (optional, we recommend to pull from the docker hub, see README.md).</li>
</ol>

},
keywords = {property-based testing, refinement types, underapproximate reasoning}
}

@software{10.5281/zenodo.7811236,
author = {Zhang, Jialun and Morrisett, Greg and Tan, Gang},
title = {Reproduction Package for Article "Interval Parsing Grammars for File Format Parsing"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7811236},
abstract = {
    <p>This package includes: (1) The parser generator for IPGs; (2) IPGs implementation for ELF, ZIP, PE, GIF and PDF; (3) A test script to reproduce all the evaluation results shown in the paper.</p>

},
keywords = {Context-sensitive Grammars, File Formats}
}

@software{10.5281/zenodo.7811406,
author = {Chen, Yu-Fang and Chung, Kai-Min and Leng\'{a}l, Ond\v{r}ej and Lin, Jyun-Ao and Tsai, Wei-Lun and Yen, Di-De},
title = {An Automata-based Framework for Verification and Bug Hunting in Quantum Circuits},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7811406},
abstract = {
    <p>We introduce a new paradigm for analysing and finding bugs in quantum circuits. In our approach, the problem is given by a triple <span class="math inline">{<em>P</em>}&nbsp;<em>C</em>&nbsp;{<em>Q</em>}</span> and the question is whether, given a set <span class="math inline"><em>P</em></span> of quantum states on the input of a circuit <span class="math inline"><em>C</em></span>, the set of quantum states on the output is equal to (or included in) a set <span class="math inline"><em>Q</em></span>. While this is not suitable to specify, e.g., functional correctness of a quantum circuit, it is sufficient to detect many bugs in quantum circuits. We propose a technique based on tree automata to compactly represent sets of quantum states and develop transformers to implement the semantics of quantum gates over this representation. Our technique computes with an algebraic representation of quantum states, avoiding the inaccuracy of working with floating-point numbers. We implemented the proposed approach in a prototype tool and evaluated its performance against various benchmarks from the literature. The evaluation shows that our approach is quite scalable, e.g., we managed to verify a large circuit with 40 qubits and 141,527 gates, or catch bugs injected into a circuit with 320 qubits and 1,758 gates, where all tools we compared with failed. In addition, our work establishes a connection between quantum program verification and automata, opening new possibilities to exploit the richness of automata theory and automata-based verification in the world of quantum computing.</p>

},
keywords = {quantum circuits, tree automata, verification}
}

@software{10.5281/zenodo.7811786,
author = {Fiala, Jon\'{a}\v{s} and Itzhaky, Shachar and M\"{u}ller, Peter and Polikarpova, Nadia and Sergey, Ilya},
title = {Reproduction Package for Article ``Leveraging Rust Types for Program Synthesis''},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7811786},
abstract = {
    <p>The purpose of this artifact is to reproduce the results presented in the PLDI 2023 paper titled “Leveraging Rust Types for Program Synthesis”. The artifact contains the instructions, tool, and Docker images to re-run the evaluation described in the paper. It also contains the appendix for the paper. The structure of the tool is described in the <code>sources/STRUCTURE.md</code> file.</p>

},
keywords = {ownership types, rust, synthesis}
}

@software{10.5281/zenodo.7811907,
author = {Yamazaki, Tetsuro and Nakamaru, Tomoki and Shioya, Ryota and Ugawa, Tomoharu and Chiba, Shigeru},
title = {Artifact - Collecting cyclic garbage across foreign function interfaces},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7811907},
abstract = {
    <p>All the programs to reproduce the evaluation presented in the corresponding paper.</p>

},
keywords = {FFI, Garbage collection, Memory Management}
}

@software{10.5281/zenodo.7811928,
author = {Cho, Kyeongmin and Jeon, Seungmin and Raad, Azalea and Kang, Jeehoon},
title = {Artifact for Article "Memento: A Framework for Detectable Recoverability in Persistent Memory"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7811928},
abstract = {
    <p>The accompanying artifact (also available at https://github.com/kaist-cp/memento) provides the implementation and the experimental results. The artifact is structured as follows.</p>
<ul>
<li><code>/memento/src/</code>: the implementation of the Memento framework and its primitives (§4).</li>
<li><code>/memento/src/</code>: the implementation of detectably persistent data structures (§5).</li>
<li><code>/memento/evaluation/</code>: the experiment script for correctness and performance (§6).</li>
<li><code>/evaluation_data/</code>: the complete experimental results (§6).</li>
</ul>
<p>Please refer to the artifact’s <code>README.md</code> for detailed instructions on how to reproduce the results.</p>

},
keywords = {concurrent data structure, detectable recovery, persistent memory}
}

@software{10.5281/zenodo.7812119,
author = {Tassarotti, Joseph and Tristan, Jean-Baptiste},
title = {Verified Density Compilation for a Probabilistic Programming Language (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7812119},
abstract = {
    <p>The artifact consists of the Coq and OCaml source code for ProbCompCert, the compiler described in the accompanying paper. ProbCompcert is implemented as an extension to CompCert. The artifact is available in 3 different forms: a copy of the source code, a Docker image, and a Qemu image. The latter two contain the compiler pre-built, along with scripts for re-running the experiments described in the paper.</p>

},
keywords = {compilers, formal verification, probabilistic programming}
}

@software{10.5281/zenodo.7812282,
author = {Ugare, Shubham and Banerjee, Debangshu and Misailovic, Sasa and Singh, Gagandeep},
title = {Incremental Verification of Neural Networks},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7812282},
abstract = {
    <p>Complete verification of deep neural networks (DNNs) can exactly determine whether the DNN satisfies a desired trustworthy property (e.g., robustness, fairness) on an infinite set of inputs or not. Despite the tremendous progress to improve the scalability of complete verifiers over the years on individual DNNs, they are inherently inefficient when a deployed DNN is updated to improve its inference speed or accuracy. The inefficiency is because the expensive verifier needs to be run from scratch on the updated DNN. To improve efficiency, we propose a new, general framework for incremental and complete DNN verification based on the design of novel theory, data structure, and algorithms. Our contributions implemented in a tool named IVAN yield an overall geometric mean speedup of 2.4x for verifying challenging MNIST and CIFAR10 classifiers and a geometric mean speedup of 3.8x for the ACAS-XU classifiers over the state-of-the-art baselines.</p>

},
keywords = {Neural Networks, Verification}
}

@software{10.5281/zenodo.7812534,
author = {Zhang, Tony Nuda and Sharma, Upamanyu and Kapritsos, Manos},
title = {Artifact for Article `Performal: Formal Verification of Latency Properties for Distributed Systems'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7812534},
abstract = {
    <p>This artifact includes source code used to produce the results the paper `Performal: Formal Verification of Latency Properties for Distributed Systems’. Instructions to reproduce the results are documented in the artifact.</p>

},
keywords = {distributed systems, formal software verification, latency, performance, systems verification}
}

@software{10.5281/zenodo.7812616,
author = {Yuan, Yongwei and Radhakrishna, Arjun and Samanta, Roopsha},
title = {Artifact for "Trace-Guided Inductive Synthesis of Recursive Functional Programs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7812616},
abstract = {
    <p>The artifact includes the implementation of the synthesis algorithm, and necessary code to reproduce the experimental results.</p>

},
keywords = {Program Synthesis, Recursive Functional Programs}
}

@software{10.5281/zenodo.7813157,
author = {Liu, Zongyuan and Stepanenko, Sergei and Pichon-Pharabod, Jean and Timany, Amin and Askarov, Aslan and Birkedal, Lars},
title = {Artifact of "VMSL: A Separation Logic for Mechanised Robust Safety of Virtual Machines Communicating above FF-A"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7813157},
abstract = {
    <p>This is the artifact for the PLDI’23 paper “VMSL: A Separation Logic for Mechanised Robust Safety of Virtual Machines Communicating above FF-A”. It is the Coq mechanisation of all results presented in the paper.</p>

},
keywords = {FF-A, hypercall, Iris, logical relation, robust safety, separation logic}
}

@software{10.5281/zenodo.7813862,
author = {Eilers, Marco and Dardinier, Thibault and M\"{u}ller, Peter},
title = {Artifact of paper "CommCSL: Proving Information Flow Security for Concurrent Programs using Abstract Commutativity"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7813862},
abstract = {
    <p>The artifact is a VirtualBox VM that contains the Isabelle/HOL formalization and soundness proof of CommCSL as well as the implementation of CommCSL in the tool HyperViper, and the evaluation presented in the paper.</p>

},
keywords = {Commutativity, concurrency, information flow security, separation logic}
}

@software{10.5281/zenodo.7813942,
author = {Sewell, Thomas and Myreen, Magnus O. and Tan, Yong Kiam and Kumar, Ramana and Mihajlovic, Alexander and Abrahamsson, Oskar and Owens, Scott},
title = {Cakeml+Eval Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7813942},
abstract = {
    <p>This is a collection of CakeML and Candle artefacts to accompany “Cakes that Bake Cakes: Dynamic Computation in CakeML”.</p>
<p>In this modified version of CakeML, the REPL and Candle modes are built into the standard bootstrapped CakeML compiler. The compiler is built into a binary via the in-HOL4 verified self-bootstrap mechanism.</p>
<p>The resulting executable REPL, and the proof repositories it is built from, are provided pre-built in this artefact.</p>

},
keywords = {compiler verification, dynamic computation, interactive theorem proving}
}

@software{10.5281/zenodo.7814275,
author = {Bansal, Manya and Hsu, Olivia and Olukotun, Kunle and Kjolstad, Fredrik},
title = {Artifact for Mosaic: An Interoperable Compiler for Tensor Algebra},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7814275},
abstract = {
    <p>This artifact describes how to set up and run Mosaic, a compiler that can compose externally defined library functions to implement an arbitrary sparse tensor algebra expression. Mosaic fills in the gaps that are not provided by the libraries, guaranteeing generality in both expressions and data structures. The artifact also describes how to reproduce the quantitative experimental results presented in the paper.</p>

},
keywords = {Code Optimization, Compiler, External Functions, Sparse Tensor Algebra}
}

@software{10.5281/zenodo.7814374,
author = {Bertram, Noah and Levinson, Alex and Hsu, Justin},
title = {Prototype implementation of Slice, appearing in "Cutting the Cake: A Language for Fair Division"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7814374},
abstract = {
    <p>This is a prototype implementation of the cake-cutting language, Slice. For more details, view the readme.</p>

},
keywords = {automatic verification, fair division}
}

@software{10.5281/zenodo.7814715,
author = {Pick, Lauren and Desai, Ankush and Gupta, Aarti},
title = {Software for `Psym: Efficient Symbolic Exploration of Distributed Systems'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7814715},
abstract = {
    <p>The artifact contains the software used to achieve experimental results the paper `Psym: Efficient Symbolic Exploration of Distributed Systems’ as well some of the benchmarks that can be used to reproduce the results.</p>

},
keywords = {binary decision diagrams, distributed systems, systematic exploration}
}

@software{10.5281/zenodo.7815663,
author = {Watt, Conrad and Trela, Maja and Lammich, Peter and M\"{a}rkl, Florian},
title = {Supplementary material for WasmRef-Isabelle},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7815663},
abstract = {
    <p>Supplementary figures and graphs as mentioned in the main publication, and an archive of our Isabelle/HOL code.</p>

},
keywords = {WasmCert}
}

@software{10.5281/zenodo.7816526,
author = {Tun\c{c}, H\"{u}nkar Can and Abdulla, Parosh Aziz and Chakraborty, Soham and Krishna, Shankaranarayanan and Mathur, Umang and Pavlogiannis, Andreas},
title = {Artifact for Article "Optimal Reads-From Consistency Checking for C11-Style Memory Models "},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7816526},
abstract = {
    <p>This artifact contains all the source codes and experimental data for replicating our evaluation in the paper. We implemented our programs as an extension to the C11Tester and GenMC tools. The provided experimental data contains all the benchmarks used in our evaluation. The artifact also contains Python scripts that fully automate the process of replicating our evaluation.</p>

},
keywords = {complexity, concurrency, weak memory models}
}

@software{10.5281/zenodo.7816533,
author = {Yoon, Yongho and Lee, Woosuk and Yi, Kwangkeun},
title = {Artifact of Inductive Program Synthesis via Iterative Forward-Backward Abstract Interpretation},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7816533},
abstract = {
    <p>The artifacts include the main tool(Simba), the other baseline solvers(Duet, Probe), benchmarks and evaluation scripts.</p>

},
keywords = {Abstract Interpretation, Program Synthesis}
}

@software{10.5281/zenodo.7817421,
author = {Zakhour, George and Weisenburger, Pascal and Salvaneschi, Guido},
title = {Type-Checking CRDT Convergence},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7817421},
abstract = {
    <p>Propel – Verifying the algebraic and relational properties of functions</p>
<p>Artifact for the paper “Type-Checking CRDT Convergence”</p>
<h2 id="getting-started">GETTING STARTED</h2>
<h3 id="building-and-loading-the-docker-image">BUILDING AND LOADING THE DOCKER IMAGE</h3>
<p>We provide you with <code>propel.tar.xz</code>, which is a pre-built container image that contains all necessary programs. To load, run the following command:</p>
<pre><code>$ docker load &lt; propel.tar.xz</code></pre>
<p>Further, we also provide the option to build the contain anew. To build, run the following command which takes between 10 and 20 minutes:</p>
<pre><code>$ docker build -t propel .</code></pre>
<p>Rebuilding the image may not work on Apple M1 machines because of incomplete emulation of system calls (specifically the inotify kernel subsystem). Hence, we recommend rebuilding the image on a platform fully supported by Docker, like x86-64 systems.</p>
<h3 id="checking-if-the-container-and-the-relevant-programs-run-correctly">CHECKING IF THE CONTAINER AND THE RELEVANT PROGRAMS RUN CORRECTLY</h3>
<p>We provide a script that runs fast checks on Propel and the other provers (HipSpec, Zeno, cvc5, Vampire) used in the evaluation.</p>
<p>The check verifies commutativity of natural number addition – a task which all programs are able to prove correct quickly. The following command runs the check:</p>
<pre><code>$ docker run -it --rm propel /check_image/check</code></pre>
<p>If you see in green the line “Check Done” at the end, the container is behaving as expected.</p>
<p>The check will show the provers’ output, which should look similar to the following (shortened) excerpt:</p>
<pre><code>Checking Zeno

[...]

Searching for proofs... 
Proved "CommutativityAddition.prop_comm_add : add x y = add y x"

[...]

Checking HipSpec

[...]

Proved:
    add m n == add n m
    add m (add n o) == add n (add m o)
    prop_comm_add {- add x y == add y x -}


Checking CVC5
"commutativity nat_add2p"
unsat

Checking Vampire

[...]

\% Termination reason: Refutation

[...]

Checking Propel

✔ Check successful.

Check Done</code></pre>
<p>Note that CVC5 and and Vampire report <code>unsat</code> or <code>Refutation</code>, respectively. This is because properties are verified by SMT solvers by finding a counterexample for their negation.</p>
<h2 id="step-by-step-instructions">STEP-BY-STEP INSTRUCTIONS</h2>
<h3 id="compiling-propel">COMPILING PROPEL</h3>
<p>The provided container already contains a binary executable of Propel.</p>
<p>To compile Propel to Java bytecode yourself, run the following command:</p>
<pre><code>$ docker run -it --rm propel bash -c 'cd /propel; sbt clean compile'</code></pre>
<p>To compile Propel to a native binary yourself, run the following command:</p>
<pre><code>$ docker run -it --rm propel bash -c 'cd /propel; sbt clean nativeLink'</code></pre>
<p>Compiling Propel, to bytecode or to a native executable, may not work inside the Docker container on Apple M1 machines for the reasons mentioned earlier.</p>
<p>The resulting binary is at <code>/propel/.native/target/scala-3.2.2/propel</code>. The <code>propel</code> executable in the PATH is already symlinked to that binary file. Hence, by default, you can just run <code>propel</code>.</p>
<h3 id="testing-propel">TESTING PROPEL</h3>
<p>To run the tests in Propel, execute:</p>
<pre><code>$ docker run -it --rm propel bash -c 'cd /propel &amp;\&amp; sbt test'</code></pre>
<p>Running the Propel tests may not work inside the Docker container on Apple M1 machines for the reasons mentioned earlier.</p>
<p>Note that running all unit tests can take several minutes. The output should look similar to the following (shortened) excerpt:</p>
<pre><code>[info] SuccessfulPropertyChecks:
[info] - nat_add2p
[info] - nat_add3p
[info] - nat_mult2p
[info] - bv_add

[...]

[info] FailingPropertyChecks:
[info] - nat_add2p_acc !!! IGNORED !!!
[info] - nat_add3p_acc !!! IGNORED !!!

[...]

[info] Total number of tests run: 49
[info] Suites: completed 2, aborted 0
[info] Tests: succeeded 49, failed 0, canceled 0, ignored 15, pending 0
</code></pre>
<p>The <code>SuccessfulPropertyChecks</code> contain the examples for which Propel can verify all properties. The <code>FailingPropertyChecks</code> contain the examples for which Propel is unable to verify all properties, hence their unit tests are disabled (<code>IGNORED</code>).</p>
<h3 id="running-the-benchmarks">RUNNING THE BENCHMARKS</h3>
<p>The benchmarks in Tables 2 and 3, and Figure 1 can be re-executed with the container. The number of the properties that (1) could be proven,(2) could not be proven and (3) timed out should match the content of tables and the figures. The given time may differ depending on the system where the benchmarks are run. Due the the timeout of one minute, not only the amount of seconds can differ but also the type of the result. It could be the case that the benchmark succeeds or fails in less than 60s on one setup but takes more than 60s on a different setup, in which case it would time out.</p>
<p>To execute the benchmarks on HipSpec, run the following command:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/hipspec/run</code></pre>
<p>To execute the benchmarks on Zeno, run the following command:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/zeno/run</code></pre>
<p>To execute the benchmarks on cvc5, run the following command:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/cvc5/run</code></pre>
<p>To execute the benchmarks on Vampire, run the following command:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/vampire/run</code></pre>
<p>To execute the benchmarks on Propel, run the following command:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/propel/run</code></pre>
<p>The results in Table 2 correspond to one line from the output of each command. We list each CRDT benchmark and the token its corresponding line starts with:</p>
<ol type="1">
<li>GCounter (Peano number list)
<ul>
<li>commutativity: <code>natlist_gcounter_comm</code></li>
<li>associativity: <code>natlist_gcounter_assoc</code></li>
<li>idempotency: <code>natlist_gcounter_idem</code></li>
</ul></li>
<li>GCounter (bit vector list)
<ul>
<li>commutativity: <code>bvlist_gcounter_comm</code></li>
<li>associativity: <code>bvlist_gcounter_assoc</code></li>
<li>idempotency: <code>bvlist_gcounter_idem</code></li>
</ul></li>
<li>BCounter (Peano number list)
<ul>
<li>commutativity: <code>natlist_bcounter_comm</code></li>
<li>associativity: <code>natlist_bcounter_assoc</code></li>
<li>idempotency: <code>natlist_bcounter_idem</code></li>
</ul></li>
<li>BCounter (bit vector list)
<ul>
<li>commutativity: <code>bvlist_bcounter_comm</code></li>
<li>associativity: <code>bvlist_bcounter_assoc</code></li>
<li>idempotency: <code>bvlist_bcounter_idem</code></li>
</ul></li>
<li>PNCounter (Peano number list)
<ul>
<li>commutativity: <code>natlist_pncounter_comm</code></li>
<li>associativity: <code>natlist_pncounter_assoc</code></li>
<li>idempotency: <code>natlist_pncounter_idem</code></li>
</ul></li>
<li>PNCounter (bit vector list)
<ul>
<li>commutativity: <code>bvlist_pncounter_comm</code></li>
<li>associativity: <code>bvlist_pncounter_assoc</code></li>
<li>idempotency: <code>bvlist_pncounter_idem</code></li>
</ul></li>
<li>LWW Register (Peano numbers)
<ul>
<li>commutativity: <code>nat_lwwreg_comm</code></li>
<li>associativity: <code>nat_lwwreg_assoc</code></li>
<li>idempotency: <code>nat_lwwreg_idem</code></li>
</ul></li>
<li>LWW Register (bit vectors)
<ul>
<li>commutativity: <code>bv_lwwreg_comm</code></li>
<li>associativity: <code>bv_lwwreg_assoc</code></li>
<li>idempotency: <code>bv_lwwreg_idem</code></li>
</ul></li>
<li>GSet
<ul>
<li>commutativity: <code>gset_comm</code></li>
<li>associativity: <code>gset_assoc</code></li>
<li>idempotency: <code>gset_idem</code></li>
</ul></li>
<li>ORSet
<ul>
<li>commutativity: <code>orset_comm</code></li>
<li>associativity: <code>orset_assoc</code></li>
<li>idempotency: <code>orset_idem</code></li>
</ul></li>
<li>2PSet
<ul>
<li>commutativity: <code>twophaseset_comm</code></li>
<li>associativity: <code>twophaseset_assoc</code></li>
<li>idempotency: <code>twophaseset_idem</code></li>
</ul></li>
</ol>
<p>The results in Table 3 correspond to one line from the output of each command. We list each CRDT benchmark and the token its corresponding line starts with:</p>
<ol type="1">
<li>add2p
<ul>
<li>commutativity: <code>nat_add2p_comm</code></li>
<li>associativity: <code>nat_add2p_assoc</code></li>
</ul></li>
<li>add3p
<ul>
<li>commutativity: <code>nat_add3p_comm</code></li>
<li>associativity: <code>nat_add3p_assoc</code></li>
</ul></li>
</ol>
<p>Figure 2 provides further benchmark results from those benchmarks of the TIP 2015 (Tons of Inductive Problems, https://tip-org.github.io/) benchmark suite, which check algebraic and relational properties supported by Propel. They can be run using the following commands:</p>
<pre><code>$ docker run -it --rm propel /tip2015/hipspec/run
$ docker run -it --rm propel /tip2015/zeno/run
$ docker run -it --rm propel /tip2015/cvc5/run
$ docker run -it --rm propel /tip2015/vampire/run
$ docker run -it --rm propel /tip2015/propel/run</code></pre>
<h3 id="using-propel-as-a-scala-dsl">USING PROPEL AS A SCALA DSL</h3>
<p>Propel as described in Section 3 is a DSL in Scala. To experiment with the DSL, we invite you take a look into <code>/propel/src/test/scala/propel/ScalaExamplesNat.scala</code>, <code>/propel/src/test/scala/propel/ScalaExamplesNum.scala</code> and <code>/propel/src/test/scala/propel/ScalaExamplesList.scala</code> inside the container.</p>
<p>As an example, you can execute the following commands to run a shell, explore the files and recompile the project:</p>
<pre><code>$ docker run -it --rm propel bash                               # open a shell
$ nano /propel/src/test/scala/propel/ScalaExamplesList.scala    # open the file

# edit and save the file

$ cd /propel &amp;\&amp; sbt Test/compile                                # recompile</code></pre>
<p>Compiling the examples may not work inside the Docker container on Apple M1 machines for the reasons mentioned earlier.</p>
<p>You may define your own function using the following syntax:</p>
<pre><code>def myFunction = prop[(FunctionProperties) ::= (T1, T1) =&gt;: T2] { (x, y) =&gt; body }
// or
def myRecursiveFunction = prop.rec[(FunctionProperties) ::= (T1, T1) =&gt;: T2] { myRecursiveFunction =&gt; (x, y) =&gt; body }</code></pre>
<p>Here, <code>myFunction</code> is the name of the function, <code>FunctionProperties</code> is a list of function properties the function has (separated by <code>&amp;</code>), <code>T1</code> is the type of the arguments of the binary function, <code>T2</code> is the return type of the function, <code>x</code> and <code>y</code> are the names of the function arguments, and <code>body</code> is the function body.</p>
<p>The function properties are chosen from the following list: <code>Comm</code>, <code>Assoc</code>, <code>Idem</code>, <code>Sel</code>, <code>Refl</code>, <code>Antisym</code>, <code>Trans</code>, <code>Conn</code>, and <code>Sym</code>. Their semantics is defined in Table 1.</p>
<p>If Propel is able to prove the properties that the function is annotated with, then compilation succeeds. If the properties cannot be proven, then a compilation error indicates which property could not be proven</p>
<p>For example, you can add the GCounter CRDT example from the paper to one of the files in <code>/propel/src/test/scala/propel</code></p>
<pre><code>def mergeGCounter = prop[(Comm \&amp; Assoc \&amp; Idem) := (List[Num], List[Num]) =&gt;: List[Num]] { (x, y) =&gt; zipWith(maxNum)(x, y) }</code></pre>
<p>We hope that the integration into Scala makes the artifact easily usable by other researchers, either (1) by directly using the DSL to check algebraic and relational properties of their programs or (2) by building on Propel’s verification engine. To facilitate the latter, the implementation of Propel’s Scala DSL (<code>propel.dsl</code> package) is separated from the verification mechanism (<code>propel.evaluator</code> package), which researchers can adopt independently of the Scala integration (an overview of the package structure is in the last section).</p>
<h3 id="using-propel-standalone-outside-of-scala">USING PROPEL STANDALONE (OUTSIDE OF SCALA)</h3>
<p>Propel can be directly reused as a verification tool in other projects (without the Scala and JVM dependency) through the <code>propel</code> binary. The binary consumes ASTs of Propel’s calculus in an S-expression-based syntax.</p>
<p>Our Scala implementation of the full surface language also follows the approach of translating Scala programs to terms in the calculus and passing them to the verification mechanism. A similar approach can be adopted by other tools that use Propel. Note that the AST is a bit more low-level then the Scala implementation and the calculus presented in the paper. In particular, the properties that are captured in the type of a function need to be propagated to the call sites of the function, i.e., function calls are syntactically annotated with the properties that should hold for them. The concrete format is described in the FORMAT.md file.</p>
<p>We provide all benchmarks in this format in the <code>/benchmarks/propel</code> directory. For example, the <code>nat_add2p_comm.propel</code> is a direct translation of the <code>add2p</code> function of Listing 4. This file can be checked by running:</p>
<pre><code>propel -f /benchmarks/propel/nat_add2p_comm.propel</code></pre>
<p>Additional information about the proof attempts can be shown using the <code>-d</code> and <code>-r</code> flags.</p>
<h3 id="structure-of-the-propel-source-code">STRUCTURE OF THE PROPEL SOURCE CODE</h3>
<p>Propel is organized into the following packages:</p>
<ul>
<li><code>ast</code>: Abstract syntax tree definitions for the verifier</li>
<li><code>dsl</code>: Scala DSL</li>
<li><code>evaluator</code>: Rewrite engine (used by an implementation of the calculus’ dynamic semantics and by the verifier)</li>
<li><code>evaluator.properties</code>: Verifier for algebraic and relational properties (call <code>evaluator.properties.check</code> on an <code>ast.Term</code> to verify properties)</li>
<li><code>parser</code>: Parser for Propel’s serialization format (as used by the benchmarks)</li>
<li><code>printing</code>: Pretty-printer for Propel ASTs</li>
<li><code>typer</code>: Standard type checker (not checking algebraic and relational properties)</li>
<li><code>util</code>: Small, useful definitions</li>
</ul>

},
keywords = {Conflict-Free Replicated Data Types, Type Systems, Verification}
}

@software{10.5281/zenodo.7819755,
author = {Lecoeur, Bastien and Mohsin, Hasan and Donaldson, Alastair F.},
title = {Artifact for "Program Reconditioning: Avoiding Undefined Behaviour When Finding and Reducing Compiler Bugs", PLDI 2023},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7819755},
abstract = {
    <p>The artifact includes runnable versions of the GLSLsmith and WGSLsmith tools (both source code and binary distributions), together with instructions showing how to use them to find and reduce compiler bugs, plus data sets related to controlled experiments described in the paper.</p>

},
keywords = {compiler testing, OpenGL, Randomised testing, test-case reduction, undefined behaviour, WebGPU}
}

@software{10.5281/zenodo.7823993,
author = {Sisco, Zachary D. and Balkind, Jonathan and Sherwood, Timothy and Hardekopf, Ben},
title = {Artifact for "Loop Rerolling for Hardware Decompilation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7823993},
abstract = {
    <p>The artifact consists of four components: (1) source code for hardware loop identification over the benchmark suite of netlists; (2) source code for hardware loop rerolling over the benchmark suite; (3) scripts for comparing simulation times between decompiled HDL code with rerolled loops and the original netlist using Verilator; and (4) Yosys scripts for converting Verilog designs to netlists in BLIF. We provide instructions to reproduce the results reported in the evaluation.</p>

},
keywords = {hardware decompilation, loop rerolling, program synthesis}
}

@software{10.5281/zenodo.7824069,
author = {Arora, Jatin and Westrick, Sam and Acar, Umut A.},
title = {Replication instructions for Article: Efficient Parallel Functional Programming with Effects},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7824069},
abstract = {
    <p>The artifact contains the implementation of our language MPL and also contains benchmarks for its evaluation w.r.t languages MLton, C/C++, Go, Java, and OCaml.</p>

},
keywords = {functional languages, memory management, parallel programming, parallelism}
}

@software{10.5281/zenodo.7824175,
author = {Guria, Sankha Narayan and Foster, Jeffrey S. and Van Horn, David},
title = {Artifact for "Absynthe: Abstract Interpretation-Guided Synthesis"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7824175},
abstract = {
    <p>The artifact is a Docker image that contains all of the source code, benchmarks, and experiment harnesses used in the development of the paper (set-up and ready to run). The README contains instructions to reproduce results from the paper, as well as pointers for how to use, extend or modify the tool and benchmarks.</p>

},
keywords = {abstract interpretation, program synthesis, Ruby}
}

@software{10.5281/zenodo.7824546,
author = {Bouajjani, Ahmed and Enea, Constantin and Rom\'{a}n-Calvo, Enrique},
title = {Transactional JPF - Artifact for "Dynamic Partial Order Reduction for Checking Correctness against Transaction Isolation Levels"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7824546},
abstract = {
    <p>Extension of Java PathFinder (JPF) for managing transactions as well as EXPLORE-CE algorithm’s implementation. It includes several benchmarks used in the article “Dynamic Partial Order Reduction for Checking Correctness against Transaction Isolation Levels” as well as graphical scripts for plotting the results.</p>

},
keywords = {Dynamic Partial-Order Reduction, Java PathFinder, Transactional Databases, Weak Isolation Levels}
}

@software{10.5281/zenodo.7824835,
author = {Yallop, Jeremy and Xie, Ningning and Krishnaswami, Neel},
title = {flap: A Deterministic Parser with Fused Lexing (artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7824835},
abstract = {
    <p>Artifact accompanying the paper “flap: A Deterministic Parser with Fused Lexing”. Please see the latest version: https://doi.org/10.5281/zenodo.7712770</p>

},
keywords = {fusion, lexing, multi-stage programming, optimization, parsing}
}

@software{10.5281/zenodo.7829982,
author = {Meyer, Roland and Wies, Thomas and Wolff, Sebastian},
title = {Artifact for "Embedding Hindsight Reasoning in Separation Logic"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7829982},
abstract = {
    <p>The artifact demonstrates that the implementation from the paper “Embedding Hindsight Reasoning in Separation Logic” [PLDI’23], an extension of the PLANKTON tool, (1) can automatically verify the Logical Ordering tree, and (2) compares the extension with the original version of PLANKTON in terms of performance and proof capabilities.</p>

},
keywords = {Automated reasoning, Hindsight, Hoare logic, Linearizability, Logical Ordering Tree, Program verification, Programming logic, Separation logic}
}

@software{10.5281/zenodo.7832346,
author = {Wilkinson, Lucas and Cheshmi, Kazem and Dehnavi, Maryam Mehri},
title = {Register Tiling for Unstructured Sparsity in Neural Network Inference Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7832346},
abstract = {
    <p>This is the code for the “Register Tiling for Unstructured Sparsity in Neural Network Inference” paper in PLDI 2023, please see the README in size <code>artifact_src.tgz</code> for instructions on how to use the code. Please see https://github.com/SpRegTiling/sparse-register-tiling for the latest version of the code.</p>

},
keywords = {Matrix Multiplication, Pruned Neural Networks, Register Tiling, Sparse Matrix, SpMM}
}

@software{10.5281/zenodo.7997778,
author = {M\"{u}ller, Mark Niklas and Fischer, Marc and Staab, Robin and Vechev, Martin},
title = {Abstract Interpretation of Fixpoint Iterators with Applications to Neural Networks - Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7997778},
abstract = {
    <p>An implementation of the abstract fixpoint iterator framework for monDEQs, CRAFT, as well as the CH-Zonotope domain. Included are the code, trained models, expected results, and detailed instructions on how to reproduce all results from the PLDI’23 paper “Abstract Interpretation of Fixpoint Iterators with Applications to Neural Networks”.</p>

},
keywords = {abstract interpretation, adversarial robustness, equlibrium models, fixpoint}
}

@software{10.5281/zenodo.7921796,
author = {Shen, Mingjie and Davis, James C. and Machiry, Aravind},
title = {Reproduction Package for Article `Towards Automated Identification of Layering Violations in Embedded Applications (WIP)'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7921796},
abstract = {
    <p>This is a tool to detect layering violations in embedded applications. The tool uses LLVM and requires a bitcode file of the target application.</p>
<p>Specifically, given a bitcode file, our tool will generate the list of all NCMAs (a type of layering violations).</p>

},
keywords = {Embedded Systems, Firmware, Hardware Abstraction Layer, Portability, Static Analysis}
}

@software{10.5281/zenodo.7929610,
author = {Gollenstede, Niklas and Kulau, Ulf and Dietrich, Christian},
title = {Implementations for "reUpNix: Reconfigurable and Updateable Embedded Systems"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7929610},
abstract = {
    <p>This repository contains the practical contributions for the paper “reUpNix: Reconfigurable and Updateable Embedded Systems”.</p>
<p>The differential update transfer mechanism <code>nix store sent</code> is implemented as part of Nix, and is included here as one big patch in <code>patches/nix-store-send.patch</code>.</p>
<p><code>modules/hermetic-bootloader.nix.md</code> implements the bootloader configuration, and <code>modules/minify.nix.md</code> realizes the reduction in installation size.</p>
<p>Container integration is implemented in <code>modules/target/containers.nix.md</code>, and the configuration model (Machine Config / System Profile) by the layout of the individual hosts in <code>hosts/</code>, by <code>lib/misc.nix#importMachineConfig</code>, and by <code>modules/target/specs.nix.md</code>.</p>

},
keywords = {embedded systems, NixOS, reproducible systems}
}

@software{10.5281/zenodo.7939291,
author = {Rommel, Florian and Dietrich, Christian and Ziegler, Andreas and Ostapyshyn, Illia and Lohmann, Daniel},
title = {Thread-Level Attack-Surface Reduction - Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7939291},
abstract = {
    <p>This artifact contains the raw data of the evaluation results and the necessary programs and scripts to repeat the experiments and analyses of the paper “Thread-Level Attack-Surface Reduction”, presented at the 24th ACM SIGPLAN/SIGBED International Conference on Languages, Compilers, and Tools for Embedded Systems (LCTES 2023). See https://doi.org/10.1145/3589610.3596281</p>

},
keywords = {binary tailoring, debloating, return-oriented programming}
}

@software{10.1145/3554355,
author = {\^{A}ngelo, Pedro and Bono, Viviana and Dezani-Ciancaglini, Mariangiola and Florido, M\'{a}rio},
title = {Gradual Guarantee for FJ with lambda-Expressions (Full Version)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554355},
abstract = {
    <p>Full version of FTfJP paper with proofs</p>

},
keywords = {Featherweight Java, Gradual Typing, Intersection Types, lambda-expressions}
}

@software{10.1145/3554356,
author = {Nanjekye, Joannah and Bremner, David and Micic, Aleksandar},
title = {Reproduction Package for Article: Towards Reliable Memory Management for Python Native Extensions},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3554356},
abstract = {
    <p>The artifact consists of three components: - benchmarks - cystck - Migration</p>
<p>The <code>cystck</code> folder contains the implementation of the proposed CyStck Python C API described in the article, while the <code>migration</code> folder contains implementation for a tool that automatically migrates extensions built using the Python C API to a version that uses the proposed CyStck API. Finally, the <code>benchmarks</code> folder has the benchmarks used in the evaluation of CyStck. There are three sets of benchmarks, one set for the Python C API, another set for the <code>HPy</code> API and a the third set for the <code>CyStck</code> API.</p>

},
keywords = {C API, garbage collection, memory management, native extensions, Python}
}

@software{10.5281/zenodo.7825616,
author = {Li, Changwen and Sifakis, Joseph and Wang, Qiang and Yan, Rongjie and Zhang, Jian},
title = {Reproduction Package for `Simulation-Based Validation for Autonomous Driving Systems'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7825616},
abstract = {
    <p>The artifact provides RvADS, a simulation-based validation framework for autonomous driving systems that contains three components: 1)Simulator, 2) Scenario Generator, and 3) Monitor.</p>

},
keywords = {Autonomous driving systems, Formal specification, LGSVL, Runtime verification, Simulation-based validation, Temporal logic}
}

@software{10.5281/zenodo.7896362,
author = {Zohdinasab, Tahereh and Riccio, Vincenzo and Tonella, Paolo},
title = {DeepAtash: Focused Test Generation for Deep Learning systems},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7896362},
abstract = {
    <p>The source code and the data of the article “DeepAtash: Focused Test Generation for Deep Learning systems”</p>

},
keywords = {deep learning, search based software engineering, software testing}
}

@software{10.5281/zenodo.7905120,
author = {Ma, Haoyang and Shen, Qingchao and Tian, Yongqiang and Chen, Junjie and Cheung, Shing-Chi},
title = {Artifact for the ISSTA2023 Paper Fuzzing Deep Learning Compilers with HirGen},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7905120},
abstract = {
    <p>This is the artifact of HirGen. It contains about 3K LOC C++ code and cmake files for building the softwares. The main purpose of it is to generate executable <code>hirgen</code> for generating computational graphs and use them to test DL compilers.</p>

},
keywords = {Fuzzer, Program Generator}
}

@software{10.5281/zenodo.7909725,
author = {Yu, Shiwen and Wang, Ting and Wang, Ji},
title = {The tool LIPuS and its experiment package of the paper ''Loop Invariant Inference through SMT Solving Enhanced Reinforcement Learning''},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7909725},
abstract = {
    <p>This is the repository of LIPuS, which is a loop invariant inference tool based on SMT Solving Enhanced Reinforcement Learning. LIPuS is the implemented tool for the method proposed in the paper: “Loop Invariant Inference through SMT Solving Enhanced Reinforcement Learning”.</p>

},
keywords = {loop invariant, reinforcement learning}
}

@software{10.5281/zenodo.7922486,
author = {Levine, Reese and Cho, Mingun and McKee, Devon and Quinn, Andrew and Sorensen, Tyler},
title = {GPUHarbor: Testing GPU Memory Consistency At Large (Experience Paper): Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7922486},
abstract = {
    <p>Artifact for the ISSTA 2023 paper “GPUHarbor: Testing GPU Memory Consistency At Large (Experience Paper)”, containing the data used in the paper as well as the tools we used to collect and analyze the data.</p>

},
keywords = {GPUs, memory consistency, mutation testing}
}

@software{10.5281/zenodo.7939536,
author = {Du, Hang and Palepu, Vijay Krishna and Jones, James A.},
title = {Reproduction Package for An Empricial Study of Mutation Testing Kills},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7939536},
abstract = {
    <p>This project provides an experimental replication setup and source code for To Kill a Mutant: An Empirical Study of Mutation Testing Kills. Artifact’s data structure, experiments’ general setups and detailed instructions are provided.</p>

},
keywords = {empirical study, mutant detection, mutation testing, test failure classification}
}

@software{10.5281/zenodo.7942804,
author = {Ramos, Frederico and Reis, Diogo Costa and Trigo, Miguel and Morgado, Ant\'{o}nio and Fragoso Santos, Jos\'{e}},
title = {Reproduction Package for Article `MetaData262: Automatic Test Suite Selection for Partial JavaScript Implementations'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7942804},
abstract = {
    <p>The overall architecture of the MetaData262 Computation Engine consists of five main modules: (1) the Frontmatter Parsing Module (M1) for parsing the frontmatter keys of each test and creating the base JSON object to which the parsed keys are to be added; (2) the Syntactic Constructs Module (M2) for computing the syntactic constructs used within each test; (3) the History Computation Module (M3) for determining the creation date and last-modified date associated with each test; (4) the Version Computation Module (M4) for determining the version of the ES standard to be associated with each test; and (5) the Built-Ins Computation Module (M5) for determining the built-in objects used within each test.</p>

},
keywords = {ECMAScript, Metadata, Test262}
}

@software{10.5281/zenodo.7944722,
author = {Lipp, Stephan and Elsner, Daniel and Kacianka, Severin and Pretschner, Alexander and B\"{o}hme, Marcel and Banescu, Sebastian},
title = {Artifacts for the paper: "Green Fuzzing: A Saturation-Based Stopping Criterion using Vulnerability Prediction"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7944722},
abstract = {
    <p>This repository contains the training and evaluation data, including the analysis script and machine-learned vulnerability prediction models, of the paper “Green Fuzzing: A Saturation-Based Stopping Criterion using Vulnerability Prediction”.</p>

},
keywords = {fuzzing, stopping criteria, vulnerability prediction}
}

@software{10.5281/zenodo.7955514,
author = {Wang, Zihan and Nie, Pengbo and Miao, Xinyuan and Chen, Yuting and Wan, Chengcheng and Bu, Lei and Zhao, Jianjun},
title = {Artifact for Paper "GenCoG: A DSL-Based Approach to Generating Computation Graphs for TVM Testing"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7955514},
abstract = {
    <p>This is the artifact for the ISSTA ’23 paper “GenCoG: A DSL-Based Approach to Generating Computation Graphs for TVM Testing”. This artifact contains the implementation of GenCoG, the adapted versions or reimplementation of the baselines, and the bug-triggering cases.</p>

},
keywords = {Computation Graph Generation, Constraint Solving, Deep Learning Compiler}
}

@software{10.5281/zenodo.7962231,
author = {Chen, Zhuo and Liu, Jie and Hu, Yubo and Wu, Lei and Zhou, Yajin and He, Yiling and Liao, Xianhao and Wang, Ke and Li, Jinku and Qin, Zhan},
title = {DeUEDroid system},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7962231},
abstract = {
    <p>Deuedroid is a detection system designed for Underground economy apps, which consists of two parts: statistic analysis part and machine learning part.</p>

},
keywords = {machine learning, UTG}
}

@software{10.5281/zenodo.7962308,
author = {Chow, Yiu Wai and Sch\"{a}fer, Max and Pradel, Michael},
title = {Artifact for "Beware of the Unexpected: Bimodal Taint Analysis"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7962308},
abstract = {
    <p>This artifact contains supplementary material for the paper “Beware of the Unexpected: Bimodal Taint Analysis” (ISSTA’23).</p>

},
keywords = {AI4SE, software security}
}

@software{10.5281/zenodo.7965678,
author = {He, Dongjie and Gui, Yujiang and Gao, Yaoqing and Xue, Jingling},
title = {Reducing the Memory Footprint of IFDS-based Data-Flow Analyses Using Fine-Grained Garbage Collection (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7965678},
abstract = {
    <p>The artifact contains our implementation of the Fine-grained Garbage Collection algorithm introduced in our paper “Reducing the Memory Footprint of IFDS-based Data-Flow Analyses Using Fine-Grained Garbage Collection”. The artifact includes all scripts and benchmarks for reproducing the results and claims made in our paper.</p>

},
keywords = {IFDS, Path Edge Collection, Taint Analysis}
}

@software{10.5281/zenodo.7970349,
author = {Alsaeed, Ziyad and Young, Michal},
title = {Artifact: Finding Short Slow Inputs Faster with Grammar-Based Search},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7970349},
abstract = {
    <p>Two grammar based performance fuzzing tools. SlackLine and TreeLine that find short strings that trigger worst-case performance.</p>
<p>TreeLine and SlackLine artifact, each in its own compressed file, which has a dedicated README file. These are related to the ISSTA’23 publication titled “Finding Short Slow Inputs Faster with Grammar-Based Search.”</p>
<p>The attached files are the ISSTA’23 snapshots of the projects. The up-to-date versions can be found in the dedicated GitHub repos of each project.</p>
<p>TreeLine: https://github.com/uo-se-research/treeline SlackLine: https://github.com/uo-se-research/slackline In addition, each tool has its own Docker repository. They can be found through the following links:</p>
<p>TreeLine: https://hub.docker.com/r/zalsaeed/treeline SlackLine: https://hub.docker.com/r/zalsaeed/slackline We share all the experimental data in a compressed file. The data size is slightly larger than 7GB when you uncompress it.</p>
<p>https://doi.org/10.6084/m9.figshare.22114373.v1</p>

},
keywords = {Input Generation, MCTS, Performance Analysis}
}

@software{10.5281/zenodo.7970822,
author = {Alonso, Juan C. and Segura, Sergio and Ruiz-Cort\'{e}s, Antonio},
title = {[Supplementary material] AGORA: Automated Generation of Test Oracles for REST APIs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7970822},
abstract = {
    <p>In order to enable reproducibility of the results reported in this paper, we provide a supplementary material containing the source code of the scripts and projects developed, videos explaining how to use the provided software, the data generated in our experiments, bug reports with the corresponding responses from the developers, as well as a Docker image and an Ubuntu virtual machine with all the projects configured. With these resources, we aim to provide a robust foundation for replicating and validating our findings.</p>
<p>To use the most up-to-date version of AGORA, please refer to the official GitHub repository: https://github.com/isa-group/Beet</p>

},
keywords = {automated testing, invariant detection, REST APIs, test oracle}
}

@software{10.5281/zenodo.7976809,
author = {Kamm, Matteo and Rigger, Manuel and Zhang, Chengyu and Su, Zhendong},
title = {Reproduction artifact for "Testing Graph Database Engines via Query Partitioning"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7976809},
abstract = {
    <p>The artifact consists of two main components: - GDBMeter, the tool which implements Predicate Partitioning and was used to find all bugs reported in the paper. - A SQLite database with a list of bugs that we reported and additional meta information.</p>

},
keywords = {automatic testing, database testing, graph databases, test oracle}
}

@software{10.5281/zenodo.7976968,
author = {Cheng, Kai and Zheng, Yaowen and Liu, Tao and Guan, Le and Liu, Peng and Li, Hong and Zhu, Hongsong and Ye, Kejiang and Sun, Limin},
title = {Reproduction Package for Article `Detecting Vulnerabilities in Linux-based Embedded Firmware with SSE-based On-demand Alias Analysis'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7976968},
abstract = {
    <p>EmTaint, a novel static analysis tool for accurate and fast detection of taint-style vulnerabilities in embedded firmware. In EmTaint, we design a structured symbolic expression-based (SSE-based) on-demand alias analysis technique, which serves as a basis for resolving both implicit data flow and control flow on potential vulnerable paths. Based on it, we come up with indirect call resolution and accurate taint analysis scheme. Combined with sanitization rule checking, EmTaint can eventually discovers a large number of taint-style vulnerabilities accurately within a limited time.</p>

},
keywords = {Embedded firmware, On-demand alias analysis, Taint analysis}
}

@software{10.5281/zenodo.7977256,
author = {Liu, Kaibo and Han, Yudong and Zhang, Jie M. and Chen, Zhenpeng and Sarro, Federica and Harman, Mark and Huang, Gang and Ma, Yun},
title = {TrickyBugs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7977256},
abstract = {
    <p>This is TrickyBugs, the dataset of the ISSTA’23 paper entitled “Who Judges the Judge: An Empirical Study on Online Judge Tests”. This dataset contains the detected false positive solutions (bugs) and the corresponding generated hack test inputs and hack test outputs in the paper. Read the paper for detailed information.</p>

},
keywords = {Online judge platform, Software testing, Test assessment}
}

@software{10.5281/zenodo.7977434,
author = {Jia, Fuqi and Han, Rui and Huang, Pei and Liu, Minghao and Ma, Feifei and Zhang, Jian},
title = {Improving Bit-Blasting for Nonlinear Integer Constraints},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7977434},
abstract = {
    <p>This Artifact Evaluation document provides an assessment of the artifact submitted with the paper titled “Improving Bit-Blasting for Nonlinear Integer Constraints”, which was accepted at ISSTA 2023. The purpose of this evaluation is to verify the artifact’s reproducibility and usefulness in advancing the field.</p>
<p>The tool names BLAN, i.e., Bit-bLAst to solve Nonlinear integer constraints. In the paper, we combine it with an SMT-LIB frontend so that it can solve QF_NIA (quantifier free nonlinear integer arithmetic) constraints. It is available at</p>
<pre><code>https://github.com/MRVAPOR/BLAN</code></pre>

},
keywords = {nonlinear integer constraints, satisfiability modulo theories}
}

@software{10.5281/zenodo.7977493,
author = {Ren, Kunlun and Qiang, Weizhong and Wu, Yueming and Zhou, Yi and Zou, Deqing and Jin, Hai},
title = {Artifacts for the ISSTA 2023 Paper: An Empirical Study on the Effects of Obfuscation on Static Machine Learning-based Malicious JavaScript Detectors},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7977493},
abstract = {
    <p>This repository contains the evaluation script and the corresponding data of the ISSTA’23 paper “An Empirical Study on the Effects of Obfuscation on Static Machine Learning-Based Malicious JavaScript Detectors”. Detailed Instructions: detectors: The detectors under the folder detectors/ are the main projects to be evaluated in our paper, which are CUJO, ZOZZLE, JAST, and JSTAP. Detailed setup and usage instructions are described in README.md in the corresponding folder. samples: The files under the folder samples/ are the samples from a random tenth of our dataset used in our paper. Results can be obtained quickly using these samples. These results will not be exactly the same as in the paper, but they are similar. RQ1: The code under folder RQ1/ is to figure out how obfuscation affects these detectors. RQ1_1_train.py is to train four detectors with unobfuscated samples. RQ1_1_test.py tests these trained detectors with unobfuscated and obfuscated samples. RQ1_2_train.py is to train the detector ZOZZLE that uses different machine learning algorithms. RQ1_2_test.py tests these trained models with unobfuscated and obfuscated samples. RQ1_3_train.py uses a training set with all unobfuscated benign samples and all obfuscated malicious samples, and a training set with all obfuscated benign samples and all unobfuscated malicious samples to train the detectors. RQ1_3_test.py uses these detectors to detect unobfuscated benign samples, obfuscated benign samples, unobfuscated malicious samples, and obfuscated malicious samples, respectively. RQ2: The code under folder RQ2/ is to study the two measures to mitigate the impact of obfuscation effective or not. RQ2_1_train.py uses obfuscated samples to train four detectors. RQ2_1_test.py tests these detectors on the same type of obfuscated samples. RQ2_2_test.py tests thest detectors on the different type of obfuscated samples. RQ2_3.py uses the BERT variants to generate code representation of unobfuscated samples, trains the detector with these code representations, and tests the trained detectors with code representations of obfuscated samples. RQ3: The code unser fodler RQ3/ visualizes the vectors, extracts the ten most important features, and calculates the distance between different sets of vectors. RQ4: There is no code related to RQ4 here because the actual operation of RQ4 is to submit the samples to VirusTotal .</p>

},
keywords = {JavaScript obfuscation, machine learning, malicious JavaScript detector, web security}
}

@software{10.5281/zenodo.7977570,
author = {Xie, Zifan and Wen, Ming and Jia, Haoxiang and Guo, Xiaochen and Huang, Xiaotong and Zou, Deqing and Jin, Hai},
title = {Reproduction Package for Ariticle "Precise and Efficient Patch Presence Test for Android Applications against Code Obfuscation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7977570},
abstract = {
    <p>This is the repository for paper submission “Precise and Efficient Patch Presence Test for Android Applications against Code Obfuscation”. It introduces PHunter, which is a precise and efficient patch presence test tool for Android applications against code obfuscation, including identifier renaming, package flattening, control flow randomization, and dead code removal. PHunter does not rely on debug information and uses fine-grained anti-obfuscation</p>

},
keywords = {Android Security, Library Detection, Patch Presence Test}
}

@software{10.5281/zenodo.7977752,
author = {Lehmann, Daniel and Thalakottur, Michelle and Tip, Frank and Pradel, Michael},
title = {Artifact for "That’s a Tough Call: Studying the Challenges of Call Graph Construction for WebAssembly"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7977752},
abstract = {
    <p>This artifact contains supplementary material for the paper “That’s a Tough Call: On Static Call Graph Construction for WebAssembly Binaries” (ISSTA’23).</p>

},
keywords = {call graphs, dataset, WebAssembly}
}

@software{10.5281/zenodo.7978245,
author = {Chen, Simin and Wei, Shiyi and Liu, Cong and Yang, Wei},
title = {Reproducation package for “DyCL: Dynamic Neural Network Compilation Via Program Rewriting and Graph Optimization”},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978245},
abstract = {
    <p>This artifact contains three parts: (1) the dynamic neural networks used in our evaluation, (2) the core implementation of DyCL, and (3) the script to automatically launch the experiments and test the compilation results.</p>

},
keywords = {Deep Learning Compiler, Dynamic Neural Networks, Static analysis.}
}

@software{10.5281/zenodo.7978251,
author = {Even-Mendoza, Karine and Sharma, Arindam and Donaldson, Alastair F. and Cadar, Cristian},
title = {Artifact of GrayC: Greybox Fuzzing of Compilers and Analysers for C},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978251},
abstract = {
    <p>This is the official artifact of the paper: GrayC: Greybox Fuzzing of Compilers and Analysers for C (ISSTA 2023).</p>
<p>The artifacts contains the data for bug reports and raw data for the whole paper, including for the evaluation in section 4 and section 5. In addition, we included all the sets generated with the tools in the evaluation in our artifact as 10-sets-of-test-programs-tool-name.zip.</p>
<p>Note 1: This work was supported by EPSRC (EP/R011605/1 and EP/R006865/1). Note 2: The first two authors both contributed equally to this research. Note 3: Karine Even-Mendoza: A major part of this work was done as an Imperial College London employee.</p>

},
keywords = {Artifact, Bug Reports, Clang, code mutators, compilers, Frama-C, Fuzzing, GCC, GrayC, Greybox fuzzing, LibFuzzer, LLVM, MSVC, program analysers}
}

@software{10.5281/zenodo.7978328,
author = {Gharachorlu, Golnaz and Sumner, Nick},
title = {Reproduction tool and data for article "Type Batched Program Reduction"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978328},
abstract = {
    <p>This artifact contains both the data and the underlying implementation for the paper “Type Batched Program Reduction”. The implementation of Type Batched Reducer, a tool for simplifying programs of multiple programming languages while preserving a property of interest is in C++. The artifact also includes the training data required to train logistic regression models used in this reducer. The included benchmark is from “Perses: Syntax-Guided Program Reduction” paper.</p>

},
keywords = {Delta Debugging, Machine Learning, Program Reduction}
}

@software{10.5281/zenodo.7978488,
author = {Pang, Chengbin and Zhang, Tiantai and Xu, Xuelan and Wang, Linzhang and Mao, Bing},
title = {OCFI: Make Function Entry Identification Hard Again},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978488},
abstract = {
    <p>We introduce OCFI, a modified LLVM/Clang compiler that offers the capability to obfuscate the .eh_frame section of compiled binaries. This obfuscation process aims to make it more challenging for disassemblers to identify function entries.</p>
<p>By leveraging OCFI, C/C++ projects can be compiled with the obfuscation feature enabled. This means that the resulting binaries will have their .eh_frame sections modified, enhancing their resistance to reverse engineering attempts and making the analysis of function boundaries more difficult for disassemblers. The application of OCFI as a compiler tool provides an additional layer of security for C/C++ projects, safeguarding sensitive code and intellectual property from potential attackers or unauthorized access.</p>

},
keywords = {binary disassembly, function entry detection, obfuscation}
}

@software{10.5281/zenodo.7978507,
author = {Jayasuriya, Dhanushka and Terragni, Valerio and Dietrich, Jens and Ou, Samuel and Blincoe, Kelly},
title = {Replication Package for Article "Understanding Breaking Changes in the Wild"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978507},
abstract = {
    <p>This Artifact comprises the data used for the research and the scripts utilized to extract the data from GitHub repositories. We have included the dataset we used for the manual analysis and the codes used for the manual analysis process. Additionally we included the transitive data we have extracted for these repositories. The README.md file includes the steps you need to create the python environment to execute the queries you need to execute on the dataset to extract the answers for each research question.</p>

},
keywords = {breaking changes, software dependency, software evolution, software libraries}
}

@software{10.5281/zenodo.7978718,
author = {Kedia, Piyus and Purandare, Rahul and Agarwal, Udit and Rishabh},
title = {CGuard: Scalable and Precise Object Bounds Protection for C},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978718},
abstract = {
    <p>A tool to detect spatial safety bugs in C programs.</p>

},
keywords = {Buffer overflow, Spatial safety}
}

@software{10.5281/zenodo.7978808,
author = {Xu, Xiangzhe and Feng, Shiwei and Ye, Yapeng and Shen, Guangyu and Su, Zian and Cheng, Siyuan and Tao, Guanhong and Shi, Qingkai and Zhang, Zhuo and Zhang, Xiangyu},
title = {Artifact for DiEmph},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978808},
abstract = {
    <p>This repo contains the artifact for paper “Improving Binary Code Similarity Transformer Models by Semantics-driven Instruction Deemphasis” published on ISSTA’23. Please refer to <code>README.md</code> for details.</p>

},
keywords = {Binary Similarity Analysis, Program Analysis, Transformer}
}

@software{10.5281/zenodo.7980923,
author = {Deng, Yinlin and Xia, Chunqiu Steven and Peng, Haoran and Yang, Chenyuan and Zhang, Lingming},
title = {ISSTA2023 Artifact for "Large Language Models Are Zero-Shot Fuzzers: Fuzzing Deep-Learning Libraries via Large Language Models"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7980923},
abstract = {
    <p>The artifact provides the source code of the ISSTA’2023 paper “Large Language Models Are Zero-Shot Fuzzers: Fuzzing Deep-Learning Libraries via Large Language Models”. Specifically, it contains TitanFuzz’s implementation for fuzzing PyTorch and TensorFlow.</p>

},
keywords = {Fuzz Testing, Large Language Model, Test Generation}
}

@software{10.5281/zenodo.7980997,
author = {Yu, Boxi and Zhong, Zhiqing and Li, Jiaqi and Yang, Yixing and He, Shilin and He, Pinjia},
title = {Reproduction Package for Article "ROME: Testing Image Captioning Systems via Recursive Object Melting"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7980997},
abstract = {
    <p>This artifact is the package for ROME along with the video tutorials for reproducing the experiments, which includes the following content: Content Description Video tutorials In Tutorial_1, we demonstrate how to perform object selection, image mutation, and fine-tuning.</p>

},
keywords = {AI software, image captioning, Metamorphic testing, testing}
}

@software{10.5281/zenodo.7981577,
author = {Tan, Tian and Li, Yue},
title = {Tai-e: A Developer-Friendly Static Analysis Framework for Java by Harnessing the Good Designs of Classics (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7981577},
abstract = {
    <p>This artifact is provided to reproduce the results of RQ4 in Section 6 of our companion paper, i.e., the data in: Table 1 (for pointer analysis) and Table 2 (for data flow analysis).</p>

},
keywords = {Java, static analysis}
}

@software{10.5281/zenodo.8004172,
author = {Zhang, Yiyu and Liu, Tianyi and Sun, Zewen and Chen, Zhe and Li, Xuandong and Zuo, Zhiqiang},
title = {Artifact Package for Article 'Catamaran: Low-Overhead Memory Safety Enforcement via Parallel Acceleration'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8004172},
abstract = {
    <p>This artifact contains the main implementation of Catamaran, as well as the scripts used for running it. This artifact claims the availability and the functionality of Catamaran.</p>

},
keywords = {memory safety enforcement, parallel acceleration, program analysis}
}

@software{10.5281/zenodo.8006662,
author = {Vikram, Vasudev and Laybourn, Isabella and Li, Ao and Nair, Nicole and OBrien, Kelton and Sanna, Rafaello and Padhye, Rohan},
title = {Mu2: Guiding Greybox Fuzzing with Mutation Testing (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8006662},
abstract = {
    <p>This artifact accompanies the paper “Guiding Greybox Fuzzing with Mutation Testing”, published at ISSTA 2023. It contains a replication package for experiments and evaluation data used to generate the figures in the paper. The evaluation data contains logs of the fuzzing experiments described in the paper.</p>

},
keywords = {fuzz testing, mutation testing, test generation}
}

@software{10.5281/zenodo.8021593,
author = {Zhang, Zhaoxu and Winn, Robert and Zhao, Yu and Yu, Tingting and Halfond, William G.J.},
title = {Reproduction Package for Article "Automatically Reproducing Android Bug Reports using Natural Language Processing and Reinforcement Learning"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8021593},
abstract = {
    <p>This is the artifact of our work “Automatically Reproducing Android Bug Reports using Natural Language Processing and Reinforcement Learning” accepted at The ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA) 2023. This artifact has the source code of the research prototype, evaluation data and results of the paper. We provided detailed instructions for running our tool in the REAEME file.</p>

},
keywords = {Android Bug Report Reproduction}
}

@software{10.5281/zenodo.8023076,
author = {Eisele, Max and Ebert, Daniel and Huth, Christopher and Zeller, Andreas},
title = {Replication Package for 'Fuzzing Embedded Systems using Debugger Interfaces'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8023076},
abstract = {
    <p>The idea of GDBFuzz is to leverage hardware breakpoints from microcontrollers as feedback for coverage-guided fuzzing. Therefore, GDB is used as a generic interface to enable broad applicability. For binary analysis of the firmware, Ghidra is used. The code contains a benchmark setup for evaluating the method. Additionally, example firmware files are included. The replication package allows the users to reproduce and extend the results reported in the paper.</p>

},
keywords = {embedded fuzzing, embedded systems, fuzzing, gdb, ghidra, hardware breakpoint}
}

@software{10.5281/zenodo.8127914,
author = {Kim, YoungJae and Han, Seungheon and Khamit, Askar Yeltayuly and Yi, Jooyong},
title = {SimAPR framework used in "Automated Program Repair from Fuzzing Perspective"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8127914},
abstract = {
    <p>This artifact contains the SimAPR framework designed to simulate the existing and new patch-scheduling algorithms of APR tools. SimAPR enables users to easily assess the efficiency of a patch-scheduling algorithm under study without the need to run APR tools. Currently, SimAPR supports six APR tools: AlphaRepair, Recoder, TBar, Avatar, FixMiner, and kPar. Furthermore, SimAPR can be expanded to include additional APR tools.</p>
<p>SimAPR also supports the new patch-scheduling algorithm named Casino, as presented in the paper titled “Automated Program Repair from Fuzzing Perspective.”</p>

},
keywords = {Automated Program Repair, Fuzzing, Multi-Armed Bandit, Patch Scheduling}
}

@software{10.5281/zenodo.8128613,
author = {Pan, Yu and Xu, Zhichao and Li, Levi Taiji and Yang, Yunhe and Zhang, Mu},
title = {Reproduction package for article "Automated Generation of Security-Centric Descriptions for Smart Contract Bytecode"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8128613},
abstract = {
    <p>Reproduce experiments in paper “Automated Generation of Security-Centric Descriptions for Smart Contract Bytecode”</p>

},
keywords = {decentralized apps, natural language generation, program analysis, smart contracts, textual description}
}

@software{10.5281/zenodo.8135199,
author = {Chen, Yang and Yildiz, Alperen and Marinov, Darko and Jabbarvand, Reyhaneh},
title = {Reproduction package of "Transforming Test Suites Into Croissants"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8135199},
abstract = {
    <p>This package includes all data and code to reproduce the results for paper “Transforming Test Suites Into Croissants”.</p>

},
keywords = {Fault Injection, Mutation Testing, Software Testing, Test Flakiness}
}

@software{10.6084/m9.figshare.19678938,
author = {Rzig, Dhia Elhaq and Iqbal, Nafees and Attisano, Isabella and Qin, Xue and Hassan, Foyzul},
title = {Replication package for the ISSTA2023 paper: &nbsp;Virtual Reality (VR) Automated Testing in the Wild: a Case Study on Unity-Based VR Applications},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.19678938},
abstract = {
    <p>This package contains the dataset and the code we used within this research work.</p>
<p>The list of 314 VR projects we used is in the file " VR_Project_List.txt", which contains the git URLs for all the projects we attempted to download.</p>
<p>The source code of the tool we developed and used to generate the data we used within this paper is available under the Source Code folder. This project is compatible with IntelliJ and Eclipse IDEs, and we specifically recommend IntelliJ. It needs Java 8 or newer to be executed and comes with all the external libraries needed for its execution. If any problems are encountered with the external libraries, Maven can be used to re-download any missing libraries to the system attempting to execute the code.</p>

},
keywords = {Software Testing and verification, Test smells., Virtual Reality (VR) environment}
}

@software{10.6084/m9.figshare.19726945.v1,
author = {Callaghan, Dylan and Fischer, Bernd},
title = {Replication package for article "Improving Spectrum-Based Localization of Multiple Faults by Iterative Test Suite Reduction"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.19726945.v1},
abstract = {
    <p>This artifact contains all necessary components to replicate the experiments described in the paper “Improving Spectrum-Based Localization of Multiple Faults by Iterative Test Suite Reduction”. This includes the FLITSR tool described in the paper and additional scripts to run the full-scale experiments, as well as the two datasets used for evaluation in the paper.</p>

},
keywords = {Automated Debugging, Fault Localization}
}

@software{10.6084/m9.figshare.23173448,
author = {Xue, Zhiyi and Liu, Si and Zhang, Zhaodi and Wu, Yiting and Zhang, Min},
title = {DualApp},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.23173448},
abstract = {
    <p>DualApp is a prototype tool for the robustness verification of neural networks. It is the official implementation for paper “A Tale of Two Approximations: Tightening Over-Approximation for DNN Robustness Verification via Under-Approximation”. In this project, we propose a dual-approximation approach to tighten over-approximations, leveraging an activation function’s underestimated domain to define tight approximation bounds.We assess it on a comprehensive benchmark of DNNs with different architectures. Our experimental results show that DualApp significantly outperforms the state-of-the-art approaches on the verified robustness ratio and the certified lower bound.</p>

},
keywords = {Deep Neural Network, DualApp, Over approximation, Robustness Verification, Under approximation}
}

@software{10.5281/zenodo.7976405,
author = {Ye, Mingxi and Nan, Yuhong and Zheng, Zibin and Wu, Dongpeng and Li, Huizhong},
title = {IcyChecker-Artifact: Detecting State Inconsistency Bugs in DApps via On-Chain Transaction Replay and Fuzzing},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7976405},
abstract = {
    <p>This repository contains a preliminary version of IcyChecker Artifact, a state inconsistency bug checker for Ethereum smart contracts.</p>

},
keywords = {Decentralized Application, Fuzz Testing, Smart Contract, Vulnerability detection}
}

@software{10.5281/zenodo.7976926,
author = {Wu, Shuohan and Li, Jianfeng and Zhou, Hao and Fang, Yongsheng and Zhao, Kaifa and Wang, Haoyu and Qian, Chenxiong and Luo, Xiapu},
title = {cydios: a model-based testing framework for ios apps},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7976926},
abstract = {
    <p>This is the artifacts for paper cydios: a model-based testing framework for ios apps.</p>

},
keywords = {iOS, UI Testing}
}

@software{10.5281/zenodo.7979021,
author = {Hu, Jiajun and Wei, Lili and Liu, Yepang and Cheung, Shing-Chi},
title = {Artifact for wTest},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7979021},
abstract = {
    <p>This is the artifact for wTest</p>

},
keywords = {Android, Testing, WebView}
}

@software{10.5281/zenodo.7981467,
author = {Kim, Myeongsoo and Corradini, Davide and Sinha, Saurabh and Orso, Alessandro and Pasqua, Michele and Tzoref-Brill, Rachel and Ceccato, Mariano},
title = {Artifact for "Enhancing REST API Testing with NLP Techniques"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7981467},
abstract = {
    <p>This artifact includes the NLP2REST tool and the experimental data necessary for both replicating and extending our work. For the most recent version of the tool, we recommend visiting the following link: https://github.com/codingsoo/nlp2rest.</p>

},
keywords = {Automated REST API Testing, Natural Language Processing for Testing, OpenAPI Specification Analysis}
}

@software{10.5281/zenodo.7907007,
author = {Zhou, Yuhao and Song, Wei},
title = {Reproduction Package for Article "DDLDroid: Efficiently Detecting Data Loss Issues in Android Apps"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7907007},
abstract = {
    <p>DDLDroid is a static analyzer for detecting data loss issues in Android apps during activity restart or app relaunch. It is bootstrapped by a saving-restoring bipartite graph which correlates variables that need saving to those that need restoring according to their carrier widgets, and is based on the analysis of saving and restoring data flows. It reports data loss issues once missed or broken data flows are identified.</p>
<p>Based on a set of available tools (e.g., Soot, FlowDroid, ApkTool), DDLDroid is implemented in Java and has three analyzers: pretreatment analyzer, static analyzer, and data loss reporter.</p>

},
keywords = {Android apps, bug detection, data flow analysis, data loss}
}

@software{10.1145/3580399,
author = {Breitner, Joachim},
title = {Reproduction package for Functional Pearl "More Fixpoints!"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580399},
abstract = {
    <p>This artifact contains the rec-def library described in the Functional Pearl “More Fixpoints!”, as published on Hackage, together with a virtual machine that has its dependencies installed.</p>

},
keywords = {Haskell}
}

@software{10.1145/3580401,
author = {Liu, Yiyun and Weirich, Stephanie},
title = {Artifact associated with Dependently-Typed Programming with Logical Equality Reﬂection},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580401},
abstract = {
    <p>This artifact contains the complete mechanized Coq proofs of the lemmas and theorems about System DE. The VM image is preinstalled with the dependencies required to build and verify the Coq development.</p>

},
keywords = {Coq, Dependent types, Mechanized metatheory}
}

@software{10.1145/3580402,
author = {\v{S}inkarovs, Artjoms and Koopman, Thomas and Scholz, Sven-Bodo},
title = {Reproduction Package for Article 'Rank-Polymorphism for Shape-Guided Blocking'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580402},
abstract = {
    <p>This artifact has two components, one for reproducing the proof check using Agda, and one component aimed at reproducing our runtime experiments.</p>

},
keywords = {agda, matrix multiplication, parallelisation, runtime measurements}
}

@software{10.1145/3580403,
author = {Keating, Finnbar and Gale, Michael B.},
title = {Severn implementation as in _This Is Driving Me Loopy: Efficient Loops in Arrowized Functional Reactive Programs_},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580403},
abstract = {
    <p>This implementation utilises the transformation detailed in the paper to transform arbitrary instances of <code>loop</code> in programs written utilising Arrowized Functional Reactive Programming (AFRP) into strict variants with known execution order. It is coupled with a small benchmark suite (producing the results shown in the paper). There is also a test suite that makes sure the transformation is implemented correctly and that arbitrarily generated <code>loop</code> guaranteed to not contain dependency cycles can be transformed.</p>

},
keywords = {arrows, Functional Reactive Programming, program transformation, reactive programming, stream programming}
}

@software{10.1145/3580404,
author = {Fu, Qiancheng and Xi, Hongwei},
title = {Formalization and Implementation of CILC},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580404},
abstract = {
    <p>This artifact consists of a formalization of the meta-theory of CILC using the Coq proof assistant and a prototype compiler for generating memory safe C code from CILC source programs.</p>

},
keywords = {dependent types, heap semantics, inductive types, linear types}
}

@software{10.5281/zenodo.7978326,
author = {Scott, Ryan G. and Dodds, Mike and Perez, Ivan and Goodloe, Alwyn E. and Dockins, Robert},
title = {Artifact for "Trustworthy Runtime Verification via Bisimulation (Experience Report)"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7978326},
abstract = {
    <p>This contains two files:</p>
<ul>
<li><p>copilot-verifier-artifact-vm-<md5sum>.tgz: A virtual machine containing the artifact for the ICFP 2023 paper Trustworthy Runtime Verification via Bisimulation (Experience Report).</md5sum></p></li>
<li><p>copilot-verifier-artifact-source-<md5sum>.tgz: The source code for the artifact itself. (The virtual machine above comes with this pre-installed.)</md5sum></p></li>
</ul>

},
keywords = {assurance, formal methods, Runtime verification}
}

@software{10.5281/zenodo.7986916,
author = {Keidel, Sven and Erdweg, Sebastian and Homb\"{u}cher, Tobias},
title = {Artifact for paper "Combinator-Based Fixpoint Algorithms for Big-Step Abstract Interpreters"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7986916},
abstract = {
    <p>The artifact contains the code of the fixpoint combinators and the case studies.</p>

},
keywords = {Big-Step Abstract Interpretation, Fixpoint Algorithm, Static Analysis}
}

@software{10.5281/zenodo.7988049,
author = {Goldstein, Harrison and Frohlich, Samantha and Wang, Meng and Pierce, Benjamin C.},
title = {Reflecting on Random Generation: Reflective Generators Development and Experiments},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7988049},
abstract = {
    <p>The code and virtual machine necessary to replicate the results from the paper Reflecting on Random Generation to be published at ICFP 2023.</p>

},
keywords = {bidirectional programming, property-based testing, random generation}
}

@software{10.5281/zenodo.7988150,
author = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter},
title = {FP^2: Fully in-Place Functional Programming Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7988150},
abstract = {
    <p>This is a QEMU VM image containing benchmarks and the compiler for fully in-place programming.</p>
<p>Start the <code>disk.qcow</code> image in QEMU using <code>./start.sh</code> or <code>start.bat</code>. Log in as <code>artifact</code> with the password <code>password</code>. Change to the test directory:</p>
<blockquote>
<p>cd koka/test/fip</p>
</blockquote>
<p>See the README.md in that folder for further information.</p>

},
keywords = {fip, fully in-place programming, koka, perceus, reuse}
}

@software{10.5281/zenodo.7990832,
author = {Matsuda, Kazutaka and Frohlich, Samantha and Wang, Meng and Wu, Nicolas},
title = {Embedding by Unembedding Code Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7990832},
abstract = {
    <p>This is a proof-of-concept implementation of embedding-by-unembedding, with a number of application examples.</p>

},
keywords = {EDSL, functional programming, higher-order abstract syntax}
}

@software{10.5281/zenodo.7992509,
author = {Bourgeat, Thomas and Clester, Ian and Erbsen, Andres and Gruetter, Samuel and Singh, Pratap and Wright, Andy and Chlipala, Adam},
title = {A Haskell-based RISC-V formal semantics and some of its use cases},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7992509},
abstract = {
    <p>Our paper at ICFP 2023 describes the formal semantics we built for the RISC-V instruction-set family. This artifact contains that semantics as well as the applications of it that we summarize in the paper. Others may wish to use this semantics as documentation or for testing or formal verification (of different styles).</p>

},
keywords = {formal semantics, instruction sets, type classes}
}

@software{10.5281/zenodo.7993545,
author = {Sieczkowski, Filip and Pyzik, Mateusz and Biernacki, Dariusz},
title = {A General Fine-Grained Reduction Theory for Effect Handlers: Formalisation},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7993545},
abstract = {
    <p>The artifact consists of a Coq formalisation and an OCaml implementation associated with the paper “A General Fine-Grained Reduction Theory for Effect Handlers”, conditionally accepted to ICFP 2023. The main part of the artifact is the Coq formalisation of the reduction theory developed in the paper, and of most of the metatheoretical results. In addition, an OCaml implementation of the (semi-)normalization procedure developed in the paper is provided.</p>

},
keywords = {algebraic effect, delimited continuation, formalisation, normalization-by-evaluation, reduction}
}

@software{10.5281/zenodo.7993904,
author = {Jacobs, Jules and Hinrichsen, Jonas Kastberg and Krebbers, Robbert},
title = {Dependent Session Protocols in Separation Logic from First Principles (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7993904},
abstract = {
    <p>Artifact for the paper “Dependent Session Protocols in Separation Logic from First Principles”. See README.pdf for details.</p>

},
keywords = {concurrency, message passing, separation logic, session types, verification}
}

@software{10.5281/zenodo.8083298,
author = {Varshosaz, Mahsa and Ghaffari, Mohsen and Johnsen, Einar Broch and W\k{a}sowski, Andrzej},
title = {Formal Specification and Testing for Reinforcement Learning (Supplementary Material)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8083298},
abstract = {
    <p>This is the supplementary material for our paper on formal specification and testing for reinforcement learning, accepted at the ACM SIGPLAN International Conference on Functional Programming (ICFP) 2023. It contains a virtual machine image to facilitate reproducing the experiment results and the source for the artifact.</p>

},
keywords = {reinforcement learning, Scala, specification-based testing}
}

@software{10.5281/zenodo.8097872,
author = {Xie, Ningning and White, Leo and Nicole, Olivier and Yallop, Jeremy},
title = {MacoCaml: Staging Composable and Compilable Macros (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8097872},
abstract = {
    <p>Artifact to accompany the ICFP’23 paper “MacoCaml: Staging Composable and Compilable Macros”.</p>

},
keywords = {Compile-time code generation, Macros, OCaml, Staging}
}

@software{10.5281/zenodo.8099902,
author = {Baudon, Tha\"{\i}s and Radanne, Gabriel and Gonnord, Laure},
title = {Ribbit Compiler and Benchmarks for Article `Bit-Stealing Made Legal'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8099902},
abstract = {
    <p>Ribbit is a pattern matching compiler for custom memory layouts of algebraic data types. This artifact contains our ribbit compiler, implemented in OCaml and using LLVM as a backend, along with several example programs, including the ones used as benchmarks in the article.</p>

},
keywords = {Algebraic Data Types, Compilation, Data Layouts, Pattern Matching}
}

@software{10.5281/zenodo.8116889,
author = {Hubers, Alex and Morris, J. Garrett},
title = {Generic Programming with Extensible Data Types; Or, Making Ad Hoc Extensible Data Types Less Ad Hoc---Artifact.},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8116889},
abstract = {
    <p>We provide an intrinsically-typed mechanization of System Rω with a shallow embedding / denotation into Agda.</p>

},
keywords = {agda, denotational semantics, extensible data types, intrinsic typing, language mechanization, row polymorphism, row types}
}

@software{10.5281/zenodo.8119348,
author = {Abel, Andreas and Danielsson, Nils Anders and Eriksson, Oskar},
title = {An Agda Formalization of a Graded Modal Type Theory with a Universe and Erasure},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8119348},
abstract = {
    <p>The Agda formalization accompanying the paper “A Graded Modal Dependent Type Theory with a Universe and Erasure, Formalized”.</p>

},
keywords = {dependent types, erasure, formalization, graded modal type theory, linearity, modalities}
}

@software{10.5281/zenodo.8121688,
author = {Gondelman, L\'{e}on and Hinrichsen, Jonas Kastberg and Pereira, M\'{a}rio and Timany, Amin and Birkedal, Lars},
title = {Companion artifact for the paper "Verifying Reliable Network Components in a Distributed Separation Logic with Dependent Separation Protocols"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8121688},
abstract = {
    <p>Virtual Machine image (file base-image.tar.xz) containing the artifact submitted as part of the ICFP 2023 evaluation process. Our paper is entitled “Verifying Reliable Network Components in a Distributed Separation Logic with Dependent Separation Protocols”.</p>
<p>The Virtual Machine contains the Coq source files of the Aneris project, the source code of the OCaml to Aneris-lang compiler, as well as several examples verified with the proposed framework.</p>
<p>We also include a .zip file (source_icfp.zip) containing the source files for the artifact’s dependencies, namely the Aneris project and the OCaml2Lang compiler.</p>

},
keywords = {Aneris, causal consistency, Distributed systems, higher-order logic, Iris, OCaml, separation logic}
}

@software{10.5281/zenodo.8124116,
author = {Bahr, Patrick and Hutton, Graham},
title = {Supplementary Material for "Calculating Compilers for Concurrency"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8124116},
abstract = {
    <p>This artifact includes Agda formalisations of all calculations in the paper “Calculating Compilers for Concurrency”.</p>

},
keywords = {Agda, choice trees, codensity monad, compiler calculation, concurrency}
}

@software{10.5281/zenodo.8126809,
author = {Fowler, Simon and Attard, Duncan Paul and Sowul, Franciszek and Gay, Simon J. and Trinder, Phil},
title = {Artifact for "Special Delivery: Programming with Mailbox Types"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8126809},
abstract = {
    <p>This artifact contains the typechecker for the Pat language, following the algorithmic type system described in the paper.</p>

},
keywords = {actor languages, concurrent programming languages, functional programming, mailbox types}
}

@software{10.5281/zenodo.8139133,
author = {Lutze, Matthew and Madsen, Magnus and Schuster, Philipp and Brachth\"{a}user, Jonathan Immanuel},
title = {With or Without You: Programming with Effect Exclusion (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8139133},
abstract = {
    <p>This artifact contains the source code for the Flix compiler, modified to support effect exclusion, as detailed in the paper. The modifications include the addition of the without expression for excluding effects, and a change to the effect system to support the described Boolean set-based effects.</p>
<p>In addition, it contains the 59 case studies: Code fragments from various open source repositories, where comments indicate a need for effect exclusion. For each fragment, a corresponding Flix code fragment enforces the effect exclusion through a signature or use of the without construct.</p>
<p>The artifact also contains two working examples of effect exclusion in realistic applications: a small GUI library and application demonstrating its use, and an eventbus library with a accompanying program.</p>
<p>These elements are all packaged in a virtual machine containing a Visual Studio Code installation with a Flix extension to support standard IDE features, allowing the Flix code to be inspected, modified, and run.</p>

},
keywords = {effect exclusion, polymorphic types and effects, without construct}
}

@software{10.5281/zenodo.8147256,
author = {Wehr, Stefan},
title = {Source code for the article "A Software Architecture Based on Coarse-Grained Self-Adjusting Computations"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8147256},
abstract = {
    <p>This repository contains the code of a framework for coarse-grained self-adjusting computations in Haskell. The framework has been extracted from a commercial software product developed by medilyse GmbH, Freiburg, Germany.</p>
<p>The repository also contains two demo applications using the framework.</p>

},
keywords = {functional reactive programming, Haskell, pull, push, self-adjusting computations, software architecture, source code}
}

@software{10.5281/zenodo.8160553,
author = {Shi, Jessica and Keles, Alperen and Goldstein, Harrison and Pierce, Benjamin C. and Lampropoulos, Leonidas},
title = {Artifact for Etna: An Evaluation Platform for Property-Based Testing},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8160553},
abstract = {
    <p>Our artifact contains the source code for Etna, a platform for empirical evaluation and comparison of property-based testing techniques. This includes code in Python, Haskell, and Coq. The README provides detailed instructions on how to reproduce the experiments in the paper, and the VM image comes pre-installed with the required dependencies.</p>

},
keywords = {empirical evaluation, mutation testing, property-based testing}
}

@software{10.5281/zenodo.8161214,
author = {Shen, Gan and Kashiwa, Shun and Kuper, Lindsey},
title = {HasChor},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8161214},
abstract = {
    <p>A library for choreographic programming in Haskell.</p>

},
keywords = {Choreographic programming, freer monads}
}

@software{10.5281/zenodo.8161357,
author = {Ho, Son and Fromherz, Aymeric and Protzenko, Jonathan},
title = {Artifact for ICFP 2023 paper: Modularity, Code Specialization, and Zero-Cost Abstractions for Program Verification},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8161357},
abstract = {
    <p>This is the artifact for the ICFP 2023 submission: Modularity, Code Specialization, and Zero-Cost Abstractions for Program Verification.</p>
<p>=====</p>
<p>For all the successes in verifying low-level, efficient, security-critical code, little has been said or studied about the structure, architecture and engineering of such large-scale proof developments. We present the design, implementation and evaluation of a set of language-based techniques that allow the programmer to modularly write and prove code at a high level of abstraction, while retaining control over the compilation process and producing high-quality, zero-overhead, low-level code suitable for integration into mainstream software.</p>
<p>We implement our techniques within the F* proof assistant, and specifically its shallowly-embedded Low* toolchain that compiles to C. Through our evaluation, we establish that our techniques were critical in scaling the popular HACL* library past 100,000 lines of verified source code, and brought about significant gains in proof engineer productivity. The exposition of our methodology converges on one final, novel case study: the streaming API, a finicky API that has historically caused many bugs in high-profile software. Using our approach, we manage to capture the streaming semantics in a generic way, and apply it ``for free’’ to over a dozen use-cases. Six of those have made it into the reference implementation of the Python programming language, replacing the previous CVE-ridden code.</p>

},
keywords = {Cryptographic Primitives, Proof Engineering}
}

@software{10.5281/zenodo.8162084,
author = {Redmond, Patrick and Kuper, Lindsey},
title = {An Exceptional Actor System (Functional Pearl): Artifact},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8162084},
abstract = {
    <p>This project explores the use of asynchronous exceptions as an inter-thread communication mechanism in GHC Haskell.</p>

},
keywords = {actor framework, asynchronous exceptions, runtime system}
}

@software{10.5281/zenodo.8162198,
author = {Elazar Mittelman, Segev and Resnick, Aviel and Perez, Ivan and Goodloe, Alwyn E. and Lampropoulos, Leonidas},
title = {Artifact for Paper: Don't Go Down the Rabbit Hole: Reprioritizing Enumeration for Property-Based Testing},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8162198},
abstract = {
    <p>Artifact for Paper: Don’t Go Down the Rabbit Hole: Reprioritizing Enumeration for Property-Based Testing</p>

},
keywords = {combinatorial testing, enumeration, functional programming, generation, property-based testing}
}

@software{10.5281/zenodo.8164971,
author = {Thiemann, Peter},
title = {Artifact for the article 'Intrinsically Typed Sessions with Callbacks'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8164971},
abstract = {
    <p>This is an artifact accompanying a paper accepted at the International Conference on Functional Programming, ICFP 2023. It contains a qemu image along with instructions how to run the material inside. It also contains a source code distribution. The artifact contains a README that explains use and installation.</p>

},
keywords = {Agda, dependent types, domain specific languages, session types}
}

@software{10.5281/zenodo.8238945,
author = {Sarkar, Abhiroop and Krook, Robert and Russo, Alejandro and Claessen, Koen},
title = {Source code for HasTEE: Programming Trusted Execution Environments with Haskell},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8238945},
abstract = {
    <p>This artifact contains the source code for the HasTEE DSL written in Haskell.</p>

},
keywords = {enclave, haskell, intel sgx, tee}
}

@software{10.1145/3580400,
author = {Fern\'{a}ndez Galeote, Daniel and Legaki, Nikoletta-Zampeta and Hamari, Juho},
title = {Data from Article 'From Traditional to Game-Based Learning of Climate Change: A Media Comparison Experiment'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580400},
abstract = {
    <p>This artifact contains the anonymized answer data from the experiment ‘From Traditional to Game-Based Learning of Climate Change: A Media Comparison Experiment’ as well as the questionnaire used for knowledge evaluation before and after.</p>

},
keywords = {climate change engagement, controlled experiment, environmental sustainability, game-based learning, gamification, immersive virtual reality, knowledge questionnaire, serious games, vr}
}

@software{10.1145/3626492,
author = {Kelly, Terence},
title = {Source code for "Protecting Secrets from Computers"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3626492},
abstract = {
    <p>The column argues that secrets should be protected from contact with computers and software. In that spirit, I recommend that you prevent the software associated herewith from seeing secrets of any kind. Use this example code only to check your practice work with paper-and-pencil methods, and for amusement.</p>
}
}

@software{10.1145/3580410,
author = {Khan, F. Ria and Romhanyi, Agnes},
title = {Github repository for game prototype "Shouting Match" from article, "Controlling Your Voice in a Shouting Match: A Preliminary Study on Fostering Self-Moderation among Gamers through Embodied Play" by F. Ria Khan and Agnes Romhanyi},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580410},
abstract = {
    <p>Repository includes source code and assets for Arduino (C++) and Unity (C#) as well as gitwiki on the development of game prototype Shouting Match.</p>

},
keywords = {Alternative controller games, Embodied play, Game prototype}
}

@software{10.5281/zenodo.8197652,
author = {Xu, Zhenyang and Tian, Yongqiang and Zhang, Mengxiao and Zhao, Gaosen and Jiang, Yu and Sun, Chengnian},
title = {Artifact for "Pushing the Limit of 1-Minimality of Language-Agnostic Program Reduction"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8197652},
abstract = {
    <p>This artifact contains the source code, benchmarks, scripts, and documentation for reproduce the evaluation results described in the paper “Pushing the Limit of 1-Minimality of Language-Agnostic Program Reduction” accepted at OOPSLA 2023.</p>

},
keywords = {Automated Debugging, Program Reduction, Test Input Minimization}
}

@software{10.1145/3580414,
author = {Lee, Edward and Lhot\'{a}k, Ond\v{r}ej},
title = {Artifact for the OOPSLA 2023 paper 'Simple Reference Immutability for System F-Sub'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580414},
abstract = {
    <p>This artifact The artifact consists of the Coq proofs for the paper ‘Simple Reference Immutability for System F-sub’. There are two calculi formalized in this artifact.</p>
<ul>
<li><p>System Lm, our untyped reference immutability calculus with the dynamic immutability safety results discussed in Section 3 of the paper.</p></li>
<li><p>System Fm, our typed calculi building on Lm and System F-sub with both the static soundness results discussed in Section 4 of our paper as well as the dynamic immutability safety results discussed in Section 4 of the paper.</p></li>
</ul>

},
keywords = {Coq, reference immutability, System F-sub, System Fm, System Lm}
}

@software{10.1145/3580415,
author = {Iraci, Grant and Chuang, Cheng-En and Hu, Raymond and Ziarek, Lukasz},
title = {Rate Based Session Types: Rust Implementation},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580415},
abstract = {
    <p>This artifact contains a prototype implementation of rate-based session types as a Rust crate. The overall artifact is split into two parts: the Rust standard library based crate implementation in rust_pst and a version specialized to FreeRTOS on the STM32F407 in STM32_FreeRTOS.</p>

},
keywords = {rate-based systems, session types, type systems}
}

@software{10.1145/3580417,
author = {Flatt, Matthew and Allred, Taylor and Angle, Nia and De Gabrielle, Stephen and Findler, Robert Bruce and Firth, Jack and Gopinathan, Kiran and Greenman, Ben and Kasivajhula, Siddhartha and Knauth, Alex and McCarthy, Jay and Phillips, Sam and Porncharoenwase, Sorawee and S\o{}gaard, Jens Axel and Tobin-Hochstadt, Sam},
title = {Artifact for "Rhombus: A New Spin on Macros without All the Parentheses"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580417},
abstract = {
    <p>Rhombus is a programming language with conventional expression syntax that is built on Racket and that is macro-extensible in the same way as Racket. The paper aims to show that Rhombus is realizable via a novel synthesis of macro technology. This artifact provides a working implementation of Rhombus along with example programs in Rhombus that show this realization. The artifact is an OVA file which can be imported into VirtualBox (and perhaps other virtualization software).</p>

},
keywords = {binding spaces, infix syntax, macros}
}

@software{10.1145/3580418,
author = {Jung, Jaehwang and Lee, Janggun and Choi, Jaemin and Kim, Jaewoo and Park, Sunho and Kang, Jeehoon},
title = {Coq Formalization for the Article "Modular Verification of Safe Memory Reclamation in Concurrent Separation Logic"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580418},
abstract = {
    <p>Coq Formalization for the Article “Modular Verification of Safe Memory Reclamation in Concurrent Separation Logic”.</p>

},
keywords = {concurrent algorithm, Coq, Iris, memory reclamation, separation logic}
}

@software{10.1145/3580420,
author = {Larsen, Jens Kanstrup and Guanciale, Roberto and Haller, Philipp and Scalas, Alceste},
title = {P4R-Type},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580420},
abstract = {
    <p>This artifact consists mainly of the code for the P4R-Type API and the associated type generator, as well examples that use the P4R-Type API. It contains also a virtual machine that can be used to set up a simulation network using mininet, which is used for testing the API. The virtual machine comes both in the form of a ready-to-use VM image as well as Vagrant configuration files for building the image yourself.</p>

},
keywords = {Match types, P4, P4Runtime, Protobuf, Scala 3, Software-defined networking}
}

@software{10.5281/zenodo.7824776,
author = {Wang, Shangwen and Lin, Bo and Sun, Zhensu and Wen, Ming and Liu, Yepang and Lei, Yan and Mao, Xiaoguang},
title = {Reproduction Package of &nbsp;the paper "Two Birds with One Stone: Boosting Code Generation and Code Search via a Generative Adversarial Network"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7824776},
abstract = {
    <p>We have released the source code and dataset of our study.</p>

},
keywords = {Code Generation, Code Search, Generative Adversarial Network}
}

@software{10.5281/zenodo.8124395,
author = {Thy, Sewen and Costea, Andreea and Gopinathan, Kiran and Sergey, Ilya},
title = {Reproduction Artefact for Article 'Adventure of a Lifetime: Extract Method Refactoring for Rust'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8124395},
abstract = {
    <p>This release snapshots the functionality of the submitted artefact for the tool Rusty Extraction Maestro (REM) described in the OOPSLA 23 paper “Adventure of a Lifetime: Extract Method Refactoring for Rust”:</p>
<ul>
<li><p>Docker file with reproducible build environment</p></li>
<li><p>Readme with getting started and step-by-step instructions</p></li>
<li><p>Source code and build files for REM</p></li>
<li><p>40 experiment programs</p></li>
</ul>

},
keywords = {Extract Method, IDE, Language Tooling, Program Repair, Refactoring, Rust}
}

@software{10.5281/zenodo.8140951,
author = {Pal, Anjali and Saiki, Brett and Tjoa, Ryan and Richey, Cynthia and Zhu, Amy and Flatt, Oliver and Willsey, Max and Tatlock, Zachary and Nandi, Chandrakana},
title = {Reproduction package for "Equality Saturation Theory Exploration \`{a} la Carte"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8140951},
abstract = {
    <p>This is the software package that contains Enumo, a new domain-specific language presented in our paper “Equality Saturation Theory Exploration \`{a} la Carte.” It contains the code and tests for the Enumo DSL as well as automated scripts to replicate the five experiments presented in the paper.</p>

},
keywords = {equality saturation, program synthesis, Rewrite rules}
}

@software{10.5281/zenodo.8144182,
author = {Chen, Qiaochu and Banerjee, Arko and Demiralp, \c{C}a\u{g}atay and Durrett, Greg and Dillig, I\c{s}\i{}l},
title = {Reproduction Package for Article 'Data Extraction via Semantic Regular Expression Synthesis'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8144182},
abstract = {
    <p>This repository contains the code artifact for evaluation section of the paper “Data Extraction via Semantic Regular Expression Synthesis”. The included README file contains further instructions on how to reproduce the evaluations.</p>

},
keywords = {Programming by examples, regular expressions}
}

@software{10.5281/zenodo.8146987,
author = {Schr\"{o}er, Philipp and Batz, Kevin and Kaminski, Benjamin Lucien and Katoen, Joost-Pieter and Matheja, Christoph},
title = {Reproduction Package for Article 'A Deductive Verification Infrastructure for Probabilistic Programs'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8146987},
abstract = {
    <p>Contained within the artifact: * Our tool <em>Caesar</em>, which parses HeyVL programs and tries to verify them. Caesar constitutes our main implementation contribution and is the focus of this artifact. * A script to reproduce our benchmarks (Table 2). * We also include our prototypical tool <em>pgcl2heyvl</em>, which takes pGCL programs with annotations and produces a HeyVL file that encodes the required proof obligations. * Our full source code is contained within the artifact as well.</p>

},
keywords = {automated reasoning, deductive verification, probabilistic programs, quantitative verification, real-valued logics, weakest preexpectations}
}

@software{10.5281/zenodo.8148784,
author = {Greenman, Ben and Felleisen, Matthias and Dimoulas, Christos},
title = {Artifact: How Profilers Can Help Navigate Type Migration},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8148784},
abstract = {
    <h4 id="contents">Contents:</h4>
<ul>
<li><code>artifact.tar.gz</code> code for reproducing our rational programmer experiment</li>
<li><code>benchmarks.tar.gz</code> GTP Benchmarks without and with modifications</li>
<li><code>cloudlab.tar.gz</code> for measuring performance on CloudLab</li>
<li><code>figure-data.tar.gz</code> figures and summarized data for the paper</li>
<li><code>rational-trails.tar.gz</code> output from the rational programmer</li>
<li><code>raw-data.tar.gz</code> running times, boundary profile output, and statistical profile output for all benchmarks</li>
</ul>

},
keywords = {gradual typing, migratory typing, profiling, rational programmer}
}

@software{10.5281/zenodo.8149701,
author = {Cao, Huanqi and Tang, Shizhi and Zhu, Qianchao and Yu, Bowen and Chen, Wenguang},
title = {Artifact of Mat2Stencil: A Modular Matrix-Based DSL for Explicit and Implicit Matrix-Free PDE Solvers on Structured Grid},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8149701},
abstract = {
    <p>The artifact submitted for evaluation of OOPSLA 23 conditionally accepted paper “Mat2Stencil: A Modular Matrix-Based DSL for Explicit and Implicit Matrix-Free PDE Solvers on Structured Grid”.</p>

},
keywords = {compiler, finite difference method, multi-stage programming, omain-specific language, performance optimization, polyhedral compilation, stencil, structured grid}
}

@software{10.5281/zenodo.8153210,
author = {Mururu, Girish and Khan, Sharjeel and Chatterjee, Bodhisatwa and Chen, Chao and Porter, Chris and Gavrilovska, Ada and Pande, Santosh},
title = {Artifact for Paper "Beacons: An End-to-End Compiler Framework for Predicting and Utilizing Dynamic Loop Characteristics"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8153210},
abstract = {
    <p>This artifact captures the source code of our ``beacons framework,’’ along with the instructions and benchmarks for building the software and reproducing the main results of our paper.</p>
<p>The beacons framework is a collection of several components, including: 1. Compiler passes 2. Machine learning scripts 3. Runtime library 4. Scheduler The goal is to achieve efficient workload scheduling by designing a cooperative compiler-runtime framework which leverages novel loop-based compiler analysis and learned models for resource allocation.</p>

},
keywords = {Compiler-Guided Scheduling, Loop Memory Analysis, Loop Timing Analysis, Loop Trip Count Analysis, ML-based Static Analysis, Proactive Scheduling, Throughput Scheduling}
}

@software{10.5281/zenodo.8200210,
author = {Feser, Jack and Dillig, I\c{s}\i{}l and Solar-Lezama, Armando},
title = {Inductive Program Synthesis Guided by Observational Program Similarity (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8200210},
abstract = {
    <p>Artifact for “Inductive Program Synthesis Guided by Observational Program Similarity”.</p>

},
keywords = {program synthesis}
}

@software{10.5281/zenodo.8202373,
author = {Cai, Zhuo and Farokhnia, Soroush and Goharshady, Amir Kafshdar and Hitarth, S.},
title = {Artifact-Asparagus: Automated Synthesis of Parametric Gas Upper-bounds for Smart Contracts},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8202373},
abstract = {
    <p>The artifact offers code, data and a virtual machine that can reproduce the result of our paper. It can be used to estimate upper bound of gas cost for ethereum smart contract public functions.</p>
<p>Structure of the Repository The root directory of the repository is Aspragus/ present in Github https: //github.com/zhuocai/Asparagus/. The artifact repository consists of the following: Algorithm/Code. The code of the algorithm is present in the src directory. It is written in Python3. Shell Scripts Various shell scripts that we use to run the benchmarks are in the root folder of our repository. GASTAP Dataset. We have evaluated our tool on the GASTAP dataset that can be found in our GitHub Repository in the directory dataset/gastap dataset. Each subfolder contains a solidity source code .sol file, Rule-Based-Representation .rbr file compiled using the EthIR tool, and .meta file that stores auxiliary information about RBR and the variables.</p>

},
keywords = {Ethereum, gas}
}

@software{10.5281/zenodo.8219447,
author = {Sahebolamri, Arash and Barrett, Langston and Moore, Scott and Micinski, Kristopher},
title = {Code and experiments for paper 'Bring Your Own Data Structures to Datalog'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8219447},
abstract = {
    <p>The artifact, packaged as a Docker image, contains the code for BYODS, a Datalog engine that allows custom relation-backing data structures in Datalog programs. In addition, the experiments presented in the paper ‘Bring Your Own Data Structures to Datalog’ are included in the artifact, allowing easy reproduction of experiments results. The file <code>README.MD</code> in the Docker image contains instructions for running the experiments.</p>

},
keywords = {data structures, Datalog, program analysis, union find}
}

@software{10.5281/zenodo.8289595,
author = {Chen, Yu-Fang and Chocholat\'{y}, David and Havlena, Vojt\v{e}ch and Hol\'{\i}k, Luk\'{a}\v{s} and Leng\'{a}l, Ond\v{r}ej and S\'{\i}\v{c}, Juraj},
title = {Artifact for the OOPSLA'23 paper "Solving String Constraints with Lengths by Stabilization"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8289595},
abstract = {
    <p>This is an artifact for the OOPSLA’23 paper “Solving String Constraints with Lengths by Stabilization”. It contains a virtual machine with Ubuntu GNU/Linux and all solvers, benchmarks, and supporting scripts to reproduce all experiments in the paper.</p>

},
keywords = {length constraints, regular languages, SMT solving, stabilization, string constraints, word equations}
}

@software{10.5281/zenodo.8310917,
author = {Renaux, Thierry and Van den Vonder, Sam and De Meuter, Wolfgang},
title = {Secure RDTs: Enforcing Access Control Policies for Offline Available JSON Data (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8310917},
abstract = {
    <p>This is an artifact associated with a paper called “Secure RDTs: Enforcing Access Control Policies for Offline Available JSON Data”. The paper associated with this artifact describes the SRDT, a secure replicated data type. To specify exactly how SRDTs work and to verify that they are secure, the paper uses a formal specification implemented in Redex, a library in the Racket language to specify executable formal semantics. The purpose of this artifact is to guide the reader on how to interact with the formal semantics, such that they can explore exactly how SRDTs work, are able to verify the claims of the paper, and are able to reproduce SRDTs for other systems.</p>

},
keywords = {conflict-free replicated data types, racket, redex, replicated data types, security}
}

@software{10.5281/zenodo.8312920,
author = {Conrado, Giovanna Kobus and Goharshady, Amir Kafshdar and Lam, Chun Kit},
title = {Artifact for The Bounded Pathwidth of Control-Flow Graphs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8312920},
abstract = {
    <p>Artifact for the paper “The Bounded Pathwidth of Control-Flow Graphs”. It contains the tarball of sdcc, patched with path decomposition computation and code for running the benchmark in our paper. The README.pdf file contains instructions for running the benchmark and explanation of the algorithm.</p>

},
keywords = {Control-flow Graphs, Parameterized Algorithms, Pathwidth, Treewidth}
}

@software{10.5281/zenodo.8313104,
author = {Haas, Thomas and Maseli, Ren\'{e} and Meyer, Roland and Ponce de Le\'{o}n, Hern\'{a}n},
title = {Static Analysis of Memory Models for SMT Encodings (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8313104},
abstract = {
    <p>This artifact allows for reproducing the results of Section 6 of the paper Static Analysis of Memory Models for SMT Encodings published OOPSLA2023.</p>

},
keywords = {Abstract interpretation, axiomatic semantics, verification, weak memory models}
}

@software{10.5281/zenodo.8314677,
author = {Gourdin, L\'{e}o and Bonneau, Benjamin and Boulm\'{e}, Sylvain and Monniaux, David and B\'{e}rard, Alexandre},
title = {Formally Verifying Optimizations with Block Simulations},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8314677},
abstract = {
    <p>The goal of this artifact is to show that the optimizations presented in our paper are effectively applied, and proved thanks to our translation validation by symbolic execution mechanism. Moreover, we demonstrate that even on large or randomly generated tests, the validation does not produce any false alarm. The artifact also provides a means of reproducing runtime benchmarks (performance in number of cycles), although this requires specific hardware.</p>

},
keywords = {Formal verification of compiler optimizations, Symbolic Execution, The Coq proof assistant, Translation validation}
}

@software{10.5281/zenodo.8314888,
author = {Vindum, Simon Friis and Birkedal, Lars},
title = {Artifact for the paper "Spirea: A Mechanized Concurrent Separation Logic for Weak Persistent Memory" in OOPSLA23},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8314888},
abstract = {
    <p>Artifact for the paper ‘Spirea: A Mechanized Concurrent Separation Logic for Weak Persistent Memory’. The artifact contains a full mechanization of the paper. The project is also available at: https://github.com/logsem/spirea</p>

},
keywords = {coq, iris, perennial, persistent memory}
}

@software{10.5281/zenodo.8315298,
author = {M\"{u}ller, Marius and Schuster, Philipp and Starup, Jonathan Lindegaard and Ostermann, Klaus and Brachth\"{a}user, Jonathan Immanuel},
title = {Artifact of the paper 'From Capabilities to Regions: Enabling Efficient Compilation of Lexical Effect Handlers'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8315298},
abstract = {
    <p>The artifact consists of the benchmarks conducted for the evaluation of the compilation approach presented in the paper. It contains a Dockerfile which can be used to build a Docker image for a container with all necessary languages installed. The benchmarks can hence be run inside this container.</p>

},
keywords = {effect handlers, lift inference, region inference}
}

@software{10.5281/zenodo.8317948,
author = {Crichton, Will and Gray, Gavin and Krishnamurthi, Shriram},
title = {Artifact for "A Grounded Conceptual Model for Ownership Types in Rust"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8317948},
abstract = {
    <p>These are Docker images that contain the codebase and evaluation scripts for our OOPSLA 2023 paper “A Grounded Conceptual Model for Ownership Types in Rust”.</p>

},
keywords = {concept inventory, ownership types, program state visualization, Rust}
}

@software{10.5281/zenodo.8318658,
author = {Madsen, Magnus and van de Pol, Jaco and Henriksen, Troels},
title = {Fast and Efficient Boolean Unification for Hindley-Milner-Style Type and Effect Systems},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8318658},
abstract = {
    <p>This artifact supports the paper Fast and Efficient Boolean Unification for Hindley-Milner-Style Type and Effect Systems. It reproduces the main quantifiable results of the paper, in particular the performance of six of the seven proposed strategies for Boolean unification (Strategy 1 is too slow to actually function). The artifact reproduces Figures 3-7 of the paper, as well as various other minor metrics referenced listed in the paper.</p>
<p>See documentation in artifact itself for more information.</p>

},
keywords = {flix, performance, type inference}
}

@software{10.5281/zenodo.8320212,
author = {Cheeseman, Luke and Parkinson, Matthew J. and Clebsch, Sylvan and Kogias, Marios and Drossopoulou, Sophia and Chisnall, David and Wrigstad, Tobias and Li\'{e}tar, Paul},
title = {Artifact for "When Concurrency Matters: Behaviour Oriented Concurrency"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8320212},
abstract = {
    <p>This contains the docker image to support the OOPSLA 2023 paper “When Concurrency Matters: Behavioural Oriented Concurrency”.</p>

},
keywords = {actors, concurrent programming, parallel programming, threads and locks}
}

@software{10.5281/zenodo.8320642,
author = {Chen, Qinlin and Zhang, Nairen and Wang, Jinpeng and Tan, Tian and Xu, Chang and Ma, Xiaoxing and Li, Yue},
title = {The Essence of Verilog: A Tractable and Tested Operational Semantics for Verilog (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8320642},
abstract = {
    <p>This is the artifact of the paper “The Essence of Verilog: A Tractable and Tested Operational Semantics for Verilog”. It provides a Java implementation of <span class="math inline"><em>λ</em><sub><em>V</em></sub></span>, which is a core language of Verilog. The implementation includes an <span class="math inline"><em>λ</em><sub><em>V</em></sub></span> interpreter based on its formal semantics and a frontend that converts Verilog code into <span class="math inline"><em>λ</em><sub><em>V</em></sub></span>. Furthermore, this artifact offers an evaluation environment that allows for the reproduction of the results presented in our paper. For more detailed instructions on how to run our <span class="math inline"><em>λ</em><sub><em>V</em></sub></span> implementation and reproduce the results from our paper, please refer to the README.pdf included in the artifact. You can download the artifact from the following URL: https://doi.org/10.5281/zenodo.8320642.</p>

},
keywords = {Core Languages, Hardware Description Languages, Semantics, Verilog}
}

@software{10.5281/zenodo.8320671,
author = {Conrado, Giovanna Kobus and Goharshady, Amir Kafshdar and Kochekov, Kerim and Tsai, Yun Chen and Zaher, Ahmed Khaled},
title = {Artifact for Exploiting the Sparseness of Control-flow and Call Graphs for Efficient and On-demand Algebraic Program Analysis},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8320671},
abstract = {
    <p>This artifact compares the performance of our algorithm presented in the paper vs.&nbsp;the classical approach of using Tarjan’s algorithm. It uses programs from DaCapo benchmarks as well as programs generated by Windows device drivers for the purpose of running the algorithms on them. After putting these programs into an appropriate form and finding the associated tree and depth decompositions, it feeds them to both our algorithm and Tarjan’s, and compares the performance of the two algorithms. Detailed instructions can be found inside the artifact in artifact-documentation.pdf</p>

},
keywords = {Algebaric Program Analysis, Data-flow Analysis, Graph Sparsity, Parameterized Algorithms, Parameterized complexity and exact algorithms, Program analysis, Program reasoning, Program verification, Treedepth, Treewidth}
}

@software{10.5281/zenodo.8321488,
author = {Chitre, Khushboo and Kedia, Piyus and Purandare, Rahul},
title = {Rapid: Region-based Pointer Disambiguation},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8321488},
abstract = {
    <p>This includes the source code of Rapid and all the required artifacts.</p>

},
keywords = {CPU SPEC 2017, LLVM, Mimalloc, Polybench, Scout}
}

@software{10.5281/zenodo.8325410,
author = {Sun, Yican and Peng, Xuanyu and Xiong, Yingfei},
title = {Artifact for "Synthesizing Efficient Memoization Algorithms"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8325410},
abstract = {
    <p>This is the artifact for the OOPLSA2023 paper “Synthesizing Efficient Memoization Algorithms”, including: - the docker image of our tool, and the reproduction package. - the readme file.</p>

},
keywords = {docker file}
}

@software{10.5281/zenodo.8327489,
author = {Hance, Travis and Howell, Jon and Padon, Oded and Parno, Bryan},
title = {Leaf: Modularity for Temporary Sharing in Separation Logic (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8327489},
abstract = {
    <p>This contains the Coq development validating the core technical contributions of the paper <em>Leaf: Modularity for Temporary Sharing in Separation Logic</em>. It contains:</p>
<ul>
<li>Definitions of Leaf concepts and proofs of Leaf inference rules</li>
<li>Instantiation of Leaf for a simple heap-based language with atomic heap operations</li>
<li>Derivation of fractional permissions and counting permissions within Leaf</li>
<li>The reader-writer lock example</li>
<li>The hash table example</li>
</ul>

},
keywords = {Coq, Iris, separation logic}
}

@software{10.5281/zenodo.8327699,
author = {Park, Kanghee and D'Antoni, Loris and Reps, Thomas},
title = {Docker Image for Article 'Synthesizing Specifications'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8327699},
abstract = {
    <p>This is the artifact for paper “Synthesizing Specifications”. Following are the contents of the artifact.</p>
<ul>
<li>spyro_oopsla23.tar.gz: A Docker image containing the source code and the dependencies to run Spyro[SMT] and Spyro[Sketch].</li>
<li>README.md: A readme containing all the step-by-step instructions to reproduce the results shown in the paper.</li>
</ul>

},
keywords = {Program Specifications, Program Synthesis}
}

@software{10.5281/zenodo.8328524,
author = {Zhang, Quan and Zhou, Chijin and Xu, Yiwen and Yin, Zijing and Wang, Mingzhe and Su, Zhuo and Sun, Chengnian and Jiang, Yu and Sun, Jiaguang},
title = {Artifact for "Building Dynamic System Call Sandbox with Partial Order Analysis"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8328524},
abstract = {
    <p>This is the artifact for the OOPSLA 2023 paper, titled “Building Dynamic System Call Sandbox with Partial Order Analysis”. It contains the DynBox prototype as well as the relevant data needed to replicate the results.</p>

},
keywords = {Attack Surface Reduction, Program Analysis, System Call Sandbox}
}

@software{10.5281/zenodo.8328742,
author = {Zhou, Chijin and Zhang, Quan and Guo, Lihua and Wang, Mingzhe and Jiang, Yu and Liao, Qing and Wu, Zhiyong and Li, Shanshan and Gu, Bin},
title = {Towards Better Semantics Exploration for Browser Fuzzing},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8328742},
abstract = {
    <p>This is the artifact for “Towards Better Semantics Exploration for Browser Fuzzing”, published in SPLASH/OOPSLA 2023. All instructions can be found in the readme.pdf file.</p>

},
keywords = {Browser Fuzzer, Browser Security, Context-Sensitive Grammar, Semantics-Aware Fuzzing}
}

@software{10.5281/zenodo.8329645,
author = {Sano, Chuta and Kavanagh, Ryan and Pientka, Brigitte},
title = {Mechanization of SCP for article 'Mechanizing Session-Types using a Structural View: Enforcing Linearity without Linearity'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8329645},
abstract = {
    <p>Mechanization of Structural Classical Processes as introduced in the article ‘Mechanizing Session-Types using a Structural View: Enforcing Linearity without Linearity’ in the proof assistant Beluga using weak higher-order abstract syntax. The artifact includes the encoding of the language alongside a mechanized proof of type preservation.</p>

},
keywords = {concurrency, linear logic, mechanization, session types}
}

@software{10.5281/zenodo.8329679,
author = {Zakhour, George and Weisenburger, Pascal and Salvaneschi, Guido},
title = {Type-Safe Dynamic Placement with First-Class Placed Values},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8329679},
abstract = {
    <h2 id="dyno">Dyno</h2>
<h3 id="artifact-for-the-paper-type-safe-dynamic-placement-with-first-class-placed-values">Artifact for the paper “Type-Safe Dynamic Placement with First-Class Placed Values”</h3>
<p>The artifact is available at: https://doi.org/10.5281/zenodo.8329679</p>
<h2 id="getting-started">GETTING STARTED</h2>
<h3 id="building-and-loading-the-docker-image">BUILDING AND LOADING THE DOCKER IMAGE</h3>
<p>We provide you with <code>dyno.tar.xz</code>, which is a pre-built container image that contains all necessary programs. To load, run the following command:</p>
<pre><code>docker load &lt; dyno.tar.xz</code></pre>
<p>Running the image may not work on Apple M1/M2 machines, or any machine with Apple’s ARM-based chips, because of incomplete emulation of system calls (specifically the inotify kernel subsystem). Hence, we recommend running the image on a platform fully supported by Docker, like x86-64 systems.</p>
<h2 id="step-by-step-instructions">STEP-BY-STEP INSTRUCTIONS</h2>
<h3 id="compiling-dyno">COMPILING DYNO</h3>
<p>The provided container already contains the pre-compiled jar files of Dyno.</p>
<p>To compile Dyno yourself, run the following command:</p>
<pre><code>docker run -it --rm dyno bash -c 'cd /dyno; sbt clean publishLocal'</code></pre>
<p>Compiling Propel may not work inside the Docker container on Apple M1/M2 machines for the reasons mentioned earlier.</p>
<p>The resulting jar files are in <code>~/.ivy2/local/io.github.dyno/</code>. You can run this command to see all of them <code>find ~/.ivy2/local/io.github.dyno/ -name "*.jar"</code></p>
<h3 id="testing-dyno">TESTING DYNO</h3>
<p>To run the tests in Dyno, execute:</p>
<pre><code>docker run -it --rm dyno bash -c 'cd /dyno &amp;\&amp; SBT_OPTS="-Xmx4G" sbt lociJVM/test'</code></pre>
<p>Running the Dyno tests may not work inside the Docker container on Apple M1/M2.</p>
<p>Running the tests may take up to five minutes.</p>
<h3 id="executing-paper-evaluations">EXECUTING PAPER EVALUATIONS</h3>
<h4 id="variants-analysis-section-8.1">VARIANTS ANALYSIS (Section 8.1)</h4>
<h5 id="verification-of-the-numbers-in-table-1">Verification of the numbers in Table 1</h5>
<p>Each variant is implemented under <code>/evaluation/casestudies</code>. In each variant’s folder there are three folders for each implementation: <code>dyno/</code>, <code>rmi/</code>, and <code>akka/</code>.</p>
<p>Reference creation, acquisition, and access are all labeled in the source code in each implementation. Creations are labeled with a comment <code>/*ref-creation*/</code> that follows immediately every expression that creates (or simulates a creation) of a reference. Similarly, an acquisition and an access are labeled with the comments <code>/*ref-acquire*/</code> and <code>/*ref-use*/</code> respectively and they follow immediately every expression that is relevant.</p>
<p>Counting each comment should match with the numbers we provide in Table 1 in the paper.</p>
<h5 id="running-each-variant">Running each variant</h5>
<h6 id="resources-variant">Resources Variant</h6>
<p>In the resources variant, the client asks the user to input their identifier (it can be any string), the supervisor takes over in case the identifier is new or untrusted and asks whether the identifier should be trusted or not. If the supervisor says yes then all subsequent calls will result in the same resource generated for that identifier, otherwise no resource will be given.</p>
<h6 id="dyno-implementation">Dyno Implementation</h6>
<p>First start by running a new container image with <code>docker run -it --rm dyno bash</code> in a console.</p>
<p>To run the Dyno Resources evaluation, you must execute in six different consoles the following commands in order:</p>
<ol type="1">
<li>On console 1, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/dyno; sbt "runMain loci.resources.TrustedKeyDb"'</code></li>
<li>On console 2, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/dyno; sbt "runMain loci.resources.PublicKeyDb"'</code></li>
<li>On console 3, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/dyno; sbt "runMain loci.resources.KeyManager"'</code></li>
<li>On console 4, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/dyno; sbt "runMain loci.resources.ResourceManager"'</code></li>
<li>On console 5, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/dyno; sbt "runMain loci.resources.Supervisor"'</code></li>
<li>On console 6, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/dyno; sbt "runMain loci.resources.Clienct"'</code></li>
</ol>
<p>The <code>CONTAINER_ID</code> variable can be found by executing: <code>docker container ls | grep dyno | head -n 1 | cut -f1 -d' '</code>.</p>
<p>Please allow each command to complete compilation and to begin running before you execute the next one.</p>
<h6 id="rmi-implementation">RMI Implementation</h6>
<p>First start by running a new container image with <code>docker run -it --rm dyno bash</code> in a console.</p>
<p>To run the RMI Resources evaluation, you must execute in six different consoles the following commands in order:</p>
<ol type="1">
<li>On console 1, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/rmi; sbt "runMain loci.resources.TrustedKeyDbMain"'</code></li>
<li>On console 2, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/rmi; sbt "runMain loci.resources.PublicKeyDbMain"'</code></li>
<li>On console 3, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/rmi; sbt "runMain loci.resources.KeyManagerMain"'</code></li>
<li>On console 4, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/rmi; sbt "runMain loci.resources.ResourceManagerMain"'</code></li>
<li>On console 5, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/rmi; sbt "runMain loci.resources.SupervisorMain"'</code></li>
<li>On console 6, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/resources/rmi; sbt "runMain loci.resources.ClienctMain"'</code></li>
</ol>
<p>Please allow each command to complete compilation and to begin running before you execute the next one.</p>
<h6 id="akka-implementation">Akka Implementation</h6>
<p>To run the Akka Resources evaluation, you must execute the following command:</p>
<pre><code>docker run -it --rm dyno bash -c 'cd /evaluation/casestudies/resources/akka; sbt run'</code></pre>
<p>This will spawn, for each peer, different actors that run in the same process.</p>
<h6 id="sessions-variant">Sessions Variant</h6>
<p>In the sessions variant, the client navigates an application that consists of different components. To login in some components you can use the username <code>admin</code> and the password <code>adminPassword</code>.</p>
<h6 id="dyno-implementation-1">Dyno Implementation</h6>
<p>First start by running a new container image with <code>docker run -it --rm dyno bash</code> in a console.</p>
<p>To run the Dyno Sessions evaluation, you must execute in four different consoles the following commands in order:</p>
<ol type="1">
<li>On console 1, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/session/dyno; sbt "runMain loci.sessions.Auth"'</code></li>
<li>On console 2, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/session/dyno; sbt "runMain loci.sessions.AdminPanel"'</code></li>
<li>On console 3, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/session/dyno; sbt "runMain loci.sessions.Server"'</code></li>
<li>On console 4, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/session/dyno; sbt "runMain loci.sessions.Client"'</code></li>
</ol>
<p>Please allow each command to complete compilation and to begin running before you execute the next one.</p>
<h6 id="rmi-implementation-1">RMI Implementation</h6>
<p>First start by running a new container image with <code>docker run -it --rm dyno bash</code> in a console.</p>
<p>To run the RMI Sessions evaluation, you must execute in four different consoles the following commands in order:</p>
<ol type="1">
<li>On console 1, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/session/rmi; PEER_TYPE=Server sbt "runMain loci.sessions.ServerMain"'</code></li>
<li>On console 2, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/session/rmi; PEER_TYPE=Auth sbt "runMain loci.sessions.AuthMain"'</code></li>
<li>On console 3, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/session/rmi; PEER_TYPE=AdminPanel sbt "runMain loci.sessions.AdminPanelMain"'</code></li>
<li>On console 4, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/session/rmi; PEER_TYPE=Client sbt "runMain loci.sessions.ClientMain"'</code></li>
</ol>
<p>Please allow each command to complete compilation and to begin running before you execute the next one.</p>
<h6 id="akka-implementation-1">Akka Implementation</h6>
<p>To run the Akka Sessions evaluation, you must execute the following command:</p>
<pre><code>docker run -it --rm dyno bash -c 'cd /evaluation/casestudies/session/akka; sbt run'</code></pre>
<h6 id="unifeed-variant">Unifeed Variant</h6>
<p>In the unifeed variant the unifier takes two streams of tweets and toots and merges them in a single feed chronologically. Tweets come from Twitter and require you to have an API key. You can obtain an API key by following the instructions on: https://developer.twitter.com/en/docs/authentication/oauth-1-0a/api-key-and-secret Toots come from Mastodon. If you are on mastodon.social you can create an API key on this URL https://mastodon.social/settings/applications/new</p>
<p>The Mastodon key is called “Your access token” and the Twitter key is called “Bearer Token”. We refer to them in the following commands using <code>&lt;MASTODON_KEY&gt;</code> and <code>&lt;TWITTER_KEY&gt;</code> respectively.</p>
<p>Twitter’s API support has been getting more and more restrictive for developers. If you are developer with a Basic or Pro Twitter subscription then please apply the patch suggested at the end of this section to unify a twitter stream with a mastodon stream. If you do not have a Basic or Pro twitter subscription then you can not use the API endpoints that this application requires. The provided example instead unified two Mastodon streams.</p>
<h6 id="dyno-implementation-2">Dyno Implementation</h6>
<p>First start by running a new container image with <code>docker run -it --rm dyno bash</code> in a console.</p>
<p>To run the Dyno Unifeed evaluation, you must execute in four different consoles the following commands in order:</p>
<ol type="1">
<li>On console 1, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/unifeed/dyno; ACCESS_TOKEN=&lt;TWITTER_KEY&gt; sbt "runMain loci.unifeed.Twitter"'</code></li>
<li>On console 2, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/unifeed/dyno; ACCESS_TOKEN=&lt;MASTODON_KEY&gt; sbt "runMain loci.unifeed.Mastodon"'</code></li>
<li>On console 3, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/unifeed/dyno; sbt "runMain loci.unifeed.Unifier"'</code></li>
<li>On console 4, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/unifeed/dyno; sbt "runMain loci.unifeed.Client"'</code></li>
</ol>
<p>Please allow each command to complete compilation and to begin running before you execute the next one.</p>
<h6 id="rmi-implementation-2">RMI Implementation</h6>
<p>First start by running a new container image with <code>docker run -it --rm dyno bash</code> in a console.</p>
<p>To run the RMI Unifeed evaluation, you must execute in three different consoles the following commands in order:</p>
<ol type="1">
<li>On console 1, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/unifeed/rmi; ACCESS_TOKEN=&lt;TWITTER_KEY&gt; sbt "runMain loci.unifeed.TwitterMain"'</code></li>
<li>On console 2, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/unifeed/rmi; ACCESS_TOKEN=&lt;MASTODON_KEY&gt; sbt "runMain loci.unifeed.MastodonMain"'</code></li>
<li>On console 3, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/casestudies/unifeed/rmi; sbt "runMain loci.sessions.ClientMain"'</code></li>
</ol>
<p>Please allow each command to complete compilation and to begin running before you execute the next one.</p>
<h6 id="akka-implementation-2">Akka Implementation</h6>
<p>To run the Akka Unifeed evaluation, you must execute the following command:</p>
<pre><code>docker run -it --rm dyno bash -c 'cd /evaluation/casestudies/unifeed/akka; TWITTER_KEY=&lt;TWITTER_KEY&gt; MASTODON_KEY=&lt;MASTODON_KEY&gt; sbt run'</code></pre>
<h6 id="patch-to-use-twitter-api">Patch to use Twitter API</h6>
<p>If you wish to use the twitter API you can go use the object that’s commented out in the source code and preceded with the string <code>TWITTER_API:</code></p>
<h4 id="performance-section-8.2">PERFORMANCE (Section 8.2)</h4>
<h5 id="running-the-dyno-version">Running the Dyno version</h5>
<p>First start by running a new container image with <code>docker run -it --rm dyno bash -c 'bash -c "service mariadb start" 2&gt;/dev/null; redis-server'</code> in a console.</p>
<p>To run the Dyno performance evaluation, you must execute in three different consoles the following commands, in order:</p>
<ol type="1">
<li>On console 1, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/performance; sbt "runMain loci.dbcachedyno.Database"'</code></li>
<li>On console 2, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/performance; sbt "runMain loci.dbcachedyno.Cache"'</code></li>
<li>On console 3, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/performance; sbt "runMain loci.dbcachedyno.Client"'</code></li>
</ol>
<h5 id="running-the-rmi-version">Running the RMI version</h5>
<p>First start by running a new container image with <code>docker run -it --rm dyno bash -c 'bash -c "service mariadb start" 2&gt;/dev/null; redis-server'</code> in a console.</p>
<p>To run the Dyno performance evaluation, you must execute in three different consoles the following commands, in order:</p>
<ol type="1">
<li>On console 1, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/performance; sbt "runMain loci.dbcachermi.DatabaseMain"'</code></li>
<li>On console 2, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/performance; sbt "runMain loci.dbcachermi.CacheMain"'</code></li>
<li>On console 3, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /evaluation/performance; sbt "runMain loci.dbcachermi.ClientMain"'</code></li>
</ol>
<h5 id="reading-the-output">Reading the Output</h5>
<p>The output will be visible in console 3.</p>
<p>The client first does a warmup trial that may take up to two minutes. Thus no output will be visible during the warmup. The whole experiment is not expected to take more than fifteen minutes.</p>
<p>The output is in the CSV format with 3 columns. The first column is the Hit percentage, from 0\% to 100\% in steps of 10\%. The second column is the time in milliseconds that N=5K queries took. The third column is the number of trials.</p>
<h5 id="changing-the-parameters">Changing the parameters</h5>
<p>If you wish to modify the number of trials, you must edit the value of the <code>N</code> value defined in <code>/evaluation/performance/src/main/scala/DbCache.scala</code> at line 77. The database already contains 200,001 unique keys. Therefore to preserve the correctness of the evaluation we recommend to keep N &lt; 200,000.</p>
<h4 id="antenna-pod-case-study-section-8.3">ANTENNA-POD CASE STUDY (Section 8.3)</h4>
<p>For the sake of completeness we describe in high-level the evaluation of Section 8.3 that we do not expect reviewers to repeat in full-details.</p>
<p>To demonstrate the bug we have found in AntennaPod we provide the following minimal RSS feed that you can host online:</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;rss version="2.0"
    xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd"&gt;
  &lt;channel&gt;
    &lt;title&gt;A Bad Feed&lt;/title&gt;
    &lt;itunes:owner&gt;
        &lt;itunes:email&gt;anon@anon.non&lt;/itunes:email&gt;
    &lt;/itunes:owner&gt;
    &lt;itunes:author&gt;Anon&lt;/itunes:author&gt;
    &lt;description&gt;A Really Bad Feed&lt;/description&gt;
    &lt;link&gt;https://bad.feed/&lt;/link&gt;
    &lt;item&gt;
      &lt;title&gt;A Bad Episode&lt;/title&gt;
      &lt;description&gt;A Really Bad Episode&lt;/description&gt;
      &lt;pubDate&gt;Tue, 14 Mar 2017 12:00:00 GMT&lt;/pubDate&gt;
      &lt;enclosure url=/do/10.5281/zenodo.8329679/export-citation-abs/"/idonotexist.mp3" type="audio/mpeg" length="34216300"/&gt;
      &lt;itunes:duration&gt;30:00&lt;/itunes:duration&gt;
    &lt;/item&gt;
  &lt;/channel&gt;
&lt;/rss&gt;</code></pre>
<p>After installing AntennaPod on your Android device from the Google Play store or F-Droid you can do the following steps:</p>
<ol type="1">
<li>Open the hamburger menu.</li>
<li>Click on the “+ Add Podcast” menu.</li>
<li>In the Advanced section, click on “Add Podcast by RSS address”.</li>
<li>In the popup window you can enter the URL of the bad RSS feed.</li>
<li>After pressing confirm a new popup should show up. Click on “A Bad Episode”.</li>
<li>A “Preview” button should appear. Click on it.</li>
<li>The player will attempt to play the file for a few seconds then it hides the “Preview” button.</li>
<li>Press the “back” button on your device and you will see the following Java error message:</li>
</ol>
<blockquote>
<p>com.google.android.exoplayer2.upstream.FileDataSource$FileDataSourceException: java.io.FileNotFoundException: /idonotexist.mp3: open failed: ENOENT (No such file or directory)</p>
</blockquote>
<h4 id="f-droid-case-study-section-8.4">F-DROID CASE STUDY (Section 8.4)</h4>
<p>For the sake of completeness we describe in high-level the evaluation of Section 8.4 that we do not expect reviewers to repeat in full-details.</p>
<ul>
<li>The F-Droid repository is available at https://f-droid.org/repo/index-v2.json which we also provide in <code>/fdroid_index.json</code></li>
<li>After cloning all git repositories in the index we kept those whose source code matched the following regular expression: <code>startsWith("file|equals("file|equalsIgnoreCase("file|startsWith("content|equals("content|equalsIgnoreCase("content</code></li>
<li>The result were 133 projects whose IDs we provide in the <code>/fdroid_matches.txt</code> file</li>
<li>The code snippets we provide in Section 8.4 illustrating the treatment of URLs are given in full-context in the <code>/fdroid_snippets/</code> folder</li>
</ul>
<h2 id="a-small-starting-example">A SMALL STARTING EXAMPLE</h2>
<p>Dyno is a general library that can be reused in other applications. We invite you to start with <code>/examples/src/main/scala/simple_example</code> which contains the source code for a small and simple example. It is made of a single file <code>SimpleExample.scala</code> that is annotated with comments explaining the details of the program.</p>
<p>The program consists of three peers. The first, <code>FirstProvider</code> contains an integer. Running this peer will prompt (repeatedly) the user to input a number that it will store inside its integer. The second, <code>SecondProvider</code> behaves exactly the same. The third, <code>Selector</code> starts by prompting the user to choose the peer from which it will retrieve a reference to its integer. If the user inputs <code>1</code> then they have chosen to use the value from <code>FirstProvider</code>, if the user inputs <code>2</code> they have chosen to use the value from <code>SecondProvider</code>. Any other input will re-prompt the user. Once a reference is obtained the user will be repeatedly prompted to press enter to dereference the integer reference. If the value has changed in between dereferences then the selector must observe these changes.</p>
<p>First start by running a new container image with <code>docker run -it --rm dyno bash</code> in a console.</p>
<p>To run these examples, you must execute in three different consoles the following commands, in order:</p>
<ol type="1">
<li>On console 1, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /examples; sbt "runMain loci.simple_example.FirstProvider"'</code></li>
<li>On console 2, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /examples; sbt "runMain loci.simple_example.SecondProvider"'</code></li>
<li>On console 3, execute <code>docker exec -it $CONTAINER_ID bash -c 'cd /examples; sbt "runMain loci.simple_example.Selector"'</code></li>
</ol>
<p>The <code>CONTAINER_ID</code> variable can be found by executing: <code>docker container ls | grep dyno | head -n 1 | cut -f1 -d' '</code>.</p>
<p>Please allow each command to complete compilation and to begin running before you execute the next one.</p>
<p>Now you are ready to interact with the peers.</p>
<p>sudo docker exec -it $(sudo docker container ls | grep dyno | head -n1 | cut -f1 -d’ ‘) bash -c ’bash -c “service mariadb start” 2&gt;/dev/null; cd /evaluation/performance; sbt “runMain loci.dbcachedyno.Database”’</p>

},
keywords = {Distributed Programming, Dynamic Placement, Multitier Programming, Placement Types, Scala, Union Types}
}

@software{10.5281/zenodo.8329703,
author = {Mohan, Anshuman and Liu, Yunhe and Foster, Nate and Kapp\'{e}, Tobias and Kozen, Dexter},
title = {Reproduction Package for 'Formal Abstractions for Packet Scheduling'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8329703},
abstract = {
    <p>This artifact contains an implementation of PIFO trees as described in the paper, along with several key definitions and concepts. The implementation obeys the semantics we describe formally in the paper. Further, the artifact contains an implementation of the embedding algorithm that we describe in our paper, along with a simulator that allows a PCAP of packets to be “run” through a PIFO tree scheduler. There is small tool to generate your own synthetic PCAPs, and also a visualization tool that generates the graphs that we show in our paper.</p>

},
keywords = {formal semantics, packet scheduling, programmable scheduling}
}

@software{10.5281/zenodo.8329813,
author = {Yi, Pu (Luke) and Achour, Sara},
title = {Artifact for the OOPSLA 2023 Article "Hardware-Aware Static Optimization of Hyperdimensional Computations"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8329813},
abstract = {
    <p>This is the artifact accompanying our study of hardware-aware static optimization of hyperdimensional computation, accepted for presentation at the 38th ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA) 2023. The artifact contains the implementation of our system, scripts to reproduce the evaluation results shown in the paper, and detailed instructions for setting up the environment and step-by-step reproduction of the results.</p>

},
keywords = {emerging hardware technologies, program optimization, unconventional computing}
}

@software{10.5281/zenodo.8329922,
author = {Liu, Fengyun and Lhot\'{a}k, Ond\v{r}ej and Hua, David and Xing, Enze},
title = {Initializing Global Objects: Time and Order},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8329922},
abstract = {
    <p>An artifact for the OOPSLA 2023 paper Initializing Global Objects: Time and Order.</p>
<p>The interested audience can check out the latest Dotty, which already contains the checker as part of its source code.</p>

},
keywords = {Dotty, global objects, initialization safety, initialization-time irrelevance}
}

@software{10.5281/zenodo.8329981,
author = {Liu, Jiangyi and Zhu, Fengmin and He, Fei},
title = {Artifact of paper "Automated Ambiguity Detection in Layout-Sensitive Grammars"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8329981},
abstract = {
    <p>This is the artifact for the paper “Automated Ambiguity Detection in Layout-Sensitive Grammars” at OOPSLA’23. The main purpose of this artifact is to support our evaluation results in §7 (mostly Table 1) and the theoretical results in §3 – §5 (the main conclusions are Theorem 5.9 and Theorem 5.10).</p>
<p>This artifact consists of two parts (each is a directory):</p>
<ul>
<li><p>tool/: our prototype tool that implements the ambiguity detection approach (following §5), together with necessary data and scripts for reproducing the evaluation (§7);</p></li>
<li><p>proof/: our Coq mechanization (§6) of all the definitions and theorems mentioned in §3 – §5.</p></li>
</ul>

},
keywords = {ambiguity, Coq, layout-sensitive grammar, SMT}
}

@software{10.5281/zenodo.8330884,
author = {Mehta, Meetesh Kalpesh and Krynski, Sebasti\'{a}n and Gualandi, Hugo Musso and Thakur, Manas and Vitek, Jan},
title = {Artifact of "Reusing Just-in-Time Compiled Code"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8330884},
abstract = {
    <p>This is the artifact to accompany our OOPSLA 2023 submission on “Reusing Just-in-Time Compiled Code”. The artifact consists of a virtual machine for the R language, called \v{R}, set of benchmarks for evaluation, and scripts to generate the plots. The instructions to run the artifact and reproduce the results are also attached (oopsla23aec-paper45-artifact_documentation.md).</p>

},
keywords = {Code reuse, JIT compilation, Specialization}
}

@software{10.5281/zenodo.8331210,
author = {Gu\'{e}neau, Arma\"{e}l and Hostert, Johannes and Spies, Simon and Sammler, Michael and Birkedal, Lars and Dreyer, Derek},
title = {Artifact for "Melocoton: A Program Logic for Verified Interoperability Between OCaml and C"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8331210},
abstract = {
    <p>This is the artifact for the OOPSLA’23 paper “Melocoton: A Program Logic for Verified Interoperability Between OCaml and C”. It contains the Coq development for the paper.</p>

},
keywords = {angelic non-determinism, C, Coq, foreign-function interfaces, garbage collection, Iris, multi-language semantics, OCaml, program logics, separation logic, transfinite step-indexing}
}

@software{10.5281/zenodo.8331495,
author = {Nazari, Amirmohammad and Huang, Yifei and Samanta, Roopsha and Radhakrishna, Arjun and Raghothaman, Mukund},
title = {Reproduction Package for Article "Explainable Program Synthesis by Localizing Specifications"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8331495},
abstract = {
    <p>This is the artifact package accompanying our OOPSLA 2023 submission titled Explainable Program Synthesis By Localizing Specifications. Our paper presents a new approach to explain the programs produced by program synthesis tools. We call this concept the sub-specification. Our paper presents examples of how subspecs can be useful and an algorithm to synthesize subspecifications. We have implemented this algorithm, which we call S3, for two program synthesis settings, SyGuS and DreamCoder. Our paper includes a user study and an experimental evaluation of the subspec synthesis procedure.</p>
<p>This artifact contains all the tools (S3, CVC5, EUSolver), benchmark files, and scripts to reproduce the experiments described in the paper. In this document, we will describe the outline of these experiments, how to run them, and also describe how one may use S3 to calculate sub-specifications on SyGuS solver and DreamCoder’s results of their own.</p>

},
keywords = {explainability, program comprehension, Program synthesis}
}

@software{10.5281/zenodo.8331516,
author = {Meier, Shawn and Mover, Sergio and Kaki, Gowtham and Chang, Bor-Yuh Evan},
title = {Historia: Refuting Callback Reachability with Message-History Logics (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8331516},
abstract = {
    <p>This is the artifact for the paper Historia: Refuting Callback Reachability with Message-History Logics and contains the implementation and open source Android applications used for evaluation. This artifact implements an application-only message-history based program analysis for Android. It handles safety properties relating to event and callback order including null pointer exceptions and other runtime exceptions in the Android framework.</p>

},
keywords = {event-driven applications, program analysis, separation logic, software safety, static analysis, temporal logics}
}

@software{10.5281/zenodo.8331740,
author = {Cho, Minki and Song, Youngju and Lee, Dongjae and G\"{a}her, Lennard and Dreyer, Derek},
title = {Stuttering For Free},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8331740},
abstract = {
    <p>This is the artifact for the paper “Stuttering For Free”.</p>

},
keywords = {Coq, stuttering simulation, verification}
}

@software{10.5281/zenodo.8332121,
author = {Ye, Fangke and Zhao, Jisheng and Shirako, Jun and Sarkar, Vivek},
title = {Code for the Paper "Concrete Type Inference for Code Optimization using Machine Learning with SMT Solving"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8332121},
abstract = {
    <p>Code for the paper “Concrete Type Inference for Code Optimization using Machine Learning with SMT Solving”.</p>

},
keywords = {Code Optimization, Machine Learning, Python, Type Inference}
}

@software{10.5281/zenodo.8332129,
author = {Bhanuka, Ishan and Parreaux, Lionel and Binder, David and Brachth\"{a}user, Jonathan Immanuel},
title = {Reproduction Package for "Getting into the Flow: Towards Better Type Error Messages for Constraint-Based Type Inference"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8332129},
abstract = {
    <p>Source code for HMloc type system implementation described in the paper. It contains - * Source code * Instructions for running the code - oopsla23-artifact-overview.md * A guide explaining the code - hmloc-codebase-doc.md</p>

},
keywords = {front-end, functional programming, type systems, user-centered techniques}
}

@software{10.5281/zenodo.8332577,
author = {D'Souza, Matt and You, James and Lhot\'{a}k, Ond\v{r}ej and Prokopec, Aleksandar},
title = {Artifact for paper "TASTyTruffle: Just-in-time Specialization of Parametric Polymorphism"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8332577},
abstract = {
    <p>This is the accompanying artifact for the paper “TASTyTruffle: Just-in-time Specialization of Parametric Polymorphism”. It contains the source code for TASTyTruffle and the accompanying benchmark scripts required to execute the benchmarks included in the evaluation.</p>

},
keywords = {just-in-time compiler, parametric polymorphism, reified types, Scala, specialization, Truffle}
}

@software{10.5281/zenodo.8332724,
author = {Laurel, Jacob and Qian, Siyuan Brant and Singh, Gagandeep and Misailovic, Sasa},
title = {Reproduction Artifact for "Synthesizing Precise Static Analyzers for Automatic Differentiation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8332724},
abstract = {
    <p>This artifact contains all of the source code for Pasado and all of the experimental scripts needed to reproduce the evaluation from our paper “Synthesizing Precise Static Analyzers for Automatic Differentiation”. This artifact is hosted on both Zenodo, as well as on github at the following repository: “https://github.com/uiuc-arc/Pasado”</p>

},
keywords = {Abstract Interpretation, Automatic Differentiation, Differentiable Programming, Static Analysis}
}

@software{10.5281/zenodo.8332960,
author = {Porncharoenwase, Sorawee and Pombrio, Justin and Torlak, Emina},
title = {Artifact for A Pretty Expressive Printer},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8332960},
abstract = {
    <p>This artifact consists of - Lean proofs of PrettyExpressive’s functional correctness; - Rosette proofs related to cost factories; - An implementation of PrettyExpressive in OCaml and Racket, and their documentation; - A Racket code formatter that employs PrettyExpressive; and - Benchmarks to reproduce our evaluation to show that PrettyExpressive and practically efficient and optimal. See the README file for more details.</p>

},
keywords = {pretty printer}
}

@software{10.5281/zenodo.8332962,
author = {Phipps-Costin, Luna and Rossberg, Andreas and Guha, Arjun and Leijen, Daan and Hillerstr\"{o}m, Daniel and Sivaramakrishnan, KC and Pretnar, Matija and Lindley, Sam},
title = {Artifact for Continuing WebAssembly with Effect Handlers},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8332962},
abstract = {
    <p>The artifact contains the software and instructions on how to reproduce the results of the associated paper.</p>

},
keywords = {effect handlers, experiments, WebAssembly}
}

@software{10.5281/zenodo.8333055,
author = {Shadab, Narges and Gharat, Pritam and Tiwari, Shrey and Ernst, Michael D. and Kellogg, Martin and Lahiri, Shuvendu K. and Lal, Akash and Sridharan, Manu},
title = {Inference of Resource Management Specifications},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8333055},
abstract = {
    <p>This artifact contains the data and analysis supporting the evaluation section in the ‘Inference of Resource Management Specifications’ paper. It includes the implementation of the inference algorithm for resource management specifications in both Java and C#, along with instructions for running the tools on the benchmarks we used to evaluate our tools. The goal of these tools is to automatically infer specifications for the Resource Leak Checker and RLC#.</p>

},
keywords = {accumulation analysis, Pluggable type systems, resource leaks, specify-and-check, specify-and-verify, static analysis, typestate analysis}
}

@software{10.5281/zenodo.8333815,
author = {Larose, Octave and Kaleba, Sophie and Burchell, Humphrey and Marr, Stefan},
title = {AST vs. Bytecode: Interpreters in the Age of Meta-Compilation (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8333815},
abstract = {
    <p>This artifact accompanies our paper AST vs.&nbsp;Bytecode: Interpreters in the Age of Meta-Compilation to enable others to reuse our experimental setup and methodology, and verify our claims.</p>
<p>Specifically, the artifacts covers our three contributions:</p>
<pre><code>It contains the implementation of our methodology to identify run-time performance and memory usage tradeoffs between AST and bytecode interpreters. Thus, it contains all benchmarks and experiments for reproduction of results, and reuse for new experiments, as well as the data we collected to verify our analysis.
It contains PySOM and TruffleSOM, which both come with an AST and a bytecode interpreter to enable their comparison. It further contains all the variants of PySOM and TruffleSOM that assess the impact of specific optimizations.
It allows to verify the key claim of our paper, that bytecode interpreters cannot be assumed to be faster than AST interpreters in the context of metacompilation systems.</code></pre>

},
keywords = {abstract-syntax-tree, bytecode, case study, comparison, interpreters, just-in-time compilation, language implementation, meta-tracing, partial evaluation}
}

@software{10.5281/zenodo.8336774,
author = {Cui, Chen and Jiang, Shengyi and Oliveira, Bruno C. d. S.},
title = {Greedy Implicit Bounded Quantification (Artifact)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8336774},
abstract = {
    <p>The artifact includes the implementation, proofs, and the extended version of the paper “Greedy Implicit Bounded Quantification”.</p>

},
keywords = {Abella, Bounded Quantification, Mechanical Formalization, Type Inference}
}

@software{10.5281/zenodo.8353069,
author = {Renda, Alex and Ding, Yi and Carbin, Michael},
title = {Artifact for OOPSLA 2023 Paper "Turaco: Complexity-Guided Data Sampling for Training Neural Surrogates of Programs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8353069},
abstract = {
    <p>This repository contains the implementation of the Turaco programming language and its analysis, and the experiments in the paper “Turaco: Complexity-Guided Data Sampling for Training Neural Surrogates of Programs”.</p>

},
keywords = {neural networks, programming languages, surrogate models}
}

@software{10.5281/zenodo.8416208,
author = {Gao, Pengfei and Zhang, Yedi and Song, Fu and Chen, Taolue and Standaert, Francois-Xavier},
title = {Peproduction Package for Article "Compositional Verification of Efficient Masking Countermeasures against Side-Channel Attacks"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8416208},
abstract = {
    <p>CONVINCE is the artifact of paper “Compositional Verification of Efficient Masking Countermeasures against Side-Channel Attacks”.</p>

},
keywords = {compositional reasoning, countermeasures, cryptographic implementations, Formal verification, power side-channel attacks}
}

@software{10.5281/zenodo.8418984,
author = {Ma, Cong and Wu, Dinghao and Tan, Gang and Kandemir, Mahmut Taylan and Zhang, Danfeng},
title = {Artiract for "Quantifying and Mitigating Cache Side Channel Leakage with Differential Set"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8418984},
abstract = {
    <p>DSA is a tool that quantifies and mitigate the cache side channel leakage of a program. Part of the implementation is a modified model-checker CBMC, which takes in C code and outputs the constraints of the program in either DIMACS and SMT-LIB v.2 format depending on the task. The constraints are analyzed and transformed through a series of Python scripts. For quantification task, we use approxMC to count the number of solutions of the constraints. For mitigation task, we use Z3 to enumerate each differential set. For more information please check the paper</p>

},
keywords = {differential set, information flow, side channels}
}

@software{10.1145/3580421,
author = {Melan\c{c}on, Olivier and Feeley, Marc and Serrano, Manuel},
title = {semPY},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580421},
abstract = {
    <p>A tool to analyze Python’s semantics and generate fast paths, called behaviors, for frequently used operators and type combinations.</p>

},
keywords = {compiler, dynamic programming language, executable semantics, optimization, partial evaluation, python}
}

@software{10.13020/badh-qf44,
author = {Kramer, Lucas and Van Wyk, Eric},
title = {Software Artifact for Reimagining Forwarding in Attribute Grammars},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.13020/badh-qf44},
abstract = {
    <p>This artifact consists of a prototype implementation of the Silver system with the new features along with sample specifications and instructions on how to use them. This artifact accompanies the 2020 Software Language Engineering paper “Sharing Trees and Contextual Information: Re-imagining Forwarding in Attribute Grammars” which can be found here: https://doi.org/10.1145/3623476.3623520</p>

},
keywords = {attribute grammars, forwarding, tree sharing}
}

@software{10.13020/h1qa-s993,
author = {Ringo, Nathan and Kramer, Lucas and Van Wyk, Eric},
title = {Software Artifact for Nanopass Attribute Grammars},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.13020/h1qa-s993},
abstract = {
    <p>The files included are the source code for the prototype nanopass attribute evaluator, an example specification, and instructions on how to set it up and run it. his artifact accompanies the 2020 Software Language Engineering paper “Nanopass Attribute Grammars” which can be found here: https://doi.org/10.1145/3623476.3623514</p>

},
keywords = {attribute grammars, nanopass compilers}
}

@software{10.5281/zenodo.8172549,
author = {Saaltink, Caz and Nicoletti, Stefano M. and Volk, Matthias and Hahn, Ernst Moritz and Stoelinga, Mari\"{e}lle},
title = {Artifact for the paper Solving Queries for Boolean Fault Tree Logic via Quantified SAT},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8172549},
abstract = {
    <p>Artifact accompanying the publication Saaltink, C., Nicoletti, S.M., Volk, M., Hahn, E.M., and Stoelinga,M., Solving Queries for Boolean Fault Tree Logic via Quantified SAT. The artifact contains an implementation, example files and the script run_experiments.sh to reproduce results in Sections 5 and 6 of the paper.</p>

},
keywords = {fault trees, QSAT, quantified Boolean formulae}
}

@software{10.5281/zenodo.8329080,
author = {Gordon, Colin S. and Matskevich, Sergey},
title = {Replication package for "Trustworthy Formal Natural Language Specifications"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8329080},
abstract = {
    <p>This is the snapshot consistent with the results of the paper “Trustworthy Formal Natural Language Specifications” from Onward! 2023.</p>
<p>This version relies on a slightly older (though recent at time of submission) version of Lean; shortly after this version, the typeclass resolution algorithm for Lean 4 underwent significant changes which required non-trivial changes to the tool.</p>
<p>To build the code, follow Lean’s instructions for installing the lake build tool, and run lake build in the root of this repository.</p>

},
keywords = {categorial grammar, natural language interfaces, proof assistants}
}

@software{10.5281/zenodo.8337245,
author = {Bach Poulsen, Casper and Zwaan, Aron and H\"{u}bner, Paul},
title = {Mophasco (MOnadic framework for PHAsed name resolution using SCOpe graphs)},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8337245},
abstract = {
    <p>The artifact is an executable Haskell project containing the following components: 1. The Hefty Algebra’s embedding in Haskell 2. Effects and Handlers for (a) Scope Graph Operations, (2) Error reporting, (3) Unification 3. The Applicative Function Composition 4. The Case Studies, including the Relevant Custom Effects</p>
<p>Installation/Execution Instructions, and detailed correlation with the paper are provided in the ReadMe</p>

},
keywords = {Haskell, higher-order effects, phasing, scope graphs, type checker}
}

@software{10.5281/zenodo.8347712,
author = {Eriksson, Oscar and Palmkvist, Viktor and Broman, David},
title = {Reproduction Package for Article: Partial Evaluation of Automatic Differentation for Differential-Algebraic Equations Solvers},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8347712},
abstract = {
    <p>This artifact contains the source code for the implementation of the evaluation as well as the source code for some of its dependencies. Additionally the artifact includes the raw data for the statistics presented in the article.</p>

},
keywords = {Automatic Differentiation, Compiler, Differential-Algebraic Equations, Jacobian Generation, Partial Evaluation}
}

@software{10.6084/m9.figshare.23646903.v1,
author = {Ribeiro, Francisco and de Macedo, Jos\'{e} Nuno Castro and Tsushima, Kanae and Abreu, Rui and Saraiva, Jo\~{a}o},
title = {Tool and Reproduction Package for "GPT-3-Powered Type Error Debugging: Investigating the Use of Large Language Models for Code Repair"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.23646903.v1},
abstract = {
    <p>This artifact contains: - the tool implementing the approach described in the paper - resources to replicate the experiments</p>

},
keywords = {Automated Program Repair, Code Generation, Fault Localization, GPT-3, Property-based Testing, Type Error Debugging}
}

@software{10.1145/3580422,
author = {Bhatnagar, Tigmanshu and Higgins, Albert and Marquardt, Nicolai and Miodownik, Mark and Holloway, Catherine},
title = {Database of Pin Array Technologies included for the Analysis of Product Architectures of Pin Array Technologies for Tactile Displays},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580422},
abstract = {
    <p>The paper’s artifact is a .xlsx file.</p>

},
keywords = {Literature Review, Pin Array, Product Architecture, Tactile}
}

@software{10.5281/zenodo.8419472,
author = {Echtler, Florian and Maierh\"{o}fer, Vitus and Hansen, Nicolai Brodersen and Wimmer, Raphael},
title = {Source code for "SurfaceCast"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8419472},
abstract = {
    <p>SurfaceCast is a super-flexible streaming toolkit that lets you create shared interactive surfaces from a huge variety of devices, merging up to four separate locations into one shared mixed-reality space.</p>

},
keywords = {gstreamer, h264, interactive surface, javascript, livestream, python, python3, webrtc}
}

@software{10.1145/3580405,
author = {Dong, Yibo and Zhang, Xiaoyu and Xu, Yicong and Cai, Chang and Chen, Yu and Miao, Weikai and Li, Jianwen and Pu, Geguang},
title = {LightF3 Experiment},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580405},
abstract = {
    <p>The data for our experiments is organized here.</p>

},
keywords = {Interlocking systems, Model Checking}
}

@software{10.1145/3580408,
author = {Eberlein, Martin and Smytzek, Marius and Steinh\"{o}fel, Dominic and Grunske, Lars and Zeller, Andreas},
title = {Replication Package for "Semantic Debugging"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580408},
abstract = {
    <p>This Replication Package contains the code to execute, develop and test our debugging prototype Avicenna.</p>
<p>Avicenna is a debugging tool designed to automatically determine the causes and conditions of program failures. It leverages both generative and predictive models to satisfy constraints over grammar elements and detect relations of input elements. Our tool uses the ISLa specification language to express complex failure circumstances as predicates over input elements. Avicenna learns input properties that are common across failing inputs and employs a feedback loop to refine the current debugging diagnoses by systematic experimentation. The result is crisp and precise diagnoses that closely match those determined by human experts, offering a significant advancement in the realm of automated debugging.</p>

},
keywords = {behavior explanation, debugging, testing}
}

@software{10.1145/3580411,
author = {Gupta, Priyanshu and Khare, Avishree and Bajpai, Yasharth and Chakraborty, Saikat and Gulwani, Sumit and Kanade, Aditya and Radhakrishna, Arjun and Soares, Gustavo and Tiwari, Ashish},
title = {Replication Package for Grace: Language Models Meet Code Edits},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580411},
abstract = {
    <p>The package contains: 1. Code and instructions to create input data for GrACE from the C3PO dataset. 2. Scripts to run experiments described in the paper 3. A tutorial notebook to demonstrate GrACE in action</p>

},
keywords = {Associated edits, Code editing, Large language models, Pre-trained
model, Programming language processing}
}

@software{10.1145/3580412,
author = {Humayun, Ahmad and Kim, Miryung and Gulzar, Muhammad Ali},
title = {Tool for "Co-dependence Aware Fuzzing for Dataflow-Based Big Data Analytics"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580412},
abstract = {
    <p>This artifact contains the tool, DepFuzz, engineered as part of the paper “Co-dependence Aware Fuzzing for Dataflow-Based Big Data Analytics”. It is a fuzzer for DISC applications.</p>

},
keywords = {Fuzzing, Provenance, Taint Analysis}
}

@software{10.1145/3580413,
author = {Davis, Matthew C. and Choi, Sangheon and Estep, Sam and Myers, Brad A. and Sunshine, Joshua},
title = {Reproduction package for article "NaNofuzz: A Usable Tool for Automatic Test Generation"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580413},
abstract = {
    <p>Includes the study materials, participant demographics, tutorials, task programs, NaNofuzz VS Code extension, VS Code configuration, collected study data, and the data analysis pipeline.</p>

},
keywords = {automatic test generation, automatic test suite generation, CodeSpaces, fuzz testing, fuzzer, human study, programmer user study, Randomized controlled trial, TypeScript, usability study}
}

@software{10.1145/3580427,
author = {Wei, Siwei and Song, Guyang and Zhu, Senlin and Ruan, Ruoyi and Zhu, Shihao and Cai, Yan},
title = {Tool and Reproduction Package for Paper 'Discovering Parallelisms in Python Programs'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580427},
abstract = {
    <p>A tool for automatically discovering parallelisms in Python programs</p>

},
keywords = {Parallelism, Python, Ray}
}

@software{10.21227/vp9n-wv96,
author = {Tihanyi, Norbert and Bisztray, Tamas and Jain, Ridhi and Ferrag, Mohamed Amine and Cordeiro, Lucas C. and Mavroeidis, Vasileios},
title = {FormAI dataset},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.21227/vp9n-wv96},
abstract = {
    <p>FormAI is a novel AI-generated dataset comprising 112,000 compilable and independent C programs. All the programs in the dataset were generated by GPT-3.5-turbo using dynamic zero-shot prompting technique and comprises programs with varying levels of complexity. Some programs handle complicated tasks such as network management, table games, or encryption, while others deal with simpler tasks like string manipulation. Each program is labelled based on vulnerabilities present in the code using a formal verification method based on the Efficient SMT-based Bounded Model Checker (ESBMC). This strategy conclusively identifies vulnerabilities without reporting false positives (due to the presence of counter examples), or false negatives (up to a certain bound). The labeled samples can be utilized to train Large Language Models (LLMs) since they contain the exact program location of the software vulnerability.</p>

},
keywords = {Artificial Intelligence, Dataset, Formal Verification, Large Language Models, Software Security, Vulnerability Classification}
}

@software{10.5281/zenodo.10046576,
author = {Wang, Jun and Xiao, Guanping and Zhang, Shuai and Lei, Huashan and Liu, Yepang and Sui, Yulei},
title = {Replication Package for "Compatibility Issues in Deep Learning Systems: Problems and Opportunities"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10046576},
abstract = {
    <p>This dataset contains scripts and data used to generate relevant results for this paper. Detailed information and procedure to reproduce our results are described in README.md.</p>
<p>code</p>
<p>This folder contains two Python scripts: soextractor.py is used to extract 3,072 high-quality StackOverflow (SO) posts and soextractor_tags.py is used to extract the number of posts for the tags on SO. For detailed data collection criteria, please refer to Section 3.1 of our paper.</p>
<p>DL compatibility issues.xlsx</p>
<p>This file provides all the collected 3,072 issues, in which each line indicates whether the issue is a DL compatibility issue. Among them, 352 are DL compatibility issues. We also provide information on the library, stage, symptom, type, solution, root cause, and exception type for the DL compatibility issues. For the type CORE-TPL, we also provide backward-incompatible or forward-incompatible as well as API evolution patterns. For detailed manual classification of DL compatibility issues, please refer to Section 3.2 of our paper.</p>
<p>Tool Survey.xlsx</p>
<p>This file includes all the papers collected from the three top SE conferences (i.e., ICSE, FSE, and ASE) in recent five years (18-22). Each line of each sheet provides the following information: (a) Title, (b) Year, (c) Conference, and (d) Type. For the detailed paper collection procedure, please refer to Section 5 of our paper.</p>

},
keywords = {compatibility issues, deep learning, empirical study}
}

@software{10.5281/zenodo.10075778,
author = {Vegas, Sira and Elbaum, Sebastian},
title = {Repository for Article "Pitfalls in Experiments with DNN4SE: An Analysis of the State of the Practice"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10075778},
abstract = {
    <p>There are 3 folders in the repository:</p>
<ul>
<li><p>3_Analysis_of_papers. Contains 5 Excel files with the results of the analyses of papers presented in Section 3 of the paper, plus one Word file with additional analyses not included in the paper:</p>
<ul>
<li><p>3_1_Search_results: Data for Section 3.1 of the paper. This includes a summary of the results of the search and selection process and the list of papers retrieved from SCOPUS, along with the inclusion/exclusion criteria applied to each one.</p></li>
<li><p>3_2_Papers_characterization_ICSE, 3_2_Papers_characterization_FSE, and 3_2_Papers_characterization_TSE: Data for Section 3.2 of the paper. These files contain the information retrieved from each individual paper associated to the steps of the experimental process, for each experiment described in the papers.</p></li>
<li><p>3_3_Papers_summary: Data for Section 3.3 of the paper. It includes a description of the characterization criteria, along with its application to the 194 experiments (per venue and overall).</p></li>
<li><p>Papers_per_experiment_type: Additional material (does not appear in the paper) containing a classification of experiments by type and the results of the characterization of the experiments per type. The data for this material is included in file 3_3_Papers_summary.</p></li>
</ul></li>
<li><p>4_Analysis_of_artifacts. Contains 1 Excel file and 1 Word file with the results of the analysis of artifacts presented in Section 4 of the paper:</p>
<ul>
<li><p>Characterization_badges. For those papers that earned an ACM artifact badge, this file includes the information retrieved from the paper, and the information that the artifact adds to the one in the paper.</p></li>
<li><p>Summary_discrepancies. A summary of the discrepancies found between papers and artifacts.</p></li>
</ul></li>
<li><p>5_Implications. Contains 1 Excel file with the results of the analysis of validity presented in Section 5 of the paper:</p>
<ul>
<li>Validity_analysis. The raw data corresponding to Fig. 3 in the paper is provided, along with the detailed values for each experiment.</li>
</ul></li>
</ul>

},
keywords = {deep learning, machine learning for software engineering, software engineering experimentation}
}

@software{10.5281/zenodo.10205261,
author = {Du, Xiaohu and Chen, Xiao and Cao, Jialun and Wen, Ming and Cheung, Shing-Chi and Jin, Hai},
title = {Reproduction Package for Article "Understanding the Bug Characteristics and Fix Strategies of Federated Learning Systems"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10205261},
abstract = {
    <p>The data, source code, and the results of this paper.</p>

},
keywords = {Bug Characteristics, Empirical Study, Federated Learning}
}

@software{10.5281/zenodo.10205303,
author = {Du, Xiaohu and Wen, Ming and Wei, Zichao and Wang, Shangwen and Jin, Hai},
title = {Reproduction Package for Article "An Extensive Study on Adversarial Attack against Pre-trained Models of Code"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10205303},
abstract = {
    <p>The data, source code, and the results of this paper.</p>

},
keywords = {Adversarial Attack, Deep Learning, Pre-Trained Model}
}

@software{10.5281/zenodo.10205548,
author = {Kim, Soomin and Kim, Hyungseok and Cha, Sang Kil},
title = {Artifact for `FunProbe: Probing Functions from Binary Code through Probabilistic Analysis`},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10205548},
abstract = {
    <p>This is an artifact for `FunProbe: Probing Functions from Binary Code through Probabilistic Analysis’, which will be published in the ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering 2023. FunProbe is a function identification tool based on Bayesian Network. The artifact contains the implementation of FunProbe, experimental scripts, and the dataset used to evaluate FunProbe.</p>

},
keywords = {binary code analysis, function identification, probabilistic analysis}
}

@software{10.5281/zenodo.10208075,
author = {Mikek, Benjamin and Zhang, Qirun},
title = {SLOT: SMT-LLVM Optimizing Translation},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10208075},
abstract = {
    <p>SLOT (SMT-LLVM Optimizing Translation) is a software tool that speeds up SMT solving in a solver-agnostic way by simplifying constraints. It converts SMT constraints to LLVM, applies the existing LLVM optimizer, and translates back.</p>

},
keywords = {compiler optimization, LLVM, SMT solving}
}

@software{10.5281/zenodo.10211988,
author = {Zhao, Zhongkai and Kou, Bonan and Ibrahim, Mohamed Yilmaz and Chen, Muhao and Zhang, Tianyi},
title = {Reproduction Package for Article "Knowledge-Based Version Incompatibility Detection for Deep Learning"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10211988},
abstract = {
    <p>The artifact contains the data and code of DECIDE, a version incompatibility detection tool based on pre-trained language models proposed in “Knowledge-based Version Incompatibility Detection for Deep Learning”. Meanwhile, this artifact also contains data and code to replicate experiment results in the paper. The artifact has been made publicly available on GitHub to support Open Science.</p>

},
keywords = {Deep Learning, Knowledge Extraction, Version Compatibility}
}

@software{10.5281/zenodo.10213968,
author = {Lin, Bo and Wang, Shangwen and Liu, Zhongxin and Liu, Yepang and Xia, Xin and Mao, Xiaoguang},
title = {Reproduction package for Article "CCT5: A Code-Change-Oriented Pre-trained Model"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10213968},
abstract = {
    <p>This is the reproduction package for article “CCT5: A Code-Change-Oriented Pre-trained Model”.</p>

},
keywords = {Code Change, Deep Learning, Pre-Training}
}

@software{10.5281/zenodo.10214179,
author = {Nicolae, Maria-Irina and Eisele, Max and Zeller, Andreas},
title = {Implementation of paper "Revisiting Neural Program Smoothing for Fuzzing"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10214179},
abstract = {
    <p>The package contains two Python artifacts: - Neuzz++: the implementation of neural program smoothing for fuzzing designed in the paper - MLFuzz: a benchmarking framework for fuzzing with machine learning.</p>

},
keywords = {fuzzing, machine learning, neural networks, neural program smoothing, Python}
}

@software{10.5281/zenodo.10215955,
author = {Xu, Junjielong and Fu, Qiuai and Zhu, Zhouruixing and Cheng, Yutong and Li, Zhijing and Ma, Yuchi and He, Pinjia},
title = {Hue: A User-Adaptive Parser for Hybrid Logs},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10215955},
abstract = {
    <p>This is the artifact of " Hue: A User-Adaptive Parser for Hybrid Logs" (ESEC/FSE’23). Please refer to README.md for more details.</p>

},
keywords = {Hybrid Logs, Log Analysis, Log Parsing}
}

@software{10.5281/zenodo.10215965,
author = {Du, Yali and Yu, Zhongxing},
title = {Reproduction package for article "Pre-training Code Representation with Semantic Flow Graph for Effective Bug Localization"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10215965},
abstract = {
    <p>The packaged artifact includes Installation Package, Dataset, Code, and Weights of Pre-trained Models. Moreover, we have write documentations explaining how to obtain the artifact package, how to unpack the artifact, how to get started, and how to use the artifacts in more detail with README.md, REQUIREMENTS.md, and INSTALL.md</p>

},
keywords = {bug localization, computation role, contrastive learning, pre-trained model, semantic flow graph, type}
}

@software{10.5281/zenodo.10221920,
author = {Wang, Yuxin and Welc, Adam and Clapp, Lazaro and Chen, Lingchao},
title = {Reproduction Package for Article `Last Diff Analyzer: Multi-language Automated Approver for Behavior-Preserving Code Revisions`},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10221920},
abstract = {
    <p>This artifact contains the source code for the tool we published in the paper <code>Last Diff Analyzer: Multi-language Automated Approver for Behavior-Preserving Code Revisions</code> for re-usability within the research and engineering communities.</p>

},
keywords = {automated code approver, code reviews, static analysis}
}

@software{10.5281/zenodo.7040003,
author = {Wang, Jiyuan and Zhang, Qian and Rong, Hongbo and Xu, Guoqing Harry and Kim, Miryung},
title = {Reproduction Package for "Leveraging Hardware Probes and Optimizations for Accelerating Fuzz Testing of Heterogeneous Applications"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7040003},
abstract = {
    <p>This is the repo for the HFuzz. We build a cross-devices fuzz testing tool that works on devcloud with DPC++.</p>

},
keywords = {Fuzzing, Heterogeneous, Software testing}
}

@software{10.5281/zenodo.7041455,
author = {Romano, Alan and Wang, Weihang},
title = {Dataset and Experiment Scripts for Article "When Function Inlining Meets WebAssembly: Counterintuitive Impacts on Runtime Performance"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7041455},
abstract = {
    <p>In this artifact, we provide the experiment results and scripts used to run the experiments described in our accompanying paper. We present the raw runtime results from our Baseline experiment, Experiments 1-5 and the Libsodium.js case study as CSV files. These results include runtime measurements from four optimization levels, O0-O3 and the two browsers analyzed, Chromium and Firefox. This artifact also contains the scripts that we used to run our compile the samples and run our experiments. We also include the Emscripten-generated WebAssembly, HTML, and JS files used to run the samples for each experiment.</p>

},
keywords = {Binaryen, Emscripten, Function Inlining, LLVM, WebAssembly}
}

@software{10.5281/zenodo.7042015,
author = {Dom\'{\i}nguez-\'{A}lvarez, Daniel and de la Cruz, Alejandro and Gorla, Alessandra and Caballero, Juan},
title = {LibKit source code and database dump},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7042015},
abstract = {
    <p>The artifact contains the source code of the technique and a database dump of the MongoDB database the technique relies on</p>

},
keywords = {iOS, library detection, mobile apps, static analysis}
}

@software{10.5281/zenodo.7546358,
author = {Wang, Shangwen and Geng, Mingyang and Lin, Bo and Sun, Zhensu and Wen, Ming and Liu, Yepang and Li, Li and Bissyand\'{e}, Tegawend\'{e} F. and Mao, Xiaoguang},
title = {The Artifact of the ESEC/FSE 2023 Paper Titled "Natural Language to Code: How Far are We?"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7546358},
abstract = {
    <p>In this online repository, we release the source code of each of the selected techniques as well as the experiment results from each technique (which are stored in the Results.zip file).</p>

},
keywords = {code generation, code search}
}

@software{10.5281/zenodo.7608802,
author = {Grishina, Anastasiia and Hort, Max and Moonen, Leon},
title = {Replication package for "The EarlyBIRD Catches the Bug: On Exploiting Early Layers of Encoder Models for More Efficient Code Classification"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7608802},
abstract = {
    <p>We refer to the description at https://doi.org/10.5281/zenodo.7608802</p>

},
keywords = {AI4Code, AI4SE, code classification, ML4SE, model optimization, sustainability, transformer, vulnerability detection}
}

@software{10.5281/zenodo.7901909,
author = {Ye, Guixin and Hu, Tianmin and Tang, Zhanyong and Fan, Zhenye and Tan, Shin Hwei and Zhang, Bo and Qian, Wenxiang and Wang, Zheng},
title = {Reproduction Package for Article "A Generative and Mutational Approach for Synthesizing Bug-Exposing Test Cases to Guide Compiler Fuzzing"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.7901909},
abstract = {
    <p>This artifact is a project for COMFUZZ that consists of source code and documentation. The source code contains various components, including test case generation, differential testing and mutation for focused testing. The purpose of this artifact is to provide a practical solution for users interested in building and utilizing our system in their own environments.</p>

},
keywords = {Compiler, Deep learning, Fuzzing, Guided testing, Historical bug}
}

@software{10.5281/zenodo.8198972,
author = {Ma, Chenyang and Song, Wei and Huang, Jeff},
title = {Reproduction Package for Article 'TransRacer: Function Dependence-Guided Transaction Race Detection for Smart Contracts'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8198972},
abstract = {
    <p>A symbolic analysis tool that detects transaction races for Ethereum smart contracts. Install dependencies: pip install -r requirements.txt. When using the “pip install” command to install web3 on Windows, you may encounter an error if you haven’t installed gcc. To resolve this, you can install Microsoft Visual C++.</p>
<p>Dependencies source: Z3 solver: Install Z3 package from <a href="https://pypi.org/project/z3-solver/#files">here</a> web3 suit: Install web3 package from [here](https://pypi.org/project/web3/#files Infura account: Acquire Infura from <a href="https://infura.io/">here</a> Etherscan api key: Acquire api key from <a href="https://etherscan.io/">here</a> Contract initial storage: Acquire contract initial storage from <a href="https://etherscan.io/">here</a> If this item is missed, TransRacer will attempt to access the contract’s initial storage by deploying the contract on a private network.</p>
<p>Steps to Run TransRacer 1) Make sure you can connect to the internet before running TransRacer. 2) After the TransRacer.zip is downloaded and the python environment is configured, one can run TransRacer with follow command: cd /SE &amp;\&amp; python main.py –addr [Contract address] –owner [Owner address] – agency_account [Infura account] –init_storage_path [initial storage file path] –api_key [api key]</p>
<p>Quick test Contract DistractedBoyfriend: cd /SE &amp;\&amp; python main.py –addr 0x351016D3eC753Db8E98a783CF51c8D6a4a8af151 –owner 0x4a3D25D58930f7b04E85E7946852fC2d8Fd59489 –agency_account https://mainnet.infura.io/v3/e67c4e1f139d4940a53bc61120bc3bf5 –api_key WTZ5E69T1SKACPGYF29W6ZG6CE3123APIU</p>
<p>The output of TransRacer is stored in a report file, which includes the following sub-files: 1) The “races” file provides information on function pairs that can lead to races and their corresponding witness transactions. 2) The “race bugs” file lists function pairs that can lead to storage and balance differences. 3) The “deps” file presents the found function dependencies. 4) The “time_cost” file reports the time duration spent by TransRacer on testing each contract. For the 50 contracts, the average time cost of the static analyzing, dependence analyzing, and race checking steps is approximately 1.0 minute, 1.5 minutes, and 2.6 minutes, respectively.</p>

},
keywords = {data race, Ethereum, smart contract, symbolic execution}
}

@software{10.5281/zenodo.8237328,
author = {Feldman, Kobi and Kellogg, Martin and Chaparro, Oscar},
title = {Replication package for the paper: "On the Relationship Between Code Verifiability and Understandability"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8237328},
abstract = {
    <p>This is the FSE’23 replication package of our meta-analysis that assesses the relationship between code verifiability and understandability. The package includes code snippets, human-based comprehensibility measurements, verification tools, scripts to process tool output and produce the study results, the raw study results, and documentation for replication.</p>

},
keywords = {code comprehension, meta-analysis, static analysis, Verification}
}

@software{10.5281/zenodo.8256377,
author = {So, Sunbeom and Oh, Hakjoo},
title = {Artifact for "SmartFix: Fixing Vulnerable Smart Contracts by Accelerating Generate-and-Verify Repair using Statistical Models"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8256377},
abstract = {
    <p>This artifact contains the package for reproducing the main experimental results in our paper accepted to ESEC/FSE 2023: “SmartFix: Fixing Vulnerable Smart Contracts by Accelerating Generate-and-Verify Repair using Statistical Models”</p>

},
keywords = {generate-and-verify repair, smart contract, statistical model}
}

@software{10.5281/zenodo.8264819,
author = {Utture, Akshay and Palsberg, Jens},
title = {Artifact for FSE'23 paper "From Leaks to Fixes: Automated Repairs for Resource Leak Warnings"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8264819},
abstract = {
    <p>The artifact includes the source code, experimental results, and detailed documentation. It also includes a VM image that comes with pre-installed dependencies, and can be used to quickly reproduce the results of the paper by running a few simple scripts.</p>

},
keywords = {Automated Repair, Resource Leaks, Static Analysis}
}

@software{10.5281/zenodo.8266568,
author = {Sun, Ruoxi and Xue, Minhui and Tyson, Gareth and Dong, Tian and Li, Shaofeng and Wang, Shuo and Zhu, Haojin and Camtepe, Seyit and Nepal, Surya},
title = {An Explainability-Guided Testing Framework for Robustness of Malware Detectors},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8266568},
abstract = {
    <p>Numerous open-source and commercial malware detectors are available. However, their efficacy is threatened by new adversarial attacks, whereby malware attempts to evade detection, e.g., by performing feature-space manipulation. In this work, we propose an explainability-guided and model-agnostic testing framework for robustness of malware detectors when confronted with adversarial attacks. The framework introduces the concept of Accrued Malicious Magnitude (AMM) to identify which malware features could be manipulated to maximize the likelihood of evading detection. We then use this framework to test several state-of-the-art malware detectors’ abilities to detect manipulated malware. We find that (i) commercial antivirus engines are vulnerable to AMM-guided test cases; (ii) the ability of a manipulated malware generated using one detector to evade detection by another detector (i.e., transferability) depends on the overlap of features with large AMM values between the different detectors; and (iii) AMM values effectively measure the fragility of features (i.e., capability of feature-space manipulation to flip the prediction results) and explain the robustness of malware detectors facing evasion attacks. Our findings shed light on the limitations of current malware detectors, as well as how they can be improved.</p>

},
keywords = {Explainability, Malware detectors, Robustness}
}

@software{10.5281/zenodo.8266660,
author = {Yin, Yining and Feng, Yang and Weng, Shihao and Liu, Zixi and Yao, Yuan and Zhang, Yichi and Zhao, Zhihong and Chen, Zhenyu},
title = {wengshihao/DFauLo: Dfaulo V1.3},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8266660},
abstract = {
    <p>This repository is the official implementation of the tool DfauLo.</p>
<p>DfauLo is a dynamic data fault localization tool for deep neural networks (DNNs), which can locate mislabeled and noisy data in the deep learning datasets. Inspired by conventional mutation-based code fault localization, DfauLo generates multiple DNN model mutants of the original trained DNN model and maps the extracted features into a suspiciousness score indicating the probability of the given data being a data fault. DfauLo is the first dynamic data fault localization technique, prioritizing the suspected data based on user feedback and providing the generalizability to unseen data faults during training.</p>

},
keywords = {fault localization
deep learning testing
data quality}
}

@software{10.5281/zenodo.8267114,
author = {Zhang, Mengxiao and Xu, Zhenyang and Tian, Yongqiang and Jiang, Yu and Sun, Chengnian},
title = {Artifact for "PPR: Pairwise Program Reduction"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8267114},
abstract = {
    <p>This artifact contains the source code, benchmarks, scripts, and documentation for reproduce the evaluation results described in the paper “PPR: Pairwise Program Reduction” accepted at ESEC/FSE 2023.</p>

},
keywords = {Bug Isolation, Delta Debugging, Program Reduction}
}

@software{10.5281/zenodo.8267404,
author = {Lee, Seongmin and B\"{o}hme, Marcel},
title = {Reproduction Package for Article `Statistical Reachability Analysis'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8267404},
abstract = {
    <h2 id="artifact-for-the-project-statistical-reachability-analysis">Artifact for the project “Statistical Reachability Analysis”</h2>
<p>This repository contains the artifact of the paper “Statistical Reachability Analysis” submitted to the FSE/ESEC 2023 conference.q</p>
<h2 id="artifact-structure">Artifact structure</h2>
<p>The artifact is structured as follows:</p>
<pre><code>├── README.md (this file)
├── rq1 (folder containing the data for the results of RQ1)
│&nbsp;&nbsp; ├── laplace (folder containing the data for the Laplace estimator)
|   |   └── RQ1-Laplace.ipynb (Jupyter notebook to generate the RQ1 results for the Laplace estimator)
│&nbsp;&nbsp; ├── preach (folder containing the data for the PReach)
│&nbsp;&nbsp; └── pse (folder containing the data for the PSE)
├── rq2 (folder containing the data for the results of RQ2)
│&nbsp;&nbsp; ├── fuzz-data (folder containing the fuzzing data)
│&nbsp;&nbsp; ├── figures (folder containing the figures)
|   ├── esti-result (folder containing the estimation results of statistical reachability estimators)
|   ├── scripts (folder containing the scripts to generate the estimation results)
|   ├── sra (folder containing the source code of the SRA tool)
|   RQ2-estimate.ipynb (Jupyter notebook to generate the RQ2 estimation results)
└── RQ2-timespent.ipynb (Jupyter notebook to generate the RQ2 time spent results)</code></pre>

},
keywords = {Markov chain, Quantitative reachability analysis, Reaching probability, Statistical reachability analysis}
}

@software{10.5281/zenodo.8267775,
author = {Liu, Bo and Liu, Hui and Li, Guangjie and Niu, Nan and Xu, Zimao and Wang, Yifan and Xia, Yunni and Zhang, Yuxia and Jiang, Yanjie},
title = {Reproduction Package for Ariticle `Deep Learning Based Feature Envy Detection Boosted by Real-World Examples'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8267775},
abstract = {
    <p>feTruth is a tool written in Python that can detect feature envy smells in Java projects.</p>

},
keywords = {Code Smells, Feature Envy, Software Refactoring}
}

@software{10.5281/zenodo.8267827,
author = {Yang, Jun and Wang, Yuehan and Lou, Yiling and Wen, Ming and Zhang, Lingming},
title = {Reproduction artifact of the paper "A Large-scale Empirical Review of Patch Correctness Checking Approaches"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8267827},
abstract = {
    <p>The artifact of the paper “A Large-scale Empirical Review of Patch Correctness Checking Approaches”. The artifact contains a new manually labeled dataset for Patch Correctness Checking and evaluation experiments for nine Patch Correctness Checking techniques.</p>

},
keywords = {Empirical assessment., Patch correctness, Program repair}
}

@software{10.5281/zenodo.8269801,
author = {Correnson, Arthur and Steinh\"{o}fel, Dominic},
title = {Artifact for "Engineering a Formally Verified Automated Bug Finder"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8269801},
abstract = {
    <p>This artifact comprises the Docker image with the WiSE and PyWiSE prototypes presented in the paper&nbsp;“’Engineering a Formally Verified Automated Bug Finder” at ESEC/FSE’23.</p>
<p>The artifact contains the following files:</p>
<p>README.md: This file provides an overview of the artifact, including information on running the examples provided in the paper and on navigating our Coq source code. REQUIREMENTS.md: The requirements for running our artifact. STATUS.md: The list of ESEC/FSE badges we apply for by submitting this artifact. LICENSE.md: The distribution rights for this artifact’s code and documentation. INSTALL.md: Installation instructions. wise-docker-20230821.tar.gz: The Docker container with our artifacts in a working environment.&nbsp;</p>

},
keywords = {Program Verification, Proof Assistants, Symbolic Execution, Symbolic Semantics, Testing}
}

@software{10.5281/zenodo.8270267,
author = {Le Dilavrec, Quentin and Khelladi, Djamel Eddine and Blouin, Arnaud and J\'{e}z\'{e}quel, Jean-Marc},
title = {Reproduction packge for HyperDiff},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8270267},
abstract = {
    <p>The artifact allow to reproduce results from associated article. It contains : - the implementation of our approach, - the baseline tool, - the scripts to run the experiments, and - the notebooks to compute plot the figures.</p>

},
keywords = {Code history mining, Diff, Edit script, Temporal code analysis}
}

@software{10.5281/zenodo.8270900,
author = {Souza, Beatriz and Pradel, Michael},
title = {Artifact for LExecutor: Learning-Guided Execution},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8270900},
abstract = {
    <p>This artifact contains the implementation of LExecutor and supplementary material for the paper “LExecutor: Learning-Guided Execution” (FSE’23).</p>

},
keywords = {dynamic analysis, execution, neural models}
}

@software{10.5281/zenodo.8271236,
author = {Karimipour, Nima and Pham, Justin and Clapp, Lazaro and Sridharan, Manu},
title = {Practical Inference of Nullability Types},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8271236},
abstract = {
    <h2 id="this-upload-is-a-docker-image-containing-the-artifact-and-scripts-to-rerun-experiments.">This upload is a docker image containing the artifact and scripts to rerun experiments.</h2>
<h3 id="container-structure">Container Structure</h3>
<p>This docker image contains:</p>
<ul>
<li><p>source code (NullAwayAnnotator) of our tool (will be found in /var/NullAwayAnnotator)</p></li>
<li><p>all benchmarks (will be cloned in /var/benchmarks)</p></li>
<li><p>scripts to reproduce our experiments (will be found in /var/AE)</p></li>
</ul>
<h3 id="setup">Setup</h3>
<ol type="1">
<li><p>Install Docker based on your system configuration: <a href="https://docs.docker.com/get-docker/">Get Docker</a>.</p></li>
<li><p>Import the artifact into Docker: <code>docker load annotator-ae-fse-2023</code></p></li>
<li><p>Run the Docker image (give container at least 16gigs of ram): <code>docker run --name annotator-ae annotator-ae-fse-2023 &amp;</code></p></li>
<li><p>Access docker container shell: <code>docker exec -it annotator-ae bash</code></p></li>
</ol>
<p>All required packages have been already installed in the docker image, the docker can be safely executed with no internet connection.</p>
<p>Instructions for how to run the paper’s experiments are inside the container in the <code>README.md</code> file at <code>/var/README.md</code>.</p>

},
keywords = {inference, java, nullability, static-code-analysis}
}

@software{10.5281/zenodo.8271643,
author = {Ganji, Mohammad and Alimadadi, Saba and Tip, Frank},
title = {JScope},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8271643},
abstract = {
    <p>VScode Extension to measure Asynchronous coverage for JavaScript</p>

},
keywords = {Asynchronous JavaScript, Code Coverage, Dynamic Analysis}
}

@software{10.5281/zenodo.8271781,
author = {Happe, Andreas and Cito, J\"{u}rgen},
title = {Supplemental/Meta Interview Data},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8271781},
abstract = {
    <ul>
<li>Interview Question Guide</li>
<li>Research Plan</li>
<li>Ethical Approval</li>
</ul>

},
keywords = {interview guide, research plan}
}

@software{10.5281/zenodo.8271853,
author = {Ahmed, Shibbir and Imtiaz, Sayem Mohammad and Khairunnesa, Samantha Syeda and Cruz, Breno Dantas and Rajan, Hridesh},
title = {Replication Package of the ESEC/FSE 2023 Paper Entitled "Design by Contract for Deep Learning APIs"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8271853},
abstract = {
    <p>This repository contains the reproducibility package, source code, benchmark, and results for the paper - “Design by Contract for Deep Learning APIs”, which appeared in ESEC/FSE’2023: The 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering at San Francisco, California.</p>

},
keywords = {API contracts, Deep learning, specification language}
}

@software{10.5281/zenodo.8271984,
author = {Xu, Xiangzhe and Xuan, Zhou and Feng, Shiwei and Cheng, Siyuan and Ye, Yapeng and Shi, Qingkai and Tao, Guanhong and Yu, Le and Zhang, Zhuo and Zhang, Xiangyu},
title = {PEM},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8271984},
abstract = {
    <p>This repository contains the artifacts of PEM. We provide a runnable docker image for the artifact evaluation. In addition, for future research and development, we provide the source code of PEM and a detailed instruction on how to compile it from the source code.</p>

},
keywords = {Binary Similarity, Dynamic Analysis}
}

@software{10.5281/zenodo.8272293,
author = {Song, Liyan and Minku, Leandro Lei and Teng, Cong and Yao, Xin},
title = {Replication package for Artical `A Practical Human Labeling Method for Online Just-In-Time Software Defect Prediction'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8272293},
abstract = {
    <p>This repository contains the source codes together with the datasets to replicate the above paper published in FSE2023.</p>

},
keywords = {human inspection, human labeling, Just-in-time software defect prediction, online learning, verification latency, waiting time}
}

@software{10.5281/zenodo.8272687,
author = {Peng, Yaohui and Xie, Jing and Yang, Qiongling and Guo, Hanwen and Li, Qingan and Xue, Jingling and Yuan, Mengting},
title = {Reproduction Package for Article `Statistical Type Inference for Incomplete Programs'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8272687},
abstract = {
    <p>Stir is a novel two-stage approach for inferring types in incomplete programs that may be ill-formed, where whole-program syntactic analysis often fails. In the first stage, Stir predicts a type tag for each token by using neural networks, and consequently, infers all the simple types in the program. In the second stage, Stir refines the complex types for the tokens with predicted complex type tags. Unlike existing machine-learning-based approaches, which solve type inference as a classification problem, Stir reduces it to a sequence-to-graph parsing problem. This artifact contains the implementation and evaluation program of Stir, which can be used to reproduce the evaluation results, and can also serve as a standalone application for general use of the approach. This artifact contains the implementation and evaluation program, which can be used to reproduce the evaluation results, and can also serve as a standalone application for general use.</p>
<p>This artifact is organized as follows: - <code>abstract.md</code>: file describing the artifact itself. - <code>README.md</code>: main document file. - <code>INSTALL.md</code>: instructions for obtaining the artifact and setting up the environment. - <code>REQUIREMENTS.md</code>: requirements for the hardware and software environment. - <code>STATUS.md</code>: badges that this artifact applies for and the reasons for applying for them. - <code>LICENSE</code>: license (MIT License) of the artifact. - <code>main.py</code>: the main entry file. - <code>first/</code>: the source code of the first stage of STIR. - <code>second/</code>: the source code of the second stage of STIR. - <code>data/</code>: the data used in the evaluation. - <code>pretrained/</code>: the pretrained model used in the evaluation. - <code>Dockerfile</code>: Dockerfile for building the Docker image with the software environment to reproduce the evaluation results. - <code>environment.yml</code>: conda environment file for reproducing the evaluation results.</p>

},
keywords = {deep learning, graph generation, structured learning, Type inference}
}

@software{10.5281/zenodo.8272703,
author = {Weyssow, Martin and Zhou, Xin and Kim, Kisub and Lo, David and Sahraoui, Houari},
title = {Replication package for the article "On the Usage of Continual Learning for Out-of-Distribution Generalization in Pre-trained Languages Models of Code"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8272703},
abstract = {
    <p>The artifact contains the Python project implemented to conduct the experiments presented in the paper. It includes an extensive guide on how to reproduce the experiments and acquire the data for performing pre-training, fine-tuning and inference using pre-trained language models.</p>

},
keywords = {continual learning, deep learning for code, out-of-distribution generalization, pre-trained language models}
}

@software{10.5281/zenodo.8272808,
author = {Srivastava, Prashast and Toffalini, Flavio and Vorobyov, Kostyantyn and Gauthier, Fran\c{c}ois and Bianchi, Antonio and Payer, Mathias},
title = {Reproduction Package for paper "Crystallizer: A Hybrid Path Analysis Framework To Aid in Uncovering Deserialization Vulnerabilities"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8272808},
abstract = {
    <p>The is a reproduction package containing source code of our framework along with scripts, auxiliary data required to run our experiments along with data to reproduce the results presented in the paper.</p>

},
keywords = {deserialization testing, hybrid analysis, Java}
}

@software{10.5281/zenodo.8272828,
author = {Zhao, Qiyuan and Luo, Chuan and Cai, Shaowei and Wu, Wei and Lin, Jinkun and Zhang, Hongyu and Hu, Chunming},
title = {Artifact for ESEC/FSE 2023 Article `CAmpactor: A Novel and Effective Local Search Algorithm for Optimizing Pairwise Covering Arrays'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8272828},
abstract = {
    <p>Combinatorial interaction testing (CIT) stands as a widely adopted testing technique for testing interactions among options within highly configurable systems. Within the realm of CIT, covering arrays refer to the test suites that are able to cover all such interactions, usually subject to certain hard constraints. Specifically, pairwise covering arrays (PCAs) are extensively utilized, because they are capable of obtaining a good balance between testing costs and the capability to disclose faults.</p>
<p>CAmpactor is a novel and effective local search algorithm for compacting given PCAs into smaller-sized ones, and it significantly advances the state of the art in building PCAs. In this artifact, we provide the implementation of CAmpactor, the testing instances adopted in the experiments and the detailed evaluation results.</p>

},
keywords = {Covering array, Local search, Software testing}
}

@software{10.5281/zenodo.8275813,
author = {Cabra-Acela, Laura and Mojica-Hanke, Anamaria and Linares-V\'{a}squez, Mario and Herbold, Steffen},
title = {Idaka: Tool Demo &nbsp;for the FSE 2023 Demonstration Article `On Using Information Retrieval to Recommend Machine Learning Good Practices for Software Engineers`},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8275813},
abstract = {
    <p>This is the artifact accompanying our demonstration article <code>On Using Information Retrieval to Recommend Machine Learning Good Practices for Software Engineers</code> accepted for the presentation at the ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE) 2023. This artifact contains the source code and data required to deploy Idaka. This tool allows the retrieval and generation of machine learning practices based on a systematic approach (browsing all the practices) or a query. In addition, it contains a readme file in which the instructions for building and deploying the tools are available.</p>

},
keywords = {Good practices, Information retrieval, Large language models, Machine learning}
}

@software{10.5281/zenodo.8275866,
author = {Yang, Yibiao and Sun, Maolin and Wang, Yang and Li, Qingyang and Wen, Ming and Zhou, Yuming},
title = {ESEC/FSE 2023 Artifact for "Heterogeneous Testing for Coverage Profilers Empowered with Debugging Support"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8275866},
abstract = {
    <p>This artifact contains Decov, a testing tool for coverage profilers. Additionally, it includes C2V and Cod for comparing the effectiveness of different tools. The README.md file provides a description of how to use the artifact.</p>

},
keywords = {bug detection, Code coverage, coverage profiler, debugging support, heterogeneous testing}
}

@software{10.5281/zenodo.8276375,
author = {Yu, Guangba and Chen, Pengfei and Li, Yufeng and Chen, Hongyang and Li, Xiaoyun and Zheng, Zibin},
title = {Nezha: Interpretable Fine-Grained Root Causes Analysis for Microservices on Multi-modal Observability Data},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8276375},
abstract = {
    <p>Nezha is an interpretable and fine-grained RCA approach that pinpoints root causes at the code region and resource type level by incorporative analysis of multimodal data. Nezha transforms heterogeneous multi-modal data into a homogeneous event representation and extracts event patterns by constructing and mining event graphs. The core idea of Nezha is to compare event patterns in the fault-free phase with those in the fault-suffering phase to localize root causes in an interpretable way.</p>

},
keywords = {Microservice, Multi-modal Observability Data, Root Cause Analysis}
}

@software{10.5281/zenodo.8276904,
author = {Chi, Xiaye and Liu, Hui and Li, Guangjie and Wang, Weixiao and Xia, Yunni and Jiang, Yanjie and Zhang, Yuxia and Ji, Weixing},
title = {Replication package for paper "An Automated Approach to Extracting Local Variables"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8276904},
abstract = {
    <p>This is the replication package for FSE submission, containing both tools and data that are requested by the replication. It also provides detailed instructions to replicate the evaluation.</p>

},
keywords = {Bugs, Extract Local Variable, Reliable, Software Refactoring}
}

@software{10.5281/zenodo.8279414,
author = {Chen, Zhiming and Chen, Pengfei and Wang, Peipei and Yu, Guangba and He, Zilong and Mai, Genting},
title = {Reproduction Package for Article 'DiagConfig: Configuration Diagnosis of Performance Violations in Configurable Software Systems'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8279414},
abstract = {
    <p>DiagConfig is a white-box configuration diagnosis system and is general enough to adapt to software systems under different configurations, workloads, and environments. This artifact includes the data and source code of DiagConfig for evaluation reproduction.</p>

},
keywords = {Configuration diagnosis, Performance violation, Program analysis, Taint tracking}
}

@software{10.5281/zenodo.8280911,
author = {Nguyen, Giang and Biswas, Sumon and Rajan, Hridesh},
title = {Replication Package of the ESEC/FSE 2023 Paper Entitled "Fix Fairness, Don't Ruin Accuracy: Performance Aware Fairness Repair using AutoML"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8280911},
abstract = {
    <p>To increase transparency and encourage reproducibility, we have made our artifact publicly available. All the source code and evaluation data with detailed descriptions will be updated here: https://github.com/giangnm58/Fair-AutoML.</p>

},
keywords = {automated machine learning, bias mitigation, fairness-accuracy trade-off, machine learning software, Software fairness}
}

@software{10.5281/zenodo.8280969,
author = {Gao, Xinyu and Wang, Zhijie and Feng, Yang and Ma, Lei and Chen, Zhenyu and Xu, Baowen},
title = {Replication Package for Article "Benchmarking Robustness of AI-Enabled Multi-sensor Fusion Systems: Challenges and Opportunities"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8280969},
abstract = {
    <p>This replication package contains the implementation of our benchmarks, including the fusion system, corruption patterns, evaluation metrics and data generation scripts. More details can be found in https://sites.google.com/view/ai-msf-benchmark .</p>

},
keywords = {AI Systems, Benchmarks, Multi-Sensor Fusion, Perception Systems}
}

@software{10.5281/zenodo.8281250,
author = {Wei, Yuxiang and Xia, Chunqiu Steven and Zhang, Lingming},
title = {Reproduction Package (Docker Image) for the ESEC/FSE 2023 Paper "Copiloting the Copilots: Fusing Large Language Models with Completion Engines for Automated Program Repair"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8281250},
abstract = {
    <p>This is the artifact accompanying our ESEC/FSE’23 paper “Copiloting the Copilots: Fusing Large Language Models with Completion Engines for Automated Program Repair”. For user convenience, we deliver our artifact in the form of a Docker image that has resolved all the software dependencies beforehand. The Docker image comprises (1) the source code of <strong>Repilot</strong>, the patch generation tool introduced in the paper, (2) all the data needed to reproduce the experiments done for the paper, (3) a detailed documentation on how to achieve the experimental results step-by-step, and (4) the <code>Dockerfile</code> we use to create this image.</p>

},
keywords = {Artifact, Docker Image, Repilot}
}

@software{10.5281/zenodo.8283633,
author = {Wang, Bo and Li, Ruishi and Li, Mingkai and Saxena, Prateek},
title = {Reproduction Package for Article `TransMap: Pinpointing Mistakes in Neural Code Translation'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8283633},
abstract = {
    <p>This is the artifact for the paper “TransMap: Pinpointing Mistakes in Neural Code Translation” published in ESEC/FSE 2023</p>
<p>The latest artifact can be found here: https://github.com/HALOCORE/TransMap</p>
<p>This artifact (TransMap) is a tool to pinpoint semantic mistakes in neural code translation by Codex or ChatGPT. More specifically, it focuses on Python to JavaScript code translation.</p>
<p>It takes a standalone Python program and its JavaScript translation (by Codex or ChatGPT) as input. It will first generate a source mapping between statements in the target program and the source program, using Codex or ChatGPT. Next, it will use the generated source map to aid in tracing the execution of the translated program and comparing it against the source reference program to pinpoint semantic mistakes in the translated program.</p>

},
keywords = {Code Translation, Large Language Models, Semantic Mistakes}
}

@software{10.5281/zenodo.8289599,
author = {Benoit, Tristan and Marion, Jean-Yves and Bardin, S\'{e}bastien},
title = {Artifacts - Scalable Program Clone Search through Spectral Analysis},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8289599},
abstract = {
    <h2 id="artifacts---scalable-program-clone-search-through-spectral-analysis">Artifacts - Scalable Program Clone Search through Spectral Analysis</h2>
<p>We focus on the problem of program clone search, which involves finding the program in a repository most similar to a target program. Program clone search has important applications, including malware detection and program clustering.</p>
<p>In solving this problem, the inherent workflow involves disassembly, feature extraction (or preprocessing), clone searches, and subsequent generation of tables.</p>
<p>A good similarity metric is crucial to finding the repository’s closest program. It has to be precise and robust even in cross-architecture scenarios and fast even when dealing with huge repositories. This artifact encompasses 21 distinctive clone search methods. Each method is different, and therefore, their workflow may be slightly different. Overall, the artifact is a purposely-built framework for clone search method comparison. It is easily extensible and can be tweaked to carry out new measurements.</p>
<p>The artifact includes four datasets with vast numbers of programs: Basic (1K), BinKit (98K), IoT (20K), and Windows (85K). Due to the enormous scale of these datasets, this artifact demands significant time consumption. To offer a perspective, the disassembly process on these considerable datasets can take days even when operating on 20 cores. The subsequent steps, such as preprocessing and clone searches, can also demand hundreds of hours. Note that we have gathered 2 TB of disassembled files throughout accumulating this data.</p>
<p>To tackle these time and space constraints, we have ensured that precomputed data are available within this artifact at multiple workflow phases. This enables a quick transition from reproducing one workflow phase to another. However, we could not include all disassembled files, so we mainly focused on the last phases, such as a clone search.</p>
<h3 id="examples-of-use">Examples of Use</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ex">conda</span> activate PSS_Base</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ex">python3</span> MakeTables.py</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ex">python3</span> MakeAblationTables.py</span></code></pre></div>
<p>The above will produce in a few minutes the Tables of our article using precomputed results.</p>
<p>See <a href="/do/10.5281/zenodo.8289599/export-citation-abs/EXAMPLES.md">EXAMPLES.md</a> for five quick examples of replications using this artifact.</p>
<h3 id="usage---basic-dataset">Usage - Basic Dataset</h3>
<h4 id="replication-script">Replication Script</h4>
<p>To replicate clone searches on the Basic dataset with all methods without any preprocessing phases, use the script provided:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ex">conda</span> activate PSS_Base</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="ex">python3</span> SetAbsolutePath.py</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="fu">bash</span> ReplicateCloneSearchesBasic.py</span></code></pre></div>
<p>It requires 40 cores and at least 100 GB of memory and should run for between 140 hours and 350 hours.</p>
<h4 id="generalities">Generalities</h4>
<p>For Basic dataset computations, ensure you have run <code>python3 SetAbsolutePath.py</code>.</p>
<p>Inside a method folder: - <code>RunMakeMD3.py</code> will compute all similarity indices using precomputed features. - <code>RunMakeMD.py</code> will utilize these indices to compute the test field results.</p>
<p>To reproduce the feature extraction, usually a script called <code>Preprocess.py</code> can be run.</p>
<p>Some frameworks have a more complex feature extraction workflow that can take a certain amount of computation.</p>
<p>For instance, a function embedding such as AlphaDiff requires a learning phase of around 60 hours with 100 GB of RAM.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ex">conda</span> activate PSS_Base</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="bu">cd</span> AlphaDiff/Train</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="fu">unzip</span> datasetAD.Py</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ex">python3</span> main.py</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="fu">rm</span> datasetAD.h5</span></code></pre></div>
<p>It is followed, by an embedding computation phase of 5 hours.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="bu">cd</span> AlphaDiff/Embeds/</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="ex">python3</span> MakeEmbeds.py</span></code></pre></div>
<p>Then, a distance computation phase of between 18 and 40 hours using 40 cores and 100 GB of RAM.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="bu">cd</span> AlphaDiff/AD_gDist/</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ex">python3</span> Run.py</span></code></pre></div>
<p>After that, similarity indices can be made from these computations.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="bu">cd</span> AlphaDiff/makeResults/</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ex">python3</span> RunMakeMD3.py</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="ex">python3</span> RunMakeMD.py</span></code></pre></div>
<h3 id="usage---binkit-dataset">Usage - BinKit Dataset</h3>
<h4 id="replication-script-1">Replication Script</h4>
<p>To replicate clone searches on the BinKit dataset without any preprocessing phases, use the script provided:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ex">conda</span> activate PSS_Base</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="fu">bash</span> ReplicateCloneSearchesBinKit.py</span></code></pre></div>
<p>It requires 40 cores and at least 100 GB of memory and should run for between 80 hours and 200 hours.</p>
<h4 id="generalities-1">Generalities</h4>
<p>The <code>BinKit</code> directory has two subdirectories, namely, <code>Obfus</code>, which deals with obfuscated programs, and <code>Normal</code>. Each subdirectory entails a <code>DataGeneration</code> folder which holds the disassembly scripts, and a unique folder for each method. These method folders have scripts to extract features and embeds from samples.</p>
<p>Each subdirectory contains three significant scripts: 1. <code>Run.py</code>: This script reproduces clone searches using precomputed features stored in folders like <code>NORMAL_EMBEDS_2</code>. 2. <code>Read.py</code>: It converts the results into a readable output. 3. <code>ReadElapsed.py</code>: It converts the results into a dictionary storing runtimes.</p>
<p>The <code>Redaction</code> subdirectory within <code>BinKit</code> holds scripts that compute tables based on results obtained within each subdataset.</p>
<h3 id="usage---iot-and-windows-datasets">Usage - IoT and Windows Datasets</h3>
<h4 id="replication-script---iot">Replication Script - IoT</h4>
<p>To replicate clone searches on the IoT malware dataset without any preprocessing phases, use the script provided:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ex">conda</span> activate PSS_Base</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="fu">bash</span> ReplicateCloneSearchesIoT.py</span></code></pre></div>
<p>It requires 40 cores and at least 100 GB of memory and should run for between 1 hours and 3 hours.</p>
<h4 id="replication-script---windows">Replication Script - Windows</h4>
<p>To replicate clone searches on the Windows dataset without any preprocessing phases, use the script provided:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ex">conda</span> activate PSS_Base</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="fu">bash</span> ReplicateCloneSearchesWindows.py</span></code></pre></div>
<p>It requires 40 cores and at least 100 GB of memory and should run for between 55 hours and 140 hours.</p>
<h4 id="generalities-2">Generalities</h4>
<p>Both <code>IoT</code> and <code>Windows</code> folders contain a <code>DataGeneration</code> subdirectory with disassembly scripts and scripts for each method to extract features and embeddings from samples. Additionally, each dataset has a <code>DataLabelling</code> subdirectory, which contains scripts for labeling data.</p>
<p>Experiment folders such as <code>XP</code> include <code>Run.py</code> scripts for conducting clone searches using precomputed embeddings. Lastly, the <code>Redaction</code> subdirectory in each dataset includes scripts for computing tables from the results of experiment folders.</p>
<h3 id="psso-study">PSSO Study</h3>
<p>To replicate clone searches for the PSSO Study on the Windows dataset, without any preprocessing phases, use the script provided:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ex">conda</span> activate PSS_Base</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="fu">bash</span> ReplicateCloneSearchesPSSOStudy.py</span></code></pre></div>
<p>It requires 40 cores and at least 100 GB of memory and should run for between 4 hours and 10 hours.</p>
<h3 id="ablation-study">Ablation Study</h3>
<p>To replicate clone searches for the Ablation Study, without any preprocessing phases, use the script provided:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ex">conda</span> activate PSS_Base</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="fu">bash</span> ReplicateCloneSearchesAblation.py</span></code></pre></div>
<p>It requires 40 cores and at least 100 GB of memory and should run for between 7 hours and 18 hours.</p>

},
keywords = {binary code analysis, clone search, cyber security, dataset, software, software engineering, spectral analysis}
}

@software{10.5281/zenodo.8309220,
author = {Hettmer, Michael and Severin, Benedikt and Blum, Florian and Gruhn, Volker},
title = {Datasets for Article "Towards Assessing the Real-World Impact of Defects in Blockchain-Based Smart Contracts"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8309220},
abstract = {
    <p>Dataset from the paper “Towards Assessing the Real-World Impact of Defects in Blockchain-based Smart Contracts” accepted at the 1st International Workshop on Software Defect Datasets (SDD 2023).</p>
<p>The dataset contains blockchain execution data, which is necessary to replicate the metrics proposed in our paper. Since we have combined the execution dataset with other pre-existing datasets, please follow the instructions in the example Jupyter Notebook (“example.ipynb”) for the further procedure. The external datasets are not included in this dataset package and must be downloaded from their original sources following the instructions in the example Jupyter Notebook.</p>

},
keywords = {blockchain, defect-datasets, smart-contract, vulnerabilities}
}

@software{10.5281/zenodo.8319975,
author = {Liu, Jiawei and Peng, Jinjun and Wang, Yuyao and Zhang, Lingming},
title = {ESEC/FSE'23 Artifact for "NeuRI: Diversifying DNN Generation via Inductive Rule Inference"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8319975},
abstract = {
    <p>This is the artifact for the ESEC/FSE’23 paper “NeuRI: Diversifying DNN Generation via Inductive Rule Inference”.</p>
<p>Deep Learning (DL) is prevalently used in various industries to improve decision-making and automate processes, driven by the ever-evolving DL libraries and compilers. The correctness of DL systems is crucial for trust in DL applications.<br>
As such, the recent wave of research has been studying the automated synthesis of test-cases (i.e., DNN models and their inputs) for fuzzing DL systems. However, existing model generators only subsume a limited number of operators, lacking the ability to pervasively model operator constraints.<br>
To address this challenge, we propose NeuRI, a fully automated approach for generating valid and diverse DL models composed of hundreds of types of operators. NeuRI adopts a three-step process:<br>
(i) collecting valid and invalid API traces from various sources;<br>
(ii) applying inductive program synthesis over the traces to infer the constraints for constructing valid models; and<br>
(iii) using hybrid model generation which incorporates both symbolic and concrete operators.<br>
Our evaluation shows that NeuRI improves branch coverage of TensorFlow and PyTorch by 24\% and 15\% over the state-of-the-art model-level fuzzers. NeuRI finds 100 new bugs for PyTorch and TensorFlow in four months, with 81 already fixed or confirmed. Of these, 9 bugs are labelled as high priority or security vulnerability, constituting 10\% of all high-priority bugs of the period.<br>
Open-source developers regard error-inducing tests reported by us as “high-quality” and “common in practice”.</p>
<p>The artifact includes evidences of real-world bug finding (RQ3) as well as procedures to replicate experiments on coverage evaluation (RQ1) and rule inference (RQ2).</p>
<p>For more information, please check the artifact GitHub repository: https://github.com/ise-uiuc/neuri-artifact</p>

},
keywords = {Compiler Testing, Deep Learning Compilers, Fuzzing}
}

@software{10.5281/zenodo.8320669,
author = {Cao, Jialun and Lu, Yaojie and Wen, Ming and Cheung, Shing-Chi},
title = {Reproduction package for artical "Testing Coreference Resolution Systems without Labeled Test Sets"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8320669},
abstract = {
    <p>This artifact is a reproduction package for artical “Testing Coreference Resolution Systems without Labeled Test Sets”. The package includes (1) source code of CREST, (2) experimental results of comparisons with baselines, and (3) labeling results of human evaluation. The purpose of this artifact is for reference, reproduce and reuse components of CREST.</p>

},
keywords = {Coreference resolution testing, Metamorphic testing, SE4AI}
}

@software{10.6084/m9.figshare.19382123.v4,
author = {Asthana, Sumit and Sajnani, Hitesh and Voyloshnikova, Elena and Acharya, Birendra and Herzig, Kim},
title = {Supplementary materials for the paper "A Case Study of Developer Bots: Motivations, Perceptions, and Challenges"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.19382123.v4},
abstract = {
    <p>The artifact contains contains: * interview codes for the qualitative analysis. * Details questionnaires used in the paper. * Action logs for bots and script to reproduce the results for the quantitative analysis of the bots</p>

},
keywords = {interview-codes, python, questionnaires, R}
}

@software{10.6084/m9.figshare.21971945.v4,
author = {Sun, Zewen and Xu, Duanchen and Zhang, Yiyu and Qi, Yun and Wang, Yueyang and Zuo, Zhiqiang and Wang, Zhaokang and Li, Yue and Li, Xuandong and Lu, Qingda and Peng, Wenwen and Guo, Shengjian},
title = {Source Code and Data for BigDataflow},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21971945.v4},
abstract = {
    <p>The material through the Figshare link contains source code and experiments data of BigDataflow</p>

},
keywords = {distributed computing, graph processing, interprocedural dataflow analysis}
}

@software{10.6084/m9.figshare.21973091.v4,
author = {Hossain, Soneya Binta and Filieri, Antonio and Dwyer, Matthew B. and Elbaum, Sebastian and Visser, Willem},
title = {Neural-Based Test Oracle Generation: A Large-Scale Evaluation and Lessons Learned},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21973091.v4},
abstract = {
    <p>The artifact contains all required data, tools, scripts, and complete documentation for replication.</p>
<p>README provides all necessary details about each directory under this artifact. Additionally, we have provided README for individual RQ.</p>
<p>The structure of the artifact is as follows:</p>
<ul>
<li><p>evosuite-artifacts – contains the original test suite generated by EvoSuite for all 25 subjects</p></li>
<li><p>RQ1 – replication package for RQ1, includes data, scripts and documentation</p></li>
<li><p>RQ2 – replication package for RQ2, includes data, scripts and documentation</p></li>
<li><p>RQ3 – replication package for RQ3, includes data, scripts and documentation</p></li>
</ul>

},
keywords = {EvoSuite, Mutation Testing, Neural Test Oracle Generation, TOGA}
}

@software{10.6084/m9.figshare.21990386.v8,
author = {Trabish, David and Rinetzky, Noam and Shoham, Sharon and Sharma, Vaibhav},
title = {Evaluation Artifact: State Merging with Quantifiers in Symbolic Execution},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21990386.v8},
abstract = {
    <p>The artifact contains a docker image with all the required resources for running the experiments from the paper.</p>

},
keywords = {State Merging, Symbolic Execution}
}

@software{10.6084/m9.figshare.23913096.v1,
author = {Kim, Shinhae and Hwang, Sungjae},
title = {Replication Package for Article `EtherDiffer: Differential Testing on RPC Services of Ethereum Nodes'},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.23913096.v1},
abstract = {
    <p>Binary files of target nodes: clients/ Configuration template files for network construction: configs/ Smart contracts used for testing: contracts/ License file: LICENSE.txt Dependency packages of EtherDiffer: node_modules/ Dependency information files: package.json, package-lock.json Readme file: README.txt Main implementation of EtherDiffer: src/ Source files for multi-concurrent transactions: transactions/</p>

},
keywords = {blockchain, differential testing, ethereum nodes, rpc services}
}

@software{10.6084/m9.figshare.23993463.v1,
author = {Zhao, Kunsong and Li, Zihao and Li, Jianfeng and Ye, He and Luo, Xiapu and Chen, Ting},
title = {Reproduction Package for DeepInfer: Deep Type Inference from Smart Contract Bytecode},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.23993463.v1},
abstract = {
    <p>In this replication package, we describe how to replicate the results of our FSE’23 paper, [DeepInfer: Deep Type Inference from Smart Contract Bytecode]. Our replication package allows for an accurate reconstruction of results presented within our paper, as well as the source code for the tool that we built to generate these results.</p>

},
keywords = {Deep Learning, Smart Contract, Type Inference}
}

@software{10.6084/m9.figshare.24004242.v1,
author = {Song, Suhwan and Lee, Byoungyoung},
title = {Reproduction Package for Article "Metamong: Detecting Render-update Bugs in Web Browsers through Fuzzing"},
year = {2023},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24004242.v1},
abstract = {
    <p>Source code and all dataset used in the paper.</p>
<p>“Metamong.zip” contains the source code of Metamong.</p>
<p>“6.1.zip” contains the result of 6.1 Effectiveness of Render-update Oracle.</p>
<p>The data used in the paper. The directory ‘chrome’ contains Chrome render-update bugs. The directory ‘firefox’ contains Firefox render-update bugs.</p>
<p>In each directory, the file ‘issue_url’ contains the URL of a bug tracker result. The file ‘bug_list.txt’ categorizes which bugs are reproducible or not. The name of each directory in ‘chrome’ and ‘firefox’ represents the issue number. It contains a PoC HTML file (poc.html), a mutation primitive file (poc.js), and the correct and incorrect rendering outputs. “6.2.zip” contains the result of 6.2 Effectiveness of Page Mutator.</p>
<p>“100k_inputs” contains the HTML testcases. “output” contains the result of each mutation primitive test.</p>

},
keywords = {Software testing, verification and validation}
}

@software{10.5281/zenodo.10160153,
author = {Park, Sungwoo and Oh, Seyeon and Kim, Min-Soo},
title = {INFINEL: An efficient GPU-based processing method for unpredictable large output graph queries},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10160153},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10213773,
author = {Hu, Siyu and Zhao, Tong and Sha, Qiuchen and Li, Enji and Meng, Xiangyu and Liu, Liping and Wang, Lin-Wang and Tan, Guangming and Jia, Weile},
title = {Training one DeePMD Model in Minutes: a Step towards Online Learning},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10213773},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10222938,
author = {Wheatman, Brian and Burns, Randal and Buluc, Aydin and Xu, Helen},
title = {CPMA: An Efficient Batch-Parallel Compressed Set Without Pointers},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10222938},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10223442,
author = {Muller, Stefan K},
title = {Language-Agnostic Static Deadlock Detection for Futures},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10223442},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10223597,
author = {Manohar, Magdalen Dobson and Shen, Zheqi and Blelloch, Guy and Dhulipala, Laxman and Gu, Yan and Simhadri, Harsha Vardhan and Sun, Yihan},
title = {ParlayANN: Scalable and Deterministic Parallel Graph-Based Approximate Nearest Neighbor Search Algorithms},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10223597},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10224742,
author = {Li, Yifei and Zhou, Bole and Zhang, Jiejing and Wei, Xuechao and Li, Yinghan and Chen, Yingda},
title = {POSTER: RadiK: Scalable Radix Top-K Selection on GPUs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10224742},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10225025,
author = {Dagli, Ismet and Belviranli, Mehmet E.},
title = {Shared Memory-contention-aware Concurrent DNN Execution for Diversely Heterogeneous System-on-Chips},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10225025},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10225523,
author = {Chen, Yuetao and Li, Kun and Wang, Yuhao and Bai, Donglin and Wang, Lei and Ma, Lingxiao and Yuan, Liang and Zhang, Yunquan and Cao, Ting and Yang, Mao},
title = {ConvStencil: Transform Stencil Computation to Matrix Multiplication on Tensor Cores},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10225523},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10225634,
author = {Park, Seongyeon and Hong, Junguk and Song, Jaeyong and Kim, Hajin and Kim, Youngsok and Lee, Jinho},
title = {AGAThA: Fast and Efficient GPU Acceleration of Guided Sequence Alignment for Long Read Mapping},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10225634},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10226261,
author = {Kim, Daewoo and Brown, Trevor and Singh, Ajay},
title = {Are Your Epochs Too Epic? Batch Free Can Be Harmful},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10226261},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10252149,
author = {Dong, Xiaojun and Dhulipala, Laxman and Gu, Yan and Sun, Yihan},
title = {Parallel Integer Sort: Theory and Practice},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10252149},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10253798,
author = {Liu, Quanquan C. and Shun, Julian and Zablotchi, Igor},
title = {Parallel k-Core Decomposition with Batched Updates and Asynchronous Reads},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10253798},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10257908,
author = {Khalaji, Mohammad and Brown, Trevor and Daudjee, Khuzaima and Aksenov, Vitaly},
title = {Practical Hardware Transactional vEB Trees},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10257908},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10275776,
author = {Xu, Jinchen and Song, Guanghui and Zhou, Bei and Li, Fei and Hao, Jiangwei and Zhao, Jie},
title = {A Holistic Approach to Automatic Mixed-Precision Code Generation and Tuning for Affine Programs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10275776},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10346358,
author = {Zong, Yi and Wang, Xinliang and Huang, Haopeng and Zhang, Chensong and Xu, Xiaowen and Sun, Jian and Yan, Bowen and Wang, Qin and Li, Sicong and Ding, Zhaohui and Xue, Wei},
title = {POSTER: StructMG: A Fast and Scalable Structured Multigrid},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10346358},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10430776,
author = {Bhosale, Akshay and Eigenmann, Rudolf},
title = {Recurrence Analysis for Automatic Parallelization of Subscripted Subscripts},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10430776},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10433852,
author = {Ma, Lixian and Chen, Haoruo and Shao, En and Wang, Leping and Chen, Quan and Tan, Guangming},
title = {POSTER: FineCo: Fine-grained Heterogeneous Resource Management for Concurrent DNN Inferences},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10433852},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10437290,
author = {Lin, Zhiheng and Meng, Ke and Shui, Chaoyang and Zhang, Kewei and Xiao, Junmin and Tan, Guangming},
title = {Exploiting Fine-Grained Redundancy in Set-Centric Graph Pattern Mining},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10437290},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10447532,
author = {Blelloch, Guy E. and Wei, Yuanhao},
title = {VERLIB: Concurrent Versioned Pointers},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10447532},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10449841,
author = {Liu, Xiaoyan and Zheng, Xuegui and Yang, Hailong and Luan, Zhongzhi and Qian, Depei},
title = {Tetris: Accelerating Sparse Convolution by Exploiting Memory Reuse on GPU},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10449841},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10475796,
author = {McCoy, Hunter and Pandey, Prashant},
title = {Gallatin: A General-Purpose GPU Memory Manager},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10475796},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.5281/zenodo.10531146,
author = {Ahmad, Zafar and Browne, Reilly and Chowdhury, Rezaul and Das, Rathish and Huang, Yushen and Zhu, Yimin},
title = {Fast American Option Pricing using Nonlinear Stencils},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10531146},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.6084/m9.figshare.24803229,
author = {Jangda, Abhinav and Yadav, Mohit},
title = {Fast Kronecker Matrix-Matrix Multiplication on GPUs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24803229},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.6084/m9.figshare.24902067,
author = {Du, Jiangsu and Wei, Jinhui and Jiang, Jiazhi and Cheng, Shenggan and Chen, Zhiguang and Huang, Dan and Lu, Yutong},
title = {Liger: Interleaving Intra- and Inter-Operator Parallelism for Distributed Large Model Inference},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24902067},
abstract = {
    
                <p>Artifact appendix item for PPoPP24</p>
              
}
}

@software{10.1145/3580424,
author = {Liu, Yiyun and Chan, Jonathan and Shi, Jessica and Weirich, Stephanie},
title = {Artifact associated with Internalizing Indistinguishability with Dependent Types},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580424},
abstract = {
    <p>This artifact contains the complete mechanized Coq proofs of the lemmas and theorems about DCOI and its prototype implementation in Haskell. The VM image is preinstalled with the dependencies required to validate the Coq proofs and run the prototype type checker. No special hardware is required as long as the host machine has 4 GiB of memory available to run the VM.</p>

},
keywords = {Coq, Dependent Types, Formalization, Modes}
}

@software{10.1145/3580425,
author = {Grodin, Harrison and Niu, Yue and Sterling, Jonathan and Harper, Robert},
title = {**calf**: A Cost-Aware Logical Framework},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580425},
abstract = {
    <p>The <strong>calf</strong> language is a <strong>c</strong>ost-<strong>a</strong>ware <strong>l</strong>ogical <strong>f</strong>ramework for studying quantitative aspects of functional programs.</p>
<p>This repository contains the Agda implementation of <strong>calf</strong>, as well as some case studies of varying complexity.</p>

},
keywords = {algorithm analysis, amortized analysis, behavioral verification, cost models, equational reasoning, intensional property, mechanized proof, modal type theory, noninterference, parallel algorithms, phase distinction, proof assistants, recurrence relations}
}

@software{10.1145/3580426,
author = {Geller, Adam T. and Frank, Justin and Bowman, William J.},
title = {Artifacts and Reproduction Package for Article `Indexed Types for a Statically Safe WebAssembly'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580426},
abstract = {
    <p>Contains the software artifacts we created as part of our work, and the benchmarks along with scripts to reproduce the data presented in the evaluation.</p>
<p>The software artifacts available through following the installation instructions are as follows: - The folder <code>wasmtime</code> contains our implementation of wasm-prechk on top of wasmtime. It is also modified not to use any memory guard pages. - The folder <code>no_checks</code> contains the configuration of wasmtime modified to produce no dynamic checks. - The folder <code>vm_guards</code> contains the unmodified version of wasmtime. - The folder <code>wasm-tools</code> contains our implementation of the wasm-prechk parser and typechecker. - The folder <code>wasm-prechk</code> contains our redex model of wasm-prechk. - The folder <code>polybenchC-4.2.1</code> contains the benchmark suite, including scripts to generate the evaluation data, the version of wasm modules with annotations and manual checks added for each benchmark, and the unmodified wasm modules for each benchmark.</p>

},
keywords = {Indexed Types, Optimization and Compiler Design, Program Logics, Type Systems, WebAssembly}
}

@software{10.17863/CAM.104080,
author = {Hammond, Angus and Liu, Zongyuan and P\'{e}rami, Thibaut and Sewell, Peter and Birkedal, Lars and Pichon-Pharabod, Jean},
title = {Research data for "An Axiomatic Basis for Computer Programming on the Relaxed Arm-A Architecture: The AxSL Logic"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.17863/CAM.104080},
abstract = {
    <p>Formal proof development for the AxSL logic</p>
<p>This artifact is a mechanised proof development that contains formalised definitions and proofs that can be checked by the Coq proof assistant. It contains all the results presented in the paper.</p>

},
keywords = {AxSL}
}

@software{10.5281/zenodo.10009365,
author = {Van Muylder, Antoine and Nuyts, Andreas and Devriese, Dominique},
title = {Agda --bridges virtual machine},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10009365},
abstract = {
    <p>This is an Ubuntu 20.04 virtual machine (.ova format) to play with Agda –bridges, a proof assistant extending the Agda 2.6.3 proof assistant with internal parametricity. The virtual machine contains (see desktop):</p>
<ul>
<li><p>The Agda –bridges repository (a fork of Agda). Sources of Agda –bridges have been pre-compiled. The resulting binaries live in <code>/home/vboxuser/.local/bin/</code>.</p></li>
<li><p>The cubical library repo.</p></li>
<li><p>The bridgy library, an Agda –bridges library featuring abstractions to prove internal free theorems modularly.</p></li>
</ul>
<p>Quick start: After having imported the VM into your system, load <code>/home/vboxuser/Desktop/bridgy-lib/Everything.agda</code> in emacs (C-c C-l) within the VM.</p>
<p>Alternatively: install Agda –bridges directly on your machine.</p>
<p>Detailed instructions: See README.md in the artifact.</p>

},
keywords = {Agda, cubical type theory, parametricity, structure relatedness principle, type theory}
}

@software{10.5281/zenodo.10015321,
author = {Smeding, Tom J. and V\'{a}k\'{a}r, Matthijs I. L.},
title = {Artifact for Efficient CHAD},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10015321},
abstract = {
    <p>Contains a proof, formalised in Agda, of the main complexity result in the paper.</p>

},
keywords = {Agda, automatic differentiation, complexity, formalized proof, source transformation}
}

@software{10.5281/zenodo.10019663,
author = {Attouche, Lyes and Baazizi, Mohamed-Amine and Colazzo, Dario and Ghelli, Giorgio and Sartiani, Carlo and Scherzinger, Stefanie},
title = {Reproduction Package for: Validation of Modern JSON Schema: Formalization and Complexity.},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10019663},
abstract = {
    <p>Reproduction package for the POPL’24 contribution “Validation of Modern JSON Schema: Formalization and Complexity”.</p>
<p>All artifacts (source code, data, scripts) are packaged in a virtual machine running Ubuntu Linux, which can be run using VirtualBox.</p>

},
keywords = {complexity of validation, JSON Schema}
}

@software{10.5281/zenodo.10023424,
author = {Pottier, Fran\c{c}ois and Gu\'{e}neau, Arma\"{e}l and Jourdan, Jacques-Henri and M\'{e}vel, Glen},
title = {Artifact for "Thunks and Debits in Separation Logic with Time Credits"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10023424},
abstract = {
    <p>This is the artifact for the POPL 2024 paper “Thunks and Debits in Separation Logic with Time Credits”.</p>
<p>The artifact is provided both as a VirtualBox virtual machine and as a .tar.gz file. They both contain the same Coq development, accessible in the following public GitLab repository:</p>
<pre><code> https://gitlab.inria.fr/cambium/iris-time-proofs</code></pre>
<h3 id="the-virtual-machine">The virtual machine</h3>
<p>The virtual machine contains the content of the archive, fully compiled, and all the software needed to compile it. When booting, it should automatically log in. In case it is necessary, it can be logged in using the user “vagrant” and the password “vagrant”.</p>
<p>The relevent files are in the directory coq-iris-time on the desktop. They can be seen using Coqide, which can be run using the icon on the desktop.</p>
<h3 id="building-the-artifact-from-the-archive">Building the artifact from the archive</h3>
<p>The archive can be compiled by following the instructions bellow.</p>
<h4 id="step-1-creating-an-opam-switch">Step 1: Creating an opam switch</h4>
<p>If opam is not already installed:_ See instructions <a href="https://opam.ocaml.org/doc/Install.html">there</a> to install it; then:</p>
<pre><code>opam init
eval $(opam env)</code></pre>
<p>(This will create a <code>~/.opam</code> directory.)</p>
<p>Extract the archive, and move to the directory:</p>
<pre><code>tar -xzvf coq-iris-time.tar.gz
cd coq-iris-time</code></pre>
<p>If opam (≥ 2.0) is already installed:_ Create a local switch for the project in the current directory:</p>
<pre><code>opam update
opam switch create --no-install . ocaml-base-compiler.4.14.1
eval $(opam env)</code></pre>
<h4 id="step-2-installing-the-dependencies">Step 2: Installing the dependencies</h4>
<p>In an opam switch as created above, the commands</p>
<pre><code>opam repo add coq-released https://coq.inria.fr/opam/released
opam repo add iris-dev git+https://gitlab.mpi-sws.org/iris/opam.git
opam update
opam pin add -n coq 8.16.1
make builddep</code></pre>
<p>will pin and install the dependencies at the correct version.</p>
<p>If you want to browse the Coq development using CoqIDE (a graphical, interactive toplevel for Coq), install it as well:</p>
<pre><code>opam install coqide</code></pre>
<h4 id="step-3-compiling-the-proof-scripts">Step 3: Compiling the proof scripts</h4>
<p>When all required libraries can be found (e.g.&nbsp;in an opam switch as configured above), compile the proof scripts with:</p>
<pre><code>make -j</code></pre>
<p>Other recipes are available, such as <code>all</code>, <code>clean</code> and <code>userinstall</code>.</p>
<h3 id="supporting-the-claims-of-the-paper">Supporting the claims of the paper</h3>
<h4 id="piggy-banks">Piggy banks</h4>
<p>The piggy bank construction is formalized in file <code>theories/thunks/PiggyBank.v</code>. Each rule in Figure 2 of the paper is formalized by a lemma in this file, named after the name of the rule.</p>
<h4 id="thunks">Thunks</h4>
<p>The common interface of thunks, base thunks and proxy thunks is defined as the <code>CommonThunkAPI</code> typeclass in file <code>theories/thunks/ThunksAPI.v</code>. Lemma <code>base_thunk_api</code> shows that base thunks implement this API (second part of Theorem 4.1).</p>
<p>Base thunks and the <code>ThunkVal</code> predicate are defined in file <code>theories/thunks/ThunksBase.v</code>. Rules in Figure 7 are proved by lemmas in the same file, named after the name of the rule (last part of Theorem 4.1). The rule Thunk-Create for base thunks is proved by lemma <code>base_thunk_create</code> (first part of Theorem 4.1).</p>
<p>Proxy thunks are defined in file <code>theories/thunks/ThunksStep.v</code>. Theorem 4.2 is proved by instance <code>step_thunk_api</code> and lemma <code>proxythunk_consequence</code>.</p>
<p>Thunks are defined in file <code>theories/thunks/ThunksFull.v</code>. Theorem 4.3 is proved by instance <code>thunk_api</code>, lemma <code>thunk_create</code> and lemma <code>thunk_consequence</code>.</p>
<h4 id="height-indexed-thunks">Height-indexed thunks</h4>
<p>Height-indexed thunks are defined in file <code>theories/thunks/HThunks.v</code>. Rules in Figure 11 are formalized in lemmas whose name should be self-explanatory, except for rule HThunk-Inc-Height-Debit, split into lemmas <code>hthunk_covariant_in_h</code> and <code>hthunk_increase_debt</code>.</p>
<h4 id="streams">Streams</h4>
<p>The code of the stream library is given in file <code>theories/streams/StreamsCode.v</code>, and its specification formalized in file <code>theories/streams/Streams.v</code>.</p>
<p>Rules of Figure 13 are formalized by lemmas with the same name, except for Stream-Increase-Height, which is backed by lemma <code>stream_covariant</code>.</p>
<p>Rules of Figure 14 are constructor of inductive predicate <code>subdebits</code>.</p>
<p>Rule Sub-Variance is split into lemmas <code>subdebits_covariant_in_slack</code> and <code>subdebits_contravariant_in_rest</code>.</p>
<p>Rule Sub-Refl is backed by lemma <code>subdebits_reflexive</code>.</p>
<p>Rule Sub-Trans is backed by lemma <code>subdebits_transitive</code>.</p>
<p>Rule Sub-Append is backed by lemma <code>subdebits_app</code>.</p>
<p>Rule Sub-Add-Slack is backed by lemma <code>subdebits_add_slack</code>.</p>
<p>Rule Sub-Repeat is backed by lemma <code>subdebits_repeat</code>.</p>
<p>Lemma 6.1 is backed by lemma <code>subdebits_alternate_characterization</code>.</p>
<h4 id="bankers-queue">Banker’s queue</h4>
<p>The code of the banker’s queue is in file <code>theories/bqueue/Code.v</code>. Its specification is in file <code>theories/bqueue/Proof.v</code>.</p>
<p>Rule Banker-Persistent is proved by lemma <code>is_queue_persistent</code>.</p>
<p>Rule Banker-Empty is proved by lemma <code>empty_spec</code>.</p>
<p>Rule Banker-Snoc is proved by lemma <code>snoc_spec</code>.</p>
<p>Rule Banker-Extract is proved by lemma <code>extract_spec</code>.</p>
<p>Rule Banker-Check is proved by lemma <code>check_spec</code>.</p>
<h4 id="the-physiscists-queue-implicit-queues.">The physiscist’s queue, implicit queues.</h4>
<p>The physiscist’s queue is formalized in directory <code>theories/pqueue</code>.</p>
<p>Implicit queus are formalized in directory <code>theories/iqueue</code>.</p>

},
keywords = {program verification, separation logic, time complexity}
}

@software{10.5281/zenodo.10023528,
author = {Li, Xiang and Zhou, Xiangyu and Dong, Rui and Zhang, Yihong and Wang, Xinyu},
title = {Reproduction Package for 'Efficient Bottom-Up Synthesis for Programs with Local Variables'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10023528},
abstract = {
    <p>This artifact includes the Arborist program synthesizer for web automation. It also contains all the necessary benchmark data to reproduce the RQ1 main results (Figure 21 of the paper).</p>

},
keywords = {Observational Equivalence, Program Synthesis, Web Automation}
}

@software{10.5281/zenodo.10026970,
author = {Randone, Francesca and Bortolussi, Luca and Incerto, Emilio and Tribastone, Mirco},
title = {Reproduction Package for the Paper "Inference of Probabilistic Programs with Moment-Matching Gaussian Mixtures"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10026970},
abstract = {
    <p>This is the replication package for the paper “Inference of Probabilistic Programs with Moment-Matching Gaussian Mixtures”</p>
<h3 id="contents">Contents</h3>
<ul>
<li>soga_docker.tar.gz contains the docker image of SOGA</li>
<li>soga_code.tar.gz contains the SOGA source code</li>
</ul>
<h3 id="requirements">Requirements</h3>
<ul>
<li>For running this package a valid docker (https://docs.docker.com/engine/install/) installation is required with version &gt;=24.0.6.</li>
<li>For compatibility issues with the external tools used for the evaluation, the image is based on x86_64 architecture</li>
</ul>
<h3 id="reproducibility">Reproducibility</h3>
<ul>
<li><p>The provided docker images can be loaded in two ways: A) using the one provided in this package and B) using the one stored on Dockerhub. To load the images provided in this package, download it and issue the following command:</p>
<p>docker load –input soga_docker.tar.gz</p></li>
<li><p>In both cases, A or B, for creating the container issue:</p>
<p>docker container create -i -t –name SOGA bistrulli/soga:0.1 docker container start SOGA docker attach SOGA</p></li>
<li><p>The detailed instructions for reproducing the paper results are reported in the README.md file within the docker image</p></li>
</ul>

},
keywords = {Gaussian Mixtures, Inference, Moment-Matching, Probabilistic Programming}
}

@software{10.5281/zenodo.10036618,
author = {Zhang, Ling and Wang, Yuting and Wu, Jinhua and Koenig, J\'{e}r\'{e}mie and Shao, Zhong},
title = {Artifact for `Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10036618},
abstract = {
    <p>This is the artifact for the POPL 2024 paper “Fully Composable and Adequate Verified Compilation with Direct Refinements between Open Modules”.</p>
<p>The artifact is a VM image in .ova format. We have tested the VM in VirtualBox version 7.0.8 running on a host Windows 11 machine with 64-bit Ubuntu LTS 20.04. The source code can be found in the directory ‘/home/authors/direct-refinement-popl24-artifact’. Follow the ‘README.md’ file in this directory to evaluate the artifact.</p>
<p>The VM should also work on Linux host machines. Note that the VM will not run on Mac computers with M-series chips as it is based on X86.</p>
<p>You may also compile from the source code on your local Linux machine. The up-to-date source code and instructions for compiling it can be found at the following address:</p>
<p>https://github.com/SJTU-PLV/direct-refinement-popl24-artifact/blob/main/README.md</p>
<p>We suggest you look at the instructions in the above URL if you have difficulty reading README.md file directly in the VM.</p>
<p>The technical report of our paper can be found at the following address:</p>
<p>https://arxiv.org/abs/2302.12990</p>

},
keywords = {Compiler Verification, Direct Refinements, Kripke Relations, Program Verification, Verified Compositional Compilation}
}

@software{10.5281/zenodo.10039066,
author = {Yao, Jianan and Tao, Runzhou and Gu, Ronghui and Nieh, Jason},
title = {Artifact for Article "Mostly Automated Verification of Liveness Properties for Distributed Protocols with Ranking Functions"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10039066},
abstract = {
    <p>This artifact provides a docker image which includes the Python source code of LVR and the evaluated mypyvy protocols. See README for instructions to run. Please use the latest version if available.</p>

},
keywords = {distributed protocols, formal verification, liveness properties, ranking functions}
}

@software{10.5281/zenodo.10040534,
author = {Sieczkowski, Filip and Stepanenko, Sergei and Sterling, Jonathan and Birkedal, Lars},
title = {The Essence of Generalized Algebraic Data Types (Coq mechanization)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10040534},
abstract = {
    <p>Coq mechanization supplement for The Essence of Generalized Algebraic Data Types paper.</p>

},
keywords = {Functional languages, Semantic models, Type systems/inference/theory}
}

@software{10.5281/zenodo.10054966,
author = {Deng, Haowei and Tao, Runzhou and Peng, Yuxiang and Wu, Xiaodi},
title = {A Case for Synthesis of Recursive Quantum Unitary Programs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10054966},
abstract = {
    <p>QSynth’s source code for POPL24 artifact evaluation.</p>

},
keywords = {Program Synthesis, SMT Solver}
}

@software{10.5281/zenodo.10069757,
author = {Cyphert, John and Kincaid, Zachary},
title = {Reproduction Package for Article Solvable Polynomial Ideals: The Ideal Reflection for Program Analysis},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10069757},
abstract = {
    <p>The artifact consists of a virtual machine (VM) in OVA format. The VM contains an installation of Ubuntu 22.04, along with the required software to verify the experimental claims in the article Solvable Polynomial Ideals: The Ideal Reflection for Program Analysis. The VM contains an executable duet.exe which implements the ideas described in the article. The VM also contains software to compare the ideas of the article with the tools ChilonInv, CRA, Veriabs, and Ultimate Automizer on benchmarks sourced from the software verification competition (SV-COMP).</p>

},
keywords = {Algebraic Program Analysis, Monotone Analysis, Polynomial Invariants}
}

@software{10.5281/zenodo.10073582,
author = {Cohen, Liron and Jabarin, Adham and Popescu, Andrei and Rowe, Reuben N. S.},
title = {The Complex(ity) Landscape of Checking Infinite Descent (Software Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10073582},
abstract = {
    <p>This is the accompanying artifact for the POPL 2024 paper “The Complex(ity) Landscape of Checking Infinite Descent” by Liron Cohen, Adham Jabarin, Andrei Popescu and Reuben N. S. Rowe. It contains the following:</p>
<ol type="1">
<li><p>Extension of the Cyclist automated theorem prover (cyclist-prover.org) by new algorithms for checking the Infinite Descent property.</p></li>
<li><p>Experimental dataset for algorithms checking Infinite Descent.</p></li>
</ol>

},
keywords = {B\"{u}chi automaton, cyclic proof, Cyclist theorem prover, infinite descent, relational criterion}
}

@software{10.5281/zenodo.10077754,
author = {Sotiropoulos, Thodoris and Chaliasos, Stefanos and Su, Zhendong},
title = {Replication Pakcage for Article "API-Driven Program Synthesis for Testing Static Typing Implementations"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10077754},
abstract = {
    <p>The purpose of this artifact is to reproduce the results presented in the POPL 2024 paper titled “API-Driven Program Synthesis for Testing Static Typing Implementations”. The artifact contains the instructions and scripts to re-run the evaluation described in the paper. The artifact has the following structure:</p>
<ul>
<li>scripts/: This directory contains the scripts needed to re-run the experiments and re-produce the figures and tables presented in the paper.</li>
<li>data/: This is the directory that contains the pre-computed results of the evaluation.</li>
<li>data/packages.csv: A CSV file that contains the 95 Maven libraries whose APIs have been used in the evaluation.</li>
<li>database/bug_schema.sql: This is the database schema that contains the bugs discovered by our approach.</li>
<li>database/bugdb.sqlite3: This is the <code>sqlite3</code> database file corresponding to our bug database.</li>
<li>database/bugs.json: Our bug reports in a JSON format.</li>
<li>stdlib/: API specification of the standard libraries of three languages: Java, Scala, Kotlin. This not the complete API specification, but rather some common API components (e.g., java.util.*) that are used frequently in third-party libraries.</li>
<li>thalia/: Contains the source code of our tool (provided as a git submodule) used for testing the compilers of Scala, Kotlin, and Groovy using API-driven program synthesis. The name of our tool is <code>thalia</code>.</li>
<li>hephaestus/: Contains the source code of the state-of-the-art tool named Hephaestus used for finding compiler typing bugs. In our evaluation, we compare Thalia` with Hephaestus.</li>
<li>doc2json/: This is a submodule that contains the source code of an auxiliary tool used to convert API documentation pages into JSON documents. More details can be found at: https://github.com/hephaestus-compiler-project/doc2json</li>
<li>installation_scripts/: Contains helper scripts used to install all dependencies (e.g., compiler versions from <a href="https://sdkman.io/">SDKMAN</a>).</li>
<li>figures/: This directory will be used to save the figures of our paper.</li>
<li>Dockerfile: The Dockerfile used to create a Docker image of our artifact. This image contains all data and dependencies.</li>
</ul>

},
keywords = {API, compiler bugs, compiler testing, enumeration, Groovy, Kotlin, library, Scala, static typing}
}

@software{10.5281/zenodo.10100892,
author = {Timany, Amin and Gregersen, Simon Oddershede and Stefanesco, L\'{e}o and Hinrichsen, Jonas Kastberg and Gondelman, L\'{e}on and Nieto, Abel and Birkedal, Lars},
title = {Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement - Coq Artefact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10100892},
abstract = {
    <p>Coq artifact accompanying the paper “Trillium: Higher-Order Concurrent and Distributed Separation Logic for Intensional Refinement”.</p>

},
keywords = {liveness, refinement, Separation logic, step-indexing}
}

@software{10.5281/zenodo.10116628,
author = {Popescu, Andrei},
title = {Nominal Recursors as Epi-Recurors (Mechanized Proofs Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10116628},
abstract = {
    <p>This is the Isabelle mechanization associated to the POPL 2024 paper “Nominal Recursors as Epi-Recursors” by Andrei Popescu. The formal proofs are located in the archive isabelle_nominal_recursors_and_corecursors.zip . They can be processed with Isabelle2023, available for download from https://isabelle.in.tum.de/ .</p>

},
keywords = {epi-(co)recuror, formal reasoning, Isabelle/HOL, nominal logic, nominal recursion and corecursion, syntax with bindings, theorem proving}
}

@software{10.5281/zenodo.10119773,
author = {Farzan, Azadeh and Klumpp, Dominik and Podelski, Andreas},
title = {Benchmarks for POPL'24 Paper "Commutativity Simplifies Proofs of Parameterized Programs"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10119773},
abstract = {
    <p>This archive contains the benchmark programs used in the POPL’24 paper “Commutativity Simplifies Proofs of Parameterized Programs” by A. Farzan, D. Klumpp and A. Podelski.</p>

},
keywords = {concurrency, constrained Horn clauses, verification}
}

@software{10.5281/zenodo.10120126,
author = {Tang, Wenhao and Hillerstr\"{o}m, Daniel and Lindley, Sam and Morris, J. Garrett},
title = {Artifact for Soundly Handling Linearity},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10120126},
abstract = {
    <p>This artifact contains the implementation of the extension of Links with control-flow linearity as described in Section 4 of the paper:</p>
<p>Wenhao Tang, Daniel Hillerstr\"{o}m, Sam Lindley, J. Garrett Morris, “Soundly Handling Linearity”, Proc. ACM Program. Lang. 8(POPL), 2024.</p>

},
keywords = {effect handlers, linear resources, linear types}
}

@software{10.5281/zenodo.10125015,
author = {Andrici, Cezar-Constantin and Ciob\^{a}c\u{a}, undefinedtefan and Hri\c{t}cu, C\u{a}t\u{a}lin and Mart\'{\i}nez, Guido and Rivas, Exequiel and Tanter, \'{E}ric and Winterhalter, Th\'{e}o},
title = {Artifact for the POPL 2024 paper `Securing Verified IO Programs Against Unverified Code in F*`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10125015},
abstract = {
    <p>The artifact contains a formalization of the contributions of the paper. The artifact contains the SCIO* framework, the mechanized proofs of sound enforcement of a global trace property and Robust Relational Hyperproperty Preservation (RrHP), as well as a few examples.</p>

},
keywords = {F*, formal verification, input-output, proof assistants, secure compilation}
}

@software{10.5281/zenodo.10125129,
author = {Zhou, Litao and Qin, Jianxing and Wang, Qinshi and Appel, Andrew W. and Cao, Qinxiang},
title = {Artifact for VST-A: A Foundationally Sound Annotation Verifier},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10125129},
abstract = {
    <p>This is the artifact for the paper “VST-A: A Foundationally Sound Annotation Verifier.” VST-A is an annotation verifier built upon VST, designed for the functional correctness verification of assertion annotated C programs. Users are guided to first install the OPAM package manager and subsequently set up OCaml 4.10.2, Menhir 20190924, and Coq 8.12.2 to facilitate the artifact’s compilation. The artifact is self-contained, incorporating a modified CompCert compiler capable of parsing annotated programs and a patched VST-2.5. The development of VST-A, encompassing formalization, implementation, and evaluation examples outlined in the paper, is consolidated within the <code>VST-A/</code> directory.</p>

},
keywords = {Annotated Programs, Coq, Foundational Verification}
}

@software{10.5281/zenodo.10125136,
author = {Elad, Neta and Padon, Oded and Shoham, Sharon},
title = {An Infinite Needle in a Finite Haystack: Finding Infinite Counter-Models in Deductive Verification &nbsp;(Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10125136},
abstract = {
    <p>Artifact for the POPL ’24 paper “An Infinite Needle in a Finite Haystack: Finding Infinite Counter-Models in Deductive Verification”.</p>
<p>The artifact is provded as a virtual machine, and includes the Python package for the FEST tool, and benchmarks (encoded in Z3’s programmatic API).</p>
<p>For more details, see the <code>README.md</code> file.</p>
<p>Note that the run times of the benchmarks inside the virtual machine can be 2x-5x slower than the times measured (in Table 2). Still, they remain below the 10 minutes threshold.</p>

},
keywords = {counter-models, deductive verification, infinite models, Paxos}
}

@software{10.5281/zenodo.10125602,
author = {Qin, Xueying and O’Connor, Liam and van Glabbeek, Rob and H\"{o}fner, Peter and Kammar, Ohad and Steuwer, Michel},
title = {Artifact for Shoggoth - A Formal Foundation for Strategic Rewriting},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10125602},
abstract = {
    <p>This is the artifact for the paper Shoggoth : A Formal Foundation for Strategic Rewriting. We provide all mechanised proofs developed in Isabelle/HOL. In total we provide nine files (with .thy extension) containing our proof scripts for the denotational semantics, operational semantics, semantic equivalence, weakest precondition calculus and soundness of the weakest precondition calculus are discussed in the paper. Please refer to README.md for detail information as well as instructions for installing and executing this artifact.</p>

},
keywords = {formal verification, semantics, weakest precondition}
}

@software{10.5281/zenodo.10125861,
author = {Hague, Matthew and Je\.{z}, Artur and Lin, Anthony W.},
title = {Parikh's Theorem Made Symbolic: Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10125861},
abstract = {
    <p>The artifact contains the source code of the tool developed in the article. This may be compiled on your own machine, or inside a Docker image (Dockerfile provided). It also contains a disk image with the tool installed, the benchmarks, and the tools that we compared with.</p>

},
keywords = {Abstraction, Decision Procedures, Infinite Alphabets, Satisfiability Modulo Theories, Sequence Theory, String Constraints, Symbolic Automata}
}

@software{10.5281/zenodo.10126819,
author = {Rinaldi, Francis and wunder, june and Azevedo de Amorim, Arthur and Muller, Stefan K.},
title = {Implementation for "Pipelines and Beyond: Graph Types for ADTs with Futures"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10126819},
abstract = {
    <p>This artifact accompanies the paper “Pipelines and Beyond: Graph Types for ADTs with Futures”, published at POPL 2024. It implements an engine to infer vertex structure annotations and graph types for a subset of OCaml, following the language and the type system presented in the paper.</p>

},
keywords = {affine type system, computation graphs, cost graphs, futures, graph types, parallel programs, pipelining}
}

@software{10.5281/zenodo.10129703,
author = {Zhao, Eric and Maroof, Raef and Dukkipati, Anand and Blinn, Andrew and Pan, Zhiyi and Omar, Cyrus},
title = {Artifact for Total Type Error Localization and Recovery with Holes},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10129703},
abstract = {
    <p>The artifact contains the complete formalization of and extensions to the marked lambda calculus, the Agda mechanization, and the implementation of Hazel including type hole inference, as described in the paper.</p>

},
keywords = {bidirectional typing, gradual typing, type errors, type inference}
}

@software{10.5281/zenodo.10129930,
author = {Ding, Yuantian and Qiu, Xiaokang},
title = {Reproduction Package (VirtualBox Image) for the POPL 2024 Article `Enhanced Enumeration Techniques for Syntax-Guided Synthesis of Bit-Vector Manipulations'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10129930},
abstract = {
    <p>This is the artifact for the ACM PACMPL article Enhanced Enumeration Techniques for Syntax-Guided Synthesis of Bit-Vector Manipulations. We provide our artifact as an easy-to-use VirtualBox image, which contains the benchmarks, our tools for bit-vector synthesis, and the scripts for generating the results showcased in the paper.</p>

},
keywords = {Bit vector, Enumeration, Large language model, Syntax-guided synthesis, Term graph}
}

@software{10.5281/zenodo.10146270,
author = {Mell, Stephen and Zdancewic, Steve and Bastani, Osbert},
title = {Artifact for "Optimal Program Synthesis via Abstract Interpretation"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10146270},
abstract = {
    <p>The artifact reproduces our experimental results (Figure 2 and Table 1) and may be useful for performing synthesis on other trajectory datasets or implementing our algorithm for other DSLs.</p>

},
keywords = {abstract interpretation, optimal synthesis, program synthesis}
}

@software{10.5281/zenodo.10151333,
author = {Moy, Cameron and Dimoulas, Christos and Felleisen, Matthias},
title = {Artifact: Effectful Software Contracts},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10151333},
abstract = {
    <p>This artifact contains a Docker image for the effect/racket language implementation along with appendices accompanying the paper.</p>

},
keywords = {effect handlers, software contracts}
}

@software{10.5281/zenodo.10155221,
author = {Castagna, Giuseppe and Laurent, Micka\"{e}l and Nguy\~{\^e}n, Kim},
title = {Prototype: Polymorphic Type Inference for Dynamic Languages},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10155221},
abstract = {
    <p>This is a prototype for the article: Polymorphic Type Inference for Dynamic Languages. See README.md for instructions.</p>

},
keywords = {intersection types, OCaml, polymorphism, type reconstruction, union types}
}

@software{10.5281/zenodo.10207465,
author = {Timany, Amin and Gu\'{e}neau, Arma\"{e}l and Birkedal, Lars},
title = {Artifact for the paper "The Logical Essence of Well-Bracketed Control Flow"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10207465},
abstract = {
    <p>This artifact includes the accompanying technical appendix and the Coq formalization of the paper “The Logical Essence of Well-Bracketed Control Flow”.</p>

},
keywords = {Coq, logical relations, program logics, program verification, semantic typing, stack discipline, well-bracketedness}
}

@software{10.5281/zenodo.8409115,
author = {Crichton, Will and Krishnamurthi, Shriram},
title = {Artifact for "A Core Calculus for Documents"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8409115},
abstract = {
    <p>These are Docker images that contain the codebase for our POPL 2024 paper “A Core Calculus for Documents”. Download the README.pdf for instructions on how to run the artifact and for details about its contents.</p>

},
keywords = {document languages, markup, templates}
}

@software{10.5281/zenodo.8414566,
author = {Moine, Alexandre and Westrick, Sam and Balzer, Stephanie},
title = {DisLog: A Separation Logic for Disentanglement - Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8414566},
abstract = {
    <p>This is the artifact corresponding to the article entitled “DisLog: A Separation Logic for Disentanglement”, and its associated documentation.</p>

},
keywords = {Coq, Disentanglement, Iris, Separation Logic}
}

@software{10.5281/zenodo.8417774,
author = {Cohen, Joshua M. and Johnson-Freyd, Philip},
title = {Coq Formalization for the paper "A Formalization of Core Why3 in Coq"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8417774},
abstract = {
    <p>This artifact contains a formalization of the logic fragment of the Why3 language, used as a backend for many verification tools, including Frama-C.</p>

},
keywords = {Coq, First-Order Logic, Formal Semantics, Why3}
}

@software{10.5281/zenodo.8421879,
author = {Sellami, Yanis and Girol, Guillaume and Recoules, Fr\'{e}d\'{e}ric and Courouss\'{e}, Damien and Bardin, S\'{e}bastien},
title = {Reproduction Package for Article `Inference of Robust Reachability Constraints'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8421879},
abstract = {
    <p>This is the Artifact for the POPL 2024 Paper `Inference of Robust Reachability Constraints’. The artifact takes the form of a virtual machine disk image from which one can regenerate the paper’s tables and graphs from the logs of the experiments and rerun the experiments for reproducibility.</p>

},
keywords = {abduction, precondition inference, program analysis, software security engineering, symbolic execution}
}

@software{10.5281/zenodo.8422415,
author = {Bergstr\"{a}\ss{}er, Pascal and Ganardi, Moses and Lin, Anthony W. and Zetzsche, Georg},
title = {Ramsey Quantifiers in Linear Arithmetics - Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8422415},
abstract = {
    <p>The purpose of the artifact is to reproduce the experimental results of the paper “Ramsey Quantifiers in Linear Arithmetics”. It consists of a “README.pdf” and the four files “ramsey.py”, “elimination_benchmarks.py”, “mondec_benchmarks.py”, and “example.py”. The file “ramsey.py” contains the main functions “eliminate_ramsey” and “is_mondec”. The purpose of the function “eliminate_ramsey” is to compute an equivalent existential formula from a given Ramsey quantified existential formula. The function “is_mondec” takes a quantifier-free formula and returns true if the formula is monadically decomposable and false otherwise. We assume the formulas to be in Linear Integer Arithmetic, in Linear Real Arithmetic, or a decomposition of a Linear Integer Real Arithmetic formula. The benchmarks that are mentioned in the paper are available in the files “elimination_benchmarks.py” and “mondec_benchmarks.py”.</p>

},
keywords = {Infinite Chains, Infinite Cliques, Linear Integer Arithmetic, Linear Real Arithmetic, Liveness, Monadic Decomposability, Ramsey Quantifiers, Satisfiability Modulo Theories, Termination}
}

@software{10.5281/zenodo.8422532,
author = {Kidney, Donnacha Ois\'{\i}n and Yang, Zhixuan and Wu, Nicolas},
title = {Artefact for "Algebraic Effects Meet Hoare Logic in Cubical Agda"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8422532},
abstract = {
    <p>This artefact contains the Agda formalisation of the paper “Algebraic Effects Meet Hoare Logic in Cubical Agda”.</p>

},
keywords = {algebraic effects, Cubical Agda, Hoare logic, program verification}
}

@software{10.5281/zenodo.8422755,
author = {Jacobs, Jules and Hinrichsen, Jonas Kastberg and Krebbers, Robbert},
title = {Linear Actris Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8422755},
abstract = {
    <h2 id="linear-actris-artifact">Linear Actris Artifact</h2>
<p>A version of Actris where Hoare triples prove deadlock and leak freedom.</p>
<p>This artifact contains Coq source code that proves the results in the paper “Deadlock-Free Separation Logic: Linearity Yields Progress for Dependent Higher-Order Message Passing”.</p>

},
keywords = {concurrency, deadlocks, message passing, Separation logic}
}

@software{10.5281/zenodo.8423335,
author = {DeYoung, Henry and Mordido, Andreia and Pfenning, Frank and Das, Ankush},
title = {Parametric Subtyping for Structural Parametric Polymorphism (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8423335},
abstract = {
    <p>This artifact consists of a Standard ML implementation of the parametric subtyping algorithm described in the POPL 2024 paper “Parametric Subtyping for Structural Parametric Polymorphism” by Henry DeYoung, Andreia Mordido, Frank Pfenning, and Ankush Das, as well as a file containing all of the examples from the paper. The up-to-date source code is maintained in a repository at https://bitbucket.org/structural-types/polyte/src/main/. For convenience, a VirtualBox VM image with the source code, necessary SML dependencies, and a pre-built binary is also available at https://zenodo.org/records/8423335.</p>

},
keywords = {parametric polymorphism, saturation-based algorithm, structural subtyping, type constructors}
}

@software{10.5281/zenodo.8423505,
author = {Patton, Noah and Rahmani, Kia and Missula, Meghana and Biswas, Joydeep and Dillig, I\c{s}\i{}l},
title = {Programming-by-Demonstration for Long-Horizon Robot Tasks},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8423505},
abstract = {
    <p>This artifact contains the source code for running the experiments in Programming-by-Demonstration for Long-Horizon Robot Tasks. We include scripts and a docker file to run the experiments as specified in the README.</p>

},
keywords = {Abstract Interpretation, Learning from Demonstrations, Program Synthesis}
}

@software{10.5281/zenodo.8423710,
author = {Peng, Yuxiang and Young, Jacob and Liu, Pengyu and Wu, Xiaodi},
title = {Artifact for SimuQ: a Framework for Programming Quantum Hamiltonian Simulation with Analog Compilation},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8423710},
abstract = {
    <p>This is the artifact for SimuQ, a framework for programming quantum Hamiltonian simulation with analog compilation. The main folder for the artifact evaluation is in <code>SimuQ/notebooks/artifact_evaluation</code>.</p>

},
keywords = {analog quantum computing, pulse-level programming, quantum simulation}
}

@software{10.5281/zenodo.8423764,
author = {Krishna, Shankaranarayanan and Lal, Aniket and Pavlogiannis, Andreas and Tuppe, Omkar},
title = {On-The-Fly Static Analysis via Dynamic Bidirected Dyck Reachability Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8423764},
abstract = {
    <p>Implementation of paper On-The-Fly Static Analysis via Dynamic Bidirected Dyck Reachability. The Dynamic Bidirected Dyck Reachability Tool accepts an initial graph and a sequence of update edge operations as input. It then calculates Bidirected Dyck reachability among nodes after executing the specified update operations on the initial graph.</p>

},
keywords = {CFL reachability, dynamic algorithms, static analysis}
}

@software{10.5281/zenodo.8423782,
author = {Frank, Justin and Quiring, Benjamin and Lampropoulos, Leonidas},
title = {Reproduction Package for Article `Generating Well-Typed Terms That Are Not “Useless”`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8423782},
abstract = {
    <p>The artifact includes the OCaml source code for the generator, the Coq proofs that the generation steps are well-typed, and the evaluation setup used to compare our generator with the Palka generator for finding bugs in GHC’s strictness analyzer.</p>

},
keywords = {property-based testing, test generation, well-typed lambda terms}
}

@software{10.5281/zenodo.8423903,
author = {Jayanti, Prasad and Jayanti, Siddhartha and Yavuz, Ugur Y. and Hernandez, Lizzie},
title = {Artifact for "A Universal, Sound, and Complete Forward Reasoning Technique for Machine-Verified Proofs of Linearizability", POPL 2024},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8423903},
abstract = {
    <p>This is the software artifact for the TLAPS proofs from the paper “A Universal, Sound, and Complete Forward Reasoning Technique for Machine-Verified Proofs of Linearizability” (POPL 2024). The artifact contains machine-verified proofs of the linearizability of the Herlihy-Wing queue and Jayanti’s single-scanner snapshot, and a proof of the strong linearizability of the Jayanti-Tarjan union-find object. All the proofs are by the ‘tracking method’ introduced in the paper and are verified in the TLA+ Proof System.</p>
<p>Details and instructions can be found in the README.md file within this Zenodo repository. The artifact is also available at the following GitHub repository: https://github.com/uguryavuz/machine-certified-linearizability.</p>

},
keywords = {linearizability, machine-verified, meta-configuration, queue, snapshot, strong linearizability, tracker method, union-find}
}

@software{10.5281/zenodo.8424490,
author = {Gregersen, Simon Oddershede and Aguirre, Alejandro and Haselwarter, Philipp G. and Tassarotti, Joseph and Birkedal, Lars},
title = {Asynchronous Probabilistic Couplings in Higher-Order Separation Logic - Coq Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8424490},
abstract = {
    <p>Coq artifact accompanying the paper “Asynchronous Probabilistic Couplings in Higher-Order Separation Logic”.</p>

},
keywords = {coq, iris, probabilistic, probabilistic coupling, separation logic}
}

@software{10.5281/zenodo.8424626,
author = {Ang, Zhendong and Mathur, Umang},
title = {Artefact for ``Predictive Monitoring against Pattern Regular Languages''},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8424626},
abstract = {
    <p>This artefact implements the predictive monitoring tool PatternTrack and the algorithm Bertoni described in our paper. We provide evaluation workflow in this artefact to demonstrate the bug-finding ability and the scalability of our tool PatternTrack.</p>

},
keywords = {concurrent system, dynamic analysis, predictive monitoring}
}

@software{10.5281/zenodo.8424750,
author = {Parreaux, Lionel and Boruch-Gruszecki, Aleksander and Fan, Andong and Chau, Chun Yin},
title = {When Subtyping Constraints Liberate: A Novel Type Inference Approach for First-Class Polymorphism (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8424750},
abstract = {
    <p>This is the artifact of our POPL 2024 paper entitled “When Subtyping Constraints Liberate: A Novel Type Inference Approach for First-Class Polymorphism”. You can find the latest version of the project at github.com/hkust-taco/superf and a web demo at hkust-taco.github.io/superf.</p>

},
keywords = {constraint solving, first-class polymorphism, subtyping, type inference}
}

@software{10.5281/zenodo.8424953,
author = {Heim, Philippe and Dimitrova, Rayna},
title = {Artifact of "Solving Infinite-State Games via Acceleration"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8424953},
abstract = {
    <p>This artifact contains the code and benchmarks for reproducing the results from the paper “Solving Infinite-State Games via Acceleration”.</p>

},
keywords = {infinite-duration games, infinite-state games, reactive synthesis}
}

@software{10.5281/zenodo.8425392,
author = {Zhang, Xing and Xie, Ruifeng and Guo, Guanchen and He, Xiao and Zan, Tao and Hu, Zhenjiang},
title = {Reproduction Package for Article 'Fusing Direct Manipulations into Functional Programs'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8425392},
abstract = {
    <p>Our paper (Fusing Direct Manipulations into Functional Programs) proposes a new operation-based framework for bidirectional live programming with a key technique that can fuse direct manipulations into general-purpose functional programs. The artifact FuseDM is a prototype tool to support our operation-based bidirectional live programming framework. As shown below, FuseDM supports developers not only to write functional programs on the left editor and get the output (i.e., SVG) on the right, but also to directly manipulate the output on the right, and automatically synchronize the left code to get the manipulated output. FuseDM offers a series of direct manipulations, as listed in Table 5 of our paper, to edit the output SVG graphics. We successfully designed 14 benchmark examples starting from blank code using direct manipulations supported by FuseDM.</p>

},
keywords = {Bidirectional Live Programming, Direct Manipulations, FuseDM}
}

@software{10.5281/zenodo.8425443,
author = {Elsman, Martin},
title = {Artifact for the POPL 2024 paper Explicit Effects and Effect Constraints in ReML},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8425443},
abstract = {
    <p>This artifact includes (1) a tutorial aiming at demonstrating the features of ReML presented in the POPL 2024 paper “Explicit Effects and Effect Constraints in ReML”, and (2) the source code for ReML, including a description of the implementation aspects of ReML. The artifact consists of a docker image containing a preinstalled version of the ReML compiler, demonstration programs, and the source code for ReML. The artifact establishes the following main claims mentioned in the paper:</p>
<ul>
<li><p>ReML has been implemented and syntactic constructs are available on top of Standard ML syntax to control the underlying region inference process.</p></li>
<li><p>A few larger ReML examples demonstrate how ReML can be used to reason about effects and in particular about the lack of allocation races (Mergesort, ray tracing, and Mandelbrot).</p></li>
</ul>

},
keywords = {Effect Systems, Memory Management, Parallelism, Region-inference}
}

@software{10.5281/zenodo.8425923,
author = {Atkey, Robert},
title = {Agda formalisation of Polynomial Time and Dependent Types},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8425923},
abstract = {
    <p>The Agda code formalising the construction of the realisability model described in Sections 5 and 6 of the paper. Please refer to the module names in the paper to find the relevant formalisations.</p>

},
keywords = {agda, formal proof}
}

@software{10.5281/zenodo.8425960,
author = {Borkowski, Michael H. and Vazou, Niki and Jhala, Ranjit},
title = {Artifact for "Mechanizing Refinement Types"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8425960},
abstract = {
    <p>Artifact containing the mechanized proofs for POPL 2024 paper “Mechanizing Refinement Types.”</p>

},
keywords = {Coq, LiquidHaskell, Mechanized metatheory}
}

@software{10.1145/3580429,
author = {Kudasov, Nikolai and Riehl, Emily and Weinberger, Jonathan},
title = {Reproduction package for "Formalizing the ∞-Categorical Yoneda Lemma"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580429},
abstract = {
    <p>Rzk formalization files source files (directory src/), configuration and generated HTML website (directory site/).</p>

},
keywords = {formalization, Rzk}
}

@software{10.1145/3580430,
author = {de Almeida Borges, Ana and González Bedmar, Mireia and Conejero Rodr\'{\i}guez, Juan and Hermo Reyes, Eduardo and Casals Bu\~{n}uel, Joaquim and Joosten, Joost J.},
title = {The FormalV Library},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580430},
abstract = {
    <p>The FormalV Library is the Coq/MathComp library developed in a public source-code setting by Formal Vindications S.L. Currently it includes three packages:</p>
<ul>
<li><p>FV Prim63 to MathComp provides conversions from the Coq primitive integers Uint63 and Sint63 to the MathComp natural and integer numbers nat and int, and vice versa, as well as lemmas to rewrite between their respective operations.</p></li>
<li><p>FV Check Range provides tactics to automatically prove Boolean goals involving 1, 2 or 3 Uint63.int/Sint63.int bounded variables through brute-force computation.</p></li>
<li><p>FV Time is a library for managing conversions between time formats (UTC and timestamps), as well as commonly used functions for time arithmetic. As a library for time conversions, its novelty is the implementation of leap seconds (which are part of the UTC standard but usually not implemented in commercial libraries).</p></li>
</ul>

},
keywords = {automation, Coq, formal verification, MathComp, time, UTC}
}

@software{10.5281/zenodo.10124427,
author = {Frumin, Dan and Timany, Amin and Birkedal, Lars},
title = {Coq formalization of Guarded Interaction Trees},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10124427},
abstract = {
    <p>This is the Coq formalization of guarded interaction trees, associated examples and case studies.</p>

},
keywords = {coq, formalization, separation logic}
}

@software{10.5281/zenodo.10366484,
author = {Zhao, Qiyuan and P\^{\i}rlea, George and Ang, Zhendong and Mathur, Umang and Sergey, Ilya},
title = {Artefact for Article 'Rooting for Efficiency: Mechanised Reasoning about Array-Based Trees in Separation Logic'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10366484},
abstract = {
    <p>This is the research artefact for the article Rooting for Efficiency: Mechanised Reasoning about Array-Based Trees in Separation Logic which has been accepted to 13th ACM SIGPLAN International Conference on Certified Programs and Proofs (CPP 2024). Please see the README.md file inside the zip archive for detailed instructions.</p>

},
keywords = {array-based trees, logical clocks, separation logic}
}

@software{10.5281/zenodo.8337004,
author = {Nguyen, Duc-Than and Beringer, Lennart and Mansky, William and Wang, Shengyi},
title = {Compositional Verification of Concurrent C Programs with Search Structure Templates (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8337004},
abstract = {
    <p>Files and virtual machine containing C and Coq code for verified implementations of binary search trees with concurrent search structure templates, as described in the paper.</p>

},
keywords = {concurrent separation logic, fine-grained locking, interactive theorem proving, Iris, logical atomicity, Verified Software Toolchain}
}

@software{10.5281/zenodo.8367154,
author = {Adjedj, Arthur and Lennon-Bertrand, Meven and Maillard, Kenji and P\'{e}drot, Pierre-Marie and Pujet, Lo\"{\i}c},
title = {Coq Formalisation for Article `Martin-L\"{o}f \`{a} la Coq`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8367154},
abstract = {
    <p>A mechanization of the meta-theory of Martin-L\"{o}f type theory, in Coq, using logical relations. Also contains an executable and certified type-checker. This mechanization is described in the CPP 24 article <em>Martin-L\"{o}f \`{a} la Coq</em>.</p>

},
keywords = {Bidirectional typing, Dependent type systems, Logical relations}
}

@software{10.5281/zenodo.8423866,
author = {Mansky, William and Du, Ke},
title = {VST on Iris},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8423866},
abstract = {
    <p>An Iris Instance for Verifying CompCert C Programs.</p>

},
keywords = {concurrent separation logic, interactive theorem
proving, Iris, program verification, software verification, Verified Software Toolchain}
}

@software{10.1145/3643873,
author = {Kelly, Terence},
title = {Source code for "Programmer Job Interviews"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3643873},
abstract = {
    <p>The tarball containing this README file provides several programs that illustrate different ways of solving the FIFO State Penitentiary problem discussed in my Drill Bits column on programmer job interview questions.  Read that column first.  This README file explains how the example programs work, how to compile and run them, and the insights we gain from implementing solutions --- insights that we might overlook if we merely design a solution without writing code.</p>
}
}

@software{10.5281/zenodo.10440364,
author = {Michelland, S\'{e}bastien and Deleuze, Christophe and Gonnord, Laure},
title = {Replication package for article: From low-level fault modeling (of a pipeline attack) to a proven hardening scheme},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10440364},
abstract = {
    <p>This software package is the Docker image of a project about protecting RISC-V processors against certain low-level fault attacks. It mainly contains a modified LLVM, GNU binutils, QEMU, and test scripts.</p>
<p>Project repository from which this image is built: https://gricad-gitlab.univ-grenoble-alpes.fr/michelse/fetch-skips-hardening</p>
<p>Instructions for using this software and reproducing results: https://gricad-gitlab.univ-grenoble-alpes.fr/michelse/fetch-skips-hardening/-/blob/main/README.md?ref_type=heads</p>

},
keywords = {Compilation, LLVM, Software fault resistance}
}

@software{10.5281/zenodo.10457086,
author = {Salvador Rohwedder, Caio and L. De Carvalho, Jo\~{a}o P. and Amaral, Jos\'{e} Nelson},
title = {Artifact of "Region-Based Data Layout via Data Reuse Analysis"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10457086},
abstract = {
    <ul>
<li>docker-artifact.tar.gz: docker image for the execution of experiments.</li>
<li>results.zip: log files, graphs, and tables that were used in the paper, as well as additional figures/tables not shown in the paper due to space constraints.</li>
<li>region-packing-pass.zip: source code for the out-of-tree LLVM implementation of the analysis that finds region-based data layout transformation candidates (.so file in docker image).</li>
<li>region-packing-scripts.zip: scripts used to run experiments and Dockerfile source (also provided in docker image).</li>
<li>artifact-appendix.pdf: Instructions on how to use this artifact.</li>
</ul>

},
keywords = {Data-Layout Transformation, LLVM, Structure Splitting}
}

@software{10.5281/zenodo.10464417,
author = {Nahian, Ahamed Al and Demsky, Brian},
title = {Artifact of CC 2024 Paper 'FlowProf: Profiling Multi-threaded Programs using Information-Flow'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10464417},
abstract = {
    <p>FlowProf is implemented as a SOOT compiler pass and instruments the bytecode of the application to be profiled. The input of FlowProf is multi-threaded Java application on which dynamic program analysis is performed. FlowProf has a lock profiler that detects lock contention. Then FlowProf performs full analysis for the most contended class. The FlowProf runtime records the execution of synchronized regions, records shared memory accesses, and tracks information flows. After running the instrumented program it performs analysis of the trace and reports waiting times of three different types of conflicts which is the output of FlowProf. The three different types of conflicts are: lock conflicts, memory access conflicts and information flow.</p>
<p>Finally we have optimized implementation of the benchmarks to see how much performance improvement can be achieved by performing the optimization.</p>

},
keywords = {Dynamic Program Analysis, Optimization, Profiling, Scalable Concurrency Control, Synchronization}
}

@software{10.5281/zenodo.10525151,
author = {Dura, Alexandru and Reichenbach, Christoph},
title = {Reproduction Package for 'Clog: A Declarative Language for C Static Code Checkers'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10525151},
abstract = {
    <p>Clog is a declarative language for describing static code checkers for C. Clog is a dialect of Datalog and adds syntactic pattern matching over the C language. We have built Clog using the MetaDL framework and the Clang C compiler frontend. The MetaDL framework supports Datalog evaluation and syntactic patterns, while the Clang frontend provides AST facts and an AST matching mechanism.</p>
<p>We provide the Clog artifact as a Docker image. The artifact contains the Clog implementation, the evaluation framework and the test suites we have used in our evaluation.</p>

},
keywords = {C, Datalog, Static Analysis Frameworks, Syntactic Patterns}
}

@software{10.5281/zenodo.10566216,
author = {Li, Wei and He, Dongjie and Gui, Yujiang and Chen, Wenguang and Xue, Jingling},
title = {Artifact for "A Context-Sensitive Pointer Analysis Framework for Rust and Its Application to Call Graph Construction"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10566216},
abstract = {
    <p>This is the artifact for the CC’24 paper titled “A Context-Sensitive Pointer Analysis Framework for Rust and Its Application to Call Graph Construction”. It includes a docker image and a READEME file.</p>

},
keywords = {Call Graph Construction, Pointer Analysis, Rust}
}

@software{10.5281/zenodo.10567311,
author = {Mavrogeorgis, Nikolaos and Vasiladiotis, Christos and Mu, Pei and Khordadi, Amir and Franke, Bj\"{o}rn and Barbalace, Antonio},
title = {Reproduction Package for Article 'UNIFICO: Thread Migration in Heterogeneous-ISA CPUs without State Transformation'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10567311},
abstract = {
    <p>Artifact of the paper “UNIFICO: Thread Migration in Heterogeneous-ISA CPUs without State Transformation”. - unificocc24-unifico.tar.gz: docker image for the execution of experiments - llvm-unifico.tar.gz: LLVM source code with Unifico implementation (binaries in docker image) - unifico.tar.gz: scripts used to run experiments, the NPB benchmark suite, logs, plots, and Dockerfile source (also provided in docker image)</p>
<ul>
<li>figures.tar.gz: generated result plots from the paper</li>
</ul>

},
keywords = {Compilers, Computer Systems, LLVM}
}

@software{10.5281/zenodo.10568392,
author = {Stinnett, J. Ryan and Kell, Stephen},
title = {Accurate Coverage Metrics for Compiler-Generated Debugging Information (artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10568392},
abstract = {
    <p>This is the artifact for the CC 2024 paper:</p>
<p>Accurate Coverage Metrics for Compiler-Generated Debugging Information</p>
<p>by J. Ryan Stinnett and Stephen Kell.</p>
<p>The source for this artifact is available at https://github.com/jryans/debug-info-metrics-artifact</p>

},
keywords = {debug information, optimisation}
}

@software{10.5281/zenodo.10570638,
author = {Zhu, Yifan and Cat, Quartic and Ge, Boluo and Sun, Shaotong},
title = {Paguroidea: Fused Parser Generator with Transparent Semantic Actions},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10570638},
abstract = {
    <p>This artifact provides source code and detailed guidance on building and benchmarking the Paguroidea parser generator. Paguroidea integrates lexer-parser fusion alongside a unique transparent encoding of semantic actions, delivering flexibility and performance. Developed using the Rust programming language, the Paguroidea enjoys good portability. Therefore, the setup process and the acquisition of results would not require too much effort.</p>

},
keywords = {compiler, context-free grammar, parser, parser generator, substructural logic}
}

@software{10.5281/zenodo.10571103,
author = {Drescher, Florian and Engelke, Alexis},
title = {Artifact for CC'24 paper on "Fast Template-Based Code Generation for MLIR"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10571103},
abstract = {
    <p>The artifact contains the sources for building the template-based MLIR compiler and the dependent LLVM sources (commit 5d4927 with some modifications). It compiles and executes MLIR programs consisting of supported operations (multiple sample programs are included; similar to mlir-cpu-runner); on first execution, it generates required templates and persists them. Furthermore, the artifact contains the modified sources for LingoDB with integrated template-based code-generation backend and Polygeist (commit fd4194b) for conversion of C files to MLIR upstream dialect operations. Sample MLIR programs and scripts for preparing/running the benchmarks from Figures 2-5 are attached.</p>

},
keywords = {Binary Code Patching, Fast Compilation, JIT Compilation, MLIR, Template-based Compilation}
}

@software{10.5281/zenodo.10574579,
author = {VenkataKeerthy, S. and Jain, Siddharth and Kalvakuntla, Umesh and Gorantla, Pranav Sai and Chitale, Rajiv Shailesh and Brevdo, Eugene and Cohen, Albert and Trofin, Mircea and Upadrasta, Ramakrishna},
title = {ML-Compiler-Bridge: The Next 700 ML-Enabled Compiler Optimizations},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10574579},
abstract = {
    <p>This artifact corresponds to the tool described in the paper, “The Next 700 ML-Enabled Compiler Optimizations”, published in CC 2024.</p>
<p>Please visit our project page - https://compilers.cse.iith.ac.in/publications/mlcompilerbridge for the latest version of ML-Compiler-Bridge.</p>

},
keywords = {Compilers, ML-based Compiler Optimizations}
}

@software{10.5281/zenodo.10577943,
author = {Mu, Pei and Mavrogeorgis, Nikolaos and Vasiladiotis, Christos and Tsoutsouras, Vasileios and Kaparounakis, Orestis and Stanley-Marbell, Phillip and Barbalace, Antonio},
title = {CoSense Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10577943},
abstract = {
    <p>The artifact of CoSense, which is a CC’2024 paper.</p>

},
keywords = {compiler optimizations, embedded systems, interval arithmetic, sensors, value interval propagation}
}

@software{10.1145/3580431,
author = {Lee, Edward and Zhao, Yaoyu and Lhot\'{a}k, Ond\v{r}ej and You, James and Satheeskumar, Kavin and Brachth\"{a}user, Jonathan Immanuel},
title = {Artifact for the OOPSLA 2024 paper ’Qualifying System F-sub’},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580431},
abstract = {
    <p>Mechanized proofs for the calculi described in the paper ’Qualifying System F-sub’.</p>

},
keywords = {Coq, Mechanized proofs, System F-sub-Q}
}

@software{10.1145/3580432,
author = {Lu, Kuang-Chen and Krishnamurthi, Shriram},
title = {Reproduction Package for Article `Identifying and Correcting Programming Language Behavior Misconceptions'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580432},
abstract = {
    <p>We claim in the paper (Section 7) that “we provide all the misinterpreters in the artifact.” To support this claim, this artifact provides the source code of all misinterpreters in ./Misinterpreters. In addition, we provide the source code of the reference interpreter ./Misinterpreters/smol-referential.rkt, which represents the correct conception. ./Misinterpreters contains a few other files:</p>
<ul>
<li>Metadata that makes the folder a Racket package: ./Misinterpreters/info.rkt</li>
<li>The definitions of AST and a parser (from S-expressions to AST): ./Misinterpreters/smol-syntax.rkt and ./Misinterpreters/parse.rkt</li>
<li>Shared helper functions for all (mis)interpreters: ./Misinterpreters/utilities.rkt</li>
</ul>
<p>We present statistical results in the paper. Though not promised in the paper, to support all those claims, this artifact also provides an R Markdown ./Paper.Rmd that computes (most of) the numbers, generates the figures, and performs the hypothesis tests. For numbers that cannot be computed, the R Markdown gives justification.</p>
<p>./Paper.Rmd depends on the ./SMoL Tutor folder, which includes</p>
<ul>
<li>Metadata about SMoL Tutor: ./SMoL Tutor/Tasks.csv and ./SMoL Tutor/Choices.csv</li>
<li>Data collected by SMoL Tutor: ./SMoL Tutor/Datasets/</li>
<li>A script that tags wrong answers with misinterpreters: ./SMoL Tutor/Tag_Answers.rkt</li>
</ul>

},
keywords = {automated interactive tutors, misconceptions, program behavior/semantics}
}

@software{10.5281/zenodo.10452601,
author = {Yuan, Charles and Villanyi, Agnes and Carbin, Michael},
title = {Artifact for Quantum Control Machine: The Limits of Control Flow in Quantum Programming},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10452601},
abstract = {
    <p>This artifact contains an implementation of a simulator for the quantum control machine and the programs from the case study as presented in the paper.</p>

},
keywords = {quantum instruction set architectures, quantum programming languages}
}

@software{10.5281/zenodo.10457566,
author = {Chatterjee, Krishnendu and Goharshady, Amir Kafshdar and Meggendorfer, Tobias and \v{Z}ikeli\'{c}, undefinedor\dj{}e},
title = {Artefact for: Quantitative Bounds on Resource Usage of Probabilistic Programs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10457566},
abstract = {
    <p>The artefact for the OOPSLA 2024 paper “Quantitative Bounds on Resource Usage of Probabilistic Programs”.</p>

},
keywords = {Cost Analysis, Martingales, Probabilistic Programming, Quantitative Bounds, Static Analysis}
}

@software{10.5281/zenodo.10463878,
author = {Yadavally, Aashish and Li, Yi and Wang, Shaohua and Nguyen, Tien N.},
title = {Artifact for "A Learning-Based Approach to Static Program Slicing"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10463878},
abstract = {
    <p>NS-Slicer is a learning-based static program slicing tool, which extends such an analysis to partial Java programs. The source code, data, and model artifacts are publicly available on GitHub (https://github.com/aashishyadavally/ns-slicer), and Zenodo (https://zenodo.org/records/10463878).</p>

},
keywords = {AI4SE, Debugging, Neural Networks, Pre-Trained Language Models, Static Slicing, Vulnerability Detection}
}

@software{10.5281/zenodo.10463907,
author = {Li, Zikun and Peng, Jinjun and Mei, Yixuan and Lin, Sina and Wu, Yi and Padon, Oded and Jia, Zhihao},
title = {Reproduction Package for "Quarl: A learning-based quantum circuit optimizer"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10463907},
abstract = {
    <p>This package contains the source code and instructions for the reproduction of the evaluation results in the paper “Quarl: A learning-based quantum circuit optimizer”.</p>

},
keywords = {Compilers, Quantum Computation, Reinforcement Learning}
}

@software{10.5281/zenodo.10463960,
author = {Nelson, Tim and Greenman, Ben and Prasad, Siddhartha and Dyer, Tristan and Bove, Ethan and Chen, Qianfan and Cutting, Charles and Del Vecchio, Thomas and LeVine, Sidney and Rudner, Julianne and Ryjikov, Ben and Varga, Alexander and Wagner, Andrew and West, Luke and Krishnamurthi, Shriram},
title = {Artifact for Forge: A Tool and Language for Teaching Formal Methods},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10463960},
abstract = {
    <p>The purpose of this artifact is to show that Forge works as advertised. To that end, we provide instructions for installing Forge (similar to what our students see), links to the documentation, and code from the paper.</p>

},
keywords = {formal-methods education, language levels, lightweight formal-methods}
}

@software{10.5281/zenodo.10464500,
author = {Liu, Jie and Zhao, Zhongyuan and Ding, Zijian and Brock, Benjamin and Rong, Hongbo and Zhang, Zhiru},
title = {Reproduction Package for Article `UniSparse: An Intermediate LanguageforGeneralSparseFormatCustomization'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10464500},
abstract = {
    <p>UniSparse is an intermediate language for general sparse format customization. UniSparse automates code generation for custom sparse format conversion and compute operations targeting heterogeneous architectures.</p>

},
keywords = {compilers, heterogeneous systems, programming languages, sparse data formats}
}

@software{10.5281/zenodo.10517828,
author = {Avanzini, Martin and Barthe, Gilles and Gr\'{e}goire, Benjamin and Moser, Georg and Vanoni, Gabriele},
title = {ehoare},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10517828},
abstract = {
    <p>This artifact provides a docker image that contains a working installation of Easycrypt together with three proof scripts related to the examples given in the paper.</p>
<ul>
<li><code>qselect.ec</code> contains the formalisation of quickselect from Section 3. It relies on an auxiliary library <code>partition.eca</code> concerned with properties of the partitioning scheme.</li>
<li><code>skip_list.ec</code> contains the formalisation of skip-lists outlined in Section 6</li>
<li><code>adversary.ec</code> contains the prototypical cryptography proof example outlined in Section 7</li>
</ul>

},
keywords = {expectation logic, skip list}
}

@software{10.5281/zenodo.10609061,
author = {Zhang, Chi and Wang, Linzhang and Rigger, Manuel},
title = {Artifact for "Finding Cross-rule Optimization Bugs in Datalog Engines"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10609061},
abstract = {
    <p>The artifact consists of two main components:</p>
<p>1、The source code of the tool Datalog Engine Optimization Tester (Deopt), which we used to find all of the bugs presented in our paper. 2、The data and reproduce documents for the results of the evaluation in the paper.</p>

},
keywords = {cross-rule optimization bugs, Datalog engine testing, test oracle}
}

@software{10.5281/zenodo.10701642,
author = {Ye, Qianchuan and Delaware, Benjamin},
title = {Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation: OOPSLA24 Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10701642},
abstract = {
    <p>This is the artifact for the OOPSLA24 paper “Taypsi: Static Enforcement of Privacy Policies for Policy-Agnostic Oblivious Computation”. It contains:</p>
<ul>
<li>README.md: artifact instructions in markdown format</li>
<li>README.pdf: artifact instructions in pdf format</li>
<li>taypsi-image-amd64.tar.xz: docker image for amd64 (x86_64) architecture</li>
<li>taypsi-image-arm64.tar.xz: docker image for arm64 architecture</li>
<li>Dockerfile: docker file used to generate the docker images</li>
<li>taypsi.tar.xz: source code of the Taypsi type checker, compiler, examples and benchmarks</li>
<li>taype-pldi.tar.xz: source code of the Taype type checker and compiler (PLDI23), extended with additional benchmarks for comparison with Taypsi</li>
<li>taype-sa.tar.xz: source code of a version of Taype with an additional optimization (smart array) for a fairer comparison with Taypsi</li>
<li>taype-drivers.tar.xz: source code of drivers that implement the cryptographic primitives and oblivious array, used by taypsi and taype-sa</li>
<li>taype-drivers-legacy.tar.xz: source code of the drivers used by taype-pldi</li>
<li>taypsi-theories.tar.xz: Coq formalization of the Taypsi core calculus</li>
<li>taype-vscode.tar.xz: source code of a VS Code extension that provides basic syntax highlighting for Taypsi programs</li>
</ul>
<p>To evaluate this artifact, you only need to download the docker image for your architecture. Other tarballs provide clean versions of the source code, but you do not need them for evaluation. See README.md / README.pdf for details about this artifact and evaluation instructions. The same README.md is also available in the docker images.</p>

},
keywords = {Algebraic Data types, Coq Proof Assistant, Dependent Types, Oblivious Computation, Secure Multiparty Computation}
}

@software{10.5281/zenodo.10723160,
author = {Naik, Aaditya and Stein, Adam and Wu, Yinjun and Naik, Mayur and Wong, Eric},
title = {Artifact for `TorchQL: A Programming Framework for Integrity Constraints in Machine Learning`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10723160},
abstract = {
    <p>This artifact contains the queries in the paper and reproduces the results. Follow the README.md file for more information.</p>

},
keywords = {integrity constraints, machine learning, query language}
}

@software{10.5281/zenodo.10727570,
author = {Honor\'{e}, Wolf and Qiu, Longfei and Kim, Yoonseung and Shin, Ji-Yong and Kim, Jieung and Shao, Zhong},
title = {Artifact For "AdoB: Bridging Benign and Byzantine Consensus with Atomic Distributed Objects"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10727570},
abstract = {
    <p>This artifact includes the Coq definitions and proofs to support the claims in the paper. It also includes the OCaml shim layer needed to evaluate the GenJolteon implementation.</p>

},
keywords = {byzantine, consensus protocols, distributed systems, formal verification, liveness, proof assistants, refinement}
}

@software{10.5281/zenodo.10774458,
author = {Sundram, Shiv and Tariq, Muhammad Usman and Kjolstad, Fredrik},
title = {Artifact for OOPSLA 2024 Paper: Compiling Recurrences over Dense and Sparse Arrays (version 1)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10774458},
abstract = {
    <p>This is a docker container containing the artifact for the OOPSLA 2024 accepted paper “Compiling Recurrences over Dense and Sparse Arrays” by Shiv Sundram, Muhammad Usman Tariq, Fredrik Kjolstad</p>
<p>Directions for running artifact and reproducing the paper’s figures can be found in the Getting Started Guide:</p>
<p>https://docs.google.com/document/d/1YCC8AskQYFQfUQ1_jtW2OOqWrT9-qpizTR4BUmbYBXQ/edit?usp=sharing</p>

},
keywords = {Domain specific languages, Recurrences, Software and its engineering, Source code generation}
}

@software{10.5281/zenodo.10775922,
author = {Chen, Zhe and Zhu, Yunlong and Wang, Zhemin},
title = {Reproduction Package for Article `Design and Implementation of an Aspect-Oriented C Programming Language'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10775922},
abstract = {
    <p>The artifact contains the Movec compiler for Aclang and all the benchmarks used in our experiments. The purpose of the artifact is to reproduce the experiments in Section 7 and support the main claims in the paper.</p>

},
keywords = {aspect-oriented programming, C language, compiler, instrumentation, semantics, transformation}
}

@software{10.5281/zenodo.10777503,
author = {Paradis, Anouk and Dekoninck, Jasper and Bichsel, Benjamin and Vechev, Martin},
title = {Reproduction Package for the Article "Synthetiq: Fast and Versatile Quantum Circuit Synthesis"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10777503},
abstract = {
    <p>This artifact contains the code for the paper ‘Synthetiq: Fast and Versatile Quantum Circuit Synthesis’. Synthetiq is a tool to synthesize quantum circuits implementing a given (partial) specification over arbitrary finite gate sets and is faster and more versatile than existing works.</p>
<p>This artifact contains: - the code of our tool Synthetiq and installation instructions; - precise instructions to reproduce our evaluation; - usage guide to use Synthetiq on new operators; - all quantum circuits found by Synthetiq and mentioned in the paper.</p>

},
keywords = {Clifford+T, Quantum Circuits, Synthesis}
}

@software{10.5281/zenodo.10779424,
author = {Binder, David and Skupin, Ingo and S\"{u}berkr\"{u}b, Tim and Ostermann, Klaus},
title = {Artifact for the article "Deriving Dependently-Typed OOP from First Principles"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10779424},
abstract = {
    <p>Contained in the artifact is a Rust implementation of a dependently-typed programming language. This implementation contains a typechecker as well as an LSP server, VScode plugin and the infrastructure necessary to produce a static website in which snippets from the programming language can be typechecked in the browser. The language server provides a code action which can transform any codata type into a data type using defunctionalization, and any data type into a codata type using refunctionalization.</p>

},
keywords = {algebraic data types, codata, defunctionalization, dependent types, refunctionalization}
}

@software{10.5281/zenodo.10780591,
author = {Li, Haonan and Hao, Yu and Zhai, Yizhuo and Qian, Zhiyun},
title = {Enhancing Static Analysis for Practical Bug Detection: An LLM-Integrated Approach (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10780591},
abstract = {
    <p>This repo contains all the code and test cases for the paper “Enhancing Static Analysis for Practical Bug Detection: An LLM-Integrated Approach”. LLift is an automated framework enhancing static analysis in bug detection with LLMs.</p>

},
keywords = {bug detection, large language model, Static analysis}
}

@software{10.5281/zenodo.10782412,
author = {Klinkenberg, Lutz and Blumenthal, Christian and Chen, Mingshuai and Haase, Darion and Katoen, Joost-Pieter},
title = {Exact Bayesian Inference for Loopy Probabilistic Programs using Generating Functions - Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10782412},
abstract = {
    <p>The artifact includes a Docker image with the Prodigy tool and program examples that were used for the benchmarks in the paper. It includes scripts and documentation to allow for easy replication of the presented benchmark results.</p>

},
keywords = {Bayesian inference, conditioning, denotational semantics, generating functions, non-termination, probabilistic programs, quantitative verification}
}

@software{10.5281/zenodo.10783906,
author = {Xu, Ziyang and Chon, Yebin and Su, Yian and Tan, Zujun and Apostolakis, Sotiris and Campanoni, Simone and August, David I.},
title = {Artifact for Paper "PROMPT: A Fast and Extensible Memory Profiling Framework"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10783906},
abstract = {
    <p>This repository contains the artifact evaluation for the PROMPT paper. PROMPT is a fast and extensible memory profiling framework.</p>

},
keywords = {compiler optimizations, memory profiling, profiler framework}
}

@software{10.5281/zenodo.10791709,
author = {Wang, Di and Reps, Thomas},
title = {Newtonian Program Analysis of Probabilistic Programs (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10791709},
abstract = {
    <p>This artifact provides a prototype implementation of the framework of Newtonian Program Analysis with Pre-Markov Algebras (NPA-PMA). NPA-PMA is an interprocedural dataflow-analysis framework for designing and implementing (partially) non-iterative program analyses of probabilistic programs with unstructured control-flow, nondeterminism, and general recursion. To demonstrate the usage of NPA-PMA, this artifact also includes five instantiations for four analyses: Bayesian-inference analysis, higher-moment analysis of accumulated rewards, expectation-invariant analysis, and expectation-recurrence analysis.</p>

},
keywords = {Algebraic Program Analysis, Interprocedural Program Analysis, Newton's Method, Probabilistic Programs}
}

@software{10.5281/zenodo.10794350,
author = {Smith, Scott and Zhang, Robert},
title = {Software Artifact for A Pure Demand Operational Semantics with Applications to Program Analysis},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10794350},
abstract = {
    <p>This artifact facilitates building, testing, benchmarking, and evolving the interpreter and program analyses presented in the paper.</p>

},
keywords = {Higher-Order Functional Programming, Operational Semantics, Program Analysis}
}

@software{10.5281/zenodo.10795614,
author = {He, Yang and Zhao, Pinhan and Wang, Xinyu and Wang, Yuepeng},
title = {Artifact Evaluation VeriEQL: Bounded Equivalence Verification for Complex SQL Queries with Integrity Constraints},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10795614},
abstract = {
    <p>The artifact aims to show that our claims and conclusions in the paper (VeriEQL: Bounded Equivalence Verification for Complex SQL Queries with Integrity Constraints) are well-founded and that others can reproduce the experimental results. It employs a SQL encoder and an SMT solver to encode and check equivalence of two SQL queries on relational schemas.</p>

},
keywords = {Equivalence Checking, Program Verification, Relational Databases}
}

@software{10.5281/zenodo.10796440,
author = {Alshnakat, Anoud and Lundberg, Didrik and Guanciale, Roberto and Dam, Mads},
title = {OOPSLA 2024 Artifact: HOL4P4: Mechanized Small-Step Semantics for P4},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10796440},
abstract = {
    <p>For a detailed description of this artifact, see OVERVIEW.md or OVERVIEW.pdf among the files.</p>
<p>HOL4P4-OOPSLA2024-source.tar.gz is a compressed directory with the source code, and hol4p4-amd64.tar.gz and hol4p4-aarch64.tar.gz are compressed Docker images for x86_64-based and ARM64-based CPUs, respectively.</p>

},
keywords = {formal verification, interactive theorem proving, P4, programming language semantics}
}

@software{10.5281/zenodo.10796555,
author = {Stjerna, Amanda and R\"{u}mmer, Philipp},
title = {Reproduction Package for `A Constraint Solving Approach to Parikh Images of Regular Languages'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10796555},
abstract = {
    <p>This is a reproduction and software package for A Constraint Solving Approach to Parikh Images of Regular Languages, published in OOPSLA 2024. For more information, see Artifact Overview.md.</p>
<p>It contains all software developed for the paper, as well as Jupyter notebooks for analysing experiments and relevant scripts for building them.</p>

},
keywords = {automata, automated theorem proving, parikh automata, parikh images, regular languages, SMT, string solving}
}

@software{10.5281/zenodo.10797459,
author = {Rose, Abhishek and Bansal, Sorav},
title = {Artifact for paper "Modeling Dynamic (De)Allocations of Local Memory for Translation Validation"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10797459},
abstract = {
    <p>This artifact contains a prototype implementation of the Dynamo algorithm described in the paper “Modeling Dynamic (De)Allocations of Local Memory for Translation Validation”. The artifact is packaged as a Docker application and is tested to run on Ubuntu 20.04 operating system. Please see README.pdf (packaged inside the archive) for more details.</p>

},
keywords = {Certified compilation, Equivalence checking, Translation validation}
}

@software{10.5281/zenodo.10797791,
author = {Marshall, Daniel and Orchard, Dominic},
title = {Functional Ownership through Fractional Uniqueness (Artefact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10797791},
abstract = {
    <p>Artifact for the paper of the same title that appears at OOPSLA 2024. Includes code examples in both Granule and Rust. See overview.pdf for more information.</p>

},
keywords = {borrowing, fractional permissions, graded modal types, ownership}
}

@software{10.5281/zenodo.10798266,
author = {Kravchuk-Kirilyuk, Anastasiya and Feng, Gary and Iskander, Jonas and Zhang, Yizhou and Amin, Nada},
title = {Persimmon: Nested Family Polymorphism with Extensible Variant Types (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10798266},
abstract = {
    <p>Our implementation consists of the Persimmon type checker and our prototype compiler to Scala.</p>

},
keywords = {composable extensions, extensibility, family polymorphism, nested inheritance, Persimmon}
}

@software{10.5281/zenodo.10798571,
author = {Crichton, Will and Krishnamurthi, Shriram},
title = {Artifact for "Profiling Programming Language Learning"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10798571},
abstract = {
    <p>These are Docker images that contain the codebase, data, and analysis scripts for our OOPSLA 2024 paper “Profiling Programming Language Learning”.</p>

},
keywords = {digital textbooks, item response theory, rust education}
}

@software{10.5281/zenodo.10798978,
author = {Lamba, Ada and Taylor, Max and Beardsley, Vincent and Bambeck, Jacob and Bond, Michael D. and Lin, Zhiqiang},
title = {Implementation for "Cocoon: Static Information Flow Control in Rust"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10798978},
abstract = {
    <p>Cocoon is a Rust library that provides types and mechanisms for statically enforcing information flow control in Rust programs. Cocoon is currently intended to prevent programmer errors such as accidentally leaking a “private” value to an untrusted function or other value. Cocoon does not currently address dynamic labels, integrity labels, OS integration, or leaks caused by other means such as side-channel attacks.</p>
<p>This artifact contains the Cocoon library itself, all examples presented in the paper, and evaluation scripts.</p>

},
keywords = {information flow control, Rust, type and effect systems}
}

@software{10.5281/zenodo.10814650,
author = {Enea, Constantin and Koskinen, Eric},
title = {CION: Concurrent Trace Reductions},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10814650},
abstract = {
    <p>A proof-of-concept implementation to automatically generate candidate layer quotient automata directly form the source code of concurrent object implementations. See f OOPSLA 2024 paper, “Scenario-Based Proofs for Concurrent Objects”.</p>

},
keywords = {concurrent objects, layer quotients, linearizability, proofs of concurrent objects, Quotients}
}

@software{10.5281/zenodo.10897277,
author = {Zhang, Yifan and Shi, Yuanfeng and Zhang, Xin},
title = {Learning Abstraction Selection for Bayesian Program Analysis (Paper Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10897277},
abstract = {
    <p>Our artifact includes all code, scripts, data, and statistics in our experiments. It supports the following things: 1. Reproduction of all results in our experiments automatically. 2. Transformation from the results to Tables 7-11 and Figures 8-10 in our paper automatically. 3. Reusability guide for applying BinGraph framework to other settings and extensions.</p>

},
keywords = {abstract interpretation, alarm ranking, Bayesian network, machine learning for program analysis, Static analysis}
}

@software{10.6084/m9.figshare.25365340.v1,
author = {Ryan, Gabriel and Cetin, Burcu and Lim, Yongwhan and Jana, Suman},
title = {HBFourier Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.25365340.v1},
abstract = {
    <p>Replication artifact for paper “Accurate Data Race Prediction in the Linux Kernel through Sparse Fourier Learning” to appear in OOPSLA 2024. The artifact contains HBFourier’s core implementation as a well as scripts for reproducing all results presented in the paper.</p>

},
keywords = {Data Race Prediction, Linux Kernel, Machine Learning, Spectral Method}
}

@software{10.1145/3672536,
author = {Kelly, Terence},
title = {Source code for "Zero Tolerance for Bias"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3672536},
abstract = {
    <p>The tarball containing this README file contains example code related to the problem of shuffling, i.e., randomly permuting a given set of items.  Compile and run the C programs in the obvious way after reading the source, noting any warnings in the comments.</p>
}
}

@software{10.1145/3580436,
author = {Miltenberger, Marc and Arzt, Steven},
title = {ValBench Replication Package},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580436},
abstract = {
    <p>This artifact contains the replication package for the ValBench evaluation numbers as well as the ValBench test suite itself. Furthermore, it contains the source code for COAL, JSA, StringHound, Violist and the Harvester results reader.</p>

},
keywords = {benchmark suite, string analysis, value analysis benchmark suite}
}

@software{10.5281/zenodo.10723168,
author = {Chatterjee, Krishnendu and Goharshady, Ehsan Kafshdar and Novotn\'{y}, Petr and \v{Z}ikeli\'{c}, undefinedor\dj{}e},
title = {Equivalence and Similarity Refutation for Probabilistic Programs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10723168},
abstract = {
    <p>This repository contains the artifact of the paper titled “Equivalence and Similarity Refutation for Probabilistic Programs” accepted at PLDI 2024.</p>
<p>The tool takes two probabilistic transition systems with specified initial configurations as input and based on user preferences either (i) tries to prove whether the two programs generate equivalent output distributions, or (ii) tries to find a lowerbound on Kantorovich distance between the output distributions of the input programs.</p>

},
keywords = {Kantorovich distance, Martingales, Probabilistic programming, Probability distribution equivalence, Static program analysis}
}

@software{10.5281/zenodo.10729070,
author = {Yuan, Charles and Carbin, Michael},
title = {The T-Complexity Costs of Error Correction for Control Flow in Quantum Computation},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10729070},
abstract = {
    <p>The artifact contains the sources for the Spire compiler, the benchmark programs and circuits used in the paper, and the evaluation package.</p>

},
keywords = {quantum compilers, quantum programming languages}
}

@software{10.5281/zenodo.10740687,
author = {Kakarla, Siva Kesava Reddy and Yan, Francis Y. and Beckett, Ryan},
title = {Source code for article "Diffy: Data-Driven Bug Finding for Configurations"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10740687},
abstract = {
    <p>Diffy is a push-button configuration analyzer that detects potential bugs in JSON configurations. It learns a common template from a set of similar configurations and uses unsupervised learning to identify anomalous template parameters as likely bugs.</p>
<p>We have used F# and C# as our programming languages and have provided instructions in our README on how to operate the tool.</p>
<p>In the paper, we used three datasets: - A large cloud provider’s wide-area network configurations - Operational configurations from a 5GvRAN network testbed - MySQL configurations</p>
<p>We have uploaded the 5GvRAN configurations and MySQL configurations to the repository under the examples directory. The majority of the evaluation section in the paper is based on the WAN configurations, which unfortunately, we cannot release publicly.</p>

},
keywords = {anomaly detection, configuration bug finding, template synthesis}
}

@software{10.5281/zenodo.10775789,
author = {Nikolaev, Ruslan and Ravindran, Binoy},
title = {A Family of Fast and Memory Efficient Lock- and Wait-Free Reclamation - Artifact for PLDI'24},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10775789},
abstract = {
    <p>The artifact contains a VM image (VirtualBox) with preinstalled Ubuntu 18.04 and the (precompiled) benchmark. The artifact also contains source code and instructions for manual (bare-metal) installations. The artifact also includes our data measurements and scripts for generating plots. Please see README.txt for more details.</p>

},
keywords = {hazard pointers, memory reclamation, wait-free}
}

@software{10.5281/zenodo.10781381,
author = {Fang, Wang and Ying, Mingsheng},
title = {Artifact: Symbolic Execution for Quantum Error Correction Programs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10781381},
abstract = {
    <p>We define QSE, a symbolic execution framework for quantum programs by integrating symbolic variables into quantum states and the outcomes of quantum measurements.&nbsp;The soundness of QSE is established through a theorem that ensures the correctness of symbolic execution within operational semantics.&nbsp;We further introduce symbolic stabilizer states, which symbolize the phases of stabilizer generators, for the efficient analysis of quantum error correction (QEC) programs.&nbsp;Within the QSE framework, we can use symbolic expressions to characterize the possible discrete Pauli errors in QEC, providing a significant improvement over existing methods that rely on sampling with simulators.&nbsp;We implement QSE &nbsp;with the support of symbolic stabilizer states in a prototype tool named QuantumSE.jl. Our experiments on representative QEC codes, including quantum repetition codes, Kitaev’s toric codes, and quantum Tanner codes, demonstrate the efficiency of QuantumSE.jl for debugging QEC programs with over 1000 qubits.&nbsp;In addition, by substituting concrete values in symbolic expressions of measurement results, QuantumSE.jl is also equipped with a sampling feature for stabilizer circuits.&nbsp;Despite a longer initialization time than the state-of-the-art stabilizer simulator, Google’s Stim, QuantumSE.jl offers a quicker sampling rate in the experiments.</p>

},
keywords = {quantum error correction, quantum programs, stabilizer formalism, symbolic execution}
}

@software{10.5281/zenodo.10783891,
author = {Jeon, Minseok and Park, Jihyeok and Oh, Hakjoo},
title = {PL4XGL: A Programming Language Approach to Explainable Graph Learning},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10783891},
abstract = {
    <p>This artifact aims to reproduce the main results of the technique PL4XGL on eleven node and graph classification datasets in our paper “PL4XGL: A Programming Language Approach to Explainable Graph Learning” submitted to PLDI 2024. Specifically, the artifact will reproduce the results of PL4XGL in Figure 11 (Sparsity and Fidelity), Table 5 (accuracy) in our paper, and Figure 2 (Precision and Generality) of our supplementary material. This artifact requires only Python 3.x (we used Python 3.8.8).</p>

},
keywords = {Domain-Specific Language, Graph Learning, Program Synthesis}
}

@software{10.5281/zenodo.10790231,
author = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter and Lindley, Sam},
title = {The Functional Essence of Imperative Binary Search Trees (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10790231},
abstract = {
    <p>Our artifact contains implementations of the binary search tree algorithms discussed in the paper in Koka, C, OCaml and Haskell as well as a benchmarking setup to reproduce our numbers. We also include the AddressC proofs of all lemmas in the paper.</p>

},
keywords = {FBIP, FIP, Splay Trees, Tail Recursion Modulo Cons, Zip Trees, Zippers}
}

@software{10.5281/zenodo.10795858,
author = {Hong, Jaemin and Ryu, Sukyoung},
title = {Don't Write, but Return: Replacing Output Parameters with Algebraic Data Types in C-to-Rust Translation (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10795858},
abstract = {
    <p>This artifact is for the paper Don’t Write, but Return: Replacing Output Parameters with Algebraic Data Types in C-to-Rust Translation. It introduces static analysis that identifies output parameters and program transformation that removes these parameters, enhancing automatic C-to-Rust translation. The tool, Nopcrat, which embodies the proposed method, is developed in Rust. Our evaluation dataset comprises 35 real-world C programs. You need the capability to run Docker containers, as the artifact is provided via a Docker image. To replicate the study’s results, a computer with at least 32 GB of RAM is necessary.</p>
<p>Nopcrat translates C code to Rust while replacing output parameters with Rust’s algebraic data types. It consists of four components: a modified version of the C2Rust translator, Extern2use, a static analyzer, and a code transformer. The translator translates C code to Rust. Extern2use replaces extern declarations in C2Rust-generated code with use. The analyzer analyzes the Rust code to identify output parameters and stores the information in a JSON file. The transformer removes output parameters in the Rust code using the analysis results.</p>
<p>The artifact supports the claims made in Section 5 of the paper by allowing the reproduction of the experimental results.</p>

},
keywords = {Algebraic Data Type, Automatic Translation, C, Output Parameter, Rust}
}

@software{10.5281/zenodo.10801691,
author = {Albert, Elvira and Garcia de la Banda, Maria and Hern\'{a}ndez-Cerezo, Alejandro and Ignatiev, Alexey and Rubio, Albert and Stuckey, Peter J.},
title = {Artifact for "SuperStack: Superoptimization of Stack-Bytecode via Greedy, Constraint-based, and SAT Techniques"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10801691},
abstract = {
    <p>This artifact includes the necessary data to reproduce the experiments in the paper “SuperStack: Superoptimization of Stack-Bytecode via Greedy, Constraint-based, and SAT Techniques,” accepted in PLDI’24.</p>

},
keywords = {EVM, Program Synthesis, SAT, Superoptimization, WebAssembly}
}

@software{10.5281/zenodo.10802176,
author = {Parthasarathy, Gaurav and Dardinier, Thibault and Bonneau, Benjamin and M\"{u}ller, Peter and Summers, Alexander J.},
title = {Towards Trustworthy Automated Program Verifiers: Formally Validating Translations into an Intermediate Verification Language -- Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10802176},
abstract = {
    <p>This artifact includes (1) a formalisation in the Isabelle theorem prover formalising the rules and definitions in the paper, (2) our proof-producing fork of the existing Viper-to-Boogie translation (implemented in Scala), which generates proofs in Isabelle on every run, and (3) the verifier test suites on which we evaluated our tool on as well as some of the corresponding verifiers (Gobra and VerCors) to generate the corresponding Viper files. The artifact describes the Isabelle formalisation and the proof-producing fork, and shows how to do the evaluation described in the paper. The entire artifact is packaged as a virtual machine using VirtualBox.</p>

},
keywords = {Boogie, Intermediate Verification Languages, Proof Certification, Viper}
}

@software{10.5281/zenodo.10802503,
author = {Lubin, Justin and Ferguson, Jeremy and Ye, Kevin and Yim, Jacob and Chasins, Sarah E.},
title = {Reproduction Package for "Equivalence by Canonicalization for Synthesis-Backed Refactoring"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10802503},
abstract = {
    <p>This artifact is a self-contained virtual machine for the artifact evaluation of the paper “Equivalence by Canonicalization for Synthesis-Backed Refactoring.” It includes our program synthesizer (Cobbler) as well as the data necessary for our empirical evaluation.</p>

},
keywords = {Program Equivalence Checking, Program Synthesis, Refactoring}
}

@software{10.5281/zenodo.10802748,
author = {Geng, Chujun and Blanas, Spyros and Bond, Michael D. and Wang, Yang},
title = {Reproduction Package for 'IsoPredict: Dynamic Predictive Analysis for Detecting Unserializable Behaviors in Weakly Isolated Data Store Applications'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10802748},
abstract = {
    <p>The artifact contains IsoPredict and its benchmarks. IsoPredict was written in Python and benchmarks were written in Java and Rust. The benchmarks generate traces that will be analyzed by IsoPredict. IsoPredict will perform both predictive analysis and validation. Everything will be provided as a docker container image. We recommend running them on a Linux machine with at least 16GB of RAM.</p>

},
keywords = {concurrency, database isolation levels, Dynamic predictive analysis, software debugging}
}

@software{10.5281/zenodo.10802849,
author = {Kellison, Ariel E. and Hsu, Justin},
title = {Artifact for Numerical Fuzz: A Type System for Rounding Error Analysis},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10802849},
abstract = {
    <p>This is the artifact for NumFuzz (“Numerical Fuzz”), a prototype implementation of the type system and floating-point error analysis tool described in the paper “Numerical Fuzz: A Type System for Rounding Error Analysis”.</p>

},
keywords = {Floating point, Linear type systems, Roundoff error}
}

@software{10.5281/zenodo.10804712,
author = {Anand, Aditya and Adithya, Solai and Rustagi, Swapnil and Seth, Priyam and Sundaresan, Vijay and Maier, Daryl and Nandivada, V. Krishna and Thakur, Manas},
title = {Optimistic Stack Allocation and Dynamic Heapification for Managed Runtimes},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10804712},
abstract = {
    <p>Artifact for PLDI 2024 paper title “Optimistic Stack Allocation and Dynamic Heapification for Managed Runtimes”.</p>

},
keywords = {Escape analysis, Managed runtimes, Stack allocation}
}

@software{10.5281/zenodo.10806044,
author = {Barri\`{e}re, Aur\`{e}le and Pit-Claudel, Cl\'{e}ment},
title = {Artifact for "Linear Matching of JavaScript Regular Expressions" at PLDI 2024},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10806044},
abstract = {
    <p>Description of artifact</p>
<p>The artifact consists of the source code and build scripts for our OCaml matchers; the patches that we wrote for V8; scripts to compute statistics on regex corpora; and the scripts to run our performance experiments and plot their results.</p>
<p>We have documented the directory structure of the OCaml matcher and the correspondence between the paper’s definitions and the source code in the OCaml matcher’s README in ocaml/allf/README.md. We recommend using this README as a guide to the OCaml code while reading the paper. Required hardware</p>
<p>We recommend running on an Ubuntu 22.04 LTS machine with at least 16GB of RAM. The VM is configured to use:</p>
<pre><code>12GB of RAM (to run experiments)
A CPU supporting the RDTSC instruction (for benchmarking)
40GB of free space on your hard drive (each V8 build takes ~12GB)</code></pre>

},
keywords = {Automata, JavaScript, Regex}
}

@software{10.5281/zenodo.10806323,
author = {Gruetter, Samuel and Fukala, Viktor and Chlipala, Adam},
title = {Code Artifact for Live Verification in an Interactive Proof Assistant},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10806323},
abstract = {
    <p>Code artifact submitted to Artifact Evaluation</p>

},
keywords = {interactive proof assistants, software verification, symbolic execution}
}

@software{10.5281/zenodo.10806686,
author = {Zhou, Zhe and Ye, Qianchuan and Delaware, Benjamin and Jagannathan, Suresh},
title = {PLDI2024 Artifact: A HAT Trick: Automatically Verifying Representation Invariants Using Symbolic Finite Automata},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10806686},
abstract = {
    <p>This artifact contains:</p>
<ol type="1">
<li>README.md : the artifact guide.</li>
<li>marple-original-submission.pdf: the original submitted paper.</li>
<li>marple:pldi-2024.tar.gz: the docker image (optional, we recommend to pull from the docker hub, see README.md).</li>
<li>Dockerfile: the docker file that can reproduce the docker image (optional, we recommend to pull from the docker hub, see README.md).</li>
</ol>

},
keywords = {refinement types, representation invariants, symbolic finite automata}
}

@software{10.5281/zenodo.10806719,
author = {Rivera, Joao and Franchetti, Franz and P\"{u}schel, Markus},
title = {Artifact: Floating-Point TVPI Abstract Domain},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10806719},
abstract = {
    <p>Artifact for the paper “Floating-Point TVPI Abstract Domain” at PLDI 2024. The artifact comes in the form of a virtual machine running Ubuntu 20.04. It contains the full source code of TVPI-FP, and benchmarks and scripts for reproducing main experiments.</p>

},
keywords = {abstract interpretation, numerical program analysis}
}

@software{10.5281/zenodo.10806736,
author = {Jung, Jaehwang and Kim, Jeonghyeon and Parkinson, Matthew J. and Kang, Jeehoon},
title = {Artifact for "Concurrent Immediate Reference Counting"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10806736},
abstract = {
    <p>This is the artifact for PLDI 2024 paper: “Concurrent Immediate Reference Counting”.</p>
<p>This artifact comprises the following files:</p>
<ul>
<li><code>circ-benchmark.zip</code>: This archive mainly contains a benchmark suite used to produce the results presented in the paper. Additionally, it contains:
<ul>
<li><code>README.md</code>: instructions on how to reproduce the benchmark results, and</li>
<li><code>paper-results</code>: generated result files that are included in the paper.</li>
</ul></li>
<li><code>circ-docker.tar.gz</code>: This file is a pre-built Docker image for conveniently running the benchmark.</li>
</ul>
<p>Refer to the README.md in the attached file for more information on this artifact.</p>

},
keywords = {automatic memory reclamation, concurrent data structures, reference counting}
}

@software{10.5281/zenodo.10806763,
author = {Liu, Jiawen and Qu, Weihao and Gaboardi, Marco and Garg, Deepak and Ullman, Jonathan},
title = {Adaptfun: Program analysis for Adaptive analysis},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10806763},
abstract = {
    <p>The software of program anlaysis tool Adaptfun, which provides the estimated upper bound on the adaptivity of adaptive data analysis algorithms. The tool is implemened using OCaml and Python. The reuslts are also evaluated in Python.</p>

},
keywords = {Adaptive data analysis, dependency graph, program analysis}
}

@software{10.5281/zenodo.10807084,
author = {Erbsen, Andres and Philipoom, Jade and Jamner, Dustin and Lin, Ashley and Gruetter, Samuel and Pit-Claudel, Cl\'{e}ment and Chlipala, Adam},
title = {Proof Artifact for `Foundational Integration Verification of a Cryptographic Server'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10807084},
abstract = {
    <p>This is the computer-checked-proof artifact for `Foundational Integration Verification of a Cryptographic Server’. It contains the component proofs, integration proofs, and software for checking them, supporting all verification claims in the paper. Static quantiative-evaluation claims about memory usage are also supported by these proofs.</p>

},
keywords = {bare-metal programming, elliptic-curve cryptography, proof assistants}
}

@software{10.5281/zenodo.10807169,
author = {Youn, Dongjun and Shin, Wonho and Lee, Jaehyun and Ryu, Sukyoung and Breitner, Joachim and Gardner, Philippa and Lindley, Sam and Pretnar, Matija and Rao, Xiaojia and Watt, Conrad and Rossberg, Andreas},
title = {Artifact for "Bringing the WebAssembly Standard up to Speed with SpecTec"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10807169},
abstract = {
    <p>Artifact for “Bringing the WebAssembly Standard up to Speed with SpecTec”, containing the source code and evaluation results.</p>

},
keywords = {DSL, executable prose, language specification, WebAssembly}
}

@software{10.5281/zenodo.10807175,
author = {Sharma, Ritvik and Achour, Sara},
title = {DARE Qutrit Compiler},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10807175},
abstract = {
    <p>This contains all code required to regenerate results of Compilation of Qubit Circuits to Optimized Qutrit Circuits and use the DARE compiler.</p>

},
keywords = {Quantum computing, Qutrits, Rewriting Tools, Synthesis}
}

@software{10.5281/zenodo.10807316,
author = {Banerjee, Debangshu and Xu, Changming and Singh, Gagandeep},
title = {Input-Relational Verification of Deep Neural Networks},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10807316},
abstract = {
    <p>We consider the verification of input-relational properties defined over deep neural networks (DNNs) such as robustness against universal adversarial perturbations, monotonicity, etc. Precise verification of these properties requires reasoning about multiple executions of the same DNN. We introduce a novel concept of difference tracking to compute the difference between the outputs of two executions of the same DNN at all layers. We design a new abstract domain, DiffPoly for efficient difference tracking that can scale large DNNs. DiffPoly is equipped with custom abstract transformers for common activation functions (ReLU, Tanh, Sigmoid, etc.) and affine layers and can create precise linear cross-execution constraints. We implement a input-relational verifier for DNNs called RaVeN which uses DiffPoly and linear program formulations to handle a wide range of input-relational properties. Our experimental results on challenging benchmarks show that by leveraging precise linear constraints defined over multiple executions of the DNN, RaVeN gains substantial precision over baselines on a wide range of datasets, networks, and input-relational properties.</p>

},
keywords = {Abstract Interpretation, Deep Learning, Relational Verification}
}

@software{10.5281/zenodo.10808233,
author = {Herklotz, Yann and Wickerson, John},
title = {Artefact: Hyperblock Scheduling for Verified High-Level Synthesis},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10808233},
abstract = {
    <p>Artefact of the implementation and verification of hyperblock scheduling on top of an existing verified high-level synthesis tool called Vericert. The artefact includes a VM with all software pre-installed to reproduce the results of the paper. The instructions can be found in README.pdf and README.md.</p>

},
keywords = {CompCert, Coq, operation chaining, symbolic evaluation, translation validation}
}

@software{10.5281/zenodo.10808236,
author = {Dardinier, Thibault and M\"{u}ller, Peter},
title = {Hyper Hoare Logic: (Dis-)Proving Program Hyperproperties (artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10808236},
abstract = {
    <p>This artifact supports the PLDI 2024 paper “Hyper Hoare Logic: (Dis-)Proving Program Hyperproperties”. It consists of an Isabelle/HOL mechanization that fully supports the formal claims made in the paper and a VirtualBox VM image with Ubuntu 22.04 that contains Isabelle 2023 and our mechanization.</p>

},
keywords = {Compositionality, Hoare Logic, Hyper Hoare Logic, Hyperproperties, Incorrectness Logic, Isabelle, Program Logic}
}

@software{10.5281/zenodo.10808465,
author = {Theodoridis, Theodoros and Su, Zhendong},
title = {PLDI 2024 Artifact for "Refined Input, Degraded Output: The Counterintuitive World of Compiler Behavior"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10808465},
abstract = {
    <p>Ths artifact consists of a docker image with instructions, the dataset, and the code necessary to reproduce the evaluation of Refined Input, Degraded Output: The Counterintuitive World of Compiler Behavior PLDI 2024.</p>

},
keywords = {automated compiler testing, missed compiler optimizations}
}

@software{10.5281/zenodo.10892762,
author = {Ball, Thomas and de Halleux, Peli and Devine, James and Hodges, Steve and Moskal, Micha\l{}},
title = {Jacdac: Service-based Prototyping of Embedded Systems (PLDI 2024 Artifact Evaluation)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10892762},
abstract = {
    <p>This artifact allows others to reproduce and explore the results seen in “Jacdac: Service-based Prototyping of Embedded Systems”. The artifact contains a prebuilt docker image and the Dockerfile source used to produce the prebuilt docker image. Evaluators should follow the README contained in this artifact for complete instruction.</p>

},
keywords = {embedded systems, microcontrollers, plug-and-play, services}
}

@software{10.5281/zenodo.10892936,
author = {Lei, Yuxiang and Bossut, Camille and Sui, Yulei and Zhang, Qirun},
title = {Artifact of "Context-Free Language Reachability via Skewed Tabulation"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10892936},
abstract = {
    <p>This is the artifact of the paper “Context-Free Language Reachability via Skewed Tabulation” accepted to PLDI 2024. The artifact is packaged as a Docker image “cflskewed.tar.gz”, which is to reproduce the experiment results of the paper.</p>

},
keywords = {CFL-reachability, performance, tabulation schemes}
}

@software{10.5281/zenodo.10895582,
author = {Lesbre, Dorian and Lemerre, Matthieu},
title = {Artifact for paper "Compiling with abstract interpretation"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10895582},
abstract = {
    <p>This is an artifact for the paper Compiling with Abstract Interpretation, submitted at PLDI 2024. It contains two abstract interpreters:</p>
<pre><code>TAI, very simple frama-c plugin that closely follows the paper definitions, but only supports a small subset of C (only integer variables, macro, and non-recursive function calls). It is used to demonstrate our technique but isn't very time or memory efficient.

It's a frama-c plugin but only uses frama-c as a C parser, so no knowledge of frama-c is required to understand it.

Codex: a much larger abstract interpretation library. It supports every aspect of C (as a frama-c plugin) and a number of binary formats (as a binsec plugin). This library implements many techniques and domains beyond the scope of the paper, but some ideas from our paper such as translation to SSA as an abstract interpretation pass have made it into its codebase.</code></pre>

},
keywords = {Abstract Interpretation, Compilation, Frama-C, OCaml, SSA}
}

@software{10.5281/zenodo.10895770,
author = {Mikek, Benjamin and Zhang, Qirun},
title = {STAUB: SMT Theory Arbitrage from Unbounded to Bounded},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10895770},
abstract = {
    <p>Implementation of STAUB in C++ and experimental data reflecting STAUB’s effectiveness in speeding up SMT solving for unbounded constraints.</p>

},
keywords = {abstract interpretation, constraint solving, SMT}
}

@software{10.5281/zenodo.10897200,
author = {Wang, Peixin and Yang, Tengshun and Fu, Hongfei and Li, Guanyan and Ong, C.-H. Luke},
title = {Updated Artifact for "Static Posterior Inference of Bayesian Probabilistic Programming via Polynomial Solving"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10897200},
abstract = {
    <p>This is the artifact for the paper “Static Posterior Inference of Bayesian Probabilistic Programming via Polynomial Solving”, which aims to derive guaranteed bounds for the normalised posterior distribution (NPD) over probabilistic programs.</p>

},
keywords = {F#, Matlab, Mosek}
}

@software{10.5281/zenodo.10901544,
author = {Garg, Poorva and Holtzen, Steven and Van den Broeck, Guy and Millstein, Todd},
title = {Reproduction Package for Article "Bit Blasting Probabilistic Programs"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10901544},
abstract = {
    <p>The artifact consists of implementation of HyBit, a probabilistic programming system based on bit blasting. It scales inference for hybrid probabilistic programs with respect to the discrete structure. The artifact also consists of all the necessary scripts to reproduce the experiment in the article “Bit Blasting Probabilistic Programs”.</p>

},
keywords = {bit blasting, discretization, probabilistic inference, probabilistic programming system}
}

@software{10.5281/zenodo.10901598,
author = {Wang, Ziteng and Pailoor, Shankara and Prakash, Aaryan and Wang, Yuepeng and Dillig, I\c{s}\i{}l},
title = {Software Artifact for `From Batch to Stream: Automatic Generation of Online Algorithms'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10901598},
abstract = {
    <p>Opera is written in Python using both Poetry and Nix for managing dependencies. A recent installation of Nix (version 2.18.1 or higher) is the only prerequisite to get started. Additionally, we offer a Docker-based solution for running Nix.</p>

},
keywords = {Incremental Computation, Online Algorithms, Program Synthesis, Stream Processing}
}

@software{10.5281/zenodo.10906088,
author = {Fitzgibbons, Michael and Paraskevopoulou, Zoe and Mushtak, Noble and Thalakottur, Michelle and Sulaiman Manzur, Jose and Ahmed, Amal},
title = {RichWasm Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10906088},
abstract = {
    <p>This artifact is a self-contained environment to reproduce the claims in the PLDI’24 paper “RichWasm: Bringing Safe, Fine-Grained, Shared-Memory Interoperability Down to WebAssembly”. This artifact contains, a mechanized proof of RichWasm’s type safety, compilers from ML and L3 to RIchWasm, an annotator and type checker for RichWasm code and a compiler from RichWasm to WebAssembly. This artifact can be used to compile the proofs, use the various compilers and run and inspect their tests.</p>

},
keywords = {RichWasm, Type-Preserving Compilation, WebAssembly}
}

@software{10.5281/zenodo.10906216,
author = {Laird, Avery and Liu, Bangtian and Bj\o{}rner, Nikolaj and Dehnavi, Maryam Mehri},
title = {SpEQ: Translation of Sparse Codes using Equivalences},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10906216},
abstract = {
    <p>Software to replicate the results of “SpEQ: Translation of Sparse Codes using Equivalences.”</p>

},
keywords = {Equality Saturation, Equivalence Checking, Program Analysis, Verification}
}

@software{10.5281/zenodo.10906305,
author = {Jang, Minseong and Rhee, Jungin and Lee, Woojin and Zhao, Shuangshuang and Kang, Jeehoon},
title = {Modular Hardware Design of Pipelined Circuits with Hazards},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10906305},
abstract = {
    <p>This is the <strong>Modular Hardware Design of Pipelined Circuits with Hazards</strong> paper artifact submitted for evaluation of the 45th ACM SIGPLAN conference on Programming Language Design and Implementation (PLDI`24).</p>
<p>It contains two files:</p>
<ul>
<li><code>hazardflow-artifact-pldi2024.zip</code>: Repository of the artifacts. Follow the README inside to reproduce the results.</li>
<li><code>artifact_evaluation_latest.tar.gz</code>: Docker image to run the CPU experiments.</li>
</ul>

},
keywords = {Functional Hardware Description, HazardFlow, PLDI24}
}

@software{10.5281/zenodo.10909272,
author = {Qiu, Longfei and Kim, Yoonseung and Shin, Ji-Yong and Kim, Jieung and Honor\'{e}, Wolf and Shao, Zhong},
title = {Artifact for PLDI 2024 paper #290: LiDO: Linearizable Byzantine Distributed Objects with Refinement-Based Liveness Proofs.},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10909272},
abstract = {
    <p>This is artifact for PLDI 2024 paper #290: LiDO: Linearizable Byzantine Distributed Objects with Refinement-Based Liveness Proofs.</p>
<p>Included files are the LiDO model formalized in Coq, together with three implementations of LiDO (unpipelined Jolteon, unpipelined Jolteon with improved pacemaker, and pipelined Jolteon), each having safety and liveness proofs.</p>
<p>See README.md inside artifact package for more details.</p>

},
keywords = {byzantine fault-tolerance, consensus protocols, distributed systems, formal verification, liveness, proof assistants, refinement, safety}
}

@software{10.5281/zenodo.10909730,
author = {Buckley, Anita and Chuprikov, Pavel and Otoni, Rodrigo and Soul\'{e}, Robert and Rand, Robert and Eugster, Patrick},
title = {Artifact for the article An Algebraic Language for Specifying Quantum Networks},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10909730},
abstract = {
    <p>The artifact is a Haskell library bellkat plus several examples provided as executables within the same Haskell package.</p>

},
keywords = {entanglement, Kleene algebra, quantum networks}
}

@software{10.5281/zenodo.10910395,
author = {Jiang, Hanru},
title = {Artifact for PLDI' 24 submission #350 "Qubit Recycling Revisited"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10910395},
abstract = {
    <p>This is the artifact of PLDI’24 submission #350 “Qubit Recycling Revisited”, containing a certified prototype qubit recycler featuring various heuristics reported in the paper, and a subset of RevLib circuits for evaluation purpose. It is provided to reproduce the results of Sec. 7, and to check the mechanized proof of Theorem6.8. It also comes with a Docker image with the experimental environment setup, to make this artifact cross-platform.</p>

},
keywords = {Certified Compilation, Quantum Circuit Optimization}
}

@software{10.5281/zenodo.10912439,
author = {G\"{a}her, Lennard and Sammler, Michael and Jung, Ralf and Krebbers, Robbert and Dreyer, Derek},
title = {Artifact for "RefinedRust: A Type System for High-Assurance Verification of Rust Programs"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10912439},
abstract = {
    <p>This is the artifact for the PLDI’24 paper “RefinedRust: A Type System for High-Assurance Verification of Rust Programs”. It contains the implementation of RefinedRust and Coq development formalizing the results of the paper.</p>

},
keywords = {Iris, program verification, Rust, separation logic}
}

@software{10.5281/zenodo.10918754,
author = {Jia, Xiaodong and Tan, Gang},
title = {V-Star Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10918754},
abstract = {
    <p>This artifact includes the V-Star library, detailed instructions, and a Docker image file necessary to reproduce the results presented in Table 1 of the paper V-Star: Learning Visibly Pushdown Grammars from Program Inputs.</p>

},
keywords = {artifact, grammar inference, v-star, visibly pushdown grammars}
}

@software{10.5281/zenodo.10925596,
author = {Svyatlovskiy, Mikhail and Mermelstein, Shai and Lahav, Ori},
title = {Coq Mechanization for "Compositional Semantics for Shared-Variable Concurrency" (PLDI 2024)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10925596},
abstract = {
    <p>Coq mechanization for the paper “Compositional Semantics for Shared-Variable Concurrency” (PLDI 2024)</p>

},
keywords = {Compiler Optimizations, Concurrency, Denotational Semantics, Shared-Memory}
}

@software{10.5281/zenodo.10930752,
author = {Laursen, Mathias Rud and Xu, Wenyuan and M\o{}ller, Anders},
title = {Artifact for "Reducing Static Analysis Unsoundness with Approximate Interpretation", PLDI 2024},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10930752},
abstract = {
    <p>This artifact consists of a VirtualBox image that contains program code and experimental data for the paper Reducing Static Analysis Unsoundness with Approximate Interpretation by Mathias Rud Laursen, Wenyuan Xu and Anders M\o{}ller, PLDI 2024.</p>

},
keywords = {call graphs, JavaScript, points-to analysis, program analysis}
}

@software{10.5281/zenodo.10932109,
author = {Liu, Amanda and Bernstein, Gilbert and Chlipala, Adam and Ragan-Kelley, Jonathan},
title = {A Verified Compiler for a Functional Tensor Language},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10932109},
abstract = {
    <p>Virtual machine for AEC PLDI 2024. This contains the source for the ATL language, its verified rewrite framework, and the proof of correctness for its lowering algorithm embedded and implemented in Coq.</p>

},
keywords = {array programming, formal verification, functional programming, tensors, type systems}
}

@software{10.5281/zenodo.10932590,
author = {Lutze, Matthew and Madsen, Magnus},
title = {Associated Effects (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10932590},
abstract = {
    <p>This artifact contains a Flix compiler, modified to support associated effects, as detailed in the paper. The artifact includes example files from the standard library, accessible in a QEMU virtual machine, in order to allow browsing files using Flix’s VSCode extension.</p>

},
keywords = {ad-hoc polymorphism, associated effects, associated types, effect systems, generic programming, type classes, type functions}
}

@software{10.5281/zenodo.10933110,
author = {Chen, Tianyu and Siek, Jeremy G.},
title = {Agda code for 'Quest Complete: The Holy Grail of Gradual Security'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10933110},
abstract = {
    <p>The artifact contains Agda code of the definitions and proofs in the paper ‘Quest Complete: The Holy Grail of Gradual Security’.</p>

},
keywords = {Agda, gradual typing, information flow security, machine-checked proofs}
}

@software{10.5281/zenodo.10933398,
author = {Park, Sunho and Kim, Jaewoo and Mulder, Ike and Jung, Jaehwang and Lee, Janggun and Krebbers, Robbert and Kang, Jeehoon},
title = {Artifact for "A Proof Recipe for Linearizability in Relaxed Memory Separation Logic", PLDI 2024},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10933398},
abstract = {
    <p>This is the formalization for the paper “A Proof Recipe for Linearizability in Relaxed Memory Separation Logic”, written in Coq, along with a Docker image file (<code>artifact.tar.gz</code>) that contains a compiled version of the project and all dependencies installed.</p>
<p>Detailed instructions and explanations are written in the README.md inside <code>pldi24-36-artifact.zip</code>.</p>

},
keywords = {automation, linearizability, relaxed memory, separation logic}
}

@software{10.5281/zenodo.10935596,
author = {Becker, McCoy R. and Lew, Alexander K. and Wang, Xiaoyan and Ghavami, Matin and Huot, Mathieu and Rinard, Martin C. and Mansinghka, Vikash K.},
title = {Reproduction Packager for Article "Probabilistic Programming with Programmable Variational Inference"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10935596},
abstract = {
    <p>A package which contains the JAX implementation that accompanies the paper “Probabilistic Programming with Programmable Variational Inference”, as well as the experiments used to generate figures and numbers in the empirical evaluation section.</p>

},
keywords = {automatic differentiation, probabilistic programming, variational inference}
}

@software{10.5281/zenodo.10936488,
author = {Ferreira, Mafalda and Monteiro, Miguel and Brito, Tiago and Coimbra, Miguel E. and Santos, Nuno and Jia, Limin and Santos, Jos\'{e} Fragoso},
title = {Artifact for paper "Efficient Static Vulnerability Analysis for JavaScript with Multiversion Dependency Graphs"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10936488},
abstract = {
    <p>This artifact evaluates Graph.js, a novel static vulnerability detection tool for Node.js applications, that detects taint-style and prototype pollution vulnerabilities. The repository includes all source code, reference datasets and instructions on how to build and run the experiments. These experiments result in the tables and plots presented in the paper, which can be used to validate the results.</p>

},
keywords = {JavaScript, Static Analysis, Vulnerability Detection}
}

@software{10.5281/zenodo.10937074,
author = {Pham, Long and Saad, Feras A. and Hoffmann, Jan},
title = {Hybrid Resource-Aware ML},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10937074},
abstract = {
    <p>Hybrid Resource-Aware ML (Hybrid RaML) is a program analysis tool that takes in an OCaml program and infers its polynomial cost bound using the technique Hybrid Automatic Amortized Resource Analysis (AARA). It integrates data-driven resource analysis (specifically linear programming and Bayesian inference) and static resource analysis (specifically the conventional AARA). Hybrid RaML is wrapped inside a Docker image, and it comes with (i) a guide README.pdf describing how to use run the software and (ii) a paper paper.pdf describing Hybrid AARA.</p>

},
keywords = {Bayesian inference, data-driven analysis, hybrid analysis, program analysis, resource analysis, static analysis, type systems, worst-case costs}
}

@software{10.5281/zenodo.10937816,
author = {Matute, Gabriel and Ni, Wode and Barik, Titus and Cheung, Alvin and Chasins, Sarah E.},
title = {Syntactic Code Search with Sequence-to-Tree Matching},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10937816},
abstract = {
    <p>A docker image <code>stbench</code> to evaluate our tool <code>stsearch</code>, under <code>/artifact</code> we include: * <code>stsearch</code>, the Rust source code (together with a release build) of our tool; * <code>queries</code>, the Semgrep rules used to curate our real-world query benchmark; * <code>corpus</code>, the Javascript corpus (scrapped from <code>npm</code>) to search over; and * <code>stbench</code>, a Python package to collect and analyze matches.</p>

},
keywords = {Code Search, Syntactic Analysis, Tree Wildcards}
}

@software{10.5281/zenodo.10940320,
author = {Spies, Simon and G\"{a}her, Lennard and Sammler, Michael and Dreyer, Derek},
title = {Artifact and Appendix for Quiver: Guided Abductive Inference of Separation Logic Specifications in Coq},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10940320},
abstract = {
    <p>This is the artifact for “Quiver: Guided Abductive Inference of Separation Logic Specifications in Coq”, submitted to PLDI 2024. It consists of a Coq implementation of a new specification inference technique in separation logic introduced in the paper.</p>

},
keywords = {abduction, Coq, functional correctness, Iris, specification inference}
}

@software{10.5281/zenodo.10948026,
author = {Ketkar, Ameya and Ramos, Daniel and Clapp, Lazaro and Barik, Raj and Ramanathan, Murali Krishna},
title = {Replication of A Lightweight Polyglot Code Transformation Language},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10948026},
abstract = {
    <p>The artifact contains the necessary instructions to replicate part of the experiments in the paper. It also provides with users with an environment to run our tool.</p>
<p>Detailed instructions can be found within the zip file.</p>

},
keywords = {code cleanup, code transformation, refactoring}
}

@software{10.5281/zenodo.10949342,
author = {Zakhour, George and Weisenburger, Pascal and Salvaneschi, Guido},
title = {Automated Verification of Fundamental Algebraic Laws},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10949342},
abstract = {
    <p>Propel – Automated Verification of Fundamental Algebraic Laws</p>
<p>Artifact for the paper #174 “Automated Verification of Fundamental Algebraic Laws”</p>
<h2 id="claims-addressed-by-this-artifact">CLAIMS ADDRESSED BY THIS ARTIFACT</h2>
<p>This artifact addresses the following claims made in the paper:</p>
<ul>
<li><p>Propel is implemented in Scala for proving a subset of Scala (cf.&nbsp;“USING PROPEL AS A SCALA DSL”) translated into an intermediate representation (cf.&nbsp;“USING PROPEL STANDALONE (OUTSIDE OF SCALA)”).</p></li>
<li><p>Propel outperforms cvc5, vawpire, Zeno, HipSpec, and CycleQ as claimed in Table 1 Section 4 (cf. “RUNNING THE BENCHMARKS”) on 142 algebraic properties.</p></li>
<li><p>The implementation of Propel is in Scala 3 and is about 10 K lines long throughout 46 Scala files (cf.&nbsp;“STRUCTURE OF THE PROPEL SOURCE CODE”).</p></li>
</ul>
<h2 id="getting-started">GETTING STARTED</h2>
<h3 id="building-and-loading-the-docker-image">BUILDING AND LOADING THE DOCKER IMAGE</h3>
<p>We provide you with <code>propel.tar.xz</code>, which is a pre-built container image that contains all necessary programs. To load, run the following command:</p>
<pre><code>$ docker load &lt; propel.tar.xz</code></pre>
<p>Further, we also provide the option to build the contain anew. To build, run the following command which takes between 10 and 20 minutes:</p>
<pre><code>$ docker build -t propel .</code></pre>
<p>Rebuilding the image may not work on Apple M1 machines because of incomplete emulation of system calls (specifically the inotify kernel subsystem). Hence, we recommend rebuilding the image on a platform fully supported by Docker, like x86-64 systems.</p>
<h3 id="checking-if-the-container-and-the-relevant-programs-run-correctly">CHECKING IF THE CONTAINER AND THE RELEVANT PROGRAMS RUN CORRECTLY</h3>
<p>We provide a script that runs fast checks on Propel and the other provers (HipSpec, Zeno, CycleQ, cvc5, Vampire) used in the evaluation.</p>
<p>The check verifies commutativity of natural number addition – a task which all programs are able to prove correct quickly. The following command runs the check:</p>
<pre><code>$ docker run -it --rm propel /check_image/check</code></pre>
<p>If you see in green the line “Check Done” at the end, the container is behaving as expected.</p>
<p>The check will show the provers’ output, which should look similar to the following (shortened) excerpt:</p>
<pre><code>Checking Zeno

[...]

Searching for proofs... 
Proved "CommutativityAddition.prop_add_comm : add x y = add y x"

[...]

Checking HipSpec

[...]

Proved:
    add m n == add n m
    add m (add n o) == add n (add m o)
    prop_add_comm {- add x y == add y x -}


Checking cvc5
"comm nat_add2p"
unsat

Checking Vampire

[...]

\% Termination reason: Refutation

[...]

Checking CycleQ

[...]

Attempting to prove: prop_nat_add1_rightid
Success!

Checking Propel

✔ Check successful.

Check Done</code></pre>
<p>Note that cvc5 and Vampire report <code>unsat</code> or <code>Refutation</code>, respectively. This is because properties are verified by SMT solvers by finding a counterexample for their negation.</p>
<h2 id="step-by-step-instructions">STEP-BY-STEP INSTRUCTIONS</h2>
<h3 id="compiling-propel">COMPILING PROPEL</h3>
<p>The provided container already contains a binary executable of Propel.</p>
<p>To compile Propel to Java bytecode yourself, run the following command:</p>
<pre><code>$ docker run -it --rm propel bash -c 'cd /propel; sbt clean compile'</code></pre>
<p>To compile Propel to a native binary yourself, run the following command:</p>
<pre><code>$ docker run -it --rm propel bash -c 'cd /propel; sbt clean nativeLink'</code></pre>
<p>Compiling Propel, to bytecode or to a native executable, may not work inside the Docker container on Apple M1 machines for the reasons mentioned earlier.</p>
<p>The resulting binary is at <code>/propel/.native/target/scala-3.3.0/propel</code>. The <code>propel</code> executable in the PATH is already symlinked to that binary file. Hence, by default, you can just run <code>propel</code>.</p>
<h3 id="testing-propel">TESTING PROPEL</h3>
<p>To run the tests in Propel, execute:</p>
<pre><code>$ docker run -it --rm propel bash -c 'cd /propel &amp;\&amp; sbt test'</code></pre>
<p>Running the Propel tests may not work inside the Docker container on Apple M1 machines for the reasons mentioned earlier.</p>
<p>Note that running all unit tests can take several minutes. The output should look similar to the following (shortened) excerpt:</p>
<pre><code>[info] SuccessfulPropertyChecks:
[info] - nat_add2p
[info] - nat_add3p
[info] - nat_mult2p
[info] - bv_add

[...]

[info] FailingPropertyChecks:
[info] - nat_add2p_acc !!! IGNORED !!!
[info] - nat_add3p_acc !!! IGNORED !!!

[...]

[info] Total number of tests run: 49
[info] Suites: completed 2, aborted 0
[info] Tests: succeeded 49, failed 0, canceled 0, ignored 15, pending 0
</code></pre>
<p>The <code>SuccessfulPropertyChecks</code> contain the examples for which Propel can verify all properties. The <code>FailingPropertyChecks</code> contain the examples for which Propel is unable to verify all properties, hence their unit tests are disabled (<code>IGNORED</code>).</p>
<h3 id="running-the-benchmarks">RUNNING THE BENCHMARKS</h3>
<p>The benchmarks in Table 1 on pages 15, 16 and 16 can be re-executed with the container. The number of the properties that (1) could be proven, (2) could not be proven and (3) timed out should match the content of tables and the figures. The given time may differ depending on the system where the benchmarks are run. Due to the timeout of one minute, not only the amount of seconds can differ but also the type of the result. It could be the case that the benchmark succeeds or fails in less than 60s on one setup but takes more than 60s on a different setup, in which case it would time out.</p>
<p>To execute the benchmarks on HipSpec, run:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/hipspec/run</code></pre>
<p>To execute the benchmarks on Zeno, run:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/zeno/run</code></pre>
<p>To execute the benchmarks on CycleQ, run:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/cycleq/run</code></pre>
<p>To execute the benchmarks on cvc5, run:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/cvc5/run</code></pre>
<p>To execute the benchmarks on Vampire, run:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/vampire/run</code></pre>
<p>To execute the benchmarks on Propel, run:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/propel/run</code></pre>
<p>To execute the benchmarks on Propel without inequalities, run:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/propel/run_no_ineq</code></pre>
<p>To execute the benchmarks that count the explored auxilliary lemmas, run:</p>
<pre><code>$ docker run -it --rm propel /benchmarks/propel/run_count_lemmas</code></pre>
<p>The results in Table 1 on pages 15, 16 and 16 correspond to one line from the output of each previous command.</p>
<h3 id="using-propel-as-a-scala-dsl">USING PROPEL AS A SCALA DSL</h3>
<p>Propel as described in Section 2.1 is a DSL in Scala. To experiment with the DSL, we invite you take a look into <code>/propel/src/test/scala/propel/ScalaExamplesNat.scala</code>, <code>/propel/src/test/scala/propel/ScalaExamplesNum.scala</code> and <code>/propel/src/test/scala/propel/ScalaExamplesList.scala</code> inside the container.</p>
<p>As an example, you can execute the following commands to run a shell, explore the files and recompile the project:</p>
<pre><code>$ docker run -it --rm propel bash                               # open a shell
$ nano /propel/src/test/scala/propel/ScalaExamplesList.scala    # open the file

# edit and save the file

$ cd /propel &amp;\&amp; sbt Test/compile                                # recompile</code></pre>
<p>Compiling the examples may not work inside the Docker container on Apple M1 machines for the reasons mentioned earlier.</p>
<p>You may define your own function using the following syntax:</p>
<pre><code>def myFunction = prop[(FunctionProperties) := (T1, T1) =&gt;: T2] { (x, y) =&gt; body }
// or
def myRecursiveFunction = prop.rec[(FunctionProperties) := (T1, T1) =&gt;: T2] { myRecursiveFunction =&gt; (x, y) =&gt; body }</code></pre>
<p>Here, <code>myFunction</code> is the name of the function, <code>FunctionProperties</code> is a list of function properties the function has (separated by <code>&amp;</code>), <code>T1</code> is the type of the arguments of the binary function, <code>T2</code> is the return type of the function, <code>x</code> and <code>y</code> are the names of the function arguments, and <code>body</code> is the function body.</p>
<p>The function properties are chosen from the following list: <code>Comm</code>, <code>Assoc</code>, <code>Idem</code>, <code>Sel</code>, <code>Refl</code>, <code>Antisym</code>, <code>Trans</code>, <code>Conn</code>, and <code>Sym</code>. Their semantics is defined in Section 2.2.</p>
<p>If Propel is able to prove the properties that the function is annotated with, then compilation succeeds. If the properties cannot be proven, then a compilation error indicates which property could not be proven</p>
<p>We hope that the integration into Scala makes the artifact easily usable by other researchers, either (1) by directly using the DSL to check algebraic and relational properties of their programs or (2) by building on Propel’s verification engine. To facilitate the latter, the implementation of Propel’s Scala DSL (<code>propel.dsl</code> package) is separated from the verification mechanism (<code>propel.evaluator</code> package), which researchers can adopt independently of the Scala integration (an overview of the package structure is in the last section).</p>
<h4 id="example">Example</h4>
<p>You can create a file in <code>/propel/src/test/scala/propel</code> with the following preamble:</p>
<pre><code>package propel

import propel.dsl.scala.*</code></pre>
<p>You can copy the <code>add1</code> example from the paper (Listing 1):</p>
<pre><code>enum ℕ:
  case Z
  case S(pred: ℕ)

def add1 = prop.rec[(Comm \&amp; Assoc) := (ℕ, ℕ) =&gt;: ℕ]: add1 =&gt;
  case (ℕ.Z, y) =&gt; y
  case (ℕ.S(x), y) =&gt; ℕ.S(add1(x, y))</code></pre>
<p>To define custom properties to be proven, you can add a <code>props</code> clause to the definition of <code>add1</code>. For instance, the following example proves the left and right identity laws:</p>
<pre><code>def add1 = prop.rec[(Comm \&amp; Assoc) := (ℕ, ℕ) =&gt;: ℕ]: add1 =&gt;
  props(
    (x: ℕ) =&gt; add1(ℕ.Z, x) =:= x, // left identity
    (x: ℕ) =&gt; add1(x, ℕ.Z) =:= x, // right identity
  ):
    case (ℕ.Z, y) =&gt; y
    case (ℕ.S(x), y) =&gt; ℕ.S(add1(x, y))</code></pre>
<p>You can execute <code>sbt Test/compile</code> to check all the annotated properties.</p>
<h3 id="using-propel-standalone-outside-of-scala">USING PROPEL STANDALONE (OUTSIDE OF SCALA)</h3>
<p>Propel can be directly reused as a verification tool in other projects (without the Scala and JVM dependency) through the <code>propel</code> binary. The binary consumes ASTs of Propel’s calculus in an S-expression-based syntax.</p>
<p>Our Scala implementation of the full surface language also follows the approach of translating Scala programs to terms in the calculus and passing them to the verification mechanism. A similar approach can be adopted by other tools that use Propel. Note that the AST is a bit more low-level then the Scala implementation and the calculus presented in the paper. In particular, the properties that are captured in the type of a function need to be propagated to the call sites of the function, i.e., function calls are syntactically annotated with the properties that should hold for them. The concrete format is described in the FORMAT.md file.</p>
<p>We provide all benchmarks in this format in the <code>/benchmarks/propel</code> directory. For example, the <code>nat_add1_comm.propel</code> is a direct translation of the <code>add1</code> function of Listing 1. This file can be checked by running:</p>
<pre><code>propel -f /benchmarks/propel/nat_add1_comm.propel</code></pre>
<p>Additional information about the proof attempts can be shown using the <code>-d</code> and <code>-r</code> flags.</p>
<h3 id="structure-of-the-propel-source-code">STRUCTURE OF THE PROPEL SOURCE CODE</h3>
<p>Propel is organized into the following packages:</p>
<ul>
<li><code>ast</code>: Abstract syntax tree definitions for the verifier</li>
<li><code>dsl</code>: Scala DSL</li>
<li><code>evaluator</code>: Rewrite engine (used by an implementation of the calculus’ dynamic semantics and by the verifier)</li>
<li><code>evaluator.properties</code>: Verifier for algebraic and relational properties (call <code>evaluator.properties.check</code> on an <code>ast.Term</code> to verify properties)</li>
<li><code>parser</code>: Parser for Propel’s serialization format (as used by the benchmarks)</li>
<li><code>printing</code>: Pretty-printer for Propel ASTs</li>
<li><code>typer</code>: Standard type checker (not checking algebraic and relational properties)</li>
<li><code>util</code>: Small, useful definitions</li>
</ul>

},
keywords = {Algebraic Properties, Type Systems, Verification}
}

@software{10.5281/zenodo.10949799,
author = {Huot, Mathieu and Ghavami, Matin and Lew, Alexander K. and Schaechtle, Ulrich and Freer, Cameron E. and Shelby, Zane and Rinard, Martin C. and Saad, Feras A. and Mansinghka, Vikash K.},
title = {PLDI artifact evaluation for "GenSQL: A Probabilistic Programming System for Querying Generative Models of Database Tables"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10949799},
abstract = {
    <p>This tarball provides evaluators with all means necessary to fully reproduce the results we show in the paper. We recommend users to check out the official GitHub repositories for GenSQL at https://github.com/OpenGen/GenSQL.query.</p>

},
keywords = {Experimental evaluation}
}

@software{10.5281/zenodo.10951313,
author = {Li, Shaohua and Theodoridis, Theodoros and Su, Zhendong},
title = {Artifact for PLDI'2024 paper "Boosting Compiler Testing by Injecting Real-world Code"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10951313},
abstract = {
    <p>This is the artifact for the PLDI’2024 paper “Boosting Compiler Testing by Injecting Real-World Code”. Please first untar the package and then refer to the README.pdf file for detailed instructions.</p>

},
keywords = {Compiler testing, compilers, miscompilation, reliability, testing}
}

@software{10.5281/zenodo.10951760,
author = {Ji, Ruyi and Zhao, Yuwei and Polikarpova, Nadia and Xiong, Yingfei and Hu, Zhenjiang},
title = {Artifact for PLDI'24: Superfusion: Eliminating Intermediate Data Structures via Inductive Synthesis},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10951760},
abstract = {
    <p>This project will be maintained at https://github.com/jiry17/SuFu.</p>

},
keywords = {Fusion, Inductive Program Synthesis, Program Optimization}
}

@software{10.5281/zenodo.10951893,
author = {Li, Jianlin and Wang, Eric and Zhang, Yizhou},
title = {Artifact for Paper 'Variable Elimination for an Expressive Probabilistic Programming Language'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10951893},
abstract = {
    <p>This repository contains the tool source code, benchmarks and instructions to reproduce the results in paper ‘Variable Elimination for an Expressive Probabilistic Programming Language’.</p>

},
keywords = {compiler, continuation-passing style, CPS, information flow type system, probabilistic programming, type checker, type system, variable elimination}
}

@software{10.5281/zenodo.10951930,
author = {Gladshtein, Vladimir and Zhao, Qiyuan and Ahrens, Willow and Amarasinghe, Saman and Sergey, Ilya},
title = {LGTM: the Logic for Graceful Tensor Manipulation},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10951930},
abstract = {
    <p>This is the research artefact for the paper Mechanised Hypersafety Proofs about Structured Data to appear in the proceedings of the 45th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2024).</p>

},
keywords = {coq, mechanised proofs, relational logic, sparse data structures}
}

@software{10.5281/zenodo.10953315,
author = {Girol, Guillaume and Lacombe, Guilhem and Bardin, S\'{e}bastien},
title = {Quantitative Robustness for Vulnerability Assessment},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10953315},
abstract = {
    <p>Most software analysis techniques focus on bug reachability. However, this approach is not ideal for security evaluation as it does not take into account the difficulty of triggering said bugs. The recently introduced notion of robust reachability tackles this issue by distinguishing between bugs that can be reached independently from uncontrolled inputs, from those that cannot. Yet, this qualitative notion is too strong in practice as it cannot distinguish mostly replicable bugs from truly unrealistic ones.</p>
<p>In this work we propose a more flexible quantitative version of robust reachability together with a dedicated form of symbolic execution, in order to automatically measure the difficulty of triggering bugs. This quantitative robust symbolic execution (QRSE) relies on a variant of model counting, called functional E-MAJSAT, which allows to account for the asymmetry between attacker-controlled and uncontrolled variables. While this specific model counting problem has been studied in AI research fields such as Bayesian networks, knowledge representation and probabilistic planning, its use within the context of formal verification presents a new set of challenges. We show the applicability of our solutions through security-oriented case studies, including real-world vulnerabilities such as CVE-2019-20839 from libvncserver.</p>

},
keywords = {Security, Static Analysis, Verification (automated)}
}

@software{10.5281/zenodo.10960926,
author = {Yi, Qiuping and Yu, Yifan and Yang, Guowei},
title = {Reproduction Package For Article `Compatible Branch Coverage Driven Symbolic Execution for Efficient Bug Finding`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10960926},
abstract = {
    <p>The current artifact comprises all the tool source code related to the paper, along with the scripts and data needed to reproduce the experiments. We provide both source code and Docker build options.</p>

},
keywords = {program analysis, software testing, symbolic execution}
}

@software{10.5281/zenodo.10961123,
author = {Moeller, Mark and Jacobs, Jules and Belanger, Olivier Savary and Darais, David and Schlesinger, Cole and Smolka, Steffen and Foster, Nate and Silva, Alexandra},
title = {KATch: A Fast Symbolic Verifier for NetKAT},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10961123},
abstract = {
    <p>The artifact is the Scala implementation of the symbolic NetKAT verifier described in the paper, along with the NetKAT input files corresponding to the benchmark sets.</p>

},
keywords = {Automata equivalence, Kleene Algebra with Tests, NetKAT Verifier, Network Verification}
}

@software{10.5281/zenodo.10961342,
author = {Chen, Hongzheng and Zhang, Niansong and Xiang, Shaojie and Zeng, Zhichen and Dai, Mengjia and Zhang, Zhiru},
title = {Allo: A Programming Model for Composable Accelerator Design},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10961342},
abstract = {
    <p>This artifact contains scripts for setting up environments and reproducing results presented in the PLDI 2024 paper entitled “Allo: A Programming Model for Composable Accelerator Design”. Please refer to our github repo for instructions on how to install and run the artifact. https://github.com/cornell-zhang/allo-pldi24-artifact</p>

},
keywords = {accelerator design language, compiler optimization, Hardware accelerators, schedule language}
}

@software{10.5281/zenodo.10961908,
author = {Wimmer, Christian and Stancu, Codrut and Kozak, David and W\"{u}rthinger, Thomas},
title = {Scaling Points-to Analysis using Saturation - Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10961908},
abstract = {
    <p>The artifact presents our work on scaling points-to analysis using saturation. The content is a docker image containing GraalVM release and our benchmarking infrastructure. There is no need for special hardware, everything should work out of the box. The evaluation runs GraalVM Native Image in various configurations on our benchmarks and output the results, so that they can be compared with the values presented in the paper. However, due to resource constraints, we chose only a small subset that finishes fast. We provide a full configuration as well, but please note the full setup would take weeks to finish is executed on a single machine.</p>

},
keywords = {GraalVM, Java, pointer analysis, points-to analysis, static analysis}
}

@software{10.5281/zenodo.10963124,
author = {Murali, Adithya and Rivera, Cody and Madhusudan, P.},
title = {Artifact for ``Predictable Verification using Intrinsic Definitions''},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10963124},
abstract = {
    <p>This is the artifact for our paper “Predictable Verification using Intrinsic Definitions”.</p>
<p>ids-artifact.zip contains our benchmarks, while ids-docker.zip contains a Docker image. Please see README.md for instructions on how to use the artifact.</p>

},
keywords = {Boogie, Dafny, Decidability, Ghost-Code Annotations, Intrinsic Definitions, Predictable Verification, Verification of Linked Data Structures}
}

@software{10.5281/zenodo.10965986,
author = {Raskind, Joseph and Babakol, Timur and Mahmoud, Khaled and Liu, Yu David},
title = {Reproduction Artifact for VESTA},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10965986},
abstract = {
    <p>An artifact that reproduces the VESTA model</p>

},
keywords = {BPF, Java virtual machines, language runtimes, power modeling}
}

@software{10.5281/zenodo.10966813,
author = {Diatchki, Iavor S. and Dodds, Mike and Goldstein, Harrison and Harris, Bill and Holland, David A. and Razet, Benoit and Schlesinger, Cole and Winwood, Simon},
title = {Daedalus},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10966813},
abstract = {
    <p>Daedalus artifact submitted to PLDI</p>

},
keywords = {parser-generator, parsing}
}

@software{10.5281/zenodo.10971411,
author = {Kokologiannakis, Michalis and Marmanis, Iason and Vafeiadis, Viktor},
title = {Replication Package for "SPORE: Combining Symmetry and Partial Order Reduction"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10971411},
abstract = {
    <p>The artifact contains the tools GenMC (which implements theTruStalgorithm) and SPORE, as well as the tests used in the evaluation section of the paper.</p>
<p>SPORE is publicly available as part of GenMC: https://github.com/MPI-SWS/genmc.</p>

},
keywords = {concurrency, model checking, partial order reduction, symmetry reduction, weak memory models}
}

@software{10.5281/zenodo.10972076,
author = {Pitchanathan, Arjun and Grover, Kunwar and Grosser, Tobias},
title = {Artifact for "Falcon: A Scalable Analytical Cache Model"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10972076},
abstract = {
    <h2 id="artifact-for-falcon-a-scalable-analytical-cache-model">Artifact for Falcon: A Scalable Analytical Cache Model</h2>
<p>This is the supporting artifact for the Falcon paper. It can be used to replicate all results in the submitted version of the paper (submission_paper.pdf), given enough time and appropriate hardware. To be precise, it takes around two weeks to reproduce all the results.</p>
<h3 id="quick-version-of-the-artifact">Quick Version of the Artifact</h3>
<p>To facilitate evaluation, we also provide a “quick” version of the artifact that reproduces the main results. It reproduces all the evaluation figures in the paper, with the following differences:</p>
<ul>
<li><p>Figure 1: we run the models at all x values of 20 up to 100 instead of multiples of 5. This is sufficient to establish the same trend.</p></li>
<li><p>Figure 6 \&amp; 7: we evaluate on the last four benchmarks files in the ordering of Figure 6, showing that even on the “worst” inputs in the benchmark, Falcon takes minutes. (base models time out after four hours)</p></li>
<li><p>Figure 8: we evaluate on thread counts [1, 2, 4, 8, 12, 16] instead of all counts up to 16. This is sufficient to establish the same trend.</p></li>
</ul>
<p>All of the above choices can be easily customized by the user before running the artifact; see “Running the Artifact” below.</p>
<h3 id="hardware-requirements">Hardware Requirements</h3>
<h4 id="requirements-for-the-quick-version">Requirements for the quick version</h4>
<p>For hardware measurement, our method requires a machine with an AMD Zen3/Zen4 CPU and access to the <code>perf_event_open</code> syscall. Note that many cloud machines disallow this syscall. If such a machine is not available, you can still use the hardware measurement data from our machine and run the rest of the artifact. The only difference will be that the accuracy figures will be plotted against our measurement data on our machine instead of yours.</p>
<p>For the parallelism experiment, a machine with 16 cores is required. If there are fewer cores, then running on 16 threads will not improve performance as much so the speedup would be less than that reported in the paper. Other than that, the artifact will still work fine on a machine with fewer cores.</p>
<h4 id="requirements-for-the-full-version">Requirements for the full version</h4>
<p>For the complete version, a machine with 192 GiB RAM is required. This is because the baseline model Haystack that we compare against can sometimes take a large amount of RAM.</p>
<p>When the full artifact is run on a machine with insufficient RAM, if Haystack runs out of memory when running some file, that file will be gracefully dropped from Figure 6. Otherwise, the rest of the artifact will continue to function normally. In such a scenario it may help system stability to run <code>./earlyoom.sh</code> before running the models, though when we tested on a low RAM machine, we did not find this to be necessary.</p>
<p>It may be difficult to obtain a single machine satisfying the high RAM requirement as well as the requirement to have access to the <code>perf_event_open</code> syscall, as the latter is often not available on cloud machines. Therefore, we provide the option to run each part on a different machine, as long as one machine is available with high RAM and another with the requirements specific for hardware measurements.</p>
<h3 id="software-requirements">Software Requirements</h3>
<p>The artifact requires <a href="https://docs.docker.com/get-docker/">Docker</a>. We tested on version <code>24.0.6</code> on a Linux machine.</p>
<h3 id="getting-started">Getting Started</h3>
<p>The artifact comes with pre-built binaries. To rebuild from scratch, see that section below. To setup the artifact and docker image:</p>
<ol type="1">
<li>Extract the provided archive and <code>cd</code> into the extracted directory.</li>
<li>Load the provided docker image with <code>docker load -i docker/docker_image.tar</code>.</li>
<li>Run the image with <code>docker run -v $(pwd):/app -it --security-opt seccomp=docker/seccomp.json falcon-artifact</code></li>
</ol>
<p>This mounts the project root directory (which should be the current directory) to the VM. Changes made in the VM will be persisted here.</p>
<p>The argument <code>--security-opt seccomp=docker/seccomp.json</code> loads a custom security configuration. The only difference between the custom one and the default is that the <code>perf_event_open</code> syscall is permitted, which is required for hardware measurement. The argument can be omitted if hardware measurement is not needed. If the measurement test assert-fails as described in the next section even though you expect it to work on your system, you can try adding the flag <code>--privileged</code>, though we did not need it during testing.</p>
<p>Note that during development, our tool was called <code>lazystack</code>, so it is referred to as such in scripts and source code.</p>
<h4 id="test-running-hardware-measurement">Test-running hardware measurement</h4>
<p>To test the hardware measurement, run <code>examples/measurement-example</code>. If it succeeds, the output will contain four numbers. On our system, we got:</p>
<pre><code>0.18134
1359152
16981
68</code></pre>
<p>The first output number is runtime and the next three are cache accesses and misses; none of these numbers are expected to be zero. If any of the last three lines are zero then your CPU is probably unsupported. In this case, you can use the measurement data from our system (see below for more details).</p>
<p>On the other hand, if the <code>perf_event_open</code> syscall is not supported, an error like the following will be reported:</p>
<pre><code>measurement-example: ../src/c-gen-perf-main.cpp:66: read_format&lt;nr&gt; disable_and_get_count_group(int) [nr = 3U]: Assertion `data.nr == nr' failed.
Aborted (core dumped)</code></pre>
<h4 id="test-running-the-cache-models">Test-running the cache models</h4>
<p><code>cd</code> into the <code>experiments</code> directory and run <code>python perf-all.py -b polybench-S -c 512,512 --output-suffix test --filter gemm</code>. This should produce output like the following.</p>
<pre><code>root@53846d9af34b:/app/experiments# python perf-all.py -b polybench-S -c 512,512 --output-suffix test --filter gemm
Will output to data/perf-polybench-S-512-512-test.json
Runnning haystack on gemm
Running warping on gemm
Running lazystack on gemm... 78ms
{
  "gemm": {
    "haystack": {
      "L1": 0,
      "L2": 0,
      "L3": 0,
      "accesses": 1352400,
      "capacity": 0,
      "compulsory": 1000,
      "misses": 1000,
      "time": 188.77
    },
    "lazystack": {
      "accesses": 1352400,
      "misses": 1000,
      "misses_L1": 1000,
      "misses_L2": 0,
      "ops": 6,
      "peak_mem": 42892,
      "stack_t": 36.9719,
      "symbolic_t": 16.7869,
      "thresh_t": 8.84229,
      "time": 55.1991,
      "varheur_t": 0.015209
    },
    "warping": {
      "access_level": [
        1352400
      ],
      "accesses": 1352400,
      "miss_level": [
        926
      ],
      "misses": 926,
      "time": 293.0
    }
  }
}
Saving to data/perf-polybench-S-512-512-test.json</code></pre>
<p>The main thing to check is that all three models haystack, lazystack, and warping ran successfully, producing a section in the output for each.</p>
<h3 id="running-the-experiments">Running the experiments</h3>
<p>To perform experiments, <code>cd</code> into the <code>experiments</code> directory.</p>
<p>To perform hardware measurement, run <code>./run_measurement.py</code>. This may take around 4 hours and should be done on a machine with an AMD Zen3/Zen4 CPU and access to the <code>perf_event_open</code> syscall. You should run the docker image with the provided seccomp for this part. Now run <code>./get_system_cache_conf.sh</code> on the same machine and note down the two numbers; these are the number of cache lines in the cache and the size of each cache line in bytes.</p>
<p>To run the full version of the model evaluation, run <code>./run_prediction.sh &lt;cache line count&gt; &lt;line size&gt;</code>. This may take around 2 weeks and requires a machine with 192 GiB of RAM.</p>
<p>To run the quick version of the model evaluation, run <code>./run_prediction_fast.sh &lt;cache line count&gt; &lt;line size&gt;</code>. This may take around 2-3 days. If you want to customize any of the parameters of the quick run described in the introduction of this document, it is easy to do so by modifying the environment variables exported in that script; they are well documented.</p>
<p>For more info on manually customizing the running of the benchmarks beyond the provided shell scripts see <code>MoreInfo.md</code>.</p>
<h4 id="using-our-hardware-measurement-data-in-case-of-unsupported-cpu">Using our hardware measurement data in case of unsupported CPU</h4>
<p>If you do not have a supported AMD CPU for the hardware measurement, you can use our hardware measurement data. To do this, simply copy the <code>perf-perf-1.json</code> file from <code>experiments</code> into the <code>experiments/data</code> directory and run the prediction scripts as usual. Our machine has 512 cache lines and the line size is 64 (bytes); use those settings when running the prediction. You can then proceed to plotting (see below).</p>
<h3 id="plotting-and-comparing-results">Plotting and comparing results</h3>
<p>To plot the data collected, run <code>./plot.sh</code> in the <code>experiments</code> directory. This will generate a report in <code>experiments/report/report.pdf</code>. This document lists all the generated figures along with their figure number in the submitted paper.</p>
<p>You can now compare these figures with those in the submitted paper <code>submitted_paper.pdf</code> and confirm that the interpretations in the captions of the figures in the submission continue to hold in the figures in the report generated from the artifact.</p>
<p>If you ran Polybench, you can print the speedups on it with <code>python print_polybench_speedup.py</code>. It also mentions the speedup reported in the paper with line number for reference.</p>
<p>Finally, in the paper we checked our tool’s correctness by comparing the outputs against Haystack. Run <code>python check.py</code> to replicate this; it will compare against all available Haystack outputs from the artifact.</p>
<h3 id="building-from-scratch">Building from Scratch</h3>
<p>The artifact comes with pre-built binaries for convenience, but can support a fresh build too. To do so, first run <code>./clean_all.sh</code> to delete pre-built data.</p>
<p>To build the binaries used for hardware measurement, run <code>./setup_measurement.sh</code></p>
<p>To build the cache models, run <code>./setup_prediction.sh</code>. The binary of our tool will be produced in <code>cmake-build-release/bin/lazystack</code>, which can be used for manually running it on a given MLIR file.</p>
<h3 id="source-code-organization">Source Code Organization</h3>
<p>The source code of our tool is in the directories <code>include</code>, <code>src</code>, and <code>lib</code>. Some modifications have also been made to the external libraries in <code>polybase/barvinok</code> and <code>polybase/isl</code>. The entrypoint into the actual cache model is in the <code>CacheModel::compute</code> function in <code>lib/Analysis/CacheModel.cpp</code>.</p>
<p>The key function is the <code>CacheModel::computeSink</code> function. This computes the cache misses at each level, for the given sink in the program. This corresponds to the body of the loop in Algorithm 1 in the paper.</p>
<p>The dependences are computed by the call to <code>Lazy::compute</code>, implemented in <code>lib/Analysis/Lazy.cpp</code>. Threshold couting is performed in the call to <code>ThresholdCounting::compute</code>, implemented in <code>lib/Analysis/ThresholdCounting.cpp</code>.</p>

},
keywords = {cache modeling, performance analysis, static analysis}
}

@software{10.5281/zenodo.10975363,
author = {Forster, Yannick and Sozeau, Matthieu and Tabareau, Nicolas},
title = {Artifact for "Verified Extraction from Coq to OCaml"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10975363},
abstract = {
    <p>The Coq code corresponding to the development described in the paper, and benchmarks corresponding to section 6.</p>

},
keywords = {Coq, extraction, functional programming, verified compilation}
}

@software{10.5281/zenodo.10976438,
author = {Cui, Guofeng and Wang, Yuning and Qiu, Wenjie and Zhu, He},
title = {ReGuS - Reproduction Package for Article `Reward-Guided Synthesis of Intelligent Agents with Control Structures`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10976438},
abstract = {
    <p>This artifact is provided as a Docker image. Before proceeding, ensure you have Docker installed. The artifact was tested with Docker version 20.10.23. We recommend that your machine has at least 16GB of memory and 16GB of available disk space for building and running Docker images. All benchmarks were tested on a Mac Mini 2023 with an Apple M2 Pro CPU and 16GB of RAM. Please refer to the README file for instructions on reproducing the experiments.</p>

},
keywords = {Program Synthesis, Reinforcement Learning, Sequential Decision Making}
}

@software{10.5281/zenodo.11097757,
author = {Blaauwbroek, Lasse and Ol\v{s}\'{a}k, Miroslav and Geuvers, Herman},
title = {Artifact for: Hashing Modulo Context-Sensitive Alpha-Equivalence},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11097757},
abstract = {
    <p>Reference implementation for hashing modulo context-sensitive alpha-equivalence</p>

},
keywords = {Alpha Equivalence, Bisimilarity, Hashing, Lambda Calculus, Syntax Tree}
}

@software{10.5281/zenodo.11099781,
author = {Brahmakshatriya, Ajay and Rinard, Chris and Ghobadi, Manya and Amarasinghe, Saman},
title = {Replication package for the PLDI 2024 paper: NetBlocks: Staging Layouts for High-Performance Custom Host Network Stacks},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11099781},
abstract = {
    <p>Replication package for the PLDI 2024 paper: NetBlocks: Staging Layouts for High-Performance Custom Host Network Stacks</p>

},
keywords = {compilers, layouts, network-protocols}
}

@software{10.5281/zenodo.11113582,
author = {Brain, Martin and Malkawi, Mahdi},
title = {[artifact] Misconceptions About Loops in C},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11113582},
abstract = {
    <p>This artifact collects the examples used in the paper and provides them as a test suite. Each example is a separate program that can be used in a number of ways. The program’s text is used in the paper. No results are generated.</p>
<p>Each program takes a single input that controls which path through the program is taken and gives a single output that records which branches were taken. This allows them to be used for back-to-back testing with compilers, interpreters, source-to-source translation, or dynamic analysis tools. If the input/output relation changes, then transformation is buggy and unable to handle that kind of loop.</p>
<p>They also have assertions that hold true only for valid paths through the program, making them ideal for testing with static analysis tools. If an assertion fails, it indicates a bug in the static analysis tool. To demonstrate how these can be used, we provide a setup to test CBMC.</p>

},
keywords = {Loop Analysis, Software Verification, Static Analysis}
}

@software{10.1145/3580435,
author = {Jiang, Shaokang and Coblenz, Michael},
title = {Reproduction package and data for "An Analysis of the Costs and Benefits of Autocomplete in IDEs"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580435},
abstract = {
    <p>This artifact includes the materials used for the experiment described in the paper and the quantitative data that resulted from the experiment. It also includes the script we used to analyze the raw data.</p>

},
keywords = {API learning, Code Completion, IDE design}
}

@software{10.5281/zenodo.10063353,
author = {Dey, Tapajit and Loungani, Jonathan and Ivers, James},
title = {Replication Package for "Smarter Project Selection For Software Engineering Research"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10063353},
abstract = {
    <p>This dataset represents the replication package for the paper: Smarter Project Selection For Software Engineering Research, accepted at PROMISE 2024 - 20th International Conference on Predictive Models and Data Analytics in Software Engineering. The README file contains the details of the dataset.</p>

},
keywords = {Application, categorization, Doc2Vec, GitHub, Library, machine learning, multi-class classification, Open Source, OSS projects, Plug-in, random forest}
}

@software{10.5281/zenodo.10570961,
author = {Birchler, Christian and Mohammed, Tanzil Kombarabettu and Rani, Pooja and Nechita, Teodora and Kehrer, Timo and Panichella, Sebastiano},
title = {Replication Package - "How does Simulation-based Testing for Self-driving Cars match Human Perception?"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10570961},
abstract = {
    <p>Software metrics such as coverage and mutation scores have been extensively explored for the automated quality assessment of test suites. While traditional tools rely on such quantifiable software metrics, the field of self-driving cars (SDCs) has primarily focused on simulation-based test case generation using quality metrics such as the out-of-bound (OOB) parameter to determine if a test case fails or passes. However, it remains unclear to what extent this quality metric aligns with the human perception of the safety and realism of SDCs, which are critical aspects in assessing SDC behavior. To address this gap, we conducted an empirical study involving 50 participants to investigate the factors that determine how humans perceive SDC test cases as safe, unsafe, realistic, or unrealistic. To this aim, we developed a framework leveraging virtual reality (VR) technologies, called SDC-Alabaster, to immerse the study participants into the virtual environment of SDC simulators. Our findings indicate that the human assessment of the safety and realism of failing and passing test cases can vary based on different factors, such as the test’s complexity and the possibility of interacting with the SDC. Especially for the assessment of realism, the participants’ age as a confounding factor leads to a different perception. This study highlights the need for more research on SDC simulation testing quality metrics and the importance of human perception in evaluating SDC behavior.</p>

},
keywords = {Human Perception, Self-driving Cars, Simulation, Software Testing, VR}
}

@software{10.5281/zenodo.10622332,
author = {de Oliveira Neto, Francisco Gomes},
title = {Package for the paper Unveiling Assumptions: Exploring the Decisions of AI Chatbots and Human Testers},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10622332},
abstract = {
    <p>This package includes the data for the study reported in the paper “Unveiling Assumptions: Exploring the Decisions of AI Chatbots and Human Testers”. The files can be used to re-generate figures, and see the additional chatlogs from AI Chatbots that were not included in the paper due to space. Intructions about using the paper are in the README.md file.</p>

},
keywords = {Chatbots, Software Testing, Test Prioritization}
}

@software{10.5281/zenodo.10626343,
author = {Y\i{}ld\i{}ran, Necip Faz\i{}l and Oh, Jeho and Lawall, Julia and Gazzillo, Paul},
title = {Artifact from "Maximizing Patch Coverage for Testing of Highly-Configurable Software without Exploding Build Times"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10626343},
abstract = {
    <p>Artifact from “Maximizing Patch Coverage for Testing of Highly-Configurable Software without Exploding Build Times”</p>

},
keywords = {krepair}
}

@software{10.5281/zenodo.10656106,
author = {Xiao, Tao and Hata, Hideaki and Treude, Christoph and Matsumoto, Kenichi},
title = {Research Artifact - Generative AI for Pull Request Descriptions: Adoption, Impact, and Developer Interventions},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10656106},
abstract = {
    <p>This is a research artifact for “Generative AI for Pull Request Descriptions: Adoption, Impact, and Developer Interventions”. This artifact is a repository that includes lists of studied PRs from GitHub, both with and without the use of Copilot for PRs. It also provides the features of PRs that were either generated or not generated by Copilot for PRs (pertaining to RQ2), coding results for RQ3, and scripts. The purpose of this artifact is enabling researchers to replicate our results of the paper, and to reuse our dataset of Copilot for PRs for further research.</p>

},
keywords = {Copilot, Generative AI, GitHub, Pull Requests}
}

@software{10.5281/zenodo.10669580,
author = {Kim, Tae Eun and Choi, Jaeseung and Im, Seongjae and Heo, Kihong and Cha, Sang Kil},
title = {Evaluating Directed Fuzzers: Are We Heading in the Right Direction? (Paper Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10669580},
abstract = {
    <p>A research artifact associated with the paper “Evaluating Directed Fuzzers: Are We Heading in the Right Direction?” (FSE 2024). This artifact provides the end-to-end system to reproduce the experiments in the paper either by running the experiment or analyzing the experimental data used in the paper.</p>

},
keywords = {Directed fuzzing, Fuzz testing, Fuzzer evaluation}
}

@software{10.5281/zenodo.10683405,
author = {Cai, Luwei and Song, Fu and Chen, Taolue},
title = {S3L-official/CT_Prover: CT_Prover},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10683405},
abstract = {
    <p>Source code for “Towards Efficient Verification of Constant-Time Cryptographic Implementations” accepted by FSE24</p>

},
keywords = {constant-time cryptographic implementation, formal verification, taint analysis, Timing side-channel}
}

@software{10.5281/zenodo.10684856,
author = {Eom, Haeun and Kim, Dohee and Lim, Sori and Koo, Hyungjoon and Hwang, Sungjae},
title = {R2I: A Relative Readability Metric for Decompiled Code},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10684856},
abstract = {
    <p>This artifact comprises the replication package for the paper titled “R2I: A Relative Readability Metric for Decompiled Code” (FSE 2024). It encompasses the source code of R2I, a readability metric designed specifically for decompiled code, along with the dataset utilized in the paper. The dataset consists of decompiled code samples from prominent decompilers such as Hex-Rays, Ghidra, and Binary Ninja.</p>

},
keywords = {Code Metric, Decompiled Code Readability}
}

@software{10.5281/zenodo.10684985,
author = {Zhang, Yifan and Li, Jiliang and Karas, Zachary and Bansal, Aakash and Li, Toby Jia-Jun and McMillan, Collin and Leach, Kevin and Huang, Yu},
title = {Reproduction Package for the FSE 2024 Paper "EyeTrans: Merging Human and Machine Attention for Neural Code Summarization"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10684985},
abstract = {
    <p>This artifact accompanies our paper “EyeTrans: Merging Human and Machine Attention for Neural Code Summarization,” which has been accepted for presentation at the ACM International Conference on the Foundations of Software Engineering (FSE) 2024.</p>
<p>The artifact contains the dataset derived from a human study using eye-tracking for code comprehension, crucial for the development of the EyeTrans model. Additionally, it includes the source code related to the research questions addressed within our work.</p>
<p>This includes the unprocessed data from the eye-tracking study, scripts for data processing, and the source code for the EyeTrans model, which merges human and machine attention within Transformer models. This resource is intended for researchers aiming to replicate our study, conduct further inquiry, or extend the techniques to new datasets in software engineering research.</p>

},
keywords = {Code Summarization, Eye-tracking, Human Attention, Machine Attention, Transformer}
}

@software{10.5281/zenodo.10719029,
author = {Sun, Gengyi and Habchi, Sarra and McIntosh, Shane},
title = {RavenBuild: Context, Relevance, and Dependency Aware Build Outcome Prediction},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10719029},
abstract = {
    <p>Open-Source Dataset: Data collection, Feature Extraction, and Model Training</p>

},
keywords = {build outcome prediction, continuous integration, maintenance cost, mining software repositories}
}

@software{10.5281/zenodo.10775868,
author = {Rahman, Md Shamimur and Codabux, Zadia and Roy, Chanchal K.},
title = {Replication Package for Do Words Have Power? Understanding and Fostering Civility in Code Review Discussion},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10775868},
abstract = {
    <p>Dataset and replication</p>

},
keywords = {Code Review, Incivility}
}

@software{10.5281/zenodo.10828316,
author = {Mohajer, Mohammad Mahdi and Aleithan, Reem and Harzevili, Nima Shiri and Wei, Moshi and Belle, Alvine Boaye and Pham, Hung Viet and Wang, Song},
title = {Replication Package for "Effectiveness of ChatGPT for Static Analysis: How Far Are We?"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10828316},
abstract = {
    <p>This artifact contains the replication package for the paper “Effectiveness of ChatGPT for Static Analysis: How Far Are We?”. This package contains a README.md file instructing how to run the experiments performed on the paper. It also contains datasets, all the experiment codes, and the packages that are required to install.</p>

},
keywords = {ChatGPT, Large language models, Static analysis}
}

@software{10.5281/zenodo.11068809,
author = {Zhang, Zhaoxu and Tawsif, Fazle Mohammed and Ryu, Komei and Yu, Tingting and Halfond, William G. J.},
title = {Reproduction Package for "Mobile Bug Report Reproduction via Global Search on the App UI Model"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11068809},
abstract = {
    <p>This is the artifact of the paper “Mobile Bug Report Reproduction via Global Search on the App UI Model” accepted by FSE 2024.</p>

},
keywords = {Bug Report Reproduction}
}

@software{10.5281/zenodo.11069504,
author = {Haroon, Sabaat and Brown, Chris and Gulzar, Muhammad Ali},
title = {Reproduction package for "DeSQL: Interactive Debugging of SQL in Data-Intensive Scalable Computing".},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11069504},
abstract = {
    <p>DeSQL artifacts provide clear and detailed documentation that guides users through a verified local setup process, ensuring the system is both functional and resuable, which streamlines the experience from installation to utilization.</p>

},
keywords = {data intensive scalable computing, Debugging, SQL}
}

@software{10.5281/zenodo.11072823,
author = {Gong, Jingzhi and Chen, Tao},
title = {Artifact Repository for Paper "Predicting Configuration Performance in Multiple Environments with Sequential Meta-Learning"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11072823},
abstract = {
    <p>This repository contains the key codes, full data used, raw experiment results, and the supplementary tables for the paper.</p>

},
keywords = {configuration performance learning, configuration performance prediction, deep learning, highly configurable software, machine learning, meta-learning, software engineering}
}

@software{10.5281/zenodo.11077099,
author = {Cheng, Xiao and Ren, Jiawei and Sui, Yulei},
title = {Fast Graph Simplification for Path-Sensitive Typestate Analysis through Tempo-Spatial Multi-Point Slicing (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11077099},
abstract = {
    <p>This artifact is for Fast Graph Simplification for Path-Sensitive Typestate Analysis through Tempo-Spatial Multi-Point Slicing by Xiao Cheng, Jiawei Ren and Yulei Sui published at FSE 2024. The artifact can be reused to analyze customized programs. The source code can also be modified to fit specific needs.</p>
<p>Typestate analysis is a commonly used static technique to identify software vulnerabilities by assessing if a sequence of operations violates temporal safety specifications defined by a finite state automaton. Path-sensitive typestate analysis (PSTA) offers a more precise solution by eliminating false alarms stemming from infeasible paths. To improve the efficiency of path-sensitive analysis, previous efforts have incorporated sparse techniques, with a focus on analyzing the path feasibility of def-use chains. However, they cannot be directly applied to detect typestate vulnerabilities requiring temporal information within the control flow graph, e.g., use-to-use information.</p>
<p>In this paper, we introduce FGS, a Fast Graph Simplification approach designed for PSTA by retaining multi-point temporal information while harnessing the advantages of sparse analysis. We propose a new multi-point slicing technique that captures the temporal and spatial correlations within the program. By doing so, it optimizes the program by only preserving the necessary program dependencies, resulting in a sparser structure for precision-preserving PSTA. Our graph simplification approach, as a fast preprocessing step, offers several benefits for existing PSTA algorithms. These include a more concise yet precision-preserving graph structure, decreased numbers of variables and constraints within execution states, and simplified path feasibility checking. As a result, the overall efficiency of the PSTA algorithm exhibits significant improvement.</p>
<p>We evaluated FGS using NIST benchmarks and ten real-world large-scale projects to detect four types of vulnerabilities, including memory leaks, double-frees, use-after-frees, and null dereferences. On average, when comparing FGS against ESP (baseline PSTA), FGS reduces 89\% of nodes, 86\% of edges, and 88\% of calling context of the input graphs, obtaining a speedup of 116<span class="math inline">\texttimes{}</span> and a memory usage reduction of 93\% on the large projects evaluated. Our experimental results also demonstrate that FGS outperforms six open-source tools (IKOS, ClangSA , Saber, Cppcheck, Infer, and Sparrow) on the NIST benchmarks, which comprises 846 programs. Specifically, FGS achieves significantly higher precision, with improvements of up to 171\% (42\% on average), and detects a greater number of true positives, with enhancements of up to 245\% (52\% on average). Moreover, among the ten large-scale projects, FGS successfully found 105 real bugs with a precision rate of 82\%. In contrast, our baseline tools not only missed over 42\% of the real bugs but also yielded an average precision rate of just 13\%.</p>

},
keywords = {Graph simplification, Multi-point slicing, Path-sensitive typestate analysis}
}

@software{10.5281/zenodo.11079042,
author = {Qin, Yi and Tong, Yanxiang and Xu, Yifei and Cao, Chun and Ma, Xiaoxing},
title = {Active Monitoring Mechanism},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11079042},
abstract = {
    <p>AMM is a runtime monitoring solution for detecting potentially abnormal behavior of control-based self-adaptive systems. The basic intuition of AMM is to stimulate the control-SAS with an active control signal when vague observations might mask model deviations. To determine the appropriate time for triggering the active signals, AMM proposes a stochastic framework to quantify the relationship between the implicit variation of a control-SAS and its explicit observation. Based on this framework, AMM’s monitor and remediator enhance model deviation detection by generating active control signals of well-designed timing and intensity.</p>

},
keywords = {control-based sefl-adpative systems, model deviation, runtime monitoring}
}

@software{10.5281/zenodo.11090237,
author = {Wu, Yaoxuan and Humayun, Ahmad and Gulzar, Muhammad Ali and Kim, Miryung},
title = {Reproduction Package for Article "Natural Symbolic Execution-based Testing for Big Data Analytics"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11090237},
abstract = {
    <p>This artifact includes NaturalSym, a symbolic-execution-based test generator. Given subject DISC programs, NaturalSym can produce high path-coverage and natural-looking test cases. This package contains both NaturalSym itself and all the necessary components to reproduce our evaluation results.</p>

},
keywords = {DISC Applications, Naturalness, Symbolic Execution}
}

@software{10.5281/zenodo.11091402,
author = {Yoon, Jaehan and Cha, Sooyoung},
title = {(Artifact Evaluation) FeatMaker: Automated Feature Engineering for Search Strategy of Symbolic Execution},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11091402},
abstract = {
    <p>FeatMaker is a novel technique that automatically generates state features to enhance the search strategy of symbolic execution. This technique is implemented on the top of KLEE, a widely adopted symbolic execution tool for testing C programs.</p>

},
keywords = {software testing, Symbolic execution}
}

@software{10.5281/zenodo.11094092,
author = {Pham, Luan and Ha, Huong and Zhang, Hongyu},
title = {Software Artifact for "BARO: Robust Root Cause Analysis for Microservices via Multivariate Bayesian Online Change Point Detection"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11094092},
abstract = {
    <p>This repository contains the Software Artifact for reproducing the main experimental results in our paper accepted to FSE 2024: “BARO: Robust Root Cause Analysis for Microservices via Multivariate Bayesian Online Change Point Detection”</p>
<p>The artifact is also available in the Github repository: https://github.com/phamquiluan/baro</p>

},
keywords = {Anomaly Detection, Microservice Systems, Root Cause Analysis}
}

@software{10.5281/zenodo.11094381,
author = {de Souza, Cleidson R. B. and Ma, Emilie and Wong, Jesse and Yoon, Dongwook and Beschastnikh, Ivan},
title = {Reproduction Package for Article "Revealing Software Development Work Patterns with PR-Issue Graph Topologies"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11094381},
abstract = {
    <p>Scripts and data for quantitative analysis in the above paper. The goal of this work is to enable topological analysis of PR-Issue networks on GitHub via graph database queries, an image generation module, and many statistics scripts. This repository includes:</p>
<ul>
<li>Data scraped from over 50 large open source projects on GitHub and converted into a Neo4j data dump.</li>
<li>Reusable Cypher (Neo4j query language) queries to surface instances of workflow types.</li>
<li>Image generation modules written in Python to visualize workflow types and clusters of Issues and PRs, used during the paper’s qualitative coding process.</li>
<li>Interactive web-based project explorer to aggregate workflow types found in a project, used during developer interviews.</li>
</ul>
<p>These were primarily used to support the qualitative aspects of this paper.</p>

},
keywords = {collaboration, open source, repository mining, software engineering}
}

@software{10.5281/zenodo.11094742,
author = {Wintersgill, Nathan and Stalnaker, Trevor and Heymann, Laura A. and Chaparro, Oscar and Poshyvanyk, Denys},
title = {"The Law Doesn't Work Like a Computer": Exploring Software Licensing Issues Faced by Legal Practitioners - Replication Package},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11094742},
abstract = {
    <p>Contains survey and interview protocols, survey questions, aggregated results, a code catalog for survey and interview responses with definitions, and code to process results. Its purpose is to present the data we obtained from our surveys as well as the tools we used to analyze the data to promote independent verification of our conclusions. All data presented has been anonymized.</p>

},
keywords = {Legal Practitioners, Open Source Software, Software Licensing}
}

@software{10.5281/zenodo.11095172,
author = {Bittner, Paul Maximilian and Schulthei\ss{}, Alexander and Moosherr, Benjamin and Kehrer, Timo and Th\"{u}m, Thomas},
title = {Demo for Article 'Variability-Aware Differencing with DiffDetective'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11095172},
abstract = {
    <p>This is a small demonstration of <a href="https://github.com/VariantSync/DiffDetective">DiffDetective</a> (DOI: 10.5281/zenodo.11095140), and the supplementary artifact to our paper <em>Variability-Aware Differencing with DiffDetective</em>. The purpose of this demo is to provide an example of how to use DiffDetective and to serve as a template project for you to clone and adapt as a quickstart for developing with DiffDetective. There is a screencast available on YouTube, guiding you through the demo’s setup with Maven in IntelliJ and how to implement variability-aware differencing and analyses of Git histories. For further information (including installation instructions and documentation) please head to the respective <a href="https://github.com/VariantSync/DiffDetective-Demo">website</a> or <a href="https://doi.org/10.5281/zenodo.11095172">archive</a>.</p>

},
keywords = {software evolution, software product lines, software variability}
}

@software{10.5281/zenodo.11095274,
author = {Drosos, Georgios-Petros and Sotiropoulos, Thodoris and Spinellis, Diomidis and Mitropoulos, Dimitris},
title = {Artifact for "Bloat beneath Python's Scales: A Fine-Grained Inter-Project Dependency Analysis"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11095274},
abstract = {
    <p>This artifact complements the FSE’24 paper titled “Bloat beneath Python’s Scales: A Fine-Grained Inter-Project Dependency Analysis” by providing comprehensive resources for reproducing its research findings. The artifact includes a meticulously structured dataset, comprising of the code bloat metrics of 1,302 Python projects and their 3,232 dependencies analyzed in the paper. It offers detailed scripts and tools for analyzing software bloat at multiple granular levels—dependencies, files, and methods and reproducing the tables and figures presented in the paper. Additionally, the artifact provides step-by-step instructions for reapplying these analyses and for constructing fine-grained project dependency graphs (FPDGs). Moreover, it includes data on identified software vulnerabilities within bloated code sections, enabling users to recreate the vulnerability assessment presented in the paper. The DOI of the artifact is the following: https://doi.org/10.5281/zenodo.11095274</p>

},
keywords = {call graph, debloating, dependencies, PyPI}, Python, software bloat}
}

@software{10.5281/zenodo.11095396,
author = {Jin, Xin and Lin, Zhiqiang},
title = {SimLLM: Calculating Semantic Similarity in Code Summaries Using a Large Language Model-Based Approach},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11095396},
abstract = {
    <p>This is the artifact for the ACM FSE’2024 paper: “SimLLM: Calculating Semantic Similarity in Code Summaries Using a Large Language Model-Based Approach”.</p>
<p>After downloading the zip file, please read and follow the README.md file to install and use it.</p>

},
keywords = {automated code summarization, large language models, summary semantic similarity}
}

@software{10.5281/zenodo.11095456,
author = {Paltenghi, Matteo and Pradel, Michael},
title = {Reproduction Package for Analyzing Quantum Programs with LintQ: A Static Analysis Framework for Qiskit},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11095456},
abstract = {
    <p>LintQ: A Static Analysis Framework for Qiskit Quantum Programs LintQ is a framework for static analysis of quantum programs written in Qiskit. It comprises:</p>
<ul>
<li>LintQ Core: a set of quantum-specific concepts that supports the definition of static analysis of quantum programs.</li>
<li>LintQ Analyses: a set of analyses build on top of the abstractions offered by the core.</li>
</ul>
<p>Use Cases You can run LintQ with two objectives:</p>
<p>Replication Package Level 1: reproduce the figures and tables from the paper. Replication Package Level 2: analyze a new dataset of quantum programs with LintQ.</p>

},
keywords = {program analysis, quantum computing, software engineering, static analysis}
}

@software{10.5281/zenodo.11096386,
author = {Su, Zian and Xu, Xiangzhe and Huang, Ziyang and Zhang, Zhuo and Ye, Yapeng and Huang, Jianjun and Zhang, Xiangyu},
title = {Reproduction Package for the Article "CodeArt: Better Code Models by Attention Regularization When Symbols Are Lacking"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11096386},
abstract = {
    <p>This artifact includes the code for reproducing the major experiment results in the paper. A docker environment is provided. Data and model checkpoints are hosted on Hugging Face Hub and can be downloaded automatically for experiments.</p>

},
keywords = {Attention Regularization, Code Language Models, Self-supervised Learning}
}

@software{10.5281/zenodo.11097202,
author = {Bouzenia, Islem and Krishan, Bajaj Piyush and Pradel, Michael},
title = {DyPyBench Docker Image},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11097202},
abstract = {
    <p>The first benchmark of Python projects that is large-scale, diverse, ready-to-run (i.e., with fully configured and prepared test suites), and ready-to-analyze (i.e., using an integrated Python dynamic analysis framework). The benchmark encompasses 50 popular open-source projects from various application domains, with a total of 681K lines of Python code, and 30K test cases.</p>

},
keywords = {Benchmarking of Software Systems, Executable collection of software, Program analysis, Python}
}

@software{10.5281/zenodo.11097846,
author = {Xin, Qi and Wu, Haojun and Tang, Jinran and Liu, Xinyu and Reiss, Steven P. and Xuan, Jifeng},
title = {Reproduction Package for Article Detecting, Creating, Repairing, and Understanding Indivisible Multi-Hunk Bugs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11097846},
abstract = {
    <p>The artifact includes the source code of our IBugFinder tool for indivisible bug detection and creation, the new bug dataset CatenaD4J, the result of the study of multi-hunk fixes, and the repair tools and test scripts used in the repair experiment. The artifact is intended to facilitate the evaluation and development of new multi-hunk repair techniques.</p>

},
keywords = {Automated program repair, indivisible multi-hunk bugs, partial patch relationship}
}

@software{10.5281/zenodo.11130683,
author = {Wang, Yiran and L\'{o}pez, Jos\'{e} Antonio Hern\'{a}ndez and Nilsson, Ulf and Varr\'{o}, D\'{a}niel},
title = {Repository of paper - Using Run-time Information to Enhance Static Analysis of Machine Learning Code in Notebooks},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11130683},
abstract = {
    <p>This repository offers a thorough explanation of the experiments detailed in the paper, encompassing detailed documentation of configurations, procedures, intermediate logs, and final results. Its goal is to promote transparency and reproducibility in the research process, empowering others to verify and expand upon the findings presented in the paper.</p>

},
keywords = {large language models, machine learning bugs, notebook, run-time information, static analysis, tensor shape mismatch}
}

@software{10.5281/zenodo.11160861,
author = {Denaro, Giovanni and El Moussa, Noura and Heydarov, Rahim and Lomio, Francesco and Pezz\`{e}, Mauro and Qiu, Ketai},
title = {Reproduction Package for Article `Predicting Failures of Autoscaling Distributed Applications`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11160861},
abstract = {
    <p>This replication package includes:</p>
<p>A large dataset of KPIs collected from Alemira, a commercial Learning Managing System developed in Constructor Tech and currently in use in several educational institutions, and TrainTicket, a microservice application widely used in research projects. Both are microservice-based applications deployed on Kubernetes that takes full advantage of its autoscaling mechanisms.</p>
<p>The results of the experiments of PREFACE, PREdicting Failures in AutosCaling distributEd Applications, the approach presented in our manuscript which predicts and localizes failures in autoscaling distributed applications.</p>
<p>The toolset to execute PREFACE to replicate the results obtained based on the provided dataset.</p>

},
keywords = {Failure Prediction, Fault Localization, Kubernetes}
}

@software{10.5281/zenodo.11168191,
author = {McQueary, Wren and Mim, Sadia Afrin and Raihan, Md Nishat and Smith, Justin and Johnson, Brittany},
title = {Py-holmes FSE 2024 artifact version 1},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11168191},
abstract = {
    <p>Artifact version 1 for FSE 2024, accompanying the paper Py-holmes: Causal Testing for Deep Neural Networks in Python</p>

},
keywords = {Adversarial Sample Generation, Causal Testing, Counterfactual Explanation, Deep Learning}
}

@software{10.5281/zenodo.11180765,
author = {Khan, Nafiz Imtiaz and Filkov, Vladimir},
title = {ReACTive: Visualizing ReACTs and Their Impact on Features},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11180765},
abstract = {
    <p>This artifact contains the dataset of Researched Actionables (ReACTs) and the source code for generating the network figures used in the ReACTive tool. Along with that, this artifact includes all the necessary files to visualize the ReACT tool on the client-side/web browser. These files encompass the HTML, CSS, and JavaScript components that power the tool’s front-end, ensuring a seamless and interactive user experience.</p>

},
keywords = {Literature Review, Open Source Software, Research Actionable, Sustainability}
}

@software{10.5281/zenodo.11186613,
author = {Bettscheider, Leon and Zeller, Andreas},
title = {Replication package for Look Ma, No Input Samples! Mining Input Grammars from Code with Symbolic Parsing},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11186613},
abstract = {
    <p>This replication package contains our prototype implementation of STALAGMITE as a Dockerfile to reproduce the evaluation, as well as experimental data.</p>

},
keywords = {fuzzing, Input grammars, symbolic analysis, test generation}
}

@software{10.5281/zenodo.11194557,
author = {Chen, Zhiyang and Liu, Ye and Beillahi, Sidi Mohamed and Li, Yi and Long, Fan},
title = {Reproduction package of the paper "Demystifying Invariant Effectiveness for Securing Smart Contracts"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11194557},
abstract = {
    <p>This artifact accompanies the paper titled “Demystifying Invariant Effectiveness for Securing Smart Contracts” and provides the source code along with a complete replication package. The purpose of this artifact is to facilitate the validation and reproduction of the research results presented in the paper. Users can explore the methodologies, execute the provided scripts, and verify the findings by using this carefully prepared package.</p>
<p>The main artifact repo is https://github.com/Trace2Inv-Artifact/Trace2Inv-Artifact-FSE24.git, which also contains instructions for using Docker</p>
<p>For results related to the invariant study discussed in the paper, please refer to a separate repository available at <a href="https://github.com/Trace2Inv-Artifact/Trace2Inv-Invariant-Study-FSE24">another separate repository</a></p>
<p>For benchmarks used in this paper, please refer to a separate repository available at <a href="https://github.com/Trace2Inv-Artifact/Trace2Inv-Benchmarks">another separate repository</a></p>

},
keywords = {Blockchain, Dynamic Analysis, Invariant Generation, Program Analysis, Runtime Guard, Security, Smart Contract}
}

@software{10.5281/zenodo.11199120,
author = {Akhoundali, Jafar and Nouri, Sajad Rahim and Rietveld, Kristian and Gadyatskaya, Olga},
title = {MoreFixes: Largest CVE dataset with fixes, Source code for "MoreFixes"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11199120},
abstract = {
    <p>There are two artifacts in this project, one of them is the source code and the other one is the dataset produced by it.</p>
<p>Dataset: <code>cvedataset-patches.zip</code> file contains fix patches, and <code>dump_morefixes_27-03-2024_19_52_58.sql.zip</code> contains a postgtesql dump of fixes, together with several other fields such as CVEs, CWEs, repository meta-data, commit data, file changes, method changed, etc. https://zenodo.org/records/11199120</p>
<p>Source code: https://zenodo.org/records/11110595</p>
<p>Specific steps to run and use the artifacts is documented on their description.</p>

},
keywords = {dataset, ecurity vulnerabilities, security metrics, vulnerability identification, vulnerability repair}
}

@software{10.5281/zenodo.11210209,
author = {Caddy, James and Treude, Christoph},
title = {Prioritising GitHub Priority Labels - Data Set and Software},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11210209},
abstract = {
    <p>This is the data set and software produced for the paper Prioritising GitHub Priority Labels, J. Caddy and C. Treude.</p>
<p>The CSV file contains a manually categorised set of GitHub issue labels that are priority-related. They have been ranked and normalised into three values; “High”, “Medium”, and “Low” priorities. These labels have been gathered from the 5000 most-starred repositories on GitHub as of 2022-06-01.</p>
<p>The Python script makes use of this data set as an example, and will retrieve the highest priority issues from all of the repositories contributed to by the author specified.</p>
<p>Run the python script from the same directory as the CSV file, providing the username you wish to see the highest priority issues for as the first command line argument. Supply your GitHub Personal Access Token either at the prompt so it’s not displayed, or as the second command line argument.</p>

},
keywords = {GitHub issues, issue labels, task priority}
}

@software{10.5281/zenodo.11406940,
author = {Chen, Yuntianyi and Huai, Yuqi and Li, Shilong and Hong, Changnam and Garcia, Joshua},
title = {ConfVE},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11406940},
abstract = {
    <p>Source code and data of ConfVE</p>

},
keywords = {Autonomous driving systems, Software configuration}
}

@software{10.5281/zenodo.11498333,
author = {Jayasuriya, Dhanushka and Terragni, Valerio and Dietrich, Jens and Blincoe, Kelly},
title = {Replication Package for Understanding the Impact of APIs Behavioral Breaking Changes on Client Applications},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11498333},
abstract = {
    <p>This repository contains the replication package for the paper Understanding the Impact of APIs Behavioral Breaking Changes on Client Applications. This paper will be published in the Proceedings of the ACM on Software Engineering journal. The replication package includes the scripts and data we extracted, leading us to our findings.</p>

},
keywords = {behavioral breaking changes, breaking changes, software dependency, software evolution, software libraries}
}

@software{10.5281/zenodo.11528723,
author = {Landauer, Max and Skopik, Florian and Wurzenberger, Markus},
title = {Reproduction package for article "A Critical Review of Common Log Data Sets Used for Evaluation of Sequence-Based Anomaly Detection Techniques"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11528723},
abstract = {
    <p>The repository contains scripts to analyze publicly available log data sets (HDFS, BGL, OpenStack, Hadoop, Thunderbird, ADFA, AWSCTD) that are commonly used to evaluate sequence-based anomaly detection techniques. The repository contains documentation and code to get the data sets, parse and group them into sequences of event types, and apply some basic anomaly detection techniques. The repository also comes with some pre-processed samples in each data set directory, which allow to get started without having to download all the data sets.</p>

},
keywords = {anomaly detection, data sets, log data analysis}
}

@software{10.5281/zenodo.11563223,
author = {Beyer, Dirk and Kettl, Matthias and Lemberger, Thomas},
title = {Reproduction Package for FSE 2024 Article `Decomposing Software Verification Using Distributed Summary Synthesis'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11563223},
abstract = {
    <h2 id="distributed-summary-synthesis">Distributed Summary Synthesis</h2>
<p>We distribute the verification of a single task by dividing the task into smaller verification tasks. We communicate new pre- and violation conditions through messages.</p>
<p>VM username: vagrant VM password: vagrant</p>
<h3 id="system-requirements">System Requirements</h3>
<p>The artifact requires 8 CPU cores and 16 GB of RAM. Additionally, we require 15 GB of empty disk space. The VM was tested on Ubuntu 22.04 with Virtual Box Version 7.0.10 r158379 (Qt5.15.3).</p>
<h3 id="implementation">Implementation</h3>
<p>The core parts of the implementation of DSS can be found in the package <code>~/DSS/cpachecker/src/org/sosy_lab/cpachecker/core/algorithm/distributed_summaries</code>. It contains several packages: - <code>block_analysis</code> (The DSS algorithm) - <code>decomposition</code> (All available decomposition algorithms) - <code>distributed_cpa</code> ((De-)serialization of abstract states for different CPAs) - <code>exchange</code> (Definitions of messages) - <code>visualization</code> (Utility for exporting an HTML report of DSS) - <code>worker</code> (The actors of the actor model) Additionally, we added a BlockCPA to ensure that CPAcheckers’ analysis stays within the assigned block. Its implementation can be found in the package <code>~/DSS/cpachecker/src/org/sosy_lab/cpachecker/cpa/block</code>.</p>
<h3 id="reproduction">Reproduction</h3>
<h4 id="reproduce-the-example-in-the-paper">Reproduce the Example in the Paper</h4>
<p>Navigate to <code>~/DSS</code> and execute <code>./example.sh test/programs/block_analysis/abstraction_safe.c</code>.</p>
<p>CPAchecker will decompose the example program in blocks and verify the program using DSS. The example program is located at <code>~/DSS/cpachecker/test/programs/block_analysis/abstraction_safe.c</code> After DSS finished, an HTML page containing the block graph and a table of messages automatically appears. We use a simplified version of the block graph in our paper, however, the idea and the verification works as described in the paper. In case, it does not appear automatically, execute <code>open ~/DSS/cpachecker/output/block_analysis/visualized/report.html</code>.</p>
<p>Red messages represent violation conditions (ERROR_CONDITION). Yellow messages represent preconditions (BLOCK_POSTCONDITION). The column of the message indicates which block sent the message. On the far left, the passed time in nanoseconds since the start of the execution is displayed.</p>
<p>We observe that blocks “L1” and “L2” send the summary “x = y”. No new violation conditions emerge, therefore DSS finds a proof (FOUND_RESULT in green).</p>
<p>We expect the last messages of “L1” and “L2” in the automatically opened browser tab to look like this:</p>
<pre><code>↓ React to message from &lt;SNIP&gt; (ID: &lt;SNIP&gt;):

Calculated new BLOCK_POSTCONDITION message for &lt;SNIP&gt;

{"readable":"(`=_T(18)` main::x@1 main::y@1)"}</code></pre>
<p>The last lines in the terminal should look like this:</p>
<pre><code>&lt;--SNIP--&gt;
Starting analysis ... (CPAchecker.runAlgorithm, INFO)

Starting block analysis... (BlockSummaryAnalysis.run, INFO)

Decomposed CFA in 6 blocks using the MERGE_DECOMPOSITION. (BlockSummaryAnalysis.run, INFO)

Block analysis finished. (BlockSummaryAnalysis.run, INFO)

Stopping analysis ... (CPAchecker.runAlgorithm, INFO)

Verification result: TRUE. No property violation found by chosen configuration.
More details about the verification run can be found in the directory "./output".
Graphical representation included in the file "./output/Report.html".</code></pre>
<p>Script <code>~/DSS/more_examples.sh</code> runs DSS on more examples with subsequent visual output. DSS should finish verification of programs with the postfix "_safe" in the filename with</p>
<pre><code>Verification result: TRUE. No property violation found by chosen configuration.</code></pre>
<p>and with</p>
<pre><code>Verification result: FALSE. Property violation found by chosen configuration.
More details about the verification run can be found in the directory "./output".</code></pre>
<p>if the postfix is "_unsafe".</p>
<h4 id="reproduce-the-plots-in-the-paper">Reproduce the Plots in the Paper</h4>
<p>Navigate to <code>~/DSS</code> and execute <code>./reproduce-plots.sh</code>.</p>
<p>The script runs <code>./evaluation.py paper-csvs</code> on our original data in <code>paper-csvs</code>. A short while later, the directory <code>~/DSS/plots</code> should open automatically. It contains all reproduced plots. The filenames equal the figure/table numbers in the paper.</p>
<p>For a fast comparison, we copied the original plots to <code>~/DSS/paper-plots</code>. Note that rerunning the script, forcefully removes the directory <code>~/DSS/plots</code> before reproducing them again.</p>
<p>We expect the following output in the terminal:</p>
<pre><code>=======Loading CSVs=======
paper-csvs/forward2.csv has 2549 results for SoftwareSystems.
paper-csvs/dcpa4.csv has 2549 results for SoftwareSystems.
paper-csvs/dcpa8.csv has 2549 results for SoftwareSystems.
paper-csvs/kind.csv has 2549 results for SoftwareSystems.
paper-csvs/dcpa2.csv has 2549 results for SoftwareSystems.
paper-csvs/dcpa1.csv has 2549 results for SoftwareSystems.
paper-csvs/imc.csv has 2549 results for SoftwareSystems.
==========================

Task with most threads (unsolved): 751
Task with most threads (solved): 476 

===Analysis of Overhead===
dcpa8backward analysis time (s)    45.719659
dcpa8decomposition time (s)         0.078870
dcpa8deserialization time (s)      53.193505
dcpa8forward analysis time (s)     21.183128
dcpa8instrumentation time (s)       0.081529
dcpa8proceed time (s)               6.998556
dcpa8serialization time (s)         1.064093
dcpa8cputime (s)                   88.211899
overhead                           54.417997
dtype: float64

Data in sections 'Communication Model' and 'Choice of Decomposition':
Decomposition takes 0.18183334764521225 \% of overall time
Packing takes 1.2062918037371835 \% of overall time
Unpacking takes 60.30196127528197 \% of overall time
==========================

Removed 64 tasks because they contain unsupported features.

Max. speed-up in parallel portfolio 15.912337391444877 

=======Unique tasks=======
ERROR                58
TIMEOUT               2
ERROR (recursion)     1
Name: imcstatus, dtype: int64
DCPA solved 61 tasks uniquely, compared to IMC
ERROR (recursion)    5
TIMEOUT              2
Name: kindstatus, dtype: int64
DCPA solved 7 tasks uniquely, compared to k-Induction
TIMEOUT              9
ERROR (recursion)    4
OUT OF MEMORY        1
Name: forward2status, dtype: int64
DCPA solved 14 tasks uniquely, compared to predicate analysis
==========================
Plots are reproduced and named accordingly</code></pre>
<p>Note that 2549 - 64 = 2485 equals the number of benchmark tasks we describe in the paper.</p>
<h4 id="reproduce-the-experiments">Reproduce the Experiments</h4>
<p>Navigate to <code>~/DSS</code> and execute <code>./reproduce-all.sh</code>.</p>
<p>After a month of computations, the directory containing all plots named according to the number of the respective figure/table in the paper should appear automatically. We store the plots in <code>~/DSS/plots</code>.</p>
<p>Benchexec stores the raw data of the benchmarks in <code>~/DSS/cpachecker/test/results</code>. The CSVs of the raw data are stored in <code>~/DSS/csvs-reproduced</code>. To reproduce the plots with the newly obtained raw data without executing the benchmarks again, run <code>./evaluation.csv csvs-reproduced</code> from <code>~/DSS</code>.</p>
<p>ATTENTION: Rerunning <code>./reproduce-all.sh</code> removes all results in <code>~/DSS/csvs-reproduced</code> and <code>~/DSS/cpachecker/test/results</code> and the progress will be lost.</p>
<p>30 seconds after executing the shell script the output in the terminal should be similar to:</p>
<pre><code>vagrant@vagrant:~/DSS$ ./reproduce-all.sh 
2024-04-30 22:21:02 - WARNING - Ignoring specified resource requirements in local-execution mode, only resource limits are used.
2024-04-30 22:21:02 - INFO - Unable to find pqos_wrapper, please install it for cache allocation and monitoring if your CPU supports Intel RDT (cf. https://gitlab.com/sosy-lab/software/pqos-wrapper).

executing run set 'DCPA1'     (2983 files)
2024-04-30 22:21:02 - INFO - LXCFS is not available, some host information like the uptime leaks into the container.
22:21:02   aws-c-common/aws_add_size_checked_harness.yml                                                                                                                                      EXCEPTION                   18.74   18.90
&lt;--SNIP--&gt;               </code></pre>
<h4 id="reproduce-a-subset">Reproduce a Subset</h4>
<p>Navigate to <code>~/DSS</code> and execute <code>./reproduce-selection.sh</code>.</p>
<p>The script runs our full pipeline of our evaluation on a small subset of 11 tasks. The small selection should illustrate that, in general, the work distributes better when more cores are available and that there are tasks that DSS solves faster than standard predicate analysis (and vice-versa). Additionally, it creates all plots using the newly obtained data.</p>
<p>After approximately 30 minutes, the directory containing all plots appear automatically. The plots are named after the figure/table number in the paper. We store the plots in <code>~/DSS/plots</code>.</p>
<p>The selection contains one unsafe task (a task where function reach_error is indeed reachable) to illustrate DSS’s capability of finding violations. However, as stated in the paper, the evaluation focuses on safe programs. Therefore, the unsafe tasks does not appear in the generated plots/tables.</p>
<p>Benchexec stores the raw data of the benchmarks in <code>~/DSS/cpachecker/test/results</code>. The CSVs of the raw data are stored in <code>~/DSS/csvs-reproduced</code>. To reproduce the plots with the newly obtained raw data without executing the benchmarks again, run <code>./evaluation.csv csvs-selected</code> from <code>~/DSS</code>.</p>
<p>ATTENTION: Rerunning <code>./reproduce-selection.sh</code> removes all results in <code>~/DSS/csvs-selected</code> and <code>~/DSS/cpachecker/test/results</code> and the progress will be lost.</p>
<p>90 seconds after executing the shell script the output in the terminal should be similar to:</p>
<pre><code>vagrant@vagrant:~/DSS$ ./reproduce-selection.sh 
2024-04-30 21:59:46 - WARNING - Ignoring specified resource requirements in local-execution mode, only resource limits are used.
2024-04-30 21:59:46 - INFO - Unable to find pqos_wrapper, please install it for cache allocation and monitoring if your CPU supports Intel RDT (cf. https://gitlab.com/sosy-lab/software/pqos-wrapper).

executing run set 'DCPA1.ReachSafety-Selection'     (11 files)
2024-04-30 21:59:46 - INFO - LXCFS is not available, some host information like the uptime leaks into the container.
21:59:46   ldv-linux-3.4-simple/43_1a_cilled_ok_nondet_linux-43_1a-drivers--char--tpm--tpm_nsc.ko-ldv_main0_sequence_infinite_withcheck_stateful.cil.out.yml                            true                        36.69   37.13
22:00:23   ldv-linux-3.4-simple/43_1a_cilled_ok_nondet_linux-43_1a-drivers--watchdog--sch311x_wdt.ko-ldv_main0_sequence_infinite_withcheck_stateful.cil.out.yml                         true                        42.26   43.08
22:01:07   ldv-linux-3.4-simple/43_1a_cilled_ok_nondet_linux-43_1a-drivers--watchdog--it8712f_wdt.ko-ldv_main0_sequence_infinite_withcheck_stateful.cil.out.yml                         true
&lt;--SNIP--&gt;               </code></pre>
<h4 id="interpret-the-data">Interpret the Data</h4>
<h5 id="benchexec">Benchexec</h5>
<p>Benchexec produces XML results files. They keep track of the used memory, the consumed response time (walltime) and the consumed CPU time per task. Since the data is barely readable for humans, we create CSV files in <code>~/DSS/csvs</code>. The data is organized in a nice table where the columns list the consumed resources per task (row).</p>
<h5 id="plots">Plots</h5>
<p>The plots as described in the paper are stored in <code>~/DSS/paper-plots</code> or can be found in <code>~/DSS/plots</code> after running a reproduction script.</p>
<h3 id="artifact-structure">Artifact Structure</h3>
<p>All tools and data are stored in <code>~/DSS</code>. The VM comes with pre-installed and pre-configured benchexec 3.16. CPAchecker is installed in <code>~/DSS/cpachecker</code>. The SV-COMP benchmark set is cloned into <code>~/DSS/sv-benchmarks</code>. In the beginning, <code>~/DSS</code> contains the following files: - <code>~/DSS/evaluation.py</code>: Python script to reproduce the plots. - <code>~/DSS/example.sh</code>: Shell script to reproduce the example in the paper with CPAchecker - <code>~/DSS/LICENSE</code>: LICENSE of the artifact. - <code>~/DSS/ReadMe.md</code>: This file. - <code>~/DSS/removed.txt</code>: 64 excluded tasks from the benchmark set due to unsupported features. - <code>~/DSS/reproduce-all.sh</code>: Script to reproduce the full evaluation. - <code>~/DSS/reproduce-selection.sh</code>: Script to reproduce parts of our evaluation. - <code>~/DSS/reproduce-plots.sh</code>: Script to reproduce all plots on the raw data of our runs. - <code>~/DSS/requirements.md</code>: Lists all requirements and shows what which commands we executed to create this VM. - <code>~/DSS/requirements.txt</code>: List of required and already installed python packages. - <code>~/DSS/software-systems.csv</code>: All tasks belonging to the software-systems category of SV-benchmarks. - <code>~/DSS/INSTALL.md</code>: Instructions for installing CPAchecker and how to check if the VM works as intended. - <code>~/DSS/more_examples.sh</code>: A small collection of examples including visual representation after calculation finished.</p>

},
keywords = {Block Summaries, Decomposition Strategies, Parallelization, Program Analysis, Software Model Checking}
}

@software{10.5281/zenodo.8252997,
author = {Chen, Tao and Li, Miqing},
title = {Reproduction package for "Adapting Multi-objectivized Software Configuration Tuning"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8252997},
abstract = {
    <p>The artifact contains the same code from Github: https://github.com/ideas-labo/admmo</p>

},
keywords = {Configuration tuning, multi-objectivization, search based software engineering}
}

@software{10.5281/zenodo.8388488,
author = {Song, Yahui and Gao, Xiang and Li, Wenhua and Chin, Wei-Ngan and Roychoudhury, Abhik},
title = {ProveNFix: Temporal Property guided Program Repair},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.8388488},
abstract = {
    <p>This is the supporting data from a paper submission to FSE24, including the source code and the benchmarks, by the time of the submission.</p>
<p>However, please check out the latest implementation and documentation (and paper) on Github: https://github.com/songyahui/infer_TempFix.</p>
<p>The summary of all the bugs in different projects is in the folder “notes.zip”; the appendixes are attached.</p>
<p>We recommend you to try out our docker image with all the benchmarked integrated and configured inside:</p>
<p>https://github.com/songyahui/infer_TempFix/blob/main/ProveNFix_Artifact_Evaluation.pdf</p>

},
keywords = {Design Science, Program analysis, Program repair, Program synthesis, Programming languages}
}

@software{10.6084/m9.figshare.22358095.v1,
author = {Deb, Sourav and Jain, Kush and van Tonder, Rijnard and Le Goues, Claire and Groce, Alex},
title = {Artifact for Syntax Is All You Need: A Universal-Language Approach to Mutant Generation},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.22358095.v1},
abstract = {
    <p>This artifact contains: 1. Source code of the tool we built 2. Mutation Scripts for Java, C++, Python, Rust 3. Script to mine repositories from github 4. Script for random-sampling of mutant files 5. Script for picking the largest source file under 20 KB for a cloned github project 6. The list of projects from github we used for experimentation 7. Readme file describing how to reproduce the results</p>

},
keywords = {Bash Scripting, Program Mutants, Python}
}

@software{10.6084/m9.figshare.24129996.v1,
author = {Hassan, Md Mahadi and Salvador, John and Santu, Shubhra Kanti Karmaker and Rahman, Akond},
title = {State Reconciliation Defects in Infrastructure as Code},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24129996.v1},
abstract = {
    <p>This repository contains all materials to reproduce the results in the paper titled ‘State Reconciliation Defects in Infrastructure as Code’</p>

},
keywords = {Ansible, infrastrcuture as code, Large Language Models (LLM), software bug}
}

@software{10.6084/m9.figshare.24216858.v2,
author = {Islam, Mohayeminul and Jha, Ajay Kumar and Akhmetov, Ildar and Nadi, Sarah},
title = {Characterizing Python Library Migrations - artifacts},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24216858.v2},
abstract = {
    <p>The data and scripts related to the paper</p>

},
keywords = {Migration, migration-related code changes, Python}
}

@software{10.6084/m9.figshare.24258439.v2,
author = {\"{O}qvist, Karl and Messinger, Jacob and Wohlrab, Rebekka},
title = {Supporting Early Decision-Making Through Tradeoff Analysis for Cloud-Based Software Systems: Supplementary Material},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24258439.v2},
abstract = {
    <p>Supplementary material, including the interview guide, plots, information about the study design, and analysis results.</p>

},
keywords = {analysis results, information about the study design, Interview guide, plots}
}

@software{10.6084/m9.figshare.24798264.v4,
author = {Kim, Yoel and Choi, Yunja},
title = {Reproduction Package (Docker Image) for the FSE 2024 Article ‘PBE-based Abstraction and Refinement for Efficient Property Falsification of Embedded Software'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.24798264.v4},
abstract = {
    <p>The docker image file of PBEAR and script files to execute it.</p>

},
keywords = {model checking}
}

@software{10.6084/m9.figshare.25999807.v1,
author = {Misu, Md Rakib Hossain and Lopes, Cristina V. and Ma, Iris and Noble, James},
title = {Artifacts@FSE24: Towards AI-Assisted Synthesis of Verified Dafny Methods},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.25999807.v1},
abstract = {
    <p>This release presents the artifact of our work “Towards AI-Assisted Synthesis of Verified Dafny Methods.” This release has been reviewed in FSE24@Artifacts-Evaluation.</p>
<p>In this work, we conduct the first empirical study of LLMs synthesizing verifiable Dafny methods. Using 178 programming problems from the MBPP dataset, we prompt two contemporary models (GPT-4 and PaLM-2) to synthesize methods in Dafny. We demonstrate that a prompt following the principles of Chain of Thought (CoT) with semantically similar few-shot examples explaining how to decompose a problem step-by-step, can synthesize verified and correct Dafny methods with meaningful specifications for 58\% of problems in our test dataset.</p>
<p>The primary purpose of this artifact is to provide a benchmark dataset MBPP-DFY-153, a collection of 153 programming problems with specifications, solutions, and tests in/for Dafny, based on the MBPP (Mostly Basic Python Programming) dataset curated by Google Research. By executing our scripts, researchers should be able to try different prompts and synthesize Dafny methods from natural language problem descriptions. Scripts are also available to run verification and tests for all verified Dafny methods.</p>
<p>This release has been prepared to claim three badges: “Available”, “Reusable” and “Functional”. For a thorough evaluation of our artifact, we suggest that reviewers have familiarity with Dafny, and its installation, Bash scripts, and UNIX command-line operations. Artifacts related to our paper are publicly accessible in our GitHub repository at Artifacts@FSE24-Reviewed.</p>

},
keywords = {Dafny, LLM, Program Synthesis, Program Verification}
}

@software{10.5281/zenodo.11070973,
author = {Beyer, Dirk and Chien, Po-Chun and Jankola, Marek and Lee, Nian-Ze},
title = {Reproduction Package for FSE 2024 Article `A Transferability Study of Interpolation-Based Hardware Model Checking for Software Verification'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11070973},
abstract = {
    <p>This artifact is a reproduction package for the article “A Transferability Study of Interpolation-Based Hardware Model Checking for Software Verification”, accepted at FSE 2024. It is archived on Zenodo with the DOI 10.5281/zenodo.11070973.</p>
<p>The FSE article investigates the transferability of the claims reported in two prior publications on interpolation-based hardware model checking to software verification. The two publications are (1) Interpolation-Sequence-Based Model Checking (Vizel and Grumberg, 2009) and (2) Intertwined Forward-Backward Reachability Analysis Using Interpolants (Vizel, Grumberg, and Shoham, 2013), proposing model-checking algorithms ISMC and DAR for hardware circuits, respectively. In the FSE article, we adopted ISMC and DAR for programs and implemented them in a software-verification framework CPAchecker. This artifact supports the reproduction of the experiments in the FSE article, which compared the implementations of ISMC and DAR against existing interpolation-based verification techniques in CPAchecker, including IMC (McMillan, 2003), Impact (McMillan, 2006), and PredAbs (Henzinger, Jhala, Majumdar, and McMillan, 2004), to validate the claims in the above two publications as well as investigate their performance characteristics versus classical approaches for software verification.</p>
<p>The artifact consists of source code, precompiled executables, and input data used in the evaluation of the transferability study, as well as the results produced from the experiments. Specifically, it includes the source code and binaries of CPAchecker (at revision 45787 of branch “itp-mc-with-slt”), which implements the verification algorithms compared in the article, the SV-COMP 2023 benchmark suite, the experimental data generated from the evaluation, and instructions to run the tools and experiments.</p>
<p>This reproduction package works best with the SoSy-Lab Virtual Machine, which runs Ubuntu 22.04 LTS and has all the required dependencies installed. If you test this artifact with this VM, you do not need to install any package.</p>
<p>By default, we assign 2 CPU cores, 15 GB of memory, and 1800 s of CPU time limit to each verification task. A full reproduction of all experiments took more than 10 months of CPU time on our machines. For demonstration purposes, a subset of the benchmark tasks can be executed, which requires roughly 2 hours of CPU time in total.</p>

},
keywords = {CPAchecker, Craig Interpolation, Formal Verification, Invariant Synthesis, Model Checking, Program Analysis, Replicability, Reproducibility, Software Verification, Transferability}
}

@software{10.5281/zenodo.11233589,
author = {Bahr, Patrick and Hutton, Graham},
title = {Supplementary Material for "Beyond Trees: Calculating Graph-Based Compilers"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11233589},
abstract = {
    <p>This repository contains the supplementary material for the paper Beyond Trees: Calculating Graph-Based Compilers. The material includes Agda formalisations of all calculations in the paper. In addition, further examples and calculations are included as well.</p>

},
keywords = {graphs, higher-order abstract syntax, program calculation}
}

@software{10.5281/zenodo.11363460,
author = {Song, Yahui and Foo, Darius and Chin, Wei-Ngan},
title = {Specification and Verification for Unrestricted Algebraic Effects and Handling},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11363460},
abstract = {
    <p>This repository serves for the artifact evaluation for the ICFP24 (#95) submission: Specification and Verification for Unrestricted Algebraic Effects and Handling.</p>

},
keywords = {Automated Verification, Effectful Specification Logic, Multi-shot Continuations, Separation Logic}
}

@software{10.5281/zenodo.11429428,
author = {Xue, Xu and Oliveira, Bruno C. d. S.},
title = {Contextual Typing (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11429428},
abstract = {
    <p>The artifact includes the Agda formalisation of the paper “Contextual Typing”.</p>

},
keywords = {Bidirectional Typing, Type Inference}
}

@software{10.5281/zenodo.11470739,
author = {Michelland, S\'{e}bastien and Zakowski, Yannick and Gonnord, Laure},
title = {Replication package for article: Abstract Interpreters: a Monadic Approach to Modular Verification},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11470739},
abstract = {
    <p>This software package is a Docker image and tarball of a project about building abstract interpreters out of a monadic denotation of source languages. The Docker image contains the tools needed to check the project’s proof scripts, namely opam, the Coq proof assistant, and a few Coq libraries.</p>

},
keywords = {Abstract Interpretation, Coq, Formal Verification, Interaction Trees, Monadic Semantics}
}

@software{10.5281/zenodo.11470781,
author = {Mulleners, Niek and Jeuring, Johan and Heeren, Bastiaan},
title = {Example-Based Reasoning About the Realizability of Polymorphic Programs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11470781},
abstract = {
    <p>This is the code accompanying the ICFP ’24 paper “Example-Based Reasoning About the Realizability of Polymorphic Programs”. It includes the source code, as well as a virtual image containing the same sources, but with all dependencies installed.</p>

},
keywords = {container functors, example propagation, parametricity, program synthesis, unrealizability}
}

@software{10.5281/zenodo.11481248,
author = {Gregersen, Simon Oddershede and Aguirre, Alejandro and Haselwarter, Philipp G. and Tassarotti, Joseph and Birkedal, Lars},
title = {Almost-Sure Termination by Guarded Refinement - Coq Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11481248},
abstract = {
    <p>This artifact contains the Coq development accompanying the ICFP 2024 submission “Almost-Sure Termination by Guarded Refinement”.</p>
<p>coq-caliper.tar.gz contains the Coq development which includes a README with instructions for installing dependencies and building the development. The archive also contains PAPER that maps definitions and results from the paper to its formalization.</p>
<p>docker-caliper.tar.gz contains a pre-built Docker image with dependencies and the Coq development already installed. Suggested commands for loading, rebuilding, and interacting with the image is shown below. The Docker image is built using the instructions found in Dockerfile. Note that building the Dockerfile requires coq-caliper.tar.gz to be available in the same folder.</p>

},
keywords = {almost-sure termination, coq, probabilistic coupling, separation logic}
}

@software{10.5281/zenodo.11489778,
author = {Aguirre, Alejandro and Haselwarter, Philipp G. and de Medeiros, Markus and Li, Kwing Hei and Gregersen, Simon Oddershede and Tassarotti, Joseph and Birkedal, Lars},
title = {Error Credits: Resourceful Reasoning about Error Bounds for Higher-Order Probabilistic Programs - Coq Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11489778},
abstract = {
    <p>This is the artifact of the Eris logic, highlighted in the ICFP 2024 submission “Error Credits: Resourceful Reasoning about Error Bounds for Higher-Order Probabilistic Programs”.</p>
<p>The logic is built using the Iris program logic framework and mechanized in the Coq proof assistant.</p>
<p>This project is built on top of the Clutch project.</p>

},
keywords = {almost-sure termination, Coq, error bounds, error credits, Iris}
}

@software{10.5281/zenodo.11491613,
author = {Carette, Jacques and Heunen, Chris and Kaarsgaard, Robin and Sabry, Amr},
title = {Software for "How to Bake a Quantum Pi"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11491613},
abstract = {
    <p>Agda source code and qemu VM for the implementation of the programming language described in the paper. Also contains runnable tests as well as some proofs reasoning with programs in QuantumPi.</p>

},
keywords = {quantum programming language, reversible computing, rig category, unitary quantum computing}
}

@software{10.5281/zenodo.11493754,
author = {Xia, Li-yao and Israel, Laura and Kramarz, Maite and Coltharp, Nicholas and Claessen, Koen and Weirich, Stephanie and Li, Yao},
title = {Story of Your Lazy Function's Life: A Bidirectional Demand Semantics for Mechanized Cost Analysis of Lazy Programs (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11493754},
abstract = {
    <p>The Coq formalization of paper “Story of Your Lazy Function’s Life: A Bidirectional Demand Semantics for Mechanized Cost Analysis of Lazy Programs”.</p>
<p>Original abstract of the paper:</p>
<p>Lazy evaluation is a powerful tool that enables better compositionality and potentially better performance in functional programming, but it is challenging to analyze its computation cost. Existing works either require manually annotating sharing, or rely on separation logic to reason about heaps of mutable cells. In this paper, we propose a bidirectional demand semantics that allows for reasoning about the computation cost of lazy programs without relying on special program logics. To show the effectiveness of our approach, we apply the demand semantics to a variety of case studies including insertion sort, selection sort, Okasaki’s banker’s queue, and the implicit queue. We formally prove that the banker’s queue and the implicit queue are both amortized and persistent using the Rocq Prover (formerly known as Coq). We also propose the reverse physicist’s method, a novel variant of the classical physicist’s method, which enables mechanized, modular and compositional reasoning about amortization and persistence with the demand semantics.</p>

},
keywords = {amortized analysis, computation cost, Coq, formal verification, lazy evaluation}
}

@software{10.5281/zenodo.11494317,
author = {De Santo, No\'{e} and Barri\`{e}re, Aur\`{e}le and Pit-Claudel, Cl\'{e}ment},
title = {Artifact for "A Coq Mechanization of JavaScript Regular Expression Semantics" at ICFP 2024},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11494317},
abstract = {
    <p>The artifact consists of a virtual machine with our Coq mechanization, our proof scripts, and our auxiliary code (fuzzer, tests), as well as scripts to recreate the virtual machine from scratch.</p>

},
keywords = {Coq, ECMAScript, Mechanization, Regex}
}

@software{10.5281/zenodo.11498450,
author = {Torrens, Paulo and Orchard, Dominic and Vasconcellos, Cristiano},
title = {Artifact for "On the Operational Theory of the CPS-calculus"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11498450},
abstract = {
    <p>Archived copy of the artifact for the paper “On the Operational Theory of the CPS-calculus: Towards a Theoretical Foundation for IRs”, submitted to ICFP24.</p>

},
keywords = {Continuations, intermediate representations, strong normalization.}
}

@software{10.5281/zenodo.11500453,
author = {Ho, Son and Fromherz, Aymeric and Protzenko, Jonathan},
title = {Artifact for: Sound Borrow-Checking for Rust via Symbolic Semantics},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11500453},
abstract = {
    <h2 id="paper-abstract">Paper Abstract</h2>
<p>The Rust programming language continues to rise in popularity, and as such, warrants the close attention of the programming languages community. In this work, we present a new foundational contribution towards the theoretical understanding of Rust’s semantics. We prove that LLBC, a high-level, borrow-centric model previously proposed for Rust’s semantics and execution, is sound with regards to a low-level pointer-based language \`{a} la CompCert. Specifically, we prove the following: that LLBC is a correct view over a traditional model of execution; that LLBC’s symbolic semantics are a correct abstraction of LLBC programs; and that LLBC’s symbolic semantics act as a borrow-checker for LLBC, i.e.&nbsp;that symbolically-checked LLBC programs do not get stuck when executed on a heap-and-addresses model of execution.</p>
<p>To prove these results, we introduce a new proof style that considerably simplifies our proofs of simulation, which relies on a notion of hybrid states. Equipped with this reasoning framework, we show that a new addition to LLBC’s symbolic semantics, namely a join operation, preserves the abstraction and borrow-checking properties. This in turn allows us to add support for loops to the Aeneas framework; we show, using a series of examples and case studies, that this unlocks new expressive power for Aeneas.</p>
<h2 id="artifact-description">Artifact Description</h2>
<p>The artifact contains the Aeneas project modified to integrate the changes described in the paper to support loops (section 5). It also contains the tests we refer to in section 6. In addition to the virtual machine, we provide two different ways of building the sources and running the tests: - either you use <strong>nix</strong> (easy) - or you build the <strong>Rust</strong> and <strong>OCaml</strong> sources with cargo and dune (more work)</p>

},
keywords = {Compiler, Semantics}
}

@software{10.5281/zenodo.11500626,
author = {Chen, Yijia and Parreaux, Lionel},
title = {The Long Way to Deforestation: A Type Inference and Elaboration Technique for Removing Intermediate Data Structures (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11500626},
abstract = {
    <p>This artifact consists of an <code>sbt</code> project with a Scala implementation of Lumberhack as introduced in the corresponding paper. Lumberhack aims to improve the efficiency of programs by eliminating intermediate data structures. We provide a test suite containing all the examples in the paper and all the <code>nofib</code> benchmarks we have ported and presented in the paper. Related scripts in bash, R and Python to generate the figures and tables in the paper are also contained in this artifact.</p>

},
keywords = {Compiler, Deforestation, OCaml, Optimization, Scala, Type Inference}
}

@software{10.5281/zenodo.11500966,
author = {Winterhalter, Th\'{e}o},
title = {ICFP 2024 Artefact: Dependent Ghosts Have a Reflection for Free},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11500966},
abstract = {
    <p>Coq formalisation of the submission ‘Dependent Ghosts Have a Reflection for Free’.</p>
<p>A README is provided in the zip file. It also explains how to run the VM provided as a QEMU file (artefact.qcow2).</p>

},
keywords = {coq formalisation, dependent types, ghost data}
}

@software{10.5281/zenodo.11502426,
author = {Melquiond, Guillaume and Moreau, Josu\'{e}},
title = {A Safe Low-level Language for Computer Algebra and its Formally Verified Compiler},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11502426},
abstract = {
    <p>This is the artifact for submission A Safe Low-level Language for Computer Algebra and its Formally Verified Compiler at ICFP’24.</p>

},
keywords = {compiler, formal proof, programming language, safety}
}

@software{10.5281/zenodo.11507455,
author = {Kura, Satoshi and Unno, Hiroshi},
title = {Artifact for "Automated Verification of Higher-Order Probabilistic Programs via a Dependent Refinement Type System"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11507455},
abstract = {
    <p>The artifact is to reproduce the experimental result (Table 2) in the paper.</p>

},
keywords = {dependent refinement type system, higher-order program}
}

@software{10.5281/zenodo.11508050,
author = {Kurashige, Cole and Ji, Ruyi and Giridharan, Aditya and Barbone, Mark and Noor, Daniel and Itzhaky, Shachar and Jhala, Ranjit and Polikarpova, Nadia},
title = {CCLemma: E-Graph Guided Lemma Discovery for Inductive Equational Proofs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11508050},
abstract = {
    <p>Artifact for ICFP’24: CCLemma: E-Graph Guided Lemma Discovery for Inductive Equational Proofs.</p>
<p>C.C. Lemma is a tool for automating equational proofs. It is implemented as a command-line tool that takes as input a file specifying inductive datatype definitions, function definitions, and equalities over these datatypes and functions. It attempts to prove each equality, optionally outputting a proof in Liquid Haskell*.</p>
<p>We include with our tool all of the datasets necessary to run the evaluation from our paper as well as scripts and instructions on how to reproduce our results. We also include the tools we evaluate against, which the scripts will also run.</p>
<p>Our code can be found at https://github.com/cole-k/cc-lemma/tree/icfp-24.</p>
<p>C.C. Lemma is implemented in Rust. At this time we do not expect there to be any special requirements for machines: modern laptops are sufficient, although even older machines ought to work fine. Some benchmarks, especially many in the optimization dataset, will run to timeout. We estimate running all benchmarks to take around 120 minutes in the worst-case; however, by default we set a much lower timeout so that testing the tool will only take a few minutes.</p>
<p>*Proof emission is experimental and not guaranteed to generate proofs that Liquid Haskell accepts, although users may find it useful to inspect the proofs to see how C.C. Lemma proved an equality.</p>

},
keywords = {Automated Theorem Proving, Equational Reasoning, Lemma Synthesis, Synthesis, Verification}
}

@software{10.5281/zenodo.11906121,
author = {Quiring, Benjamin and Van Horn, David},
title = {Experiments for "Deriving with Derivatives: Optimizing Incremental Fixpoints for Higher-Order Flow Analysis"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.11906121},
abstract = {
    <p>This artifact contains the current implementation of the compiler for the 3CPS compiler and fixpoint methods for its static analysis. It also contains the benchmark programs from the paper, and a script to the run the experiments.</p>

},
keywords = {compiler, fixpoint, higher-order, incremental-computation, Standard ML, static analysis}
}

@software{10.5281/zenodo.12518800,
author = {Beck, Calvin and Yoon, Irene and Chen, Hanxi and Zakowski, Yannick and Zdancewic, Steve},
title = {Development for "A Two-Phase Infinite/Finite Low-Level Memory Model"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12518800},
abstract = {
    <p>This paper provides a novel approach to reconciling complex low-level memory model features, such as pointer–integer casts, with desired refinements that are needed to justify the correctness of program transformations. The idea is to use a “two-phase” memory model, one with an unbounded memory and corresponding unbounded integer type, and one with a finite memory; the connection between the two levels is made explicit by a notion of refinement that handles out-of-memory behaviors. This approach allows for more optimizations to be performed and establishes a clear boundary between the idealized semantics of a program and the implementation of that program on finite hardware.</p>
<p>The two-phase memory model has been incorporated into an LLVM IR semantics, demonstrating its utility in practice in the context of a low-level language with features like undef and bitcast. This yields infinite and finite memory versions of the language semantics that are proven to be in refinement with respect to out-of-memory behaviors. Each semantics is accompanied by a verified executable reference interpreter. The semantics justify optimizations, such as dead-alloca-elimination, that were previously impossible or difficult to prove correct.</p>
<p>The artifact contains the development including the Coq proofs of the important theorems. The source code can be used to build the executable interpreter as well, which can execute LLVM programs. A VM is included with all of the dependencies pre-installed.</p>

},
keywords = {Coq, integer--pointer casts, llvm, memory models, ocaml, semantics, vellvm}
}

@software{10.5281/zenodo.12656335,
author = {Kov\'{a}cs, Andr\'{a}s},
title = {ICFP 2024 artifact - "Closure-Free Functional Programming in a Two-Level Type Theory"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12656335},
abstract = {
    <p>Artifact for the paper “Closure-Free Functional Programming in a Two-Level Type Theory”</p>

},
keywords = {staged compilation, two-level type theory}
}

@software{10.5281/zenodo.12659179,
author = {Vandenbogaerde, Bram and Sti\'{e}venart, Quentin and De Roover, Coen},
title = {Blame-Correct Support for Receiver Properties in Recursively-Structured Actor Contracts (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12659179},
abstract = {
    <p>This replication package contains an executable semantics as a PLT-Redex implementation for the formalisation presented in the paper titled “Blame-Correct Support for Receiver Properties in Recursively-Structured Actor Contracts”. It also contains an implementation of our contract language in Racket. This implementation is used for testing all examples presented in the paper which are also included in the replication package. Finally, the replication package also contains a virtual machine image which contains all prerequisites for running the replication package.</p>

},
keywords = {actors, design-by-contract, formalisation, plt-redex, racket}
}

@software{10.5281/zenodo.12684335,
author = {Elsman, Martin},
title = {Artifact for the ICFP 2024 paper Double-Ended Bit-Stealing for Algebraic Data Types},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12684335},
abstract = {
    <p>The artifact aims at replicating the performance results reported in the paper.</p>

},
keywords = {Compilation, Data-type representations, Functional languages, Unboxing}
}

@software{10.5281/zenodo.12702677,
author = {Chen, Jiawei and de Mendon\c{c}a, Jos\'{e} Luiz Vargas and Ayele, Bereket Shimels and Bekele, Bereket Ngussie and Jalili, Shayan and Sharma, Pranjal and Wohlfeil, Nicholas and Zhang, Yicheng and Jeannin, Jean-Baptiste},
title = {Artifact for "Synchronous Programming with Refinement Types"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12702677},
abstract = {
    <p>Experimental data, source code, and an executable artifact image for MARVeLus, based on the Z\'{e}lus project.</p>

},
keywords = {refinement types, robotics, synchronous programming}
}

@software{10.5281/zenodo.12704905,
author = {Binder, David and Tzschentke, Marco and M\"{u}ller, Marius and Ostermann, Klaus},
title = {Grokking the Sequent Calculus (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12704905},
abstract = {
    <p>A Haskell implementation of the algorithms described in the paper, together with a parser and type inference algorithm for the surface language. Code snippets can be run either on the console or via a web interface.</p>

},
keywords = {compiler, intermediate representations, sequent calculus}
}

@software{10.5281/zenodo.12792675,
author = {Serrano, Manuel and Findler, Robert Bruce},
title = {The Functional, the Imperative, and the Sudoku (artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12792675},
abstract = {
    <p>This artifact will let you run the HipHop solver described in the companion paper and let you conduct some experiments with new puzzles and solver extensions. The objective is to offer you a taste of programming in HipHop. For that, first, we briefly present the structure and organization of the solver and then we suggest three assignments to get you familiar with HipHop and the codebase.</p>
<p>The artifact has no special requirement. It can be run within the provided virtual machine or installed locally using the GIT repository:</p>
<pre><code>The VM can be download at: https://zenodo.org/records/11481893
The source of the artifact is available at: https://github.com/manuel-serrano/icfp2024-sudoku</code></pre>

},
keywords = {Esterel, HipHop, JavaScript, Sudoku}
}

@software{10.1145/3580437,
author = {Keating, Finnbar and Gale, Michael B.},
title = {Oxbow implementation for `Functional Reactive Programming, Rearranged'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580437},
abstract = {
    <p>This artifact is an implementation of Oxbow as described in the paper <em>Functional Reactive Programming, Rearranged</em> [Keating and Gale 2024]. It includes the full type-level implementation described in Section 5, and the full corpus and test results of our benchmarks.</p>

},
keywords = {arrowised functional reactive programming, arrows, functional reactive programming, haskell}
}

@software{10.17861/68b8a67f-2684-47fa-bcec-1f97dcb98446,
author = {Ramsay, Craig and Stewart, Robert},
title = {Dataset for "Cloaca: A Concurrent Hardware Garbage Collector for Non-Strict Functional Languages"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.17861/68b8a67f-2684-47fa-bcec-1f97dcb98446},
abstract = {
    <p>This dataset provides the sources for the Heron (including the Cloaca GC), its testing, and scripts used to generate the paper’s results. Where possible, each directory comes with a README guide and a nix environment to assist reproducibility.</p>

},
keywords = {Functional languages, Functional verification, High-level language architectures, Memory management}
}

@software{10.5281/zenodo.12771956,
author = {Garby, Zac and Hutton, Graham and Bahr, Patrick},
title = {Haskell and Agda code for the article "Calculating Compilers Effectively"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12771956},
abstract = {
    <p>The Haskell and Agda source code for the paper</p>
<p>Calculating Effectful Compilers</p>
<p>Haskell (print.hs, state.hs, non-det.hs)</p>
<p>In these files we give practical implementations of each of the three effects we consider in the paper. For each one, we include the full source code as described in the paper itself, and full definitions for each of the concrete effect interpretations.</p>
<p>Agda (print.agda, state.agda, non-det.agda, lemmas.agda)</p>
<p>As noted in the paper, we use Agda to formally verify the correctness of our calculations. These four files constitute those proofs. We use function extensionality, which is postulated in lemmas.agda.</p>
<p>Each Agda file begins by translating the types and functions from Haskell into Agda’s syntax. We prove all relevant results:</p>
<pre><code> * The functor and monad laws for each effect type

 * Compiler correctness

      exec (comp e c) s = do v &lt;- eval e; exec c (v : s)

 * Correctness of the fusion of run and exec:

      exec' c s = run (exec c s) </code></pre>
<p>There are some differences between the Agda presentation and that given in the paper. In particular:</p>
<pre><code> * Agda does not like partial functions, so we augment the stack
   with an arity (essentially making it a vector) and the code with
   tags to describe how it transforms the shape of the stack.  This
   is a standard, straightforward transformation which doesn't
   affect the validity of the proofs, but keeps Agda happy.

 * Agda's 'do' notation only permits one monad per file.  So we are
   forced to translate the IO 'do' blocks into binds and lambdas.

 * The calculations are presented as "calculational proofs".  Agda
   does not provide any utility for calculating data types and
   functions *during* equational proofs, so we structure these by
   first writing down the calculated definition and then following
   up with the proof that it is correct.

   These proofs, while technically not calculations, still follow the
   same steps as in the paper, so the reader can follow along.</code></pre>

},
keywords = {Agda, algebraic effects, compilers, Haskell, program calculation}
}

@software{10.5281/zenodo.12774237,
author = {Vasconcelos, Pedro and Marques, Rodrigo},
title = {Haskelite implementation},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12774237},
abstract = {
    <p>An implementation of a web-based step-by-step interpreter for a subset of Haskell.</p>

},
keywords = {interpreters, lazy evaluation, operational semantics, pattern matching, teaching}
}

@software{10.1145/3580433,
author = {Cao, Ying and Zhang, Runze and Liang, Ruigang and Chen, Kai},
title = {Reproduction Package for Paper "Evaluating the Effectiveness of Decompilers"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580433},
abstract = {
    <p>The source code consists of three parts, including the correctness
test code mainly based on the symbolic execution framework, the
readability test code based on statistics, and the platform source code
for human study.</p>

},
keywords = {Decompiler, Human Study, Symbolic execution}
}

@software{10.5072/zenodo.45711,
author = {Ouyang, Yicheng and Yang, Jun and Zhang, Lingming},
title = {Reproduction Package for Article "Benchmarking Automated Program Repair: An Extensive Study on Both Real-world and Artificial Bugs"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5072/zenodo.45711},
abstract = {
    <p>Reproduction Package for Article “Benchmarking Automated Program
Repair: An Extensive Study on Both Real-world and Artificial Bugs”.
Containing artificial bugs, Defects4J bugs, and patches generated on the
bugs, and scripts for reproduction.</p>

},
keywords = {Debugging, Mutation Testing., Patch Correctness Checking, Program Repair}
}

@software{10.5281/zenodo.10888532,
author = {Helm, Dominik and Keidel, Sven and Kampk\"{o}tter, Anemone and D\"{u}sing, Johannes and Roth, Tobias and Hermann, Ben and Mezini, Mira},
title = {Total Recall? How Good are Static Call Graphs Really? - Companion Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10888532},
abstract = {
    <p>This artifact holds a pipeline that captures a dynamic callgraph for
a JVM program and a given set of inputs (input corpus). This dynamic
callgraph can then be used as a baseline to compute precision and recall
of a defined set of static callgraphs.</p>
<p>To achieve a good quality of the dynamic baseline, the pipeline
provides different techniques for creating a suitable input corpus.
These are:</p>
<pre><code>Base Seed Corpus: Pre-existing input corpora found online, without any modification
Seed Corpus: Manual additions to the Base Seed Corpus derived from inspecting the coverage values.
Fuzzing: A coverage-guided fuzzer (Jazzer) generates program inputs from scratch
Fuzzing Seed: Jazzer generates new inputs using the Seed Corpus as a starting point. This is the combination of all aforementioned techniques, which we found to be best suited for good quality dynamic callgraphs.</code></pre>
<p>The pipeline evaluates precision and recall for the following fixed
set of static callgraphs:</p>
<pre><code>OPAL: CHA, RTA, 0-CFA
WALA: CHA, RTA, 0-CFA
Soot: CHA
Doop: 0-CFA</code></pre>
<p>Numerical values for precision and recall are computed for every
static callgraph and every project. We further include scripts that
visualize those values for our set of four programs.</p>
<p>The artifact consists of three archives:</p>
<pre><code>total_recall_paper_supplementary.zip: Holds supplementary material for our paper, including proofs for bounds to precision and recall, as well as additional visualizations.
total_recall_artifact.zip: Holds the implementation of our pipeline and most of the data generated for our evaluation. A detailed description on how to use this artifact can be found in the enclosed README.md file.
total_recall_artifact_supplementary.zip: Holds supplementary data for our artifact. This may be helpful if you do not have access to the computing resources required to compute static callgraphs. Installation instructions can be found in the enclosed README.md file.</code></pre>

},
keywords = {Call Graph, Dynamic Analysis, Precision, Recall, Static Analysis}
}

@software{10.5281/zenodo.10890011,
author = {Helm, Dominik and Roth, Tobias and Keidel, Sven and Reif, Michael and Mezini, Mira},
title = {Unimocg: Modular Call-Graph Algorithms for Consistent Handling of Language Features - Companion Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10890011},
abstract = {
    <p>This is the artifact of the paper: Unimocg: Modular Call-Graph
Algorithms for Consistent Handling of Language Features published at
ISSTA 2024. Our paper proposes a modular architecture for call-graph
construction that decouples the computation of type information from
resolving calls.</p>
<p>Unimocg_Artifact.zip contains our artifact and results (excluding
computed call graphs because of their size). The evaluation is performed
in a docker container that can automatically be build from the files in
the artifact zip.</p>

},
keywords = {call graph, static analysis}
}

@software{10.5281/zenodo.10897855,
author = {Zhou, Mingyi and Gao, Xiang and Liu, Pei and Grundy, John and Chen, Chunyang and Chen, Xiao and Li, Li},
title = {CustomDLCoder: Generating Pure Code Implementations to Replace On-Device DL Models},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10897855},
abstract = {
    <p>Code for our paper “Model-less Is the Best Model: Generating Pure
Code Implementations to Replace On-Device DL Models” which has been
accepted by ISSTA’24</p>

},
keywords = {Program Analysis, Software Engineering for AI}
}

@software{10.5281/zenodo.10900080,
author = {Liu, Yunqi and Song, Wei},
title = {Reproduction Package of &nbsp;"FunRedisp: Reordering Function Dispatch in Smart Contract to Reduce Invocation Gas Fees"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10900080},
abstract = {
    <p>FunRedisp is a bytecode refactoring tool to reduce the overall
invocation gas consumption of Solidity smart contracts. This artifact
includes the source code of FunRedisp written in Python, as well as
source code of the smart contracts and address information required for
the corresponding experiment. It also includes the addresses of all
Solidity smart contracts required for empirical study in the
article.</p>

},
keywords = {Ethereum, function dispatch, FunRedisp, gas optimization, smart contract, Solidity}
}

@software{10.5281/zenodo.10901816,
author = {Wang, Ruixin and Lu, Minghai and Yu, Cody Hao and Lai, Yi-Hsiang and Zhang, Tianyi},
title = {Reproduction Package for Article "Automated Deep Learning Optimization via DSL-based Source Code Transformation"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.10901816},
abstract = {
    <p>This artifact includes the source code and experimental result of the
corresponding research paper. This artifact aims to help with the
reproduction work and future research.</p>

},
keywords = {Deep Learning Optimization, Program Transformation}
}

@software{10.5281/zenodo.12632401,
author = {Jiang, Zhihan and Liu, Jinyang and Huang, Junjie and Li, Yichen and Huo, Yintong and Gu, Jiazhen and Chen, Zhuangbin and Zhu, Jieming and Lyu, Michael R.},
title = {Reproduction Package for Article "A Large-Scale Evaluation for Log Parsing Techniques: How Far Are We?"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12632401},
abstract = {
    <p>This is the artifact of [ISSTA’24] “A Large-Scale Evaluation for Log
Parsing Techniques: How Far Are We?”</p>

},
keywords = {Benchmark, Log Analysis, Log Parsing}
}

@software{10.5281/zenodo.12633908,
author = {Wang, Tong and Gu, Taotao and Deng, Huan and Li, Hu and Kuang, Xiaohui and Zhao, Gang},
title = {ScenarioFuzz},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12633908},
abstract = {
    <p>ScenarioFuzz is a framework that focuses on conducting fuzz testing
on autonomous driving systems at the scenario level. The framework
utilizes the following approaches:</p>
<p>1.Leveraging map crawling techniques to construct a topological graph
from road semantic web maps based on the OPENDRIVE format. It clusters
scene-relevant waypoints and queries waypoint connectivity to build a
scenario seed corpus.</p>
<p>2.Based on the scenario seed corpus, the framework mutates the seed
scenarios to generate realistic and effective scenario instances.</p>
<p>3.The mutated seed scenarios are evaluated and filtered using a
scenario evaluation model, which helps reduce trial-and-error costs.</p>
<p>4.The constructed scenarios are then implemented in the CARLA
simulation engine and integrated with the system under test for testing
purposes.</p>
<p>5.The framework accurately identifies corner cases in the tested
system’s scenarios.</p>
<p>6.Multiple iterations of scenario evaluation model training can be
performed using the collected test data.</p>

},
keywords = {Autonomous Driving Systems, Fuzzing, Scenario-based Testing}
}

@software{10.5281/zenodo.12639546,
author = {He, Yifeng and Huang, Jiabo and Rong, Yuyang and Guo, Yiwen and Wang, Ethan and Chen, Hao},
title = {UniTSyn: A Large-Scale Dataset Capable of Enhancing the Prowess of Large Language Models for Program Testing},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12639546},
abstract = {
    <p>Code to build and reproduce dataset UniTSyn.</p>

},
keywords = {dataset, Large language models, software testing, test case generation}
}

@software{10.5281/zenodo.12643079,
author = {Canelas, Paulo and Schmerl, Bradley and Fonseca, Alcides and Timperley, Christopher S.},
title = {Artifact for Understanding Misconfigurations in ROS: An Empirical Study and Current Approaches},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12643079},
abstract = {
    <p>This artifact contains all the information collected from ROS Answers
and categorized in the empirical study and literature review.</p>

},
keywords = {Empirical Study, Literature Review, Misconfigurations, ROS}
}

@software{10.5281/zenodo.12647526,
author = {Zhao, Wenxuan and Zeng, Ruiying and Zhou, Yangfan},
title = {Code \&amp; Data of "Wapplique : Testing WebAssembly Runtime via Execution Context-Aware Bytecode Mutation"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12647526},
abstract = {
    <p>Artifact provide the code and data of Wapplique. demo/ and wapplique/
dircetory is the code.coverage_data/ directory is the coverage data.</p>

},
keywords = {Code Generation, Fuzzing, Runtime Testing, WebAssembly}
}

@software{10.5281/zenodo.12653656,
author = {Charoenwet, Wachiraphan and Thongtanunam, Patanamon and Pham, Van-Thuan and Treude, Christoph},
title = {Dataset for An Empirical Study of Static Analysis Tools for Secure Code Review},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12653656},
abstract = {
    <p>This package contains the fundamental datasets and the core scripts
in the study. The following sections describe the content of each
folder, and the technical instructions to obtain and analyze the dataset
with the provided scripts.</p>

},
keywords = {secure code review, static application security testing tools, vulnerability-contributing commits}
}

@software{10.5281/zenodo.12655683,
author = {Kukucka, James and Pina, Lu\'{\i}s and Ammann, Paul and Bell, Jonathan},
title = {Artifact to accompany "An Empirical Examination of Fuzzer Mutator Performance" (ISSTA 2024 article)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12655683},
abstract = {
    <p>The primary purpose of this artifact is to store all of the data that
is presented in the paper “An Empirical Examination of Fuzzer Mutator
Performance,” published at ISSTA 2024.</p>
<p>The artifact has many directories, which are explained below:</p>
<ol type="1">
<li>An example of how to run the experiments in the paper:
<code>run_experiments.zip</code></li>
<li>Our unprocessed, raw coverage data output from the modified AFL++
that we presented in our paper: <code>afl-knobs-output.tar</code></li>
<li>Processed coverage JSON files that can be used for further analysis,
as well as reports on bugs reached and found for each trial:
<code>data.tar.gz</code></li>
<li>Analysis scripts to convert the raw data from 1 into processable
JSON files in 2: <code>analyze_data.zip</code></li>
<li>TypeScript to parse coverage JSON files into CSVs:
<code>coverage-parser</code></li>
<li>Jupyter notebooks to analyze coverage and bug data after being
converted to CSVs: <code>notebooks</code></li>
</ol>

},
keywords = {AFL++, evaluation, fuzzing, mutators}
}

@software{10.5281/zenodo.12657258,
author = {Ye, Zhenyu and Zhou, Lei and Zhang, Fengwei and Jin, Wenqiang and Ning, Zhenyu and Hu, Yupeng and Qin, Zheng},
title = {FortifyPatch: Towards Tamper-Resistant Live Patching in Linux-Based Hypervisor},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12657258},
abstract = {
    <p>The artifact of paper FortifyPatch for ISSTA’24.</p>

},
keywords = {Arm, Confidential Compute Architecture, Live Patch}
}

@software{10.5281/zenodo.12660892,
author = {Lin, Bo and Wang, Shangwen and Wen, Ming and Chen, Liqian and Mao, Xiaoguang},
title = {The artifacts of ISSTA 2024 paper titled "One Size Does Not Fit All: Multi-Granularity Patch Generation for Better Automated Program Repair"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12660892},
abstract = {
    <p>The artifacts include the scripts for preprocessing and training.</p>

},
keywords = {Automated Program Repair, Deep Learning, Pre-Training}
}

@software{10.5281/zenodo.12661302,
author = {Luo, Chuan and Lyu, Shuangyu and Zhao, Qiyuan and Wu, Wei and Zhang, Hongyu and Hu, Chunming},
title = {Artifact for ISSTA 2024 Article `Beyond Pairwise Testing: Advancing 3-wise Combinatorial Interaction Testing for Highly Configurable Systems'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12661302},
abstract = {
    <p>ScalableCA is a novel and scalable algorithm that demonstrates
effectiveness and efficiency in solving large-scale 3-wise CCAG
instances. This artifact includes the implementation of ScalableCA, the
testing instances adopted in the experiments and the experimental
results.</p>

},
keywords = {Combinatorial Interaction Testing, Sampling, Satisfiability}
}

@software{10.5281/zenodo.12662049,
author = {Dasu, Vishnu Asutosh and Kumar, Ashish and Tizpaz-Niari, Saeid and Tan, Gang},
title = {Source code for "NeuFair: Neural Network Fairness Repair with Dropout"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12662049},
abstract = {
    <p>This repository contains the source code to reproduce the results in
the paper “NeuFair: Neural Network Fairness Repair with Dropout”
accepted at ACM ISSTA 2024.</p>

},
keywords = {Machine Learning, Software Applications}
}

@software{10.5281/zenodo.12662090,
author = {Cheng, Runxiang and Wang, Shuai and Jabbarvand, Reyhaneh and Marinov, Darko},
title = {Artifact for "Revisiting Test-Case Prioritization on Long-Running Test Suites" (ISSTA 2024)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12662090},
abstract = {
    <p>This is the artifact of the research paper “Revisiting Test-Case
Prioritization on Long-Running Test Suites” in ISSTA 2024.</p>
<p>This artifact provides a quick walkthrough of its general
functionality (e.g., downloading and extracting data from more builds,
running TCP techniques) using one of the evaluated projects as an
example, and steps to produce tables and figures analyzed in the paper’s
evaluation section.</p>
<p>This artifact provides: (1) steps to download and use the full
dataset of Long-Running Test Suites (LRTS) we previously collected; (2)
scripts to collect more builds from the evaluated projects; (3)
implementations of different categories of test-case prioritization
(TCP) algorithms (time-based, history-based,
information-retrieval-based, ML-based, RL-based); (4) experiment scripts
to evaluate the implemented TCP algorithms on the collected, extensible
dataset.</p>

},
keywords = {regression testing, reliability, Software testing, test prioritization}
}

@software{10.5281/zenodo.12662219,
author = {Cui, Di and Wang, Qiangqiang and Zhao, Yutong and Wang, Jiaqi and Wei, Minjie and Hu, Jingzhao and Wang, Luqiao and Li, Qingshan},
title = {HECS: A Hypergraph Learning-based System for Detecting Extract Class Refactoring Opportunities},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12662219},
abstract = {
    <p>HECS is an advanced tool designed for Extract Class refactoring by
leveraging hypergraph learning to model complex dependencies within
large classes. Unlike traditional tools that rely on direct oneto-one
dependency graphs, HECS uses intra-class dependency hypergraphs to
capture one-to-many relationships. This allows HECS to provide more
accurate and relevant refactoring suggestions. The tool constructs
hypergraphs for each target class, attributes nodes using a pre-trained
code model, and trains an enhanced hypergraph neural network. Coupled
with a large language model, HECS delivers practical refactoring
suggestions. In evaluations on largescale and real-world datasets, HECS
achieved a 38.5\% increase in precision, 9.7\% in recall, and 44.4\% in
f1-measure compared to JDeodorant, SSECS, and LLMRefactor. These
improvements make HECS a valuable tool for developers, offering
practical insights and enhancing existing refactoring techniques.</p>

},
keywords = {Extract Class Refactoring, Hypergraph Neural Network}
}

@software{10.5281/zenodo.12663279,
author = {Nguyen, Thanh-Dat and Do-Viet, Tung and Nguyen-Duy, Hung and Luu, Tuan-Hai and Le, Hung and Le, Bach and Thongtanunam, Patanamon},
title = {VRDSynth Replication Package},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12663279},
abstract = {
    <p>Full replication package of VRDSynth</p>

},
keywords = {Automatic Programming, Information Extraction, Program Synthesis}
}

@software{10.5281/zenodo.12664081,
author = {Wang, Jikai and Wang, Haoyu},
title = {Artifact for "NativeSummary: Summarizing Native Binary Code for Inter-language Static Analysis of Android Apps"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12664081},
abstract = {
    <p>NativeSummary is a new inter-language Android application static
analysis framework using static analysis (based on BinAbsInspector)
instead of symbolic execution to make binary code analysis more
efficient. To make binary analysis results more generic, we translate
the semantic summary extracted from binary code to java bytecode, inject
the generated method body into the corresponding native method on the
java side, and repack it as a new apk file.</p>

},
keywords = {Android, Mobile Security, Static Analysis}
}

@software{10.5281/zenodo.12664230,
author = {Zhang, Zhijie and Chen, Liwei and Wei, Haolai and Shi, Gang and Meng, Dan},
title = {Reproduction Package of "Prospector: Boosting Directed Greybox Fuzzing for Large-Scale Target Sets with Iterative Prioritization"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12664230},
abstract = {
    <p>In order to support open science, we provide a supplementary material
containing the source code of Prospector, the experimental scripts for
instrumentation, fuzzing and crash triaging, the data generated in our
experiments, as well as Dockerfile for building Docker images. With
these resources, we aim to provide a robust foundation for replicating
and validating our work.</p>

},
keywords = {bug finding, directed fuzzing}
}

@software{10.5281/zenodo.12665353,
author = {Fiter\u{a}u-Bro\c{s}tean, Paul and Jonsson, Bengt and Sagonas, Konstantinos and T\r{a}quist, Fredrik},
title = {SMBugFinder: An Automated Framework for Testing Protocol Implementations for State Machine Bugs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12665353},
abstract = {
    <p>Source code of the SMBugFinder at the time of the submission of the
ISSTA’24 paper with the above title.</p>

},
keywords = {model checking, model-based testing, network protocols, protocol security, protocol state fuzzing, Software security}
}

@software{10.5281/zenodo.12667479,
author = {Jajal, Purvish and Jiang, Wenxin and Tewari, Arav and Kocinare, Erik and Woo, Joseph and Sarraf, Anusha and Lu, Yung-Hsiang and Thiruvathukal, George K. and Davis, James C.},
title = {Interoperability in Deep Learning: A User Survey and Failure Analysis of ONNX Model Converters},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12667479},
abstract = {
    <p>This is the artifact for Interoperability in Deep Learning: A User
Survey and Failure Analysis of ONNX Model Converters, that will be
presented at the 2024 International Symposium on Software Testing and
Analysis (ISSTA).</p>
<p>Instructions are in the README.</p>

},
keywords = {Empirical software engineering, ONNX, Software Engineering}
}

@software{10.5281/zenodo.12668172,
author = {Wei, Haolai and Chen, Liwei and Zhang, Zhijie and Shi, Gang and Meng, Dan},
title = {Artifact of the ISSTA 2024 paper -- "Sleuth: A Switchable Dual-Mode Fuzzer to Investigate Bug Impacts Following a Single PoC"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12668172},
abstract = {
    <p>Sleuth is an open-source fuzzer for automatically discovering bug
impacts following a single PoC. It is based on LLVM and the fuzzing tool
AFL++. It employs SVF to construct the memory-relevant graph, and
utilizes this graph to guide Fuzzer to efficiently discover new bug
impacts.</p>
<p>The artifact contains a docker image and the source code with a
READEME file. The current version still has some cumbersome user
interactions. We will optimize this part in the future and release a
more stable version.</p>

},
keywords = {Bug impact, Fuzzing, Patch testing}
}

@software{10.5281/zenodo.12668777,
author = {Mazouni, Quentin and Spieker, Helge and Gotlieb, Arnaud and Acher, Mathieu},
title = {Policy Testing with MDPFuzz (Replicability Study)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12668777},
abstract = {
    <p>This is the artifact implementing our replicability study of the
policy testing method MDPFuzz. The artifact is hosted on Zenodo as well
as on GitHub. It contains all the source code for reproducing the
experiments of the paper. In particular, we provide detailed
instructions and a Dockerfile that can be used to build a Docker image
and run the artifact as a Docker container. We also release the Docker
image on Docker Hub.</p>

},
keywords = {Reinforcement Learning, Replicability, Software Testing}
}

@software{10.5281/zenodo.12668852,
author = {Gulcan, Ege Berkay and Neto, Jo\~{a}o and Ozkan, Burcu Kulahcioglu},
title = {Archived Repository of "Generalized Concurrency Testing Tool for Distributed Systems"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12668852},
abstract = {
    <p>This artifact is a repository, containing the archived version of our
paper “Generalized Concurrency Testing Tool for Distributed
Systems”.</p>

},
keywords = {Concurrency testing, Distributed systems}
}

@software{10.5281/zenodo.12669081,
author = {Saha, Antu and Song, Yang and Mahmud, Junayed and Zhou, Ying and Moran, Kevin and Chaparro, Oscar},
title = {Toward the Automated Localization of Buggy Mobile App UIs from Bug Descriptions},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669081},
abstract = {
    <p>This is the replication package for the ISSTA’24 paper titled “Toward
the Automated Localization of Buggy Mobile App UIs from Bug
Descriptions”. Authors: Antu Saha, Yang Song, Junayed Mahmud, Ying Zhou,
Kevin Moran, and Oscar Chaparro</p>
<p>Please visit the latest version (currently v5) for the most updated
artifacts.</p>

},
keywords = {Bug Reports, Information Retrieval, Mobile Applications, UI Data}
}

@software{10.5281/zenodo.12669148,
author = {Blumschein, Christoph and Niephaus, Fabio and Stancu, Codru\c{t} and Wimmer, Christian and Lincke, Jens and Hirschfeld, Robert},
title = {Finding Cuts in Static Analysis Graphs to Debloat Software - Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669148},
abstract = {
    <p>This artifact consists of two parts: the CutTool as described in
section 5.2 of our paper, and evaluation scripts for reproducing the
results of section 6.3 and 6.4.</p>

},
keywords = {CutTool}
}

@software{10.5281/zenodo.12669650,
author = {Yan, Xiaoyong and He, Biao and Shen, Wenbo and Ouyang, Yu and Zhou, Kaihang and Zhang, Xingjian and Wang, Xingyu and Cao, Yukai and Chang, Rui},
title = {DIVER},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669650},
abstract = {
    <p>DIVER is the first tool to automatically analyse data binding
vulnerabilities in Java web frameworks. DIVER employs three new
techniques: the Nested Property Graph-based Extraction to extract nested
properties, the Bind-Site Instrumentation-based Identification to
identify bindable nested properties, and the Property-aware Fuzzing to
trigger and detect data binding vulnerabilities.</p>

},
keywords = {data binding vulnerability, Java web framework}
}

@software{10.5281/zenodo.12669708,
author = {Tan, Jovyn and Rigger, Manuel},
title = {Artefact for "Inconsistencies in TeX-Produced Documents"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669708},
abstract = {
    <p>This artefact comprises:</p>
<ul>
<li>The source code of our automated tool</li>
<li>The data and results from running this tool, as well as relevant
configurations, for:
<ul>
<li>RQ1 (Cross-engine comparisons)</li>
<li>RQ2 (Cross-version comparisons)</li>
<li>RQ3 (Root cause analysis)</li>
<li>Motivating study</li>
<li>Alignment study</li>
</ul></li>
</ul>
<p>More details are included in <code>README.md</code> found in the root
directory.</p>

},
keywords = {LaTeX, PDF documents, TeX, typesetting}
}

@software{10.5281/zenodo.12669927,
author = {Go, Gwihwan and Zhou, Chijin and Zhang, Quan and Zou, Xiazijian and Shi, Heyuan and Jiang, Yu},
title = {DeepConstr},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669927},
abstract = {
    <p>Artifact of the paper “Towards More Complete Constraints for Deep
Learning Library Testing via Complementary Set Guided Refinement”</p>

},
keywords = {DL library, Fuzzing, Large Language Model}
}

@software{10.5281/zenodo.12669964,
author = {Zhang, Mengxiao and Tian, Yongqiang and Xu, Zhenyang and Dong, Yiwen and Tan, Shin Hwei and Sun, Chengnian},
title = {Artifact for "LPR: Large Language Models-Aided Program Reduction"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669964},
abstract = {
    <p>This is the artifact for the paper “LPR: Large Language Models-Aided
Program Reduction”</p>

},
keywords = {compiler testing, debugging, LLM, program reduction}
}

@software{10.5281/zenodo.12670050,
author = {Chen, Yang and Jabbarvand, Reyhaneh},
title = {Artifact for "Neurosymbolic Repair of Test Flakiness"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670050},
abstract = {
    <p>This is the artifact for “Neurosymbolic Repair of Test
Flakiness”.</p>

},
keywords = {Large Language Models, Program Repair, Test Flakiness}
}

@software{10.5281/zenodo.12670309,
author = {Cao, Shangtong and He, Ningyu and She, Xinyu and Zhang, Yixuan and Zhang, Mu and Wang, Haoyu},
title = {WASMaker: Differential Testing of WebAssembly Runtimes via Semantic-aware Binary Generation},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670309},
abstract = {
    <p>WASMaker, a novel differential testing framework that can generate
complicated Wasm test cases by disassembling and assembling real-world
Wasm binaries, which can trigger hidden inconsistencies among Wasm
runtimes.</p>

},
keywords = {Differential Testing, WebAssembly}
}

@software{10.5281/zenodo.12670528,
author = {Liu, Shuang and Lan, Junhao and Du, Xiaoning and Li, Jiyuan and Lu, Wei and Jiang, Jiajun and Du, Xiaoyong},
title = {Reproduction Package for Article "Testing Graph Database Systems with Graph-State Persistence Oracle"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670528},
abstract = {
    <p>The artifact contains the source code(including the configuration
file) of GraspDB and the executable jar file.One can follow the
instructions in the readme documentation to reproduce the results of our
experiment as well as to detect bugs.</p>

},
keywords = {Database Testing, Graph Database, Writing-related Bug}
}

@software{10.5281/zenodo.12670597,
author = {Nguyen, Huan and Priyadarshan, Soumyakant and Sekar, R.},
title = {Reproduction Package for the ISSTA 2024 Article 'Scalable, Sound and Accurate Jump Table Analysis'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670597},
abstract = {
    <p>This artifact contains our state-of-the-art jump table analyzer,
which is accepted for presentation at the ACM SIGSOFT International
Symposium on Software Testing and Analysis (ISSTA) 2024. We ship our
artifact as a VM that contains our source code and the scripts used to
obtain the results in the paper.</p>

},
keywords = {Binary Analysis, Program Analysis, Reverse Engineering, Static Analysis}
}

@software{10.5281/zenodo.12671411,
author = {Liu, Yunqi and Song, Wei},
title = {Reproduction Package of ‘FunRedisp: Reordering Function Dispatch in Smart Contract to Reduce Invocation Gas Fees’},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12671411},
abstract = {
    <p>FunRedisp is a function dispatch refactoring tool to reduce the
overall invocation gas consumption of Solidity smart contracts.</p>

},
keywords = {Ethereum, function dispatch, gas optimization, refactoring, smart contract, Solidity}
}

@software{10.5281/zenodo.12671638,
author = {Guan, Hao and Bai, Guangdong and Liu, Yepang},
title = {Prototype of YanHui, the tools in `Large Language Models Can Connect the Dots: Exploring Model Optimization Bugs with Domain Knowledge-Aware Prompts'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12671638},
abstract = {
    <p>Prototype of YanHui, including the data and labels for GitHub issues.
Code to generate test cases with large language models.</p>

},
keywords = {Large Language Model, Library Testing, Model Optimization}
}

@software{10.5281/zenodo.12673450,
author = {Liu, Zengyu and Chen, Liqian and Liu, Wanwei and Wang, Ji},
title = {Synthesizing Boxes Preconditions for Deep Neural Networks},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12673450},
abstract = {
    <p>This repository contains the artifact of the following ISSTA 2024
paper. Zengyu Liu, Liqian Chen, Wanwei Liu and Ji Wang. Synthesizing
Boxes Preconditions for Deep Neural Networks</p>

},
keywords = {Boxes, Neural Network, Precondition Synthesis, Robustness, Safety}
}

@software{10.5281/zenodo.12771889,
author = {Zheng, Yingying and Dou, Wensheng and Tang, Lei and Cui, Ziyu and Gao, Yu and Song, Jiansen and Xu, Liang and Zhu, Jiaxin and Wang, Wei and Wei, Jun and Zhong, Hua and Huang, Tao},
title = {Testing Gremlin-Based Graph Database Systems via Query Disassembling},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12771889},
abstract = {
    <p>Query disassembling (QuDi) is an effective testing technique to
automatically detect logic bugs in individual graph database systems
(GDBs). By disassembling a complex graph query into an equivalent atomic
graph traversal sequence, we can reveal logic bugs related to incorrect
implementations and optimizations of Gremlin queries in GDBs.</p>
<p>We evaluate QuDi on six widely-used Gremlin-based GDBs, i.e., Neo4j,
OrientDB, JanusGraph, HugeGraph, TinkerGraph, and ArcadeDB. In total, we
have found 25 logic bugs in these six GDBs, and 10 of them have been
confirmed as previously-unknown bugs by GDB developers.</p>

},
keywords = {bug detection, Graph database systems, graph traversal, logic bug}
}

@software{10.5281/zenodo.12786604,
author = {Kim, Hyungseok and Kim, Soomin and Lee, Jungwoo and Cha, Sang Kil},
title = {AsFuzzer: Differential Testing of Assemblers with Error-Driven Grammar Inference},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12786604},
abstract = {
    <p>This is an artifact for `AsFuzzer: Differential Testing of Assemblers
with Error-Driven Grammar Inference’, which will be published in the ACM
SIGSOFT International Symposium on Software Testing and Analysis (ISSTA
2024). AsFuzzer is an assembler testing tool that detects potential bugs
in assemblers. The artifact includes the implementation of AsFuzzer,
experimental scripts, and the four real-world assemblers used in the
paper.</p>

},
keywords = {assembler testing, compiler testing, grammar inference}
}

@software{10.5281/zenodo.12792159,
author = {He, Dongnan and Xie, Dongchen and Wang, Yujie and You, Wei and Liang, Bin and Huang, Jianjun and Shi, Wenchang and Zhang, Zhuo and Zhang, Xiangyu},
title = {Artifact for "Define-Use Guided Path Exploration for Better Forced Execution"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12792159},
abstract = {
    <p>This artifact contains supplementary material for the paper
“Define-Use Guided Path Exploration for Better Forced Execution”
(ISSTA’24). The artifact contains a docker image and a READEME file.</p>

},
keywords = {dynamic analysis, forced execution, path exploration}
}

@software{10.5281/zenodo.13147364,
author = {Hayet, Ishrak and Scott, Adam and d'Amorim, Marcelo},
title = {Incompleter (source and dataset)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13147364},
abstract = {
    <p>This artifact includes the source and three datasets used for the
paper “Feedback-Directed Partial Execution”.</p>

},
keywords = {Code completion, Debugging, Rule mining}
}

@software{10.5281/zenodo.13340387,
author = {Xu, Qingxin and Gao, Yu and Wei, Jun},
title = {Dataset for ISSTA'24 An Empirical Study on Kubernetes Operator Bugs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13340387},
abstract = {
    <p>This is the dataset for the ISSTA’24 submission An Empirical Study on
Kubernetes Operator Bugs. It contains 210 operator bugs collected from
36 popular Kubernetes operators.</p>
<p>It can be used to replicate and reproduce the paper’s study, as well
as to serve as a bug benchmark for future work on combating operator
bugs in Kubernetes.</p>

},
keywords = {empirical study, Kubernetes, operation, operator bugs}
}

@software{10.5281/zenodo.13625004,
author = {Hu, Tianmin and Ye, Guixin and Tang, Zhanyong and Tan, Shin Hwei and Wang, Huanting and Li, Meng and Wang, Zheng},
title = {Artifact for the paper "Upbeat: Test Input Checks of Q# Quantum Libraries"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13625004},
abstract = {
    <p>Upbeat is a fuzzing tool designed to generate random test cases for
identifying input-checking bugs in Q# libraries. This artifact includes
the source code and necessary data for Upbeat, along with documentation
to guide users through installation and usage, ensuring a smooth and
convenient experience.</p>

},
keywords = {Fuzzing, Quantum computing, Software testing}
}

@software{10.5281/zenodo.13690435,
author = {Xie, Linna and Li, Chongmin and Pei, Yu and Zhang, Tian and Pan, Minxue},
title = {BRAFAR: Bidirectional Refactoring, Alignment, Fault Localization, and Repair for Programming Assignments Linna Xie, Chongmin Li, Yu Pei, Tian Zhang, and Minxue Pan},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13690435},
abstract = {
    <p>The published version of this work.</p>

},
keywords = {Program Repair, Programming Education, Software Refactoring}
}

@software{10.6084/m9.figshare.21523611.v1,
author = {Pham, Long H. and Sun, Jun},
title = {Certified Continual Learning Dataset},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.21523611.v1},
abstract = {
    <p>This file contains all the trained models, datasets, verified
properties, and generated certificates of the paper “Certified Continual
Learning for Neural Network Regression”.</p>

},
keywords = {continual learning, neural network verification}
}

@software{10.6084/m9.figshare.26156944.v4,
author = {Shi, Chenghang and Li, Haofeng and Lu, Jie and Li, Lian},
title = {Artifact for Article ``Better Not Together: Staged Solving for Context-Free Language Reachability''},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.26156944.v4},
abstract = {
    <p>This is the official artifact of our ISSTA’24 paper ``Better Not
Together: Staged Solving for Context-Free Language Reachability’’.
Please follow the instructions of README.pdf to reproduce our
results.</p>

},
keywords = {CFL-reachability, Performance, Staged Analysis}
}

@software{10.6084/m9.figshare.26397136.v2,
author = {Xue, Zhiyi and Li, Liangguo and Tian, Senyue and Chen, Xiaohong and Li, Pingping and Chen, Liangyu and Jiang, Tingting and Zhang, Min},
title = {Reproduction Package for Article `LLM4Fin: Fully Automating LLM-Powered Test Case Generation for FinTech Software Acceptance Testing'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.26397136.v2},
abstract = {
    <p>LLM4Fin is a prototype tool for automatically generating test cases
from natural language business rules. It is the official implementation
for paper “LLM4Fin: Fully Automating LLM-Powered Test Case Generation
for FinTech Software Acceptance Testing” accepted by ISSTA 2024. The
process of LLM4Fin can be divided into three steps: I. Rule Extraction,
II. Test Scenario Generation, III. Test Data Generation. The workflow is
shown as below. Step I.1 and Step I.2 are performed by fine-tuned LLMs,
and the other steps are implemented by well-designed algorithms. We
evaluate it on real-world stock-trading software. Experimental results
shows that LLM4Fin outperforms both general LLMs like ChatGPT and
skilled testing engineers, on the business scenario coverage, code
coverage, and time consumption.</p>

},
keywords = {fintech software, large language model, Software acceptance testing, test case generation}
}

@software{10.6084/m9.figshare.26948143.v1,
author = {Kushigian, Benjamin and Kaufman, Samuel J. and Featherman, Ryan and Potter, Hannah and Madadi, Ardi and Just, Ren\'{e}},
title = {Supplementary Material for Equivalent Mutants in the Wild: Identifying and Efficiently Suppressing Equivalent Mutants for Java Programs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.26948143.v1},
abstract = {
    <p>This includes the data pipeline for Equivalent Mutants in the Wild,
as well as supplementary Materials.</p>

},
keywords = {Mutation Analysis, Mutation Testing}
}

@software{10.1145/3580438,
author = {Rehman, Baber and Oliveira, Bruno C. d. S.},
title = {Disjoint Polymorphism with Intersection and Union Types (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580438},
abstract = {
    <p>This artifact contains Coq formalization associated with the paper
titled Disjoint Polymorphism with Intersection and Union Types. The
paper studies a novel disjointness algorithm for deterministic
type-based union elimination by exploiting union ordinary and union
splittable types. Proposed disjointness algorithm naturally extends for
a variant of parametric polymorphism called disjoint polymorphism. This
artifact contains Coq formalization of all the metatheory presented in
the paper, including proofs of all the theorems and lemmas.</p>

},
keywords = {Disjointness, Intersection types, Polymorphism, Union types}
}

@software{10.5281/zenodo.13119225,
author = {Norlinder, Jonas and Yang, Albert Mingkun and Black-Schaffer, David and Wrigstad, Tobias},
title = {Mutator-Driven Object Placement using Load Barriers (code)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13119225},
abstract = {
    <p>This artefact contains the implementation of LR-Z that was described
in the paper Mutator-Driven Object Placement using Load Barriers.</p>

},
keywords = {cache performance, garbage collection, locality}
}

@software{10.6084/m9.figshare.26075962.v3,
author = {Sharma, Arindam and Cadar, Cristian and Metzman, Jonathan},
title = {Artifact for "Effective Fuzzing within CI/CD Pipelines (Registered Report)"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.6084/m9.figshare.26075962.v3},
abstract = {
    <p>This artifact contains the exported docker container that can be
imported to reproduce the results shown in the paper “Effective Fuzzing
within CI/CD Pipelines (Registered Report)”. A more detailed overview of
using this is present in the attached README.</p>

},
keywords = {AFLGo, CI/CD Fuzzing, GitHub, Large Scale, Software Testing, Test Suite}
}

@software{10.1145/3580439,
author = {Grossman, Shelly and Toman, John and Bakst, Alexander and Arora, Sameer and Sagiv, Mooly and Nandi, Chandrakana},
title = {Artifact for our paper titled "Practical Verification Of Smart Contracts using Memory Splitting"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.1145/3580439},
abstract = {
    <p>This is the artifact for our paper “Practical Verification Of Smart
Contracts using Memory Splitting”. In our paper, we present a novel
memory splitting transformation and a memory analysis for EVM (Ethereum
Virtual Machine) bytecode. The key insight of the paper is that applying
memory splitting transformation during a pre-processing step leads to
faster SMT solving times and mitigates SMT timeouts when performing
automated verification of real-world programs. We apply this idea in the
domain of smart contracts. This artifact is developed by Certora:
https://www.certora.com/.</p>

},
keywords = {pointer analysis, smart contracts, SMT solving, verification}
}

@software{10.5281/zenodo.12453932,
author = {Cassano, Federico and Gouwar, John and Lucchetti, Francesca and Schlesinger, Claire and Freeman, Anders and Anderson, Carolyn Jane and Feldman, Molly Q and Greenberg, Michael and Jangda, Abhinav and Guha, Arjun},
title = {Artifact: Knowledge Transfer from High-Resource to Low-Resource Programming Languages for Code LLMs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12453932},
abstract = {
    <p>The artifact contains the code to fully reproduce the results in the
paper.</p>

},
keywords = {large language models trained on code}
}

@software{10.5281/zenodo.12552491,
author = {Lin, Zhengyao and Gancher, Joshua and Parno, Bryan},
title = {FlowCert: Translation Validation for Asynchronous Dataflow Programs via Dynamic Fractional Permissions},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12552491},
abstract = {
    <p>Implementation of FlowCert and evaluation data packaged in a Docker
image.</p>

},
keywords = {Asynchronous Dataflow, Coarse-Grained Reconfigurable Arrays, Translation Validation}
}

@software{10.5281/zenodo.12604575,
author = {Le, Callista and Gopinathan, Kiran and Lee, Koon Wen and Gilbert, Seth and Sergey, Ilya},
title = {OBatcher: Implementation, Data Structures, and Experiments (OOPSLA'24 Artefact) Creators},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12604575},
abstract = {
    <p>This release snapshots the functionality of the submitted artefact
for the OBatcher framework and data structures described in the OOPSLA
24 paper “Concurrent Data Structures Made Easy”:</p>
<ul>
<li><p>Docker file with reproducible build environment</p></li>
<li><p>Readme with getting started and step-by-step
instructions</p></li>
<li><p>Source code and build files for OBatcher</p></li>
<li><p>Instantiation of the OBatcher framework in Rust</p></li>
<li><p>Benchmark code and scripts to reproduce the 33 graphs presented
in the paper</p></li>
</ul>

},
keywords = {batched data structures, batching, concurrency, OCaml, programming languages, Rust}
}

@software{10.5281/zenodo.12627576,
author = {Nagy, Shaan and Kim, Jinwoo and Reps, Thomas and D’Antoni, Loris},
title = {Wuldo Unrealizability Logic Proof Synthesizer},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12627576},
abstract = {
    <p>Automated verification of all members of a (potentially infinite) set
of programs has the potential to be useful in program synthesis, as well
as in verification of dynamically loaded code, concurrent code, and
language properties. Existing techniques for verification of sets of
programs are limited in scope and unable to create or use interpretable
or reusable information about sets of programs. The consequence is that
one cannot learn anything from one verification problem that can be used
in another. Unrealizability logic (UL), proposed by Kim et al.&nbsp;as the
first Hoare-style proof system to prove properties over sets of programs
(defined by a regular tree grammar), presents a theoretical framework
that can express and use reusable insight. In particular, UL features
nonterminal summaries—inductive facts that characterize recursive
nonterminals (analogous to procedure summaries in Hoare logic). In this
work, we design the first UL proof synthesis algorithm, implemented as
Wuldo. Specifically, we decouple the problem of deciding how to apply UL
rules from the problem of synthesizing/checking nonterminal summaries by
computing proof structure in a fully syntax-directed fashion. We show
that Wuldo, when provided nonterminal summaries, can express and prove
verification problems beyond the reach of existing tools, including
establishing how infinitely many programs behave on infinitely many
inputs. In some cases, Wuldo can even synthesize the necessary
nonterminal summaries. Moreover, Wuldo can reuse previously proven
nonterminal summaries across verification queries, making verification
1.96 times as fast as when summaries are instead proven from
scratch.</p>

},
keywords = {automated reasoning, infinite sets of programs, Unrealizability logic}
}

@software{10.5281/zenodo.12637140,
author = {Schwartz, David and Kowshik, Ankith and Pina, Lu\'{\i}s},
title = {Artifact for Jmvx: Fast Multi-threaded Multi-Version eXecution and Record-Replay for Managed Languages},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12637140},
abstract = {
    <p>Java Multi-Version Execution (JMVX) is a tool for performing
Multi-Version Execution (MVX) and Record Replay (RR) in Java.</p>
<p>Most tools for MVX and RR observe the behavior of a program at a low
level, e.g., by looking at system calls.</p>
<p>Unfortunately, this approach fails for high level language virtual
machines due to benign divergences (differences in behavior that
accomplish that same result) introduced by the virtual machine –
particularly by garbage collection and just-in-time compilation.</p>
<p>In other words, the management of the virtual machines creates
differing sequences of system calls that lead existing tools to believe
a program has diverged, when in practice, the application running on top
of the VM has not.</p>
<p>JMVX takes a different approach, opting instead to add MVX and RR
logic into the bytecode of compiled programs running in the VM to avoid
benign divergences related to VM management.</p>
<p>This artifact is a docker image that will create a container holding
our source code, compiled system, and experiments with JMVX.</p>
<p>The image allows you to run the experiments we used to address the
research questions from the paper (from Section 4).</p>
<p>This artifact is desiged to show:</p>
<p>[Supported] JMVX performs MVX for Java [Supported] JMVX performs RR
for Java [Supported] JMVX is performant</p>

},
keywords = {deterministic replay, Multi-version execution, record replay, reproducible debugging}
}

@software{10.5281/zenodo.12637589,
author = {Raad, Azalea and Vanegue, Julien and O’Hearn, Peter},
title = {Non Termination Proving At Scale: Artifact (Pulse Infinite)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12637589},
abstract = {
    <p>This package contains the Pulse-Infinite project source code
distributed as part of the Infer framework as of 7/6/24.</p>
<p>For the most recent version of Pulse-Infinite, please consult:
https://github.com/jvanegue/infer/</p>

},
keywords = {incorrectness, infer, logic, separation, termination}
}

@software{10.5281/zenodo.12654518,
author = {Torczon, Cassia and Su\'{a}rez Acevedo, Emmanuel and Agrawal, Shubh and Velez-Ginorio, Joey and Weirich, Stephanie},
title = {Artifact Associated with "Effects and Coeffects in Call-by-Push-Value"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12654518},
abstract = {
    <p>Coq mechanization of definitions and theorems</p>

},
keywords = {CBPV, Coeffects, Coq, Effects}
}

@software{10.5281/zenodo.12659527,
author = {Haselwarter, Philipp G. and Li, Kwing Hei and de Medeiros, Markus and Gregersen, Simon Oddershede and Aguirre, Alejandro and Tassarotti, Joseph and Birkedal, Lars},
title = {Tachis: Higher-Order Separation Logic with Credits for Expected Costs - Coq Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12659527},
abstract = {
    <p>Formalization of the results of the paper “Tachis: Higher-Order
Separation Logic with Credits for Expected Costs” in the Coq proof
assistant.</p>

},
keywords = {expected time complexity, probabilistic programs, resource analysis}
}

@software{10.5281/zenodo.12663344,
author = {Yan, Zhenyu and Zhang, Xin and Di, Peng},
title = {Scaling Abstraction Refinement for Program Analyses in Datalog Using Graph Neural Networks (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12663344},
abstract = {
    <p>This is the artifact of the paper Scaling Abstraction Refinement for
Program Analyses in Datalog Using Graph Neural Networks to appear in
OOPSLA 2024.</p>

},
keywords = {abstraction refinement, graph neural networks, program analysis}
}

@software{10.5281/zenodo.12666682,
author = {Liew, Dennis and Cogumbreiro, Tiago and Lange, Julien},
title = {Sound and partially-complete static analysis of data-races in GPU programs (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12666682},
abstract = {
    <p>An artifact with all the tools and datasets presented in Section 6,
and mechanized proofs of the theoretical results mentioned in Section
4.4.</p>

},
keywords = {data-race detection, GPU programming, static analysis, true positives}
}

@software{10.5281/zenodo.12668895,
author = {Drosos, Georgios-Petros and Sotiropoulos, Thodoris and Alexopoulos, Georgios and Mitropoulos, Dimitris and Su, Zhendong},
title = {Reproduction Package for Article: "When Your Infrastructure Is a Buggy Program: Understanding Faults in Infrastructure as Code Ecosystems},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12668895},
abstract = {
    <p>The purpose of this artifact is (1) to reproduce the results
presented in the OOPSLA 2024 paper titled “When Your Infrastructure Is a
Buggy Program: Understanding Faults in Infrastructure as Code
Ecosystems”, and (2) to document the dataset and the proposed
categorization in order to facilitate further research. Specifically,
the artifact has the following structure:</p>
<ul>
<li><code>scripts/</code>: This directory contains the scripts necessary
to replicate the findings, figures, and tables introduced in our
study.</li>
<li><code>scripts/fetch/</code>: This directory contains the scripts
required to assemble the dataset of IaC bugs as outlined in Section 3.1
of our study (i.e., this directory includes the code for our repository
collection gathering and bug collection stages).</li>
<li><code>data/</code>: This directory contains the initial bug dataset
of the data collection phase as well as the “pre-baked” dataset of the
360 IaC bugs under study.</li>
<li><code>figures/</code>: A directory which is going to store the
produced paper figures.</li>
<li><code>requirements.txt</code>: A textual file declaring the required
PyPI libraries to run our analysis.</li>
</ul>

},
keywords = {Ansible, bug, Chef, deployment, IaC, infrastructure as code, Puppet}
}

@software{10.5281/zenodo.12669479,
author = {Blinn, Andrew and Li, Xiang and Kim, June Hyung and Omar, Cyrus},
title = {Artifact for Statically Contextualizing Large Language Models with Typed Holes},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669479},
abstract = {
    <p>Artifact for the paper ‘Artifact for Statically Contextualizing Large
Language Models with Typed Holes’, to be published at OOPSLA2024. The
artifact consists of raw data from the experiments, the testing harness
used, the source for the Hazel Editor and Langauge Server, and a copy of
the StarCoder2 LLM weights. The archive is password protected to prevent
the benchmark data set from being automatically scrapped; see the Zenodo
description for the password.</p>

},
keywords = {Large Language Models, Program Synthesis, Programming Languages, Types}
}

@software{10.5281/zenodo.12669572,
author = {Pham, Long and Wang, Di and Saad, Feras A. and Hoffmann, Jan},
title = {Artifact for Programmable MCMC with Soundly Composed Guide Programs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669572},
abstract = {
    <p>In probabilistic programming with a newly proposed coroutine-based
programmable inference framework, the user provides (i) a model
coroutine and (ii) a sequential composition of guide coroutines. The
model coroutine specifies a probabilistic model for Bayesian inference.
Meanwhile, the sequential composition of guide coroutines customizes the
Block Metropolis-Hastings (BMH) algorithm, where we successively run the
guide coroutines, each of which is followed by an MH acceptance routine.
Each guide coroutine only updates a subset (i.e., block) of random
variables. The model and guide coroutines communicate with one another
by message passing, and their communication protocols are described by
guide types.</p>
<p>This artifact is a program analysis tool for statically checking the
soundness of a probabilistic program in this coroutine-based framework.
The artifact offers three functionalities: - Type-equality checking:
check structural type equality of guide types. - Type inference: infer
guide types of model and guide coroutines (using the first functionality
for structural-type-equality checking) - Coverage checking: check
whether the support of sequentially composed guide coroutines coincides
with the support of a model coroutine.</p>

},
keywords = {Bayesian inference, context-free types, coroutines, probabilistic programming, type systems}
}

@software{10.5281/zenodo.12669638,
author = {Zhang, Chengyu and Su, Zhendong},
title = {SMT2Test: From SMT Formulas to Effective Test Cases},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669638},
abstract = {
    <p>The main focus of this artifact is to help people 1) validate the
functionality of the bugfinding tool SMT2Test, 2) check the bug
triggering test cases reported in the paper, 3) reproduce the
performance evaluation. This artifact includes the implementation of
SMT2Test, bug-triggering test cases, seed formulas, and scripts for
reproducing the experiments.</p>

},
keywords = {program verification, SMT solving, software testing}
}

@software{10.5281/zenodo.12669773,
author = {Johnson, Keith J.C. and Krishnan, Rahul and Reps, Thomas and D’Antoni, Loris},
title = {Automating Pruning in Top-Down Enumeration for Program Synthesis Problems with Monotonic Semantics},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669773},
abstract = {
    <p>This is the artifact submission for OOPSLA’24 (R2) submission #377:
Automating Pruning in Top-Down Enumeration for Program Synthesis
Problems with Monotonic Semantics</p>

},
keywords = {abstract interpretation, grammar flow analysis, program synthesis}
}

@software{10.5281/zenodo.12669929,
author = {Zhou, Litao and Wan, Qianyong and Oliveira, Bruno C. d. S.},
title = {Artifact for "Full Iso-Recursive Types"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12669929},
abstract = {
    <p>This artifact accompanies the OOPSLA’24 paper titled Full
Iso-recursive Types. It provides the Coq formalization of the proofs
discussed in the paper, including a pre-configured Docker image for easy
verification and the original source code for those who wish to build
the proofs manually. The artifact includes all necessary scripts, proof
files, and dependencies to reproduce the results presented in the paper,
with a focus on the formalization of iso-recursive types and their
extensions.</p>

},
keywords = {Coq, Mechanized Proof, Recursive types, Subtyping, Type system}
}

@software{10.5281/zenodo.12670155,
author = {Sistla, Meghana and Chaudhuri, Swarat and Reps, Thomas},
title = {Weighted CFLOBDDs},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670155},
abstract = {
    <p>The artifact contains source code and experiments to run Weighted
CFLOBDDs (WCFLOBDDs)</p>

},
keywords = {quantum simulation, Weighted decision diagrams}
}

@software{10.5281/zenodo.12670476,
author = {Reitz, Antonin and Fromherz, Aymeric and Protzenko, Jonathan},
title = {Artifact for OOPSLA 2024 paper: StarMalloc: Verifying a Modern, Hardened Memory Allocator},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670476},
abstract = {
    <p>This is the artifact for the OOPSLA 2024 paper: StarMalloc: Verifying
a Modern, Hardened Memory Allocator. It includes the F* sources for
StarMalloc, the generated C code, and the experimental setup to
reproduce experiments presented in the paper.</p>

},
keywords = {Formal Verification, Memory Allocators, Separation Logic}
}

@software{10.5281/zenodo.12670660,
author = {Wang, Qian and Jung, Ralf},
title = {Reproduction Image for Article 'Rustlantis: Randomized Differential Testing of the Rust Compiler'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12670660},
abstract = {
    <p>Docker image to reproduce evaluations in OOPSLA 2024 paper
Rustlantis: Randomized Differential Testing of the Rust Compiler.</p>

},
keywords = {Compiler testing, Differential fuzzing, Rust}
}

@software{10.5281/zenodo.12671461,
author = {Li, Yichuan and Song, Wei and Huang, Jeff},
title = {VarLifter: Recovering Variables and Types from Bytecode of Solidity Smart Contracts},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12671461},
abstract = {
    <p>The artifact presented here is VarLifter, a tool designed to lift
variables and their types from compiled Solidity smart contract runtime
bytecode. VarLifter provides precise variable and type information,
freeing researchers from the burden of dealing with intricate low-level
details, and is proven to assist downstream tasks related to smart
contracts. VarLifter supports both command-line interface (CLI) and
graphical user interface (GUI) for ease of use.</p>

},
keywords = {Blockchain, EVM, smart contract, Solidity bytecode, variable recovery}
}

@software{10.5281/zenodo.12671562,
author = {Dardinier, Thibault and Li, Anqi and M\"{u}ller, Peter},
title = {Hypra: A Deductive Program Verifier for Hyperproperties (artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12671562},
abstract = {
    <p>This artifact consists of: - Our tool Hypra. - Our evaluation, with
instructions to replicate it. - An Isabelle/HOL proof of the soundness
of the novel loop rule described in section 4.2 (Theorem 1), as well as
Lemma 1.</p>
<p>The artifact is a VirtualBox VM image with Ubuntu 24.04 LTS that
contains our tool Hypra, all benchmarks used in our evaluation, Isabelle
2024, and our Isabelle/HOL formalization. It uses 8GB of RAM and two
cores by default.</p>

},
keywords = {automated reasoning, deductive verification, hyperproperties, incorrectness logic}
}

@software{10.5281/zenodo.12671619,
author = {Zhou, Chijin and Qian, Bingzhou and Go, Gwihwan and Zhang, Quan and Li, Shanshan and Jiang, Yu},
title = {PolyJuice: Detecting Mis-Compilation Bugs in Tensor Compilers with Equality Saturation Based Rewriting},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12671619},
abstract = {
    <p>This is the artifact for “PolyJuice: Detecting Mis-Compilation Bugs
in Tensor Compilers with Equality Saturation Based Rewriting”, published
in SPLASH/OOPSLA 2024. Reproducibility instructions can be found in the
“oopsla24-polyjuice-artifact.pdf” file.</p>

},
keywords = {Equality Saturation, Fuzzing, ML System, Tensor Compiler Testing}
}

@software{10.5281/zenodo.12764370,
author = {Dias, Adhitha and Anderson, Logan and Sundararajah, Kirshanthan and Pelenitsyn, Artem and Kulkarni, Milind},
title = {Reproduction package of article "SparseAuto: An Auto-Scheduler for Sparse Tensor Computations Using Recursive Loop Nest Restructuring"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12764370},
abstract = {
    <p>The artifact contains a self contained docker image with the dataset
and the software package that was used to generate the graphs in the
paper. The artifact also contains the source files without the docker
image. The artifact contains two main directories containing the
auto-scheduler (written in Python) described in Section 06 in the paper,
and the language extension to SparseLNR/TACO described in the Section 05
in the paper.</p>

},
keywords = {Asymptotic Analysis., Automatic Scheduling, Fusion, Loop Transformations, Sparse Tensor Algebra}
}

@software{10.5281/zenodo.12775308,
author = {Schenck, Robert and Hinnerskov, Nikolaj Hey and Henriksen, Troels and Madsen, Magnus and Elsman, Martin},
title = {futhark-oopsla24},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12775308},
abstract = {
    <p>Artifact for the paper AUTOMAP: Inferring Rank-Polymorphic Function
Applications with Integer Linear Programming submitted to OOPSLA 24.</p>

},
keywords = {array programming, constraint-based type systems, data parallelism}
}

@software{10.5281/zenodo.12783666,
author = {Yang, Chen and Chen, Junjie and Jiang, Jiajun and Huang, Yuliang},
title = {Dependency-aware code naturalness},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12783666},
abstract = {
    <p>Docker image and data for the artifact of DAN (dependency-aware code
naturalness)</p>

},
keywords = {Code Entropy, Naturalness, Program Dependency}
}

@software{10.5281/zenodo.12785373,
author = {Campbell, Eric Hayden and Hojjat, Hossein and Foster, Nate},
title = {Capisce Source Code for paper ``Computing Precise Control Interface Specifications''},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12785373},
abstract = {
    <h2 id="capisce">Capisce</h2>
<p>Capisce is described in the OOPSLA paper entitled <em>Computing
Precise Control Interface Specifications</em>.</p>
<p>The Capisce library comprises two key pieces:</p>
<ul>
<li><p>an OCAML library for writing down and specifying data plane
programs called <code>GPL</code>.</p>
<ul>
<li><p>Example programs can be seen in the
<code>capisce/programs</code>.</p></li>
<li><p>The core interface for writing programs can be found in
<code>capisce/lib/ASTs.ml</code>.</p></li>
</ul></li>
<li><p>an instrumentation algorithm to translate <code>GPL</code>
programs into programs in the guarded command language</p>
<ul>
<li>the instrumentation algorithm <code>GPL.encode_tables</code> van be
found in <code>capisce/lib/AST.ml</code></li>
</ul></li>
<li><p>an inference algorithm to infer control interface specifications
for data plane programs</p>
<ul>
<li>The core algorithm (<code>cegqe</code>) can be found in
<code>capisce/lib/Qe.ml</code>.</li>
</ul></li>
</ul>
<p>Here we list the claims in the paper and how they are supported by
the artifact:</p>
<ol type="1">
<li><p><em>Capisce compute control interface specifications for real
programs.</em> This artifact supports this via its survey of real world
programs that have been implemented in our library. We have provided
scripts to automatically generate the tex for Figures 5 and 6 from the
paper.</p></li>
<li><p><em>A small proportion of paths suffice to compute control
interface specifications for real programs</em>. This can be seen in the
final column of Figures 5 and 6, as well as qualitatively in Figure 7.
We have provided scripts to automatically generate the graphs in Figure
7.</p></li>
</ol>
<h3 id="hardware-dependencies">Hardware Dependencies</h3>
<p>We ran our experiments on an Ubuntu 22.04.4 server with the following
specs: - CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz - RAM: 0.5
TB</p>
<h3 id="getting-started">Getting started</h3>
<p>There are two ways to get started with Docker: using Docker, and
building from source. We have tested <code>Capisce</code> on Ubuntu
20.04 and 22.04. We recommend using docker to get started quickly.</p>
<p>Either way, the first step is to download the source code, by either
cloning the repository using git, or unpacking the downloaded .zip file.
Then change into the newly created directory. For instance:</p>
<pre><code>git clone https://github.com/cornell-netlab/capisce.git
cd capisce</code></pre>
<h4 id="docker">Docker</h4>
<p>The easiest way to get Capisce running is using Docker.</p>
<ul>
<li>First install Docker.</li>
<li>Finally, <code>build</code> and <code>run</code> the docker
image</li>
</ul>
<pre><code>docker build -t capisce .
docker run -it capisce</code></pre>
<p>Once this succeeds (it may take a while), you should be greeted with
a shell prompt similar to the following:</p>
<pre><code>opam@1497723f4b4d:~/capisce/capisce$</code></pre>
<p>Now to build Capisce, run <code>make</code>.</p>
<p>Verify your build by running <code>./capisce exp -help</code></p>
<h6 id="known-issue">Known Issue</h6>
<p>On M1 Macs there may be an issue regarding the a missing
<code>/lib64/ld-linux-x86-64.so.2</code> file. If you get such an error
try building with the flag <code>--platform linux/amd64</code></p>
<h4 id="installing-from-source">Installing from source</h4>
<p>Capiscelib is an ocaml library, so we first need to install
<code>opam</code>. Then, <code>switch</code> to the supported ocaml
compiler version</p>
<pre><code>opam switch create 4.14.0
eval $(opam env)</code></pre>
<p>Now install some basic ocaml tooling</p>
<pre><code>opam install dune
opam install menhir
opam install utop</code></pre>
<p>As well as a system dependency:</p>
<pre><code>sudo apt install libgmp-dev -y</code></pre>
<p>Now, change into the nested <code>capisce</code> directory
(i.e.&nbsp;<code>/path/to/repo/capisce/capisce</code>), and install the
dependencies in the <code>capisce.opam</code> file:</p>
<pre><code>opam install . --deps-only</code></pre>
<p>Now you should be ready to build <code>capisce</code> by running
<code>make</code></p>
<pre><code>make</code></pre>
<p>Verify your installation by running
<code>./capisce exp -help</code></p>
<h5 id="dependencies-for-processing-the-experimental-results">Dependencies
for processing the experimental results</h5>
<p>The experimental results are processed using some python scripts.
They have their own dependencies that need to be installed:</p>
<pre><code>sudo apt install python3 -y
sudo apt install python3-pip -y
pip3 install sigfig
pip3 install matplotlib
pip3 install ipython</code></pre>
<h4 id="hello-world-arp">Hello World: ARP</h4>
<p>Once you’ve installed <code>Capisce</code>, you can verify it works,
by computing a specification for the <code>arp</code> program, which can
be found in <code>programs/Arp.ml</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># wd: capisce/capisce</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mkdir</span> ./survey_data_oopsla</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ex">./capisce</span> exp arp <span class="at">-out</span> ./survey_data_oopsla <span class="at">-hv</span></span></code></pre></div>
<p><code>capisce</code> will spit out a collection of SMT formulae whose
conjunction corresponds to the control interface specification (spec)
that enforces there are no invalid header reads (<code>-hv</code>). It
should take about 5 seconds.</p>
<p>If the above command fails, with an error complaining about not being
able to find <code>../solvers/z3.4.8.13</code> or
<code>../solvers/princess</code>, you can specify the path to these
solvers (in the <code>solvers</code> directory) manually by using the
<code>-z3</code> and <code>-princess</code> flags. For instance:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./capisce</span> exp <span class="at">-name</span> arp <span class="at">-hv</span> <span class="at">-out</span> ./survey_data_oopsla <span class="at">-z3</span> /path/to/z3 <span class="at">-princess</span> /path/to/princess</span></code></pre></div>
<p>In the sequel we will omit the explicit paths flags, but they may
always be added if needed.</p>
<h3 id="step-by-step-instructions">Step By Step Instructions</h3>
<p>We’ve provided instructions for automatically exercising the
experiments using our scripts, and for running them manually.</p>
<h4 id="exercising-the-experiments">Exercising the Experiments</h4>
<p>Now you can run the experiments from the paper. These will take
several days. Note that because path selection is done by Z3, there may
be some variation in the precise numbers generated by this step.</p>
<ul>
<li><p><code>make survey</code> runs the experiments described in
Figures 5 and 6. The output can be seen in
<code>./survey_data_oopsla</code>. Running the experiments takes about 5
days of compute.</p></li>
<li><p><code>make survey-tex</code> generates the TeX for Figures 5 and
6. Note. Run this while <code>make survey</code> is running to see the
results computed so far.</p></li>
<li><p><code>make coverage</code> generates the graphs in Figure 7. This
will take 2-3 hours</p></li>
</ul>
<h4 id="running-experiments-one-by-one">Running Experiments
One-by-One</h4>
<p>To run the experiments individually, execute the following command
once for each pipeline:</p>
<pre><code>./capisce exp NAME -out ./survey_data_oopsla</code></pre>
<p>where <code>OUT</code> is the output directory in which you wish to
store the results, and <code>NAME</code> is the name of the example
program. The valid names can be seen by typing
<code>./capisce exp</code>.</p>
<p>Most of these will finish in minutes, but several will take nearly
two days. For more-precise timing expectations, consult Figures 5 and
6.</p>
<p>Once you’ve done this, you can generate Figures 5 and 6 using the
script <code>./scripts/survey-to-tex.py</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python3</span> ./scripts/survey-to-tex.py</span></code></pre></div>
<p>You may run this script after any number of examples have been run,
and you will get partial results. Those results that haven’t finished
running yet will be indicated by an infinity symbol in the “Result”
column.</p>
<p>To reproduce Figure 7, re-run the relevant programs with the
<code>-replay</code> flag. This will generate the additional data
required to generate Figure 7. The coverage analysis is slow, and may
take several hours. To generate the data run the following commands:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./capisce</span> exp arp <span class="at">-replay</span> <span class="at">-out</span> survey_data_oopsla <span class="at">-hv</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ex">./capisce</span> exp heavy_hitter_2 <span class="at">-replay</span> <span class="at">-out</span> survey_data_oopsla <span class="at">-hv</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ex">./capisce</span> exp heavy_hitter_1 <span class="at">-replay</span> <span class="at">-out</span> survey_data_oopsla <span class="at">-hv</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="ex">./capisce</span> exp flowlet <span class="at">-replay</span> <span class="at">-out</span> survey_data_oopsla <span class="at">-hv</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="ex">./capisce</span> exp 07-multiprotocol <span class="at">-replay</span> <span class="at">-out</span> survey_data_oopsla <span class="at">-hv</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="ex">./capisce</span> exp simple_nat <span class="at">-replay</span> <span class="at">-out</span> survey_data_oopsla <span class="at">-hv</span></span></code></pre></div>
<p>Then, to produce the graphs as seen in Figure 7, run the following
script:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python3</span> scripts/graphs.py</span></code></pre></div>
<p>Running the script will output the relative paths to the pdfs it
generates.</p>
<h4 id="common-issues">Common Issues</h4>
<p>The Capisce repo ships with solver executables in the
<code>solvers</code> directory. It is common to have are issues with the
solvers—Capisce prints an inscrutable error message followed by
<code>(Failure "found false")</code>. For instance,</p>
<pre><code>Error: Cannot find or load the main class ap.CmdlMain
Cause: java.lang.ClassNotFoundException: ap.CmdlMain
Uncaught exception:

  (Failure "found false")</code></pre>
<p>If these occur, please install <a href="https://github.com/Z3Prover/z3">Z3</a> and <a href="http://www.philipp.ruemmer.org/princess.shtml">princess</a>. You
can either place the executables in capisce’s <code>solvers</code>
directory, or pass the locations of the executables to
<code>capisce</code> using the <code>-z3</code> and
<code>-princess</code> flags.</p>
<h3 id="reusability-guide">Reusability Guide</h3>
<p>Our artifact supports three key pieces for reusability.</p>
<ul>
<li><p>The pipeline specification IR <code>GPL</code>, which can be
found in <code>ASTs.GPL</code>. This AST can be used as a compiler
backend for related dataplane analysis tools like <code>petr4</code>,
<code>p4cub</code>, <code>p4k</code>, <code>p4-constraints</code>, or
<code>PI4</code>.</p></li>
<li><p>The compiler infrastructure for <code>GPL.t</code> allows for
programmers to easily extend the core set of primitives, in a way that
supports efficient reuse.</p></li>
<li><p>The Counterexample-guided inductive quantifier elimination
algorithm <code>QE.cegqe</code> is succinctly stated, and can be
reimplemented or adapted to as new algorithms are discovered.</p></li>
</ul>
<h4 id="tutorial">Tutorial</h4>
<p>Now that you’ve build <code>Capisce</code>, we’ll show you how it
works.</p>
<p>First run <code>dune utop</code>. This will load <code>Capisce</code>
into a REPL. Now, open the <code>Capisce</code> module:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">open</span> Capisce;;</span></code></pre></div>
<p>In this Hello-World tutorial, we’ll write a program in our IR
<code>GPL</code>, which represents the guarded pipeline language
described in the paper. Then we’ll write a specification that it must
satisfy. Finally, we’ll infer a ccontrol interface spec that will ensure
the assertion is satisfied.</p>
<h5 id="part-1-writing-a-program-in-gpl">Part 1: Writing a program in
GPL</h5>
<p>First, let open the Modules for the program syntax
(<code>GPL</code>), including Bitvector Expressions (<code>Expr</code>)
and Boolean Expressions (<code>BExpr</code>).</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">open</span> ASTs.GPL;; <span class="kw">open</span> Expr;; <span class="kw">open</span> BExpr;;</span></code></pre></div>
<p>We’ll now write a simple GPL program that uses a single forwarding
table to set a single 9-bit field <code>port</code> based on the value
of a 32-bit destination address <code>dst</code>. First, we can define
the variables <code>port</code>and <code>dst</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">let</span> port = Var.make <span class="st">"port"</span> <span class="dv">9</span>;;</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> port : Var.t = &lt;abstr&gt;</span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">let</span> dst = Var.make <span class="st">"dst"</span> <span class="dv">32</span>;;</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> dst : Var.t = &lt;abstr&gt;</span></code></pre></div>
<p>We’ll use these variables to construct our table. Lets see how we
might do that by inspecting the type of the constructor
<code>table</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>utop # table;;</span></code></pre></div>
<p>should produce</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> -&gt;</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    [&gt; `Exact <span class="kw">of</span> Var.t | `Maskable <span class="kw">of</span> Var.t | `MaskableDegen <span class="kw">of</span> Var.t ] <span class="dt">list</span> -&gt;</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    (Var.t <span class="dt">list</span> * Capiscelib.Primitives.Action.t <span class="dt">list</span>) <span class="dt">list</span> -&gt;</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    Pack.t</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>= &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>This tells us that to construct a <code>table</code>, we need 3
arguments: a <code>string</code> name, a list variable keys tagged with
their matchkind (<code>Exact</code>, <code>Maskable</code>, and
<code>MaskableDegen</code>), then a list of
<code>Var.t list * Primitives.Action.t list</code>. Each pair
<code>(xs, as)</code> in this list corresponds to an anonymous function
where <code>xs</code> occur free in a list of primitive actions. This
list should be understood as sequential composition. Lets construct our
first action.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">let</span> nop : Var.t <span class="dt">list</span> * Primitives.Action.t <span class="dt">list</span> = [],[];;</span></code></pre></div>
<p>This action is the trivial action. It takes no arguments
<code>[],</code> and executes noactions <code>[]</code>.</p>
<p>Stepping it up a notch in complexity. We will define a action that
takes in a single argument, indicated by parameter <code>p</code>, and
assigns <code>p</code> to our previously-defined variable
<code>port</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">let</span> setport =</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> p = Var.make <span class="st">"p"</span> <span class="dv">9</span> <span class="kw">in</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>     [p], Primitives.Action.[</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>          assign port (Expr.var p)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>     ];;</span></code></pre></div>
<p>The first line constructs the AST node for parameter <code>p</code>.
Then the <code>[p],</code> says that <code>p</code> is an argument for
the action, which is defined by the subsequent action list.</p>
<p>Now we can define a table, called <code>simpletable</code> that reads
the vpalue of <code>port</code>, and then either execute the
<code>setport</code> action with some parameter, or take no action.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">let</span> simpletable =</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    table <span class="st">"simpletable"</span> [`Exact port] [setport; nop];;</span></code></pre></div>
<p>The <code>Exact</code> matchkind tells us that
<code>simpletable</code> must precisely read the bits of
<code>port</code>. Using <code>Maskable</code> corresponds unifies the
notions of <code>ternary</code>, <code>lpm</code> and
<code>optional</code>, all of which allow the the table to skip reading
that specific key. <code>MaskableDegen</code> is semantically equivalent
to <code>Exact</code>, but allows us to differentiate between truly
maskable match data and degenerate cases described in the paper</p>
<h5 id="part-2-writing-a-specification">Part 2: Writing a
Specification</h5>
<p>Now, as an example specification, we can exclude a specific port
value. Perhaps to indicate that this port value, say <code>47</code> is
disabled. So we never want to forward a packet out on port
<code>47</code>. We define a spec that ensures this as follows:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">let</span> port_not_47 =</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> prohibited = Expr.bvi <span class="dv">47</span> <span class="dv">9</span> <span class="kw">in</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    BExpr.(not_ (eq_ (Expr.var port) prohibited));;</span></code></pre></div>
<p>Now we can use assertions to specify that our table must satisfy this
spec:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">let</span> program = sequence [</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    simpletable;</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    assert_ port_not_47</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>];;</span></code></pre></div>
<h5 id="part-3-inferring-a-spec">Part 3: Inferring A Spec</h5>
<p>Inferring the control interface spec for the table requires two
steps. First we encode the tables using the instrumentation strategy
described in the paper, and then we run our inference algorithm.</p>
<p>The encoding step eliminates tables, and converts a
<code>GPL.t</code> program into a <code>GCL.t</code> program.
<code>GCL</code> here stands for Dijkstra’s <em>guarded command
language</em>. We run this using the <code>GPL.encode_tables</code>
function:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">let</span> gcl = ASTs.GPL.encode_tables program;;</span></code></pre></div>
<p>To see a pretty printed version of the table-free program, run the
following:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="dt">Printf</span>.printf <span class="st">"\%s"</span> @@ ASTs.GCL.to_string gcl;;</span></code></pre></div>
<p>Now we can infer the specification for this program by running the
<code>CEGQE</code> algorithm:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="kw">let</span> cis = Qe.cegqe gcl;;</span></code></pre></div>
<p>To pretty print the result in SMTLIB format, run the following
command:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>utop # <span class="dt">Printf</span>.printf <span class="st">"\%s"</span> @@ BExpr.to_smtlib cis;;</span></code></pre></div>
<p>The resulting specification has two conjucts. The first, shown below,
says that whenever the action is has index <code>0</code>, that is when
it corresponds to <code>setport</code>, the argument to
<code>setport</code> must not be <code>47</code>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">not</span> (<span class="kw">and</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>          (<span class="op">=</span> _symb$simpletable$action$_$<span class="dv">0</span> (_ bv1 <span class="dv">1</span>))</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>          (<span class="op">=</span> _symb$simpletable$<span class="dv">1</span>$p$_$<span class="dv">0</span> (_ bv47 <span class="dv">9</span>))))</span></code></pre></div>
<p>The second conjunct, replicated below, says that whenever the action
is <code>setport</code>, the key that was matched by
<code>simpletable</code> must not be equal to <code>47</code>.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">not</span> (<span class="kw">and</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>          (<span class="op">=</span> _symb$simpletable$action$_$<span class="dv">0</span> (_ bv0 <span class="dv">1</span>))</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>          (<span class="op">=</span> _symb$simpletable$match_0$_$<span class="dv">0</span> (_ bv47 <span class="dv">9</span>))))</span></code></pre></div>
<h4 id="guarded-pipeline-language-gpl">Guarded Pipeline Language
<code>GPL</code></h4>
<p>Here we provide documentation of the core interface for writing
<code>GPL.t</code> programs.</p>
<p>The <code>GPL</code> module, defined in <code>ASTs.ml</code> defines
programs.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> t</span></code></pre></div>
<p>It has a type <code>t</code> that corresponds to <code>GPL</code>
programs themselves.</p>
<p>We can construct trivial programs</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> skip : t</span></code></pre></div>
<p>Sequential compositions of programs;</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sequence : t <span class="dt">list</span> -&gt; t</span></code></pre></div>
<p>Nondeterministic choice between programs:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> choice : t <span class="dt">list</span> -&gt; ts</span></code></pre></div>
<p>We can also construct variable assignments</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> assign_ : Var.t -&gt; Expr.t -&gt; t</span></code></pre></div>
<p>and the most important constuct, tables:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> table : <span class="dt">string</span> </span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  -&gt; [&gt; `Exact <span class="kw">of</span> Var.t <span class="dt">list</span> | `Maskable <span class="kw">of</span> Var.t <span class="dt">list</span> | `MaskableDegen <span class="kw">of</span> Var.t ] <span class="dt">list</span> </span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  -&gt; ( Var.t * Primtives.Action.t <span class="dt">list</span>) <span class="dt">list</span> -&gt; t</span></code></pre></div>
<p>As described above <code>table name keys actions</code> constructs a
table named <code>name</code> that chooses an action <code>a</code> in
<code>actions</code> by inspecting the variables in
<code>keys</code>.</p>
<p>More about <code>Primitives.Action</code> can be found in the next
section.</p>
<p>To specify desired behaviors we have two primitives,
<code>assume</code> and <code>assert</code>.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> assume : BExpr.t -&gt; t</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> assert_ : BExpr.t -&gt; t</span></code></pre></div>
<p>The <code>assume</code> primitive is angelic—if it can be satisfied
the program assumes it is. Conversely, <code>assert_</code> is
demonic—if it can ba falsified the program assumes it is.</p>
<h5 id="building-the-documentation">Building the Documentation</h5>
<p>The full documentation can be viewed using the following command. It
may prompt you to install <code>odoc</code>. Please do so using
<code>opam install odoc</code>.</p>
<pre><code>make doc -B</code></pre>
<p>This will open the documentation in your systems default web browser.
If you do not have a web browser installed the terminal
<code>xdg-open</code> command will fail. Feel free to browse the
documenation some other way. In the docker container the docs will be
opened in <code>w3m</code> (press <code>enter</code> to follow links and
<code>q</code> to quit).</p>
<p>The documentation for the core modules can be found by clicking on
<code>capisce</code> and then navigating to modules <code>Cmd</code>,
<code>ASTs</code>, and <code>Qe</code>.</p>
<h4 id="instrumentation-and-compiler">Instrumentation and Compiler</h4>
<p><code>GPL.t</code> is constructed using a functor
<code>Cmd.Make</code> that allows users to produce simple loop-free
imperative programs with demonic nondeterminism.</p>
<p><code>Cmd.Make</code> has a single module argument which must have
module type <code>Primitive</code> shown below:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> Primitive = <span class="kw">sig</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> t [@@deriving quickcheck, eq, hash, sexp, <span class="dt">compare</span>]</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> assume : BExpr.t -&gt; t</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> assert_ : BExpr.t -&gt; t</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> contra : t -&gt; t -&gt; <span class="dt">bool</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> to_smtlib : t -&gt; <span class="dt">string</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> size : t -&gt; <span class="dt">int</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> vars : t -&gt; Var.t <span class="dt">list</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>The <code>assume</code> and <code>assert_</code> functions construct
assumptions and assertions as before; <code>contra</code> describes when
two assumptions and/or assertions are contradictory;
<code>to_smtlib</code> converts <code>t</code> into an string that uses
smtlib syntax for expressions and variables; <code>size</code> computes
the size of a primitive, and <code>vars</code> computes the variables
used in a primitive.</p>
<p>This structure is extremely extensible and facilitates easy reuse of
our code. The file <code>Primitives.ml</code> serves as a great tutorial
for how to build up a higherarchical set of Primitives. Then
<code>ASTs.ml</code> uses these Primtives to build a set of IRs and a
compiler pipeline between them. We summarize it here.</p>
<p>Our compiler pipeline starts with <code>GPL</code> and then uses
<code>encode_tables</code> to produce a <code>GCL</code> program. Then
passify produces a program in the passive form <code>Psv.t</code> as
defined in Section 3.4 of the paper. Then we use standard verification
generation technqiues to produce formulae in SMTLIB.</p>
<p>Each of these passes is a fundamentally a catamorphism over the core
structure of the programs, and eliminates a single primitive at a time:
<code>encode_tables</code> eliminates tables, and <code>passify</code>
eliminates assignments. This is captured in the types.</p>
<p>Starting from the bottom, <code>Psv.t = Cmd.Make(Passive).t</code>,
where <code>Passive.t</code> is either an <code>Assume</code> or an
<code>Assert</code>. Then <code>GCL = Cmd.Make(Active).t</code>, where
<code>Active.t</code> is either a <code>Passive.t</code> or an
<code>Assign</code>ment. Finally
<code>GPL = Cmd.Make(Pipeline).t</code>, where <code>Pipeline.t</code>
is either a <code>Table</code> or an <code>Active</code>. The
transformation functions <code>encode_tables</code> and
<code>passify</code> defined in <code>ASTs.ml</code> define this
clearly.</p>
<p>With this compiler infrastructure in place, it would be easy for
future researchers to extend our work with additional features. Just as
writing the compiler for <code>GPL</code> leverages the existing
compiler for <code>GCL</code>, futurue work could extend GPL add
primitives for multiple-assignment, hash functions, or stateful
operations. Simply by writing elimination passes, researchers could make
ready use of our existing verification generation and specification
inference code.</p>
<h4 id="specification-inference-and-modelling">Specification Inference
and Modelling</h4>
<p>The algorithm <code>Qe.ceqge</code> in the <code>Qe.ml</code> file is
straightfoward and easy to modify. The experimental setup defined in
<code>bin/Main.ml</code> supports swapping in different algorithms for
performing the inference, which will allow future researchers to
directly measure their improvements over CegQe.</p>

},
keywords = {deductive synthesis, programmable networks, quantifier elimination}
}

@software{10.5281/zenodo.12786846,
author = {Pimpalkhare, Nikhil and Kincaid, Zachary},
title = {Virtual Machine Artifact for "Monotone Procedure Summarization via Vector Addition Systems and Inductive Potentials"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.12786846},
abstract = {
    <p>UTM Virtual Machine for replicating Evaluation of “Monotone Procedure
Summarization via Vector Addition Systems and Inductive Potentials”</p>

},
keywords = {Abstract Machines, Program Analysis}
}

@software{10.5281/zenodo.13117983,
author = {Zhang, Yiyu and Liu, Tianyi and Wang, Yueyang and Qi, Yun and Ji, Kai and Tang, Jian and Wang, Xiaoliang and Li, Xuandong and Zuo, Zhiqiang},
title = {Artifact Package for Article 'HardTaint: Production-Run Dynamic Taint Analysis via Selective Hardware Tracing'},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13117983},
abstract = {
    <p>The artifact is used to claim that the main components proposed in
the paper “HardTaint: Production-Run Dynamic Taint Analysis via
Selective Hardware Tracing” are functional.</p>

},
keywords = {Dynamic Taint Analysis, Intel PT, Selective Tracing}
}

@software{10.5281/zenodo.13166254,
author = {Borgarelli, Andrea and Enea, Constantin and Majumdar, Rupak and Nagendra, Srinidhi},
title = {Artifact for Reward Augmentation in Reinforcement Learning for Testing Distributed Systems &nbsp;Creators},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13166254},
abstract = {
    <p>The artifact provides a framework - WaypointRL - for testing
distributed protocol implementations using Reinforcement learning
methods and strategies. The framework expects an instrumented
implementation as input. The instrumentation will allow the framework to
simulate the network and pick the order of messages delivered.
Additionally, the framework will control the nodes of the distributed
system to introduce failures (stops and restarts). Apart from RL based
strategies when testing, the framework provides a generic interface to
implement any strategy as an Agent that interacts with the distributed
system Environment.</p>

},
keywords = {distributed systems, reactive systems testing, reinforcement learning}
}

@software{10.5281/zenodo.13323059,
author = {Jungmair, Michael and Engelke, Alexis and Giceva, Jana},
title = {Artifact for "HiPy: Extracting High-Level Semantics From Python Code For Data Processing"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13323059},
abstract = {
    <p>This is the artifact to the paper “HiPy: Extracting High-Level
Semantics From Python Code For Data Processing” which provides the
source code of HiPy as well as tooling, benchmarks, and Docker images to
reproduce the experiments shown in the paper.</p>

},
keywords = {Data Processing, High-Level Optimizations, Program Generation, Python}
}

@software{10.5281/zenodo.13361333,
author = {Norlinder, Jonas and \"{O}sterlund, Erik and Black-Schaffer, David and Wrigstad, Tobias},
title = {[OOPSLA'24 Artefact] Mark–Scavenge: Waiting for Trash to Take Itself Out},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13361333},
abstract = {
    <p>This artefact contains contains MS-ZGC, an implementation of
mark-scavenge, presented in the paper Mark–Scavenge: Waiting for Trash
to Take Itself Out.</p>

},
keywords = {concurrent, garbage collection, mark-evacuate, mark-scavenge, scavenging}
}

@software{10.5281/zenodo.13367665,
author = {Wu, Jifeng and Lemieux, Caroline},
title = {Reproduction Package for Article `QuAC: Quick Attribute-Centric Type Inference for Python`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13367665},
abstract = {
    <p>This artifact supports the paper “QuAC: Quick Attribute-Centric Type
Inference for Python.” The artifact includes the code and data used to
generate the results presented in the paper. It aims to reproduce the
main scientific claims and facilitate future research by making the
software publicly available.</p>

},
keywords = {Gradual Typing, Python, Static Analysis, Type Inference}
}

@software{10.5281/zenodo.13368062,
author = {Liu, Jiangyi and Murphy, Charlie and Grover, Anvay and Johnson, Keith J.C. and Reps, Thomas and D’Antoni, Loris},
title = {Artifact of paper "Synthesizing Formal Semantics from Executable Interpreters"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13368062},
abstract = {
    <p>This is the artifact of paper “Synthesizing Formal Semantics from
Executable Interpreters”. It contains code for the tool Synantic as well
as benchmarks used to support our claims in the paper.</p>

},
keywords = {program synthesis, semantics, SemGuS, SMT solvers, SyGuS}
}

@software{10.5281/zenodo.13370788,
author = {Kang, Chan Gu and Lee, Joonghoon and Oh, Hakjoo},
title = {Artifact for Paper "Statistical Testing of Quantum Programs via Fixed-Point Amplitude Amplification" in OOPSLA 2024},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13370788},
abstract = {
    <p>This is Zenodo repoistory for Software Artifact of Paper “Statistical
Testing of Quantum Programs via Fixed-Point Amplitude Amplification”
appeared in in OOPSLA 2024.</p>
<p>This repository contains a PDF file of artifact manual and runnable
software artifact. Running the artifact will give :</p>
<ul>
<li>Numerical calculation shown in the Examples in the paper</li>
<li>Validation of depth cost expression (appeared in Section 6 and 7 of
the paper)</li>
<li>Producing Speed-up plots in Case Study (appeared in Section 7 of the
paper)</li>
<li>Implementation of Testing Algorithms</li>
</ul>
<p>For the further details, see the attached artifact manual. For any
questions, contact changukang@korea.ac.kr. The artifact may be continued
through following github repo : https://github.com/kupl/FpaaTestArtifact
.</p>

},
keywords = {Quantum Computing, Quantum Programming, Testing, Verification}
}

@software{10.5281/zenodo.13370814,
author = {Tan, Jinhao and Oliveira, Bruno C. d. S.},
title = {A Case for First-Class Environments (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13370814},
abstract = {
    <p>The artifact includes the Coq formalization of the paper “A Case for
First-Class Environments”.</p>

},
keywords = {First-class Environments, Mechanical Formalization, Semantics}
}

@software{10.5281/zenodo.13372050,
author = {Eymer, Jeff and Dexter, Philip and Raskind, Joseph and Liu, Yu David},
title = {A Runtime System for Interruptible Query Processing: When Incremental Computing Meets Fine-Grained Parallelism - Artifact},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13372050},
abstract = {
    <p>The goal of PitStop is to use lazy evaluation to improve both
throughput and operation latency for data processing systems. PitStop
allows for queries and updates to be temporarily halted mid-traversal
and continued at a later time. Though it may seem counter intuitive,
this pausing allows for a fine-grained parallelism that helps to balance
workload and alleviate workload fluctuation. This design also allows for
further query optimization through the use of techniques such as
batching and fusion.</p>

},
keywords = {fine-grained parallelism, interruptible query processing, query language runtime design}
}

@software{10.5281/zenodo.13372573,
author = {Bembenek, Aaron and Greenberg, Michael and Chong, Stephen},
title = {Making Formulog Fast: An Argument for Unconventional Datalog Evaluation (OOPSLA'24 Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13372573},
abstract = {
    <p>Welcome to the artifact for the paper “Making Formulog Fast: An
Argument for Unconventional Datalog Evaluation” (OOPSLA’24) by Aaron
Bembenek, Michael Greenberg, and Stephen Chong. This artifact was
reviewed by the OOPSLA’24 Artifact Evaluation Committee. The artifact
includes: our extensions to Formulog and Souffl\'{e}; benchmarks and
experimental infrastructure; the data from our experiments and our data
analysis scripts; and documentation on how to build on top of our
software. To use the artifact, download the archive, extract it, and
follow the instructions in the README. If you just want to run Formulog,
you can get Formulog directly from the GitHub repo
(https://github.com/HarvardPL/formulog).</p>

},
keywords = {compilation, Datalog, Formulog, parallel evaluation, SMT solving}
}

@software{10.5281/zenodo.13373228,
author = {Ye, Wenjia and Sun, Yaozhu and Oliveira, Bruno C. d. S.},
title = {Imperative Compositional Programming (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13373228},
abstract = {
    <p>This is the artifact of the OOPSLA2024 research paper : Imperative
Compositional Programming.</p>

},
keywords = {Bidirectional Typing, Compositional Programming, Distributive Subtyping, Intersection Types, Mutable References, Type Soundness}
}

@software{10.5281/zenodo.13376916,
author = {Bowman, William J.},
title = {A Low-Level Look at A-Normal Form (artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13376916},
abstract = {
    <p>This artifact accompanies the paper A low-level look at A-normal form
(https://doi.org/10.1145/3689717). The <code>materials.tar.gz</code>
contain source files, documentation, Docker files, and assorted build
scripts. The file <code>oopsla2024-159-artifact-amd64.qcow2</code>
contains the same files, bundled as a QEMU VM image; instructions for
running it are in the gzip file.</p>

},
keywords = {A-normal form, Compilers, CPS, Intermediate Representation, Monadic Form, Normal Form, Normalization, Optimization}
}

@software{10.5281/zenodo.13377564,
author = {Jeon, Seungmin and Cho, Kyeongmin and Kang, Chan Gu and Lee, Janggun and Oh, Hakjoo and Kang, Jeehoon},
title = {Artifact for "Quantum Probabilistic Model Checking for Time-Bounded Properties"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13377564},
abstract = {
    <p>This is the artifact for OOPSLA 2024 paper: “Quantum Probabilistic
Model Checking for Time-Bounded Properties”.</p>
<p>This artifact includes the following files: - qpmc.zip: Contains the
implementation and evaluation program used to generate the results
presented in the paper. - qpmc-evaluation-results.zip: Includes the
output files generated by the evaluation program.</p>
<p>For detailed information about this artifact, please refer to the
README.md file within the qpmc.zip archive. The artifact also includes
the full paper with appendices (paper-full.pdf).</p>

},
keywords = {bounded reachability, probabilistic model checking, quantum computing}
}

@software{10.5281/zenodo.13378311,
author = {Ye, Wenjia and Oliveira, Bruno C. d. S. and Toro, Mat\'{\i}as},
title = {Merging Gradual Typing (Artifact)},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13378311},
abstract = {
    <p>This is the artifact of OOPSLA2024 research paper: Merging Gradual
Typing.</p>

},
keywords = {Bidirectional Typing, Gradual Typing, Merge Operator, Type-Directed Semantics}
}

@software{10.5281/zenodo.13380062,
author = {Craaijo, Jos and Verbeek, Freek and Ravindran, Binoy},
title = {Reproduction package (Docker container) for the OOPSLA 2024 article "libLISA: Instruction Discovery and Analysis on x86-64"},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13380062},
abstract = {
    <p>These files accompany the OOPSLA 2024 paper ‘libLISA - Instruction
Discovery and Analysis on x86-64’.</p>
<p>This artifact consists of the following:</p>
<ul>
<li>The source code for libLISA, the tool presented in the paper.</li>
<li>The generated semantics for the five CPU architectures we
analyzed.</li>
<li>The source code for all additional tools that we used to generate
the data in Table 5, 6, 7, 8 and 9.</li>
</ul>
<p>This is all relevant source code and data necessary to reproduce all
results in the paper.</p>
<p>Please see the full guide in artifact-evaluation-guide.7z.</p>

},
keywords = {instruction enumeration, instruction semantics, synthesis}
}

@software{10.5281/zenodo.13380561,
author = {Hinrichsen, Jonas Kastberg and Jacobs, Jules and Krebbers, Robbert},
title = {Multris: Functional Verification of Multiparty Message Passing in Separation Logic - Coq Mechanization},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13380561},
abstract = {
    <p>Coq mechanization artifact for the OOPSLA’24 paper: “Multris:
Functional Verification of Multiparty Message Passing in Separation
Logic”.</p>
<p>See included README for more details.</p>

},
keywords = {Coq, Mechanization, Separation Logic}
}

@software{10.5281/zenodo.13381305,
author = {Root, Alexander J and Yan, Bobby and Liu, Peiming and Gyurgyik, Christophe and Bik, Aart J.C. and Kjolstad, Fredrik},
title = {Artifact for OOPSLA 2024 Paper: Compilation of Shape Operators on Sparse Arrays},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13381305},
abstract = {
    <p>This artifact contains the prototype Burrito compiler, all benchmarks
from the paper, and graphing scripts used to produce the figures in the
paper.</p>

},
keywords = {sparse array programming, sparse data structures, sparse iteration theory}
}

@software{10.5281/zenodo.13381352,
author = {Palmer, Zachary and Filardo, Nathaniel Wesley and Wu, Ke},
title = {Intensional Functions Virtual Machine Image},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13381352},
abstract = {
    <p>This archive contains a virtual machine image with a precompiled
version of the artifact from the paper Intensional Functions, which
appears in OOPSLA 2024 / PACMPL.</p>

},
keywords = {function, image, intensional, machine, virtual}
}

@software{10.5281/zenodo.13382344,
author = {Baek, Doehyun and Getz, Jakob and Sim, Yusung and Lehmann, Daniel and Titzer, Ben L. and Ryu, Sukyoung and Pradel, Michael},
title = {Reproduction Package for Article `Wasm-R3: Record-Reduce-Replay for Realistic and Standalone WebAssembly Benchmarks`},
year = {2024},
publisher = {Association for Computing Machinery},
url = {https://doi.org/10.5281/zenodo.13382344},
abstract = {
    <p>This artifact contains supplementary material for the paper “Wasm-R3:
Record-Reduce-Replay for Realistic and Standalone WebAssembly
Benchmarks” (OOPSLA’24).</p>
<p>There are two main components to this artifact, which are Wasm-R3, a
record-and-replay framework for Webassembly, and Wasm-R3-Bench, a
benchmark suite of 27 real-world web applications generated by
Wasm-R3.</p>

},
keywords = {Benchmarking, record and replay, WebAssembly}
}

