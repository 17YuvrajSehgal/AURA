1. **Consistency and Completeness**: The artifact should directly implement or support the technical content of the paper, validating any claims made in the paper about the artifact.
2. **Exercisability**: The artifact should be executable in a commonly used environment, allowing reviewers to reproduce the artifactâ€™s contribution. This includes providing a VM image with all relevant software and data sets.
3. **Documentation**: The artifact should contain sufficient documentation to guide reviewers in building, running, and interpreting the artifact. This includes installation instructions, usage guidelines, and mapping of proof scripts to paper theorems.
4. **Future-Proofing**: The artifact should be designed to work on modern operating systems with up-to-date dependencies, facilitating future reuse and extension by other researchers.
5. **Ease of Extension and Modification**: The artifact should be structured in a way that allows future researchers to easily extend or modify it, supporting the reuse of the work.
6. **Quality**: The artifact should be of high quality, with clear and consistently formatted code, a simple build process, and clear error messages to facilitate debugging.
7. **Functional Badge**: Awarded to artifacts that allow future scientists to confirm that the claims from the paper are supported by the artifact. This includes consistency, completeness, exercisability, and documentation.
8. **Reusable Badge**: Awarded to artifacts that enable future scientists to build upon the artifact, requiring additional qualities such as future-proofing, ease of extension, and high quality.
9. **Available Badge**: Awarded to artifacts stored in a long-term, publicly accessible archive, ensuring that they are available indefinitely and accessible to the general public.
10. **Packaging Guidelines**: Artifacts should be packaged as a source tarball and a VM image, with a README file providing step-by-step instructions for execution and reproduction of results.
11. **Common Problems**: Artifacts should address issues such as proprietary software dependencies, special hardware requirements, long-running computations, and unstable or dangerous software, providing solutions or workarounds where necessary.
